// Code generated by 'ccgo -o pcre2.go -pkgname lib -trace-translation-units -export-externs X -export-defines D -export-fields F -export-structs S -export-typedefs T pcre.json .libs/libpcre2-8.a', DO NOT EDIT.

package lib

import (
	"math"
	"reflect"
	"sync/atomic"
	"unsafe"

	"modernc.org/libc"
	"modernc.org/libc/sys/types"
)

var _ = math.Pi
var _ reflect.Kind
var _ atomic.Value
var _ unsafe.Pointer
var _ *libc.TLS
var _ types.Size_t

const (
	DAIO_PRIO_DELTA_MAX                              = 20                   // local_lim.h:78:1:
	DBC_BASE_MAX                                     = 99                   // posix2_lim.h:63:1:
	DBC_DIM_MAX                                      = 2048                 // posix2_lim.h:66:1:
	DBC_SCALE_MAX                                    = 99                   // posix2_lim.h:69:1:
	DBC_STRING_MAX                                   = 1000                 // posix2_lim.h:72:1:
	DBIG_ENDIAN                                      = 4321                 // endian.h:28:1:
	DBOOL_MAX                                        = 1                    // limits.h:186:1:
	DBOOL_WIDTH                                      = 1                    // limits.h:189:1:
	DBSR_DEFAULT                                     = 1                    // pcre2_internal.h:243:1:
	DBUFSIZ                                          = 8192                 // stdio.h:99:1:
	DBYTE_ORDER                                      = 1234                 // endian.h:30:1:
	DCHARCLASS_NAME_MAX                              = 2048                 // posix2_lim.h:84:1:
	DCHAR_0                                          = 48                   // pcre2_internal.h:999:1:
	DCHAR_1                                          = 49                   // pcre2_internal.h:1000:1:
	DCHAR_2                                          = 50                   // pcre2_internal.h:1001:1:
	DCHAR_3                                          = 51                   // pcre2_internal.h:1002:1:
	DCHAR_4                                          = 52                   // pcre2_internal.h:1003:1:
	DCHAR_5                                          = 53                   // pcre2_internal.h:1004:1:
	DCHAR_6                                          = 54                   // pcre2_internal.h:1005:1:
	DCHAR_7                                          = 55                   // pcre2_internal.h:1006:1:
	DCHAR_8                                          = 56                   // pcre2_internal.h:1007:1:
	DCHAR_9                                          = 57                   // pcre2_internal.h:1008:1:
	DCHAR_A                                          = 65                   // pcre2_internal.h:1016:1:
	DCHAR_AMPERSAND                                  = 38                   // pcre2_internal.h:989:1:
	DCHAR_APOSTROPHE                                 = 39                   // pcre2_internal.h:990:1:
	DCHAR_ASTERISK                                   = 42                   // pcre2_internal.h:993:1:
	DCHAR_B                                          = 66                   // pcre2_internal.h:1017:1:
	DCHAR_BACKSLASH                                  = 92                   // pcre2_internal.h:1043:1:
	DCHAR_BEL                                        = 7                    // pcre2_internal.h:978:1:
	DCHAR_BIT                                        = 8                    // limits.h:64:1:
	DCHAR_BS                                         = 8                    // pcre2_internal.h:977:1:
	DCHAR_C                                          = 67                   // pcre2_internal.h:1018:1:
	DCHAR_CIRCUMFLEX_ACCENT                          = 94                   // pcre2_internal.h:1045:1:
	DCHAR_COLON                                      = 58                   // pcre2_internal.h:1009:1:
	DCHAR_COMMA                                      = 44                   // pcre2_internal.h:995:1:
	DCHAR_COMMERCIAL_AT                              = 64                   // pcre2_internal.h:1015:1:
	DCHAR_CR                                         = 13                   // pcre2_internal.h:973:1:
	DCHAR_D                                          = 68                   // pcre2_internal.h:1019:1:
	DCHAR_DEL                                        = 127                  // pcre2_internal.h:980:1:
	DCHAR_DOLLAR_SIGN                                = 36                   // pcre2_internal.h:987:1:
	DCHAR_DOT                                        = 46                   // pcre2_internal.h:997:1:
	DCHAR_E                                          = 69                   // pcre2_internal.h:1020:1:
	DCHAR_EQUALS_SIGN                                = 61                   // pcre2_internal.h:1012:1:
	DCHAR_ESC                                        = 27                   // pcre2_internal.h:979:1:
	DCHAR_EXCLAMATION_MARK                           = 33                   // pcre2_internal.h:984:1:
	DCHAR_F                                          = 70                   // pcre2_internal.h:1021:1:
	DCHAR_FF                                         = 12                   // pcre2_internal.h:972:1:
	DCHAR_G                                          = 71                   // pcre2_internal.h:1022:1:
	DCHAR_GRAVE_ACCENT                               = 96                   // pcre2_internal.h:1047:1:
	DCHAR_GREATER_THAN_SIGN                          = 62                   // pcre2_internal.h:1013:1:
	DCHAR_H                                          = 72                   // pcre2_internal.h:1023:1:
	DCHAR_HT                                         = 9                    // pcre2_internal.h:970:1:
	DCHAR_I                                          = 73                   // pcre2_internal.h:1024:1:
	DCHAR_J                                          = 74                   // pcre2_internal.h:1025:1:
	DCHAR_K                                          = 75                   // pcre2_internal.h:1026:1:
	DCHAR_L                                          = 76                   // pcre2_internal.h:1027:1:
	DCHAR_LEFT_CURLY_BRACKET                         = 123                  // pcre2_internal.h:1074:1:
	DCHAR_LEFT_PARENTHESIS                           = 40                   // pcre2_internal.h:991:1:
	DCHAR_LEFT_SQUARE_BRACKET                        = 91                   // pcre2_internal.h:1042:1:
	DCHAR_LESS_THAN_SIGN                             = 60                   // pcre2_internal.h:1011:1:
	DCHAR_LF                                         = 10                   // pcre2_internal.h:974:1:
	DCHAR_M                                          = 77                   // pcre2_internal.h:1028:1:
	DCHAR_MAX                                        = 127                  // limits.h:99:1:
	DCHAR_MIN                                        = -128                 // limits.h:97:1:
	DCHAR_MINUS                                      = 45                   // pcre2_internal.h:996:1:
	DCHAR_N                                          = 78                   // pcre2_internal.h:1029:1:
	DCHAR_NL                                         = 10                   // pcre2_internal.h:975:1:
	DCHAR_NUL                                        = 0                    // pcre2_internal.h:982:1:
	DCHAR_NUMBER_SIGN                                = 35                   // pcre2_internal.h:986:1:
	DCHAR_O                                          = 79                   // pcre2_internal.h:1030:1:
	DCHAR_P                                          = 80                   // pcre2_internal.h:1031:1:
	DCHAR_PERCENT_SIGN                               = 37                   // pcre2_internal.h:988:1:
	DCHAR_PLUS                                       = 43                   // pcre2_internal.h:994:1:
	DCHAR_Q                                          = 81                   // pcre2_internal.h:1032:1:
	DCHAR_QUESTION_MARK                              = 63                   // pcre2_internal.h:1014:1:
	DCHAR_QUOTATION_MARK                             = 34                   // pcre2_internal.h:985:1:
	DCHAR_R                                          = 82                   // pcre2_internal.h:1033:1:
	DCHAR_RIGHT_CURLY_BRACKET                        = 125                  // pcre2_internal.h:1076:1:
	DCHAR_RIGHT_PARENTHESIS                          = 41                   // pcre2_internal.h:992:1:
	DCHAR_RIGHT_SQUARE_BRACKET                       = 93                   // pcre2_internal.h:1044:1:
	DCHAR_S                                          = 83                   // pcre2_internal.h:1034:1:
	DCHAR_SEMICOLON                                  = 59                   // pcre2_internal.h:1010:1:
	DCHAR_SLASH                                      = 47                   // pcre2_internal.h:998:1:
	DCHAR_SPACE                                      = 32                   // pcre2_internal.h:983:1:
	DCHAR_T                                          = 84                   // pcre2_internal.h:1035:1:
	DCHAR_TILDE                                      = 126                  // pcre2_internal.h:1077:1:
	DCHAR_U                                          = 85                   // pcre2_internal.h:1036:1:
	DCHAR_UNDERSCORE                                 = 95                   // pcre2_internal.h:1046:1:
	DCHAR_V                                          = 86                   // pcre2_internal.h:1037:1:
	DCHAR_VERTICAL_LINE                              = 124                  // pcre2_internal.h:1075:1:
	DCHAR_VT                                         = 11                   // pcre2_internal.h:971:1:
	DCHAR_W                                          = 87                   // pcre2_internal.h:1038:1:
	DCHAR_WIDTH                                      = 8                    // limits.h:165:1:
	DCHAR_X                                          = 88                   // pcre2_internal.h:1039:1:
	DCHAR_Y                                          = 89                   // pcre2_internal.h:1040:1:
	DCHAR_Z                                          = 90                   // pcre2_internal.h:1041:1:
	DCHAR_a                                          = 97                   // pcre2_internal.h:1048:1:
	DCHAR_b                                          = 98                   // pcre2_internal.h:1049:1:
	DCHAR_c                                          = 99                   // pcre2_internal.h:1050:1:
	DCHAR_d                                          = 100                  // pcre2_internal.h:1051:1:
	DCHAR_e                                          = 101                  // pcre2_internal.h:1052:1:
	DCHAR_f                                          = 102                  // pcre2_internal.h:1053:1:
	DCHAR_g                                          = 103                  // pcre2_internal.h:1054:1:
	DCHAR_h                                          = 104                  // pcre2_internal.h:1055:1:
	DCHAR_i                                          = 105                  // pcre2_internal.h:1056:1:
	DCHAR_j                                          = 106                  // pcre2_internal.h:1057:1:
	DCHAR_k                                          = 107                  // pcre2_internal.h:1058:1:
	DCHAR_l                                          = 108                  // pcre2_internal.h:1059:1:
	DCHAR_m                                          = 109                  // pcre2_internal.h:1060:1:
	DCHAR_n                                          = 110                  // pcre2_internal.h:1061:1:
	DCHAR_o                                          = 111                  // pcre2_internal.h:1062:1:
	DCHAR_p                                          = 112                  // pcre2_internal.h:1063:1:
	DCHAR_q                                          = 113                  // pcre2_internal.h:1064:1:
	DCHAR_r                                          = 114                  // pcre2_internal.h:1065:1:
	DCHAR_s                                          = 115                  // pcre2_internal.h:1066:1:
	DCHAR_t                                          = 116                  // pcre2_internal.h:1067:1:
	DCHAR_u                                          = 117                  // pcre2_internal.h:1068:1:
	DCHAR_v                                          = 118                  // pcre2_internal.h:1069:1:
	DCHAR_w                                          = 119                  // pcre2_internal.h:1070:1:
	DCHAR_x                                          = 120                  // pcre2_internal.h:1071:1:
	DCHAR_y                                          = 121                  // pcre2_internal.h:1072:1:
	DCHAR_z                                          = 122                  // pcre2_internal.h:1073:1:
	DCOLL_WEIGHTS_MAX                                = 255                  // posix2_lim.h:75:1:
	DCOMPILE_ERROR_BASE                              = 100                  // pcre2_internal.h:221:1:
	DDELAYTIMER_MAX                                  = 2147483647           // local_lim.h:84:1:
	DDFA_START_RWS_SIZE                              = 30720                // pcre2_internal.h:236:1:
	DEOF                                             = -1                   // stdio.h:104:1:
	DEXIT_FAILURE                                    = 1                    // stdlib.h:92:1:
	DEXIT_SUCCESS                                    = 0                    // stdlib.h:93:1:
	DEXPR_NEST_MAX                                   = 32                   // posix2_lim.h:78:1:
	DFALSE                                           = 0                    // pcre2_internal.h:69:1:
	DFD_SETSIZE                                      = 1024                 // select.h:73:1:
	DFILENAME_MAX                                    = 4096                 // stdio_lim.h:27:1:
	DFOPEN_MAX                                       = 16                   // stdio_lim.h:37:1:
	DHAVE_BCOPY                                      = 1                    // config.h:60:1:
	DHAVE_BZLIB_H                                    = 1                    // config.h:63:1:
	DHAVE_CONFIG_H                                   = 1                    // <defines>:1:1:
	DHAVE_DIRENT_H                                   = 1                    // config.h:66:1:
	DHAVE_DLFCN_H                                    = 1                    // config.h:69:1:
	DHAVE_INTTYPES_H                                 = 1                    // config.h:78:1:
	DHAVE_LIMITS_H                                   = 1                    // config.h:81:1:
	DHAVE_MEMFD_CREATE                               = 1                    // config.h:84:1:
	DHAVE_MEMMOVE                                    = 1                    // config.h:87:1:
	DHAVE_MKOSTEMP                                   = 1                    // config.h:93:1:
	DHAVE_REALPATH                                   = 1                    // config.h:111:1:
	DHAVE_SECURE_GETENV                              = 1                    // config.h:114:1:
	DHAVE_STDINT_H                                   = 1                    // config.h:117:1:
	DHAVE_STDIO_H                                    = 1                    // config.h:120:1:
	DHAVE_STDLIB_H                                   = 1                    // config.h:123:1:
	DHAVE_STRERROR                                   = 1                    // config.h:126:1:
	DHAVE_STRINGS_H                                  = 1                    // config.h:129:1:
	DHAVE_STRING_H                                   = 1                    // config.h:132:1:
	DHAVE_SYS_STAT_H                                 = 1                    // config.h:135:1:
	DHAVE_SYS_TYPES_H                                = 1                    // config.h:138:1:
	DHAVE_SYS_WAIT_H                                 = 1                    // config.h:141:1:
	DHAVE_UNISTD_H                                   = 1                    // config.h:144:1:
	DHAVE_VISIBILITY                                 = 1                    // config.h:147:1:
	DHAVE_WCHAR_H                                    = 1                    // config.h:150:1:
	DHAVE_ZLIB_H                                     = 1                    // config.h:156:1:
	DHEAP_LIMIT                                      = 20000000             // config.h:161:1:
	DHOST_NAME_MAX                                   = 64                   // local_lim.h:93:1:
	DIMM2_SIZE                                       = 2                    // pcre2_intmodedep.h:193:1:
	DINT16_MAX                                       = 32767                // stdint.h:122:1:
	DINT16_MIN                                       = -32768               // stdint.h:117:1:
	DINT16_WIDTH                                     = 16                   // stdint.h:280:1:
	DINT32_MAX                                       = 2147483647           // stdint.h:123:1:
	DINT32_MIN                                       = -2147483648          // stdint.h:118:1:
	DINT32_WIDTH                                     = 32                   // stdint.h:282:1:
	DINT64_MAX                                       = 9223372036854775807  // stdint.h:124:1:
	DINT64_MIN                                       = -9223372036854775808 // stdint.h:119:1:
	DINT64_WIDTH                                     = 64                   // stdint.h:284:1:
	DINT8_MAX                                        = 127                  // stdint.h:121:1:
	DINT8_MIN                                        = -128                 // stdint.h:116:1:
	DINT8_WIDTH                                      = 8                    // stdint.h:278:1:
	DINTMAX_MAX                                      = 9223372036854775807  // stdint.h:199:1:
	DINTMAX_MIN                                      = -9223372036854775808 // stdint.h:197:1:
	DINTMAX_WIDTH                                    = 64                   // stdint.h:308:1:
	DINTPTR_MAX                                      = 9223372036854775807  // stdint.h:187:1:
	DINTPTR_MIN                                      = -9223372036854775808 // stdint.h:186:1:
	DINTPTR_WIDTH                                    = 64                   // stdint.h:305:1:
	DINT_FAST16_MAX                                  = 9223372036854775807  // stdint.h:164:1:
	DINT_FAST16_MIN                                  = -9223372036854775808 // stdint.h:154:1:
	DINT_FAST16_WIDTH                                = 64                   // stdint.h:298:1:
	DINT_FAST32_MAX                                  = 9223372036854775807  // stdint.h:165:1:
	DINT_FAST32_MIN                                  = -9223372036854775808 // stdint.h:155:1:
	DINT_FAST32_WIDTH                                = 64                   // stdint.h:300:1:
	DINT_FAST64_MAX                                  = 9223372036854775807  // stdint.h:170:1:
	DINT_FAST64_MIN                                  = -9223372036854775808 // stdint.h:160:1:
	DINT_FAST64_WIDTH                                = 64                   // stdint.h:302:1:
	DINT_FAST8_MAX                                   = 127                  // stdint.h:162:1:
	DINT_FAST8_MIN                                   = -128                 // stdint.h:152:1:
	DINT_FAST8_WIDTH                                 = 8                    // stdint.h:296:1:
	DINT_LEAST16_MAX                                 = 32767                // stdint.h:140:1:
	DINT_LEAST16_MIN                                 = -32768               // stdint.h:135:1:
	DINT_LEAST16_WIDTH                               = 16                   // stdint.h:289:1:
	DINT_LEAST32_MAX                                 = 2147483647           // stdint.h:141:1:
	DINT_LEAST32_MIN                                 = -2147483648          // stdint.h:136:1:
	DINT_LEAST32_WIDTH                               = 32                   // stdint.h:291:1:
	DINT_LEAST64_MAX                                 = 9223372036854775807  // stdint.h:142:1:
	DINT_LEAST64_MIN                                 = -9223372036854775808 // stdint.h:137:1:
	DINT_LEAST64_WIDTH                               = 64                   // stdint.h:293:1:
	DINT_LEAST8_MAX                                  = 127                  // stdint.h:139:1:
	DINT_LEAST8_MIN                                  = -128                 // stdint.h:134:1:
	DINT_LEAST8_WIDTH                                = 8                    // stdint.h:287:1:
	DINT_MAX                                         = 2147483647           // limits.h:120:1:
	DINT_MIN                                         = -2147483648          // limits.h:118:1:
	DINT_WIDTH                                       = 32                   // limits.h:175:1:
	DIOV_MAX                                         = 1024                 // xopen_lim.h:66:1:
	DLINE_MAX                                        = 2048                 // posix2_lim.h:81:1:
	DLINK_SIZE                                       = 2                    // config.h:168:1:
	DLITTLE_ENDIAN                                   = 1234                 // endian.h:27:1:
	DLLONG_MAX                                       = 9223372036854775807  // limits.h:142:1:
	DLLONG_MIN                                       = -9223372036854775808 // limits.h:140:1:
	DLLONG_WIDTH                                     = 64                   // limits.h:183:1:
	DLOGIN_NAME_MAX                                  = 256                  // local_lim.h:90:1:
	DLONG_BIT                                        = 64                   // xopen_lim.h:137:1:
	DLONG_LONG_MAX                                   = 9223372036854775807  // limits.h:154:1:
	DLONG_LONG_MIN                                   = -9223372036854775808 // limits.h:152:1:
	DLONG_MAX                                        = 9223372036854775807  // limits.h:131:1:
	DLONG_MIN                                        = -9223372036854775808 // limits.h:129:1:
	DLONG_WIDTH                                      = 64                   // limits.h:179:1:
	DLOOKBEHIND_MAX                                  = 65535                // pcre2_intmodedep.h:616:1:
	DLT_OBJDIR                                       = ".libs/"             // config.h:171:1:
	DL_ctermid                                       = 9                    // stdio_lim.h:30:1:
	DL_cuserid                                       = 9                    // stdio_lim.h:32:1:
	DL_tmpnam                                        = 20                   // stdio_lim.h:25:1:
	DMAGIC_NUMBER                                    = 0x50435245           // pcre2_internal.h:547:1:
	DMATCH_LIMIT                                     = 10000000             // config.h:180:1:
	DMATCH_LIMIT_DEPTH                               = 10000000             // config.h:192:1:
	DMAX_CANON                                       = 255                  // limits.h:10:1:
	DMAX_INPUT                                       = 255                  // limits.h:11:1:
	DMAX_MARK                                        = 255                  // pcre2_intmodedep.h:213:1:
	DMAX_NAME_COUNT                                  = 10000                // config.h:197:1:
	DMAX_NAME_SIZE                                   = 32                   // config.h:202:1:
	DMAX_NON_UTF_CHAR                                = 255                  // pcre2_internal.h:1894:1:
	DMAX_PATTERN_SIZE                                = 65536                // pcre2_intmodedep.h:110:1:
	DMAX_UTF_CODE_POINT                              = 0x10ffff             // pcre2_internal.h:209:1:
	DMAX_UTF_SINGLE_CU                               = 127                  // pcre2_intmodedep.h:282:1:
	DMAYBE_UTF_MULTI                                 = 0                    // pcre2_intmodedep.h:278:1:
	DMB_LEN_MAX                                      = 16                   // limits.h:32:1:
	DMQ_PRIO_MAX                                     = 32768                // local_lim.h:96:1:
	DNAME_MAX                                        = 255                  // limits.h:12:1:
	DNEWLINE_DEFAULT                                 = 2                    // config.h:211:1:
	DNGROUPS_MAX                                     = 65536                // limits.h:7:1:
	DNLTYPE_ANY                                      = 1                    // pcre2_internal.h:474:1:
	DNLTYPE_ANYCRLF                                  = 2                    // pcre2_internal.h:475:1:
	DNLTYPE_FIXED                                    = 0                    // pcre2_internal.h:473:1:
	DNL_ARGMAX                                       = 4096                 // xopen_lim.h:73:1:
	DNL_LANGMAX                                      = 2048                 // xopen_lim.h:76:1:
	DNL_MSGMAX                                       = 2147483647           // xopen_lim.h:79:1:
	DNL_NMAX                                         = 2147483647           // xopen_lim.h:84:1:
	DNL_SETMAX                                       = 2147483647           // xopen_lim.h:88:1:
	DNL_TEXTMAX                                      = 2147483647           // xopen_lim.h:91:1:
	DNOTACHAR                                        = 0xffffffff           // pcre2_internal.h:205:1:
	DNZERO                                           = 20                   // xopen_lim.h:94:1:
	DPACKAGE                                         = "pcre2"              // config.h:214:1:
	DPACKAGE_BUGREPORT                               = ""                   // config.h:217:1:
	DPACKAGE_NAME                                    = "PCRE2"              // config.h:220:1:
	DPACKAGE_STRING                                  = "PCRE2 10.40"        // config.h:223:1:
	DPACKAGE_TARNAME                                 = "pcre2"              // config.h:226:1:
	DPACKAGE_URL                                     = ""                   // config.h:229:1:
	DPACKAGE_VERSION                                 = "10.40"              // config.h:232:1:
	DPARENS_NEST_LIMIT                               = 250                  // config.h:237:1:
	DPATH_MAX                                        = 4096                 // limits.h:13:1:
	DPCRE2GREP_BUFSIZE                               = 20480                // config.h:245:1:
	DPCRE2GREP_MAX_BUFSIZE                           = 1048576              // config.h:251:1:
	DPCRE2_ALLOW_EMPTY_CLASS                         = 0x00000001           // pcre2.h:119:1:
	DPCRE2_ALT_BSUX                                  = 0x00000002           // pcre2.h:120:1:
	DPCRE2_ALT_CIRCUMFLEX                            = 0x00200000           // pcre2.h:140:1:
	DPCRE2_ALT_VERBNAMES                             = 0x00400000           // pcre2.h:141:1:
	DPCRE2_ANCHORED                                  = 0x80000000           // pcre2.h:105:1:
	DPCRE2_AUTO_CALLOUT                              = 0x00000004           // pcre2.h:121:1:
	DPCRE2_BSR_ANYCRLF                               = 2                    // pcre2.h:211:1:
	DPCRE2_BSR_SET                                   = 0x00004000           // pcre2_internal.h:522:1:
	DPCRE2_BSR_UNICODE                               = 1                    // pcre2.h:210:1:
	DPCRE2_CALLOUT_BACKTRACK                         = 0x00000002           // pcre2.h:513:1:
	DPCRE2_CALLOUT_STARTMATCH                        = 0x00000001           // pcre2.h:512:1:
	DPCRE2_CALL_CONVENTION                           = 0                    // pcre2.h:81:1:
	DPCRE2_CASELESS                                  = 0x00000008           // pcre2.h:122:1:
	DPCRE2_CODE_UNIT_WIDTH                           = 8                    // <defines>:2:1:
	DPCRE2_CONFIG_BSR                                = 0                    // pcre2.h:437:1:
	DPCRE2_CONFIG_COMPILED_WIDTHS                    = 14                   // pcre2.h:452:1:
	DPCRE2_CONFIG_DEPTHLIMIT                         = 7                    // pcre2.h:444:1:
	DPCRE2_CONFIG_HEAPLIMIT                          = 12                   // pcre2.h:450:1:
	DPCRE2_CONFIG_JIT                                = 1                    // pcre2.h:438:1:
	DPCRE2_CONFIG_JITTARGET                          = 2                    // pcre2.h:439:1:
	DPCRE2_CONFIG_LINKSIZE                           = 3                    // pcre2.h:440:1:
	DPCRE2_CONFIG_MATCHLIMIT                         = 4                    // pcre2.h:441:1:
	DPCRE2_CONFIG_NEVER_BACKSLASH_C                  = 13                   // pcre2.h:451:1:
	DPCRE2_CONFIG_NEWLINE                            = 5                    // pcre2.h:442:1:
	DPCRE2_CONFIG_PARENSLIMIT                        = 6                    // pcre2.h:443:1:
	DPCRE2_CONFIG_RECURSIONLIMIT                     = 7                    // pcre2.h:445:1:
	DPCRE2_CONFIG_STACKRECURSE                       = 8                    // pcre2.h:446:1:
	DPCRE2_CONFIG_TABLES_LENGTH                      = 15                   // pcre2.h:453:1:
	DPCRE2_CONFIG_UNICODE                            = 9                    // pcre2.h:447:1:
	DPCRE2_CONFIG_UNICODE_VERSION                    = 10                   // pcre2.h:448:1:
	DPCRE2_CONFIG_VERSION                            = 11                   // pcre2.h:449:1:
	DPCRE2_CONVERT_GLOB                              = 0x00000010           // pcre2.h:195:1:
	DPCRE2_CONVERT_GLOB_NO_STARSTAR                  = 0x00000050           // pcre2.h:197:1:
	DPCRE2_CONVERT_GLOB_NO_WILD_SEPARATOR            = 0x00000030           // pcre2.h:196:1:
	DPCRE2_CONVERT_NO_UTF_CHECK                      = 0x00000002           // pcre2.h:192:1:
	DPCRE2_CONVERT_POSIX_BASIC                       = 0x00000004           // pcre2.h:193:1:
	DPCRE2_CONVERT_POSIX_EXTENDED                    = 0x00000008           // pcre2.h:194:1:
	DPCRE2_CONVERT_UTF                               = 0x00000001           // pcre2.h:191:1:
	DPCRE2_COPY_MATCHED_SUBJECT                      = 0x00004000           // pcre2.h:184:1:
	DPCRE2_DATE                                      = 2004                 // pcre2.h:47:1:
	DPCRE2_DEREF_TABLES                              = 0x00040000           // pcre2_internal.h:526:1:
	DPCRE2_DFA_RESTART                               = 0x00000040           // pcre2.h:176:1:
	DPCRE2_DFA_SHORTEST                              = 0x00000080           // pcre2.h:177:1:
	DPCRE2_DOLLAR_ENDONLY                            = 0x00000010           // pcre2.h:123:1:
	DPCRE2_DOTALL                                    = 0x00000020           // pcre2.h:124:1:
	DPCRE2_DUPCAPUSED                                = 0x00200000           // pcre2_internal.h:529:1:
	DPCRE2_DUPNAMES                                  = 0x00000040           // pcre2.h:125:1:
	DPCRE2_ENDANCHORED                               = 0x20000000           // pcre2.h:107:1:
	DPCRE2_ERROR_ALPHA_ASSERTION_UNKNOWN             = 195                  // pcre2.h:311:1:
	DPCRE2_ERROR_BACKSLASH_C_CALLER_DISABLED         = 183                  // pcre2.h:299:1:
	DPCRE2_ERROR_BACKSLASH_C_LIBRARY_DISABLED        = 185                  // pcre2.h:301:1:
	DPCRE2_ERROR_BACKSLASH_C_SYNTAX                  = 168                  // pcre2.h:284:1:
	DPCRE2_ERROR_BACKSLASH_G_SYNTAX                  = 157                  // pcre2.h:272:1:
	DPCRE2_ERROR_BACKSLASH_K_IN_LOOKAROUND           = 199                  // pcre2.h:315:1:
	DPCRE2_ERROR_BACKSLASH_K_SYNTAX                  = 169                  // pcre2.h:285:1:
	DPCRE2_ERROR_BACKSLASH_N_IN_CLASS                = 171                  // pcre2.h:287:1:
	DPCRE2_ERROR_BACKSLASH_O_MISSING_BRACE           = 155                  // pcre2.h:270:1:
	DPCRE2_ERROR_BACKSLASH_U_CODE_POINT_TOO_BIG      = 177                  // pcre2.h:293:1:
	DPCRE2_ERROR_BADDATA                             = -29                  // pcre2.h:363:1:
	DPCRE2_ERROR_BADMAGIC                            = -31                  // pcre2.h:365:1:
	DPCRE2_ERROR_BADMODE                             = -32                  // pcre2.h:366:1:
	DPCRE2_ERROR_BADOFFSET                           = -33                  // pcre2.h:367:1:
	DPCRE2_ERROR_BADOFFSETLIMIT                      = -56                  // pcre2.h:391:1:
	DPCRE2_ERROR_BADOPTION                           = -34                  // pcre2.h:368:1:
	DPCRE2_ERROR_BADREPESCAPE                        = -57                  // pcre2.h:392:1:
	DPCRE2_ERROR_BADREPLACEMENT                      = -35                  // pcre2.h:369:1:
	DPCRE2_ERROR_BADSERIALIZEDDATA                   = -62                  // pcre2.h:397:1:
	DPCRE2_ERROR_BADSUBSPATTERN                      = -60                  // pcre2.h:395:1:
	DPCRE2_ERROR_BADSUBSTITUTION                     = -59                  // pcre2.h:394:1:
	DPCRE2_ERROR_BADUTFOFFSET                        = -36                  // pcre2.h:370:1:
	DPCRE2_ERROR_BAD_LITERAL_OPTIONS                 = 192                  // pcre2.h:308:1:
	DPCRE2_ERROR_BAD_OPTIONS                         = 117                  // pcre2.h:232:1:
	DPCRE2_ERROR_BAD_RELATIVE_REFERENCE              = 129                  // pcre2.h:244:1:
	DPCRE2_ERROR_BAD_SUBPATTERN_REFERENCE            = 115                  // pcre2.h:230:1:
	DPCRE2_ERROR_CALLOUT                             = -37                  // pcre2.h:371:1:
	DPCRE2_ERROR_CALLOUT_BAD_STRING_DELIMITER        = 182                  // pcre2.h:298:1:
	DPCRE2_ERROR_CALLOUT_NO_STRING_DELIMITER         = 181                  // pcre2.h:297:1:
	DPCRE2_ERROR_CALLOUT_NUMBER_TOO_BIG              = 138                  // pcre2.h:253:1:
	DPCRE2_ERROR_CALLOUT_STRING_TOO_LONG             = 172                  // pcre2.h:288:1:
	DPCRE2_ERROR_CLASS_INVALID_RANGE                 = 150                  // pcre2.h:265:1:
	DPCRE2_ERROR_CLASS_RANGE_ORDER                   = 108                  // pcre2.h:223:1:
	DPCRE2_ERROR_CODE_POINT_TOO_BIG                  = 134                  // pcre2.h:249:1:
	DPCRE2_ERROR_CONDITION_ASSERTION_EXPECTED        = 128                  // pcre2.h:243:1:
	DPCRE2_ERROR_CONDITION_ATOMIC_ASSERTION_EXPECTED = 198                  // pcre2.h:314:1:
	DPCRE2_ERROR_CONVERT_SYNTAX                      = -64                  // pcre2.h:399:1:
	DPCRE2_ERROR_DEFINE_TOO_MANY_BRANCHES            = 154                  // pcre2.h:269:1:
	DPCRE2_ERROR_DEPTHLIMIT                          = -53                  // pcre2.h:387:1:
	DPCRE2_ERROR_DFA_BADRESTART                      = -38                  // pcre2.h:372:1:
	DPCRE2_ERROR_DFA_RECURSE                         = -39                  // pcre2.h:373:1:
	DPCRE2_ERROR_DFA_UCOND                           = -40                  // pcre2.h:374:1:
	DPCRE2_ERROR_DFA_UFUNC                           = -41                  // pcre2.h:375:1:
	DPCRE2_ERROR_DFA_UINVALID_UTF                    = -66                  // pcre2.h:401:1:
	DPCRE2_ERROR_DFA_UITEM                           = -42                  // pcre2.h:376:1:
	DPCRE2_ERROR_DFA_WSSIZE                          = -43                  // pcre2.h:377:1:
	DPCRE2_ERROR_DUPLICATE_SUBPATTERN_NAME           = 143                  // pcre2.h:258:1:
	DPCRE2_ERROR_END_BACKSLASH                       = 101                  // pcre2.h:216:1:
	DPCRE2_ERROR_END_BACKSLASH_C                     = 102                  // pcre2.h:217:1:
	DPCRE2_ERROR_ESCAPE_INVALID_IN_CLASS             = 107                  // pcre2.h:222:1:
	DPCRE2_ERROR_ESCAPE_INVALID_IN_VERB              = 140                  // pcre2.h:255:1:
	DPCRE2_ERROR_HEAPLIMIT                           = -63                  // pcre2.h:398:1:
	DPCRE2_ERROR_HEAP_FAILED                         = 121                  // pcre2.h:236:1:
	DPCRE2_ERROR_INTERNAL                            = -44                  // pcre2.h:378:1:
	DPCRE2_ERROR_INTERNAL_BAD_CODE                   = 189                  // pcre2.h:305:1:
	DPCRE2_ERROR_INTERNAL_BAD_CODE_AUTO_POSSESS      = 180                  // pcre2.h:296:1:
	DPCRE2_ERROR_INTERNAL_BAD_CODE_IN_SKIP           = 190                  // pcre2.h:306:1:
	DPCRE2_ERROR_INTERNAL_BAD_CODE_LOOKBEHINDS       = 170                  // pcre2.h:286:1:
	DPCRE2_ERROR_INTERNAL_CODE_OVERFLOW              = 123                  // pcre2.h:238:1:
	DPCRE2_ERROR_INTERNAL_DUPMATCH                   = -65                  // pcre2.h:400:1:
	DPCRE2_ERROR_INTERNAL_MISSING_SUBPATTERN         = 153                  // pcre2.h:268:1:
	DPCRE2_ERROR_INTERNAL_OVERRAN_WORKSPACE          = 152                  // pcre2.h:267:1:
	DPCRE2_ERROR_INTERNAL_PARSED_OVERFLOW            = 163                  // pcre2.h:279:1:
	DPCRE2_ERROR_INTERNAL_STUDY_ERROR                = 131                  // pcre2.h:246:1:
	DPCRE2_ERROR_INTERNAL_UNEXPECTED_REPEAT          = 110                  // pcre2.h:225:1:
	DPCRE2_ERROR_INTERNAL_UNKNOWN_NEWLINE            = 156                  // pcre2.h:271:1:
	DPCRE2_ERROR_INVALID_AFTER_PARENS_QUERY          = 111                  // pcre2.h:226:1:
	DPCRE2_ERROR_INVALID_HEXADECIMAL                 = 167                  // pcre2.h:283:1:
	DPCRE2_ERROR_INVALID_HYPHEN_IN_OPTIONS           = 194                  // pcre2.h:310:1:
	DPCRE2_ERROR_INVALID_OCTAL                       = 164                  // pcre2.h:280:1:
	DPCRE2_ERROR_INVALID_SUBPATTERN_NAME             = 144                  // pcre2.h:259:1:
	DPCRE2_ERROR_JIT_BADOPTION                       = -45                  // pcre2.h:379:1:
	DPCRE2_ERROR_JIT_STACKLIMIT                      = -46                  // pcre2.h:380:1:
	DPCRE2_ERROR_LOOKBEHIND_INVALID_BACKSLASH_C      = 136                  // pcre2.h:251:1:
	DPCRE2_ERROR_LOOKBEHIND_NOT_FIXED_LENGTH         = 125                  // pcre2.h:240:1:
	DPCRE2_ERROR_LOOKBEHIND_TOO_COMPLICATED          = 135                  // pcre2.h:250:1:
	DPCRE2_ERROR_LOOKBEHIND_TOO_LONG                 = 187                  // pcre2.h:303:1:
	DPCRE2_ERROR_MALFORMED_UNICODE_PROPERTY          = 146                  // pcre2.h:261:1:
	DPCRE2_ERROR_MARK_MISSING_ARGUMENT               = 166                  // pcre2.h:282:1:
	DPCRE2_ERROR_MATCHLIMIT                          = -47                  // pcre2.h:381:1:
	DPCRE2_ERROR_MISSING_CALLOUT_CLOSING             = 139                  // pcre2.h:254:1:
	DPCRE2_ERROR_MISSING_CLOSING_PARENTHESIS         = 114                  // pcre2.h:229:1:
	DPCRE2_ERROR_MISSING_COMMENT_CLOSING             = 118                  // pcre2.h:233:1:
	DPCRE2_ERROR_MISSING_CONDITION_CLOSING           = 124                  // pcre2.h:239:1:
	DPCRE2_ERROR_MISSING_NAME_TERMINATOR             = 142                  // pcre2.h:257:1:
	DPCRE2_ERROR_MISSING_OCTAL_OR_HEX_DIGITS         = 178                  // pcre2.h:294:1:
	DPCRE2_ERROR_MISSING_SQUARE_BRACKET              = 106                  // pcre2.h:221:1:
	DPCRE2_ERROR_MIXEDTABLES                         = -30                  // pcre2.h:364:1:
	DPCRE2_ERROR_NOMATCH                             = -1                   // pcre2.h:320:1:
	DPCRE2_ERROR_NOMEMORY                            = -48                  // pcre2.h:382:1:
	DPCRE2_ERROR_NOSUBSTRING                         = -49                  // pcre2.h:383:1:
	DPCRE2_ERROR_NOUNIQUESUBSTRING                   = -50                  // pcre2.h:384:1:
	DPCRE2_ERROR_NO_SURROGATES_IN_UTF16              = 191                  // pcre2.h:307:1:
	DPCRE2_ERROR_NULL                                = -51                  // pcre2.h:385:1:
	DPCRE2_ERROR_NULL_PATTERN                        = 116                  // pcre2.h:231:1:
	DPCRE2_ERROR_OCTAL_BYTE_TOO_BIG                  = 151                  // pcre2.h:266:1:
	DPCRE2_ERROR_PARENS_QUERY_R_MISSING_CLOSING      = 158                  // pcre2.h:273:1:
	DPCRE2_ERROR_PARENTHESES_NEST_TOO_DEEP           = 119                  // pcre2.h:234:1:
	DPCRE2_ERROR_PARENTHESES_STACK_CHECK             = 133                  // pcre2.h:248:1:
	DPCRE2_ERROR_PARTIAL                             = -2                   // pcre2.h:321:1:
	DPCRE2_ERROR_PATTERN_STRING_TOO_LONG             = 188                  // pcre2.h:304:1:
	DPCRE2_ERROR_PATTERN_TOO_COMPLICATED             = 186                  // pcre2.h:302:1:
	DPCRE2_ERROR_PATTERN_TOO_LARGE                   = 120                  // pcre2.h:235:1:
	DPCRE2_ERROR_POSIX_CLASS_NOT_IN_CLASS            = 112                  // pcre2.h:227:1:
	DPCRE2_ERROR_POSIX_NO_SUPPORT_COLLATING          = 113                  // pcre2.h:228:1:
	DPCRE2_ERROR_QUANTIFIER_INVALID                  = 109                  // pcre2.h:224:1:
	DPCRE2_ERROR_QUANTIFIER_OUT_OF_ORDER             = 104                  // pcre2.h:219:1:
	DPCRE2_ERROR_QUANTIFIER_TOO_BIG                  = 105                  // pcre2.h:220:1:
	DPCRE2_ERROR_QUERY_BARJX_NEST_TOO_DEEP           = 184                  // pcre2.h:300:1:
	DPCRE2_ERROR_RECURSELOOP                         = -52                  // pcre2.h:386:1:
	DPCRE2_ERROR_RECURSIONLIMIT                      = -53                  // pcre2.h:388:1:
	DPCRE2_ERROR_REPMISSINGBRACE                     = -58                  // pcre2.h:393:1:
	DPCRE2_ERROR_SCRIPT_RUN_NOT_AVAILABLE            = 196                  // pcre2.h:312:1:
	DPCRE2_ERROR_SUBPATTERN_NAMES_MISMATCH           = 165                  // pcre2.h:281:1:
	DPCRE2_ERROR_SUBPATTERN_NAME_EXPECTED            = 162                  // pcre2.h:278:1:
	DPCRE2_ERROR_SUBPATTERN_NAME_TOO_LONG            = 148                  // pcre2.h:263:1:
	DPCRE2_ERROR_SUBPATTERN_NUMBER_TOO_BIG           = 161                  // pcre2.h:277:1:
	DPCRE2_ERROR_SUPPORTED_ONLY_IN_UNICODE           = 193                  // pcre2.h:309:1:
	DPCRE2_ERROR_TOOMANYREPLACE                      = -61                  // pcre2.h:396:1:
	DPCRE2_ERROR_TOO_MANY_CAPTURES                   = 197                  // pcre2.h:313:1:
	DPCRE2_ERROR_TOO_MANY_CONDITION_BRANCHES         = 127                  // pcre2.h:242:1:
	DPCRE2_ERROR_TOO_MANY_NAMED_SUBPATTERNS          = 149                  // pcre2.h:264:1:
	DPCRE2_ERROR_UCP_IS_DISABLED                     = 175                  // pcre2.h:291:1:
	DPCRE2_ERROR_UNAVAILABLE                         = -54                  // pcre2.h:389:1:
	DPCRE2_ERROR_UNICODE_DISALLOWED_CODE_POINT       = 173                  // pcre2.h:289:1:
	DPCRE2_ERROR_UNICODE_NOT_SUPPORTED               = 132                  // pcre2.h:247:1:
	DPCRE2_ERROR_UNICODE_PROPERTIES_UNAVAILABLE      = 145                  // pcre2.h:260:1:
	DPCRE2_ERROR_UNKNOWN_ESCAPE                      = 103                  // pcre2.h:218:1:
	DPCRE2_ERROR_UNKNOWN_POSIX_CLASS                 = 130                  // pcre2.h:245:1:
	DPCRE2_ERROR_UNKNOWN_UNICODE_PROPERTY            = 147                  // pcre2.h:262:1:
	DPCRE2_ERROR_UNMATCHED_CLOSING_PARENTHESIS       = 122                  // pcre2.h:237:1:
	DPCRE2_ERROR_UNRECOGNIZED_AFTER_QUERY_P          = 141                  // pcre2.h:256:1:
	DPCRE2_ERROR_UNSET                               = -55                  // pcre2.h:390:1:
	DPCRE2_ERROR_UNSUPPORTED_ESCAPE_SEQUENCE         = 137                  // pcre2.h:252:1:
	DPCRE2_ERROR_UTF16_ERR1                          = -24                  // pcre2.h:349:1:
	DPCRE2_ERROR_UTF16_ERR2                          = -25                  // pcre2.h:350:1:
	DPCRE2_ERROR_UTF16_ERR3                          = -26                  // pcre2.h:351:1:
	DPCRE2_ERROR_UTF32_ERR1                          = -27                  // pcre2.h:355:1:
	DPCRE2_ERROR_UTF32_ERR2                          = -28                  // pcre2.h:356:1:
	DPCRE2_ERROR_UTF8_ERR1                           = -3                   // pcre2.h:325:1:
	DPCRE2_ERROR_UTF8_ERR10                          = -12                  // pcre2.h:334:1:
	DPCRE2_ERROR_UTF8_ERR11                          = -13                  // pcre2.h:335:1:
	DPCRE2_ERROR_UTF8_ERR12                          = -14                  // pcre2.h:336:1:
	DPCRE2_ERROR_UTF8_ERR13                          = -15                  // pcre2.h:337:1:
	DPCRE2_ERROR_UTF8_ERR14                          = -16                  // pcre2.h:338:1:
	DPCRE2_ERROR_UTF8_ERR15                          = -17                  // pcre2.h:339:1:
	DPCRE2_ERROR_UTF8_ERR16                          = -18                  // pcre2.h:340:1:
	DPCRE2_ERROR_UTF8_ERR17                          = -19                  // pcre2.h:341:1:
	DPCRE2_ERROR_UTF8_ERR18                          = -20                  // pcre2.h:342:1:
	DPCRE2_ERROR_UTF8_ERR19                          = -21                  // pcre2.h:343:1:
	DPCRE2_ERROR_UTF8_ERR2                           = -4                   // pcre2.h:326:1:
	DPCRE2_ERROR_UTF8_ERR20                          = -22                  // pcre2.h:344:1:
	DPCRE2_ERROR_UTF8_ERR21                          = -23                  // pcre2.h:345:1:
	DPCRE2_ERROR_UTF8_ERR3                           = -5                   // pcre2.h:327:1:
	DPCRE2_ERROR_UTF8_ERR4                           = -6                   // pcre2.h:328:1:
	DPCRE2_ERROR_UTF8_ERR5                           = -7                   // pcre2.h:329:1:
	DPCRE2_ERROR_UTF8_ERR6                           = -8                   // pcre2.h:330:1:
	DPCRE2_ERROR_UTF8_ERR7                           = -9                   // pcre2.h:331:1:
	DPCRE2_ERROR_UTF8_ERR8                           = -10                  // pcre2.h:332:1:
	DPCRE2_ERROR_UTF8_ERR9                           = -11                  // pcre2.h:333:1:
	DPCRE2_ERROR_UTF_IS_DISABLED                     = 174                  // pcre2.h:290:1:
	DPCRE2_ERROR_VERB_ARGUMENT_NOT_ALLOWED           = 159                  // pcre2.h:275:1:
	DPCRE2_ERROR_VERB_NAME_TOO_LONG                  = 176                  // pcre2.h:292:1:
	DPCRE2_ERROR_VERB_UNKNOWN                        = 160                  // pcre2.h:276:1:
	DPCRE2_ERROR_VERSION_CONDITION_SYNTAX            = 179                  // pcre2.h:295:1:
	DPCRE2_ERROR_ZERO_RELATIVE_REFERENCE             = 126                  // pcre2.h:241:1:
	DPCRE2_EXTENDED                                  = 0x00000080           // pcre2.h:126:1:
	DPCRE2_EXTENDED_MORE                             = 0x01000000           // pcre2.h:143:1:
	DPCRE2_EXTRA_ALLOW_LOOKAROUND_BSK                = 0x00000040           // pcre2.h:155:1:
	DPCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES             = 0x00000001           // pcre2.h:149:1:
	DPCRE2_EXTRA_ALT_BSUX                            = 0x00000020           // pcre2.h:154:1:
	DPCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL               = 0x00000002           // pcre2.h:150:1:
	DPCRE2_EXTRA_ESCAPED_CR_IS_LF                    = 0x00000010           // pcre2.h:153:1:
	DPCRE2_EXTRA_MATCH_LINE                          = 0x00000008           // pcre2.h:152:1:
	DPCRE2_EXTRA_MATCH_WORD                          = 0x00000004           // pcre2.h:151:1:
	DPCRE2_FIRSTCASELESS                             = 0x00000020           // pcre2_internal.h:513:1:
	DPCRE2_FIRSTLINE                                 = 0x00000100           // pcre2.h:127:1:
	DPCRE2_FIRSTMAPSET                               = 0x00000040           // pcre2_internal.h:514:1:
	DPCRE2_FIRSTSET                                  = 0x00000010           // pcre2_internal.h:512:1:
	DPCRE2_HASACCEPT                                 = 0x00800000           // pcre2_internal.h:531:1:
	DPCRE2_HASBKC                                    = 0x00400000           // pcre2_internal.h:530:1:
	DPCRE2_HASBKPORX                                 = 0x00100000           // pcre2_internal.h:528:1:
	DPCRE2_HASCRORLF                                 = 0x00000800           // pcre2_internal.h:519:1:
	DPCRE2_HASTHEN                                   = 0x00001000           // pcre2_internal.h:520:1:
	DPCRE2_H_IDEMPOTENT_GUARD                        = 0                    // pcre2.h:40:1:
	DPCRE2_INFO_ALLOPTIONS                           = 0                    // pcre2.h:406:1:
	DPCRE2_INFO_ARGOPTIONS                           = 1                    // pcre2.h:407:1:
	DPCRE2_INFO_BACKREFMAX                           = 2                    // pcre2.h:408:1:
	DPCRE2_INFO_BSR                                  = 3                    // pcre2.h:409:1:
	DPCRE2_INFO_CAPTURECOUNT                         = 4                    // pcre2.h:410:1:
	DPCRE2_INFO_DEPTHLIMIT                           = 21                   // pcre2.h:427:1:
	DPCRE2_INFO_EXTRAOPTIONS                         = 26                   // pcre2.h:433:1:
	DPCRE2_INFO_FIRSTBITMAP                          = 7                    // pcre2.h:413:1:
	DPCRE2_INFO_FIRSTCODETYPE                        = 6                    // pcre2.h:412:1:
	DPCRE2_INFO_FIRSTCODEUNIT                        = 5                    // pcre2.h:411:1:
	DPCRE2_INFO_FRAMESIZE                            = 24                   // pcre2.h:431:1:
	DPCRE2_INFO_HASBACKSLASHC                        = 23                   // pcre2.h:430:1:
	DPCRE2_INFO_HASCRORLF                            = 8                    // pcre2.h:414:1:
	DPCRE2_INFO_HEAPLIMIT                            = 25                   // pcre2.h:432:1:
	DPCRE2_INFO_JCHANGED                             = 9                    // pcre2.h:415:1:
	DPCRE2_INFO_JITSIZE                              = 10                   // pcre2.h:416:1:
	DPCRE2_INFO_LASTCODETYPE                         = 12                   // pcre2.h:418:1:
	DPCRE2_INFO_LASTCODEUNIT                         = 11                   // pcre2.h:417:1:
	DPCRE2_INFO_MATCHEMPTY                           = 13                   // pcre2.h:419:1:
	DPCRE2_INFO_MATCHLIMIT                           = 14                   // pcre2.h:420:1:
	DPCRE2_INFO_MAXLOOKBEHIND                        = 15                   // pcre2.h:421:1:
	DPCRE2_INFO_MINLENGTH                            = 16                   // pcre2.h:422:1:
	DPCRE2_INFO_NAMECOUNT                            = 17                   // pcre2.h:423:1:
	DPCRE2_INFO_NAMEENTRYSIZE                        = 18                   // pcre2.h:424:1:
	DPCRE2_INFO_NAMETABLE                            = 19                   // pcre2.h:425:1:
	DPCRE2_INFO_NEWLINE                              = 20                   // pcre2.h:426:1:
	DPCRE2_INFO_RECURSIONLIMIT                       = 21                   // pcre2.h:428:1:
	DPCRE2_INFO_SIZE                                 = 22                   // pcre2.h:429:1:
	DPCRE2_INTERNAL_H_IDEMPOTENT_GUARD               = 0                    // pcre2_internal.h:42:1:
	DPCRE2_JCHANGED                                  = 0x00000400           // pcre2_internal.h:518:1:
	DPCRE2_JIT_COMPLETE                              = 0x00000001           // pcre2.h:159:1:
	DPCRE2_JIT_INVALID_UTF                           = 0x00000100           // pcre2.h:162:1:
	DPCRE2_JIT_PARTIAL_HARD                          = 0x00000004           // pcre2.h:161:1:
	DPCRE2_JIT_PARTIAL_SOFT                          = 0x00000002           // pcre2.h:160:1:
	DPCRE2_KEEP_UNINITIALIZED                        = 0                    // pcre2_internal.h:87:1:
	DPCRE2_LASTCASELESS                              = 0x00000100           // pcre2_internal.h:516:1:
	DPCRE2_LASTSET                                   = 0x00000080           // pcre2_internal.h:515:1:
	DPCRE2_LITERAL                                   = 0x02000000           // pcre2.h:144:1:
	DPCRE2_MAJOR                                     = 10                   // pcre2.h:44:1:
	DPCRE2_MATCH_EMPTY                               = 0x00002000           // pcre2_internal.h:521:1:
	DPCRE2_MATCH_INVALID_UTF                         = 0x04000000           // pcre2.h:145:1:
	DPCRE2_MATCH_UNSET_BACKREF                       = 0x00000200           // pcre2.h:128:1:
	DPCRE2_MD_COPIED_SUBJECT                         = 0x01                 // pcre2_internal.h:543:1:
	DPCRE2_MINOR                                     = 40                   // pcre2.h:45:1:
	DPCRE2_MODE16                                    = 0x00000002           // pcre2_internal.h:510:1:
	DPCRE2_MODE32                                    = 0x00000004           // pcre2_internal.h:511:1:
	DPCRE2_MODE8                                     = 0x00000001           // pcre2_internal.h:509:1:
	DPCRE2_MODE_MASK                                 = 7                    // pcre2_internal.h:533:1:
	DPCRE2_MULTILINE                                 = 0x00000400           // pcre2.h:129:1:
	DPCRE2_NEVER_BACKSLASH_C                         = 0x00100000           // pcre2.h:139:1:
	DPCRE2_NEVER_UCP                                 = 0x00000800           // pcre2.h:130:1:
	DPCRE2_NEVER_UTF                                 = 0x00001000           // pcre2.h:131:1:
	DPCRE2_NEWLINE_ANY                               = 4                    // pcre2.h:206:1:
	DPCRE2_NEWLINE_ANYCRLF                           = 5                    // pcre2.h:207:1:
	DPCRE2_NEWLINE_CR                                = 1                    // pcre2.h:203:1:
	DPCRE2_NEWLINE_CRLF                              = 3                    // pcre2.h:205:1:
	DPCRE2_NEWLINE_LF                                = 2                    // pcre2.h:204:1:
	DPCRE2_NEWLINE_NUL                               = 6                    // pcre2.h:208:1:
	DPCRE2_NE_ATST_SET                               = 0x00020000           // pcre2_internal.h:525:1:
	DPCRE2_NL_SET                                    = 0x00008000           // pcre2_internal.h:523:1:
	DPCRE2_NOJIT                                     = 0x00080000           // pcre2_internal.h:527:1:
	DPCRE2_NOTBOL                                    = 0x00000001           // pcre2.h:170:1:
	DPCRE2_NOTEMPTY                                  = 0x00000004           // pcre2.h:172:1:
	DPCRE2_NOTEMPTY_ATSTART                          = 0x00000008           // pcre2.h:173:1:
	DPCRE2_NOTEMPTY_SET                              = 0x00010000           // pcre2_internal.h:524:1:
	DPCRE2_NOTEOL                                    = 0x00000002           // pcre2.h:171:1:
	DPCRE2_NO_AUTO_CAPTURE                           = 0x00002000           // pcre2.h:132:1:
	DPCRE2_NO_AUTO_POSSESS                           = 0x00004000           // pcre2.h:133:1:
	DPCRE2_NO_DOTSTAR_ANCHOR                         = 0x00008000           // pcre2.h:134:1:
	DPCRE2_NO_JIT                                    = 0x00002000           // pcre2.h:183:1:
	DPCRE2_NO_START_OPTIMIZE                         = 0x00010000           // pcre2.h:135:1:
	DPCRE2_NO_UTF_CHECK                              = 0x40000000           // pcre2.h:106:1:
	DPCRE2_PARTIAL_HARD                              = 0x00000020           // pcre2.h:175:1:
	DPCRE2_PARTIAL_SOFT                              = 0x00000010           // pcre2.h:174:1:
	DPCRE2_PRERELEASE                                = 0                    // pcre2.h:46:1:
	DPCRE2_SIZE_MAX                                  = 18446744073709551615 // pcre2.h:472:1:
	DPCRE2_STARTLINE                                 = 0x00000200           // pcre2_internal.h:517:1:
	DPCRE2_SUBSTITUTE_EXTENDED                       = 0x00000200           // pcre2.h:179:1:
	DPCRE2_SUBSTITUTE_GLOBAL                         = 0x00000100           // pcre2.h:178:1:
	DPCRE2_SUBSTITUTE_LITERAL                        = 0x00008000           // pcre2.h:185:1:
	DPCRE2_SUBSTITUTE_MATCHED                        = 0x00010000           // pcre2.h:186:1:
	DPCRE2_SUBSTITUTE_OVERFLOW_LENGTH                = 0x00001000           // pcre2.h:182:1:
	DPCRE2_SUBSTITUTE_REPLACEMENT_ONLY               = 0x00020000           // pcre2.h:187:1:
	DPCRE2_SUBSTITUTE_UNKNOWN_UNSET                  = 0x00000800           // pcre2.h:181:1:
	DPCRE2_SUBSTITUTE_UNSET_EMPTY                    = 0x00000400           // pcre2.h:180:1:
	DPCRE2_UCP                                       = 0x00020000           // pcre2.h:136:1:
	DPCRE2_UCP_H_IDEMPOTENT_GUARD                    = 0                    // pcre2_ucp.h:46:1:
	DPCRE2_UNGREEDY                                  = 0x00040000           // pcre2.h:137:1:
	DPCRE2_USE_OFFSET_LIMIT                          = 0x00800000           // pcre2.h:142:1:
	DPCRE2_UTF                                       = 0x00080000           // pcre2.h:138:1:
	DPDP_ENDIAN                                      = 3412                 // endian.h:29:1:
	DPIPE_BUF                                        = 4096                 // limits.h:14:1:
	DPRIX16                                          = "X"                  // inttypes.h:135:1:
	DPRIX32                                          = "X"                  // inttypes.h:136:1:
	DPRIX8                                           = "X"                  // inttypes.h:134:1:
	DPRIXFAST8                                       = "X"                  // inttypes.h:144:1:
	DPRIXLEAST16                                     = "X"                  // inttypes.h:140:1:
	DPRIXLEAST32                                     = "X"                  // inttypes.h:141:1:
	DPRIXLEAST8                                      = "X"                  // inttypes.h:139:1:
	DPRId16                                          = "d"                  // inttypes.h:55:1:
	DPRId32                                          = "d"                  // inttypes.h:56:1:
	DPRId8                                           = "d"                  // inttypes.h:54:1:
	DPRIdFAST8                                       = "d"                  // inttypes.h:64:1:
	DPRIdLEAST16                                     = "d"                  // inttypes.h:60:1:
	DPRIdLEAST32                                     = "d"                  // inttypes.h:61:1:
	DPRIdLEAST8                                      = "d"                  // inttypes.h:59:1:
	DPRIi16                                          = "i"                  // inttypes.h:71:1:
	DPRIi32                                          = "i"                  // inttypes.h:72:1:
	DPRIi8                                           = "i"                  // inttypes.h:70:1:
	DPRIiFAST8                                       = "i"                  // inttypes.h:80:1:
	DPRIiLEAST16                                     = "i"                  // inttypes.h:76:1:
	DPRIiLEAST32                                     = "i"                  // inttypes.h:77:1:
	DPRIiLEAST8                                      = "i"                  // inttypes.h:75:1:
	DPRIo16                                          = "o"                  // inttypes.h:87:1:
	DPRIo32                                          = "o"                  // inttypes.h:88:1:
	DPRIo8                                           = "o"                  // inttypes.h:86:1:
	DPRIoFAST8                                       = "o"                  // inttypes.h:96:1:
	DPRIoLEAST16                                     = "o"                  // inttypes.h:92:1:
	DPRIoLEAST32                                     = "o"                  // inttypes.h:93:1:
	DPRIoLEAST8                                      = "o"                  // inttypes.h:91:1:
	DPRIu16                                          = "u"                  // inttypes.h:103:1:
	DPRIu32                                          = "u"                  // inttypes.h:104:1:
	DPRIu8                                           = "u"                  // inttypes.h:102:1:
	DPRIuFAST8                                       = "u"                  // inttypes.h:112:1:
	DPRIuLEAST16                                     = "u"                  // inttypes.h:108:1:
	DPRIuLEAST32                                     = "u"                  // inttypes.h:109:1:
	DPRIuLEAST8                                      = "u"                  // inttypes.h:107:1:
	DPRIx16                                          = "x"                  // inttypes.h:119:1:
	DPRIx32                                          = "x"                  // inttypes.h:120:1:
	DPRIx8                                           = "x"                  // inttypes.h:118:1:
	DPRIxFAST8                                       = "x"                  // inttypes.h:128:1:
	DPRIxLEAST16                                     = "x"                  // inttypes.h:124:1:
	DPRIxLEAST32                                     = "x"                  // inttypes.h:125:1:
	DPRIxLEAST8                                      = "x"                  // inttypes.h:123:1:
	DPTHREAD_DESTRUCTOR_ITERATIONS                   = 4                    // local_lim.h:69:1:
	DPTHREAD_KEYS_MAX                                = 1024                 // local_lim.h:64:1:
	DPTRDIFF_MAX                                     = 9223372036854775807  // stdint.h:210:1:
	DPTRDIFF_MIN                                     = -9223372036854775808 // stdint.h:209:1:
	DPTRDIFF_WIDTH                                   = 64                   // stdint.h:311:1:
	DPT_ALNUM                                        = 6                    // pcre2_internal.h:1282:1:
	DPT_ANY                                          = 0                    // pcre2_internal.h:1276:1:
	DPT_BIDICL                                       = 12                   // pcre2_internal.h:1288:1:
	DPT_BOOL                                         = 13                   // pcre2_internal.h:1289:1:
	DPT_CLIST                                        = 10                   // pcre2_internal.h:1286:1:
	DPT_GC                                           = 2                    // pcre2_internal.h:1278:1:
	DPT_LAMP                                         = 1                    // pcre2_internal.h:1277:1:
	DPT_NOTSCRIPT                                    = 255                  // pcre2_internal.h:1305:1:
	DPT_PC                                           = 3                    // pcre2_internal.h:1279:1:
	DPT_PXGRAPH                                      = 14                   // pcre2_internal.h:1298:1:
	DPT_PXPRINT                                      = 15                   // pcre2_internal.h:1299:1:
	DPT_PXPUNCT                                      = 16                   // pcre2_internal.h:1300:1:
	DPT_PXSPACE                                      = 8                    // pcre2_internal.h:1284:1:
	DPT_SC                                           = 4                    // pcre2_internal.h:1280:1:
	DPT_SCX                                          = 5                    // pcre2_internal.h:1281:1:
	DPT_SPACE                                        = 7                    // pcre2_internal.h:1283:1:
	DPT_TABSIZE                                      = 14                   // pcre2_internal.h:1290:1:
	DPT_UCNC                                         = 11                   // pcre2_internal.h:1287:1:
	DPT_WORD                                         = 9                    // pcre2_internal.h:1285:1:
	DP_tmpdir                                        = "/tmp"               // stdio.h:120:1:
	DRAND_MAX                                        = 2147483647           // stdlib.h:87:1:
	DRENAME_EXCHANGE                                 = 2                    // stdio.h:165:1:
	DRENAME_NOREPLACE                                = 1                    // stdio.h:164:1:
	DRENAME_WHITEOUT                                 = 4                    // stdio.h:166:1:
	DREQ_CU_MAX                                      = 5000                 // pcre2_internal.h:555:1:
	DRE_DUP_MAX                                      = 32767                // posix2_lim.h:88:1:
	DRREF_ANY                                        = 0xffff               // pcre2_internal.h:1783:1:
	DRTSIG_MAX                                       = 32                   // limits.h:19:1:
	DSCHAR_MAX                                       = 127                  // limits.h:75:1:
	DSCHAR_MIN                                       = -128                 // limits.h:73:1:
	DSCHAR_WIDTH                                     = 8                    // limits.h:167:1:
	DSCNd16                                          = "hd"                 // inttypes.h:172:1:
	DSCNd32                                          = "d"                  // inttypes.h:173:1:
	DSCNd8                                           = "hhd"                // inttypes.h:171:1:
	DSCNdFAST8                                       = "hhd"                // inttypes.h:181:1:
	DSCNdLEAST16                                     = "hd"                 // inttypes.h:177:1:
	DSCNdLEAST32                                     = "d"                  // inttypes.h:178:1:
	DSCNdLEAST8                                      = "hhd"                // inttypes.h:176:1:
	DSCNi16                                          = "hi"                 // inttypes.h:188:1:
	DSCNi32                                          = "i"                  // inttypes.h:189:1:
	DSCNi8                                           = "hhi"                // inttypes.h:187:1:
	DSCNiFAST8                                       = "hhi"                // inttypes.h:197:1:
	DSCNiLEAST16                                     = "hi"                 // inttypes.h:193:1:
	DSCNiLEAST32                                     = "i"                  // inttypes.h:194:1:
	DSCNiLEAST8                                      = "hhi"                // inttypes.h:192:1:
	DSCNo16                                          = "ho"                 // inttypes.h:220:1:
	DSCNo32                                          = "o"                  // inttypes.h:221:1:
	DSCNo8                                           = "hho"                // inttypes.h:219:1:
	DSCNoFAST8                                       = "hho"                // inttypes.h:229:1:
	DSCNoLEAST16                                     = "ho"                 // inttypes.h:225:1:
	DSCNoLEAST32                                     = "o"                  // inttypes.h:226:1:
	DSCNoLEAST8                                      = "hho"                // inttypes.h:224:1:
	DSCNu16                                          = "hu"                 // inttypes.h:204:1:
	DSCNu32                                          = "u"                  // inttypes.h:205:1:
	DSCNu8                                           = "hhu"                // inttypes.h:203:1:
	DSCNuFAST8                                       = "hhu"                // inttypes.h:213:1:
	DSCNuLEAST16                                     = "hu"                 // inttypes.h:209:1:
	DSCNuLEAST32                                     = "u"                  // inttypes.h:210:1:
	DSCNuLEAST8                                      = "hhu"                // inttypes.h:208:1:
	DSCNx16                                          = "hx"                 // inttypes.h:236:1:
	DSCNx32                                          = "x"                  // inttypes.h:237:1:
	DSCNx8                                           = "hhx"                // inttypes.h:235:1:
	DSCNxFAST8                                       = "hhx"                // inttypes.h:245:1:
	DSCNxLEAST16                                     = "hx"                 // inttypes.h:241:1:
	DSCNxLEAST32                                     = "x"                  // inttypes.h:242:1:
	DSCNxLEAST8                                      = "hhx"                // inttypes.h:240:1:
	DSEEK_CUR                                        = 1                    // stdio.h:110:1:
	DSEEK_DATA                                       = 3                    // stdio.h:113:1:
	DSEEK_END                                        = 2                    // stdio.h:111:1:
	DSEEK_HOLE                                       = 4                    // stdio.h:114:1:
	DSEEK_SET                                        = 0                    // stdio.h:109:1:
	DSEM_VALUE_MAX                                   = 2147483647           // local_lim.h:99:1:
	DSHRT_MAX                                        = 32767                // limits.h:106:1:
	DSHRT_MIN                                        = -32768               // limits.h:104:1:
	DSHRT_WIDTH                                      = 16                   // limits.h:171:1:
	DSIG_ATOMIC_MAX                                  = 2147483647           // stdint.h:223:1:
	DSIG_ATOMIC_MIN                                  = -2147483648          // stdint.h:222:1:
	DSIG_ATOMIC_WIDTH                                = 32                   // stdint.h:312:1:
	DSIZE_MAX                                        = 18446744073709551615 // stdint.h:227:1:
	DSIZE_WIDTH                                      = 64                   // stdint.h:313:1:
	DSSIZE_MAX                                       = 9223372036854775807  // posix1_lim.h:169:1:
	DSTART_FRAMES_SIZE                               = 20480                // pcre2_internal.h:231:1:
	DSTDC_HEADERS                                    = 1                    // config.h:292:1:
	DSTR_0                                           = "\060"               // pcre2_internal.h:1106:1:
	DSTR_1                                           = "\061"               // pcre2_internal.h:1107:1:
	DSTR_2                                           = "\062"               // pcre2_internal.h:1108:1:
	DSTR_3                                           = "\063"               // pcre2_internal.h:1109:1:
	DSTR_4                                           = "\064"               // pcre2_internal.h:1110:1:
	DSTR_5                                           = "\065"               // pcre2_internal.h:1111:1:
	DSTR_6                                           = "\066"               // pcre2_internal.h:1112:1:
	DSTR_7                                           = "\067"               // pcre2_internal.h:1113:1:
	DSTR_8                                           = "\070"               // pcre2_internal.h:1114:1:
	DSTR_9                                           = "\071"               // pcre2_internal.h:1115:1:
	DSTR_A                                           = "\101"               // pcre2_internal.h:1123:1:
	DSTR_AMPERSAND                                   = "\046"               // pcre2_internal.h:1096:1:
	DSTR_APOSTROPHE                                  = "\047"               // pcre2_internal.h:1097:1:
	DSTR_ASTERISK                                    = "\052"               // pcre2_internal.h:1100:1:
	DSTR_B                                           = "\102"               // pcre2_internal.h:1124:1:
	DSTR_BACKSLASH                                   = "\134"               // pcre2_internal.h:1150:1:
	DSTR_BEL                                         = "\007"               // pcre2_internal.h:1086:1:
	DSTR_BS                                          = "\010"               // pcre2_internal.h:1085:1:
	DSTR_C                                           = "\103"               // pcre2_internal.h:1125:1:
	DSTR_CIRCUMFLEX_ACCENT                           = "\136"               // pcre2_internal.h:1152:1:
	DSTR_COLON                                       = "\072"               // pcre2_internal.h:1116:1:
	DSTR_COMMA                                       = "\054"               // pcre2_internal.h:1102:1:
	DSTR_COMMERCIAL_AT                               = "\100"               // pcre2_internal.h:1122:1:
	DSTR_CR                                          = "\015"               // pcre2_internal.h:1083:1:
	DSTR_D                                           = "\104"               // pcre2_internal.h:1126:1:
	DSTR_DEL                                         = "\177"               // pcre2_internal.h:1088:1:
	DSTR_DOLLAR_SIGN                                 = "\044"               // pcre2_internal.h:1094:1:
	DSTR_DOT                                         = "\056"               // pcre2_internal.h:1104:1:
	DSTR_E                                           = "\105"               // pcre2_internal.h:1127:1:
	DSTR_EQUALS_SIGN                                 = "\075"               // pcre2_internal.h:1119:1:
	DSTR_ESC                                         = "\033"               // pcre2_internal.h:1087:1:
	DSTR_EXCLAMATION_MARK                            = "\041"               // pcre2_internal.h:1091:1:
	DSTR_F                                           = "\106"               // pcre2_internal.h:1128:1:
	DSTR_FF                                          = "\014"               // pcre2_internal.h:1082:1:
	DSTR_G                                           = "\107"               // pcre2_internal.h:1129:1:
	DSTR_GRAVE_ACCENT                                = "\140"               // pcre2_internal.h:1154:1:
	DSTR_GREATER_THAN_SIGN                           = "\076"               // pcre2_internal.h:1120:1:
	DSTR_H                                           = "\110"               // pcre2_internal.h:1130:1:
	DSTR_HT                                          = "\011"               // pcre2_internal.h:1080:1:
	DSTR_I                                           = "\111"               // pcre2_internal.h:1131:1:
	DSTR_J                                           = "\112"               // pcre2_internal.h:1132:1:
	DSTR_K                                           = "\113"               // pcre2_internal.h:1133:1:
	DSTR_L                                           = "\114"               // pcre2_internal.h:1134:1:
	DSTR_LEFT_CURLY_BRACKET                          = "\173"               // pcre2_internal.h:1181:1:
	DSTR_LEFT_PARENTHESIS                            = "\050"               // pcre2_internal.h:1098:1:
	DSTR_LEFT_SQUARE_BRACKET                         = "\133"               // pcre2_internal.h:1149:1:
	DSTR_LESS_THAN_SIGN                              = "\074"               // pcre2_internal.h:1118:1:
	DSTR_M                                           = "\115"               // pcre2_internal.h:1135:1:
	DSTR_MINUS                                       = "\055"               // pcre2_internal.h:1103:1:
	DSTR_N                                           = "\116"               // pcre2_internal.h:1136:1:
	DSTR_NL                                          = "\012"               // pcre2_internal.h:1084:1:
	DSTR_NUMBER_SIGN                                 = "\043"               // pcre2_internal.h:1093:1:
	DSTR_O                                           = "\117"               // pcre2_internal.h:1137:1:
	DSTR_P                                           = "\120"               // pcre2_internal.h:1138:1:
	DSTR_PERCENT_SIGN                                = "\045"               // pcre2_internal.h:1095:1:
	DSTR_PLUS                                        = "\053"               // pcre2_internal.h:1101:1:
	DSTR_Q                                           = "\121"               // pcre2_internal.h:1139:1:
	DSTR_QUESTION_MARK                               = "\077"               // pcre2_internal.h:1121:1:
	DSTR_QUOTATION_MARK                              = "\042"               // pcre2_internal.h:1092:1:
	DSTR_R                                           = "\122"               // pcre2_internal.h:1140:1:
	DSTR_RIGHT_CURLY_BRACKET                         = "\175"               // pcre2_internal.h:1183:1:
	DSTR_RIGHT_PARENTHESIS                           = "\051"               // pcre2_internal.h:1099:1:
	DSTR_RIGHT_SQUARE_BRACKET                        = "\135"               // pcre2_internal.h:1151:1:
	DSTR_S                                           = "\123"               // pcre2_internal.h:1141:1:
	DSTR_SEMICOLON                                   = "\073"               // pcre2_internal.h:1117:1:
	DSTR_SLASH                                       = "\057"               // pcre2_internal.h:1105:1:
	DSTR_SPACE                                       = "\040"               // pcre2_internal.h:1090:1:
	DSTR_T                                           = "\124"               // pcre2_internal.h:1142:1:
	DSTR_TILDE                                       = "\176"               // pcre2_internal.h:1184:1:
	DSTR_U                                           = "\125"               // pcre2_internal.h:1143:1:
	DSTR_UNDERSCORE                                  = "\137"               // pcre2_internal.h:1153:1:
	DSTR_V                                           = "\126"               // pcre2_internal.h:1144:1:
	DSTR_VERTICAL_LINE                               = "\174"               // pcre2_internal.h:1182:1:
	DSTR_VT                                          = "\013"               // pcre2_internal.h:1081:1:
	DSTR_W                                           = "\127"               // pcre2_internal.h:1145:1:
	DSTR_X                                           = "\130"               // pcre2_internal.h:1146:1:
	DSTR_Y                                           = "\131"               // pcre2_internal.h:1147:1:
	DSTR_Z                                           = "\132"               // pcre2_internal.h:1148:1:
	DSTR_a                                           = "\141"               // pcre2_internal.h:1155:1:
	DSTR_b                                           = "\142"               // pcre2_internal.h:1156:1:
	DSTR_c                                           = "\143"               // pcre2_internal.h:1157:1:
	DSTR_d                                           = "\144"               // pcre2_internal.h:1158:1:
	DSTR_e                                           = "\145"               // pcre2_internal.h:1159:1:
	DSTR_f                                           = "\146"               // pcre2_internal.h:1160:1:
	DSTR_g                                           = "\147"               // pcre2_internal.h:1161:1:
	DSTR_h                                           = "\150"               // pcre2_internal.h:1162:1:
	DSTR_i                                           = "\151"               // pcre2_internal.h:1163:1:
	DSTR_j                                           = "\152"               // pcre2_internal.h:1164:1:
	DSTR_k                                           = "\153"               // pcre2_internal.h:1165:1:
	DSTR_l                                           = "\154"               // pcre2_internal.h:1166:1:
	DSTR_m                                           = "\155"               // pcre2_internal.h:1167:1:
	DSTR_n                                           = "\156"               // pcre2_internal.h:1168:1:
	DSTR_o                                           = "\157"               // pcre2_internal.h:1169:1:
	DSTR_p                                           = "\160"               // pcre2_internal.h:1170:1:
	DSTR_q                                           = "\161"               // pcre2_internal.h:1171:1:
	DSTR_r                                           = "\162"               // pcre2_internal.h:1172:1:
	DSTR_s                                           = "\163"               // pcre2_internal.h:1173:1:
	DSTR_t                                           = "\164"               // pcre2_internal.h:1174:1:
	DSTR_u                                           = "\165"               // pcre2_internal.h:1175:1:
	DSTR_v                                           = "\166"               // pcre2_internal.h:1176:1:
	DSTR_w                                           = "\167"               // pcre2_internal.h:1177:1:
	DSTR_x                                           = "\170"               // pcre2_internal.h:1178:1:
	DSTR_y                                           = "\171"               // pcre2_internal.h:1179:1:
	DSTR_z                                           = "\172"               // pcre2_internal.h:1180:1:
	DSUPPORT_PCRE2GREP_CALLOUT                       = 0                    // config.h:312:1:
	DSUPPORT_PCRE2GREP_CALLOUT_FORK                  = 0                    // config.h:317:1:
	DSUPPORT_PCRE2_8                                 = 0                    // config.h:330:1:
	DSUPPORT_UNICODE                                 = 0                    // config.h:336:1:
	DSUPPORT_WIDE_CHARS                              = 0                    // pcre2_intmodedep.h:216:1:
	DTABLES_LENGTH                                   = 1088                 // pcre2_internal.h:593:1:
	DTMP_MAX                                         = 238328               // stdio_lim.h:26:1:
	DTRUE                                            = 1                    // pcre2_internal.h:70:1:
	DTTY_NAME_MAX                                    = 32                   // local_lim.h:87:1:
	DUCD_BIDICLASS_SHIFT                             = 11                   // pcre2_internal.h:1844:1:
	DUCD_BLOCK_SIZE                                  = 128                  // pcre2_internal.h:1831:1:
	DUCD_BPROPS_MASK                                 = 0xfff                // pcre2_internal.h:1845:1:
	DUCD_SCRIPTX_MASK                                = 0x3ff                // pcre2_internal.h:1843:1:
	DUCHAR_MAX                                       = 255                  // limits.h:82:1:
	DUCHAR_WIDTH                                     = 8                    // limits.h:169:1:
	DUINT16_MAX                                      = 65535                // stdint.h:128:1:
	DUINT16_WIDTH                                    = 16                   // stdint.h:281:1:
	DUINT32_MAX                                      = 4294967295           // stdint.h:129:1:
	DUINT32_WIDTH                                    = 32                   // stdint.h:283:1:
	DUINT64_MAX                                      = 18446744073709551615 // stdint.h:130:1:
	DUINT64_WIDTH                                    = 64                   // stdint.h:285:1:
	DUINT8_MAX                                       = 255                  // stdint.h:127:1:
	DUINT8_WIDTH                                     = 8                    // stdint.h:279:1:
	DUINTMAX_MAX                                     = 18446744073709551615 // stdint.h:202:1:
	DUINTMAX_WIDTH                                   = 64                   // stdint.h:309:1:
	DUINTPTR_MAX                                     = 18446744073709551615 // stdint.h:188:1:
	DUINTPTR_WIDTH                                   = 64                   // stdint.h:306:1:
	DUINT_FAST16_MAX                                 = 18446744073709551615 // stdint.h:175:1:
	DUINT_FAST16_WIDTH                               = 64                   // stdint.h:299:1:
	DUINT_FAST32_MAX                                 = 18446744073709551615 // stdint.h:176:1:
	DUINT_FAST32_WIDTH                               = 64                   // stdint.h:301:1:
	DUINT_FAST64_MAX                                 = 18446744073709551615 // stdint.h:181:1:
	DUINT_FAST64_WIDTH                               = 64                   // stdint.h:303:1:
	DUINT_FAST8_MAX                                  = 255                  // stdint.h:173:1:
	DUINT_FAST8_WIDTH                                = 8                    // stdint.h:297:1:
	DUINT_LEAST16_MAX                                = 65535                // stdint.h:146:1:
	DUINT_LEAST16_WIDTH                              = 16                   // stdint.h:290:1:
	DUINT_LEAST32_MAX                                = 4294967295           // stdint.h:147:1:
	DUINT_LEAST32_WIDTH                              = 32                   // stdint.h:292:1:
	DUINT_LEAST64_MAX                                = 18446744073709551615 // stdint.h:148:1:
	DUINT_LEAST64_WIDTH                              = 64                   // stdint.h:294:1:
	DUINT_LEAST8_MAX                                 = 255                  // stdint.h:145:1:
	DUINT_LEAST8_WIDTH                               = 8                    // stdint.h:288:1:
	DUINT_MAX                                        = 4294967295           // limits.h:124:1:
	DUINT_WIDTH                                      = 32                   // limits.h:177:1:
	DULLONG_MAX                                      = 18446744073709551615 // limits.h:146:1:
	DULLONG_WIDTH                                    = 64                   // limits.h:185:1:
	DULONG_LONG_MAX                                  = 18446744073709551615 // limits.h:158:1:
	DULONG_MAX                                       = 18446744073709551615 // limits.h:135:1:
	DULONG_WIDTH                                     = 64                   // limits.h:181:1:
	DUSHRT_MAX                                       = 65535                // limits.h:113:1:
	DUSHRT_WIDTH                                     = 16                   // limits.h:173:1:
	DVERSION                                         = "10.40"              // config.h:430:1:
	DWCHAR_MAX                                       = 2147483647           // stdint.h:240:1:
	DWCHAR_MIN                                       = -2147483648          // stdint.h:239:1:
	DWCHAR_WIDTH                                     = 32                   // stdint.h:314:1:
	DWCONTINUED                                      = 8                    // waitflags.h:32:1:
	DWEXITED                                         = 4                    // waitflags.h:31:1:
	DWINT_MAX                                        = 4294967295           // stdint.h:245:1:
	DWINT_MIN                                        = 0                    // stdint.h:244:1:
	DWINT_WIDTH                                      = 32                   // stdint.h:315:1:
	DWNOHANG                                         = 1                    // waitflags.h:25:1:
	DWNOWAIT                                         = 0x01000000           // waitflags.h:33:1:
	DWORD_BIT                                        = 32                   // xopen_lim.h:114:1:
	DWSTOPPED                                        = 2                    // waitflags.h:30:1:
	DWUNTRACED                                       = 2                    // waitflags.h:26:1:
	DXATTR_LIST_MAX                                  = 65536                // limits.h:17:1:
	DXATTR_NAME_MAX                                  = 255                  // limits.h:15:1:
	DXATTR_SIZE_MAX                                  = 65536                // limits.h:16:1:
	DXCL_END                                         = 0                    // pcre2_internal.h:1314:1:
	DXCL_HASPROP                                     = 0x04                 // pcre2_internal.h:1312:1:
	DXCL_MAP                                         = 0x02                 // pcre2_internal.h:1311:1:
	DXCL_NOT                                         = 0x01                 // pcre2_internal.h:1310:1:
	DXCL_NOTPROP                                     = 4                    // pcre2_internal.h:1318:1:
	DXCL_PROP                                        = 3                    // pcre2_internal.h:1317:1:
	DXCL_RANGE                                       = 2                    // pcre2_internal.h:1316:1:
	DXCL_SINGLE                                      = 1                    // pcre2_internal.h:1315:1:
	D_ALLOCA_H                                       = 1                    // alloca.h:19:1:
	D_ALL_SOURCE                                     = 1                    // config.h:343:1:
	D_ANSI_STDDEF_H                                  = 0                    // stddef.h:42:1:
	D_ATFILE_SOURCE                                  = 1                    // features.h:351:1:
	D_BITS_ATOMIC_WIDE_COUNTER_H                     = 0                    // atomic_wide_counter.h:20:1:
	D_BITS_BYTESWAP_H                                = 1                    // byteswap.h:24:1:
	D_BITS_ENDIANNESS_H                              = 1                    // endianness.h:2:1:
	D_BITS_ENDIAN_H                                  = 1                    // endian.h:20:1:
	D_BITS_FLOATN_COMMON_H                           = 0                    // floatn-common.h:21:1:
	D_BITS_FLOATN_H                                  = 0                    // floatn.h:20:1:
	D_BITS_POSIX1_LIM_H                              = 1                    // posix1_lim.h:25:1:
	D_BITS_POSIX2_LIM_H                              = 1                    // posix2_lim.h:23:1:
	D_BITS_PTHREADTYPES_ARCH_H                       = 1                    // pthreadtypes-arch.h:19:1:
	D_BITS_PTHREADTYPES_COMMON_H                     = 1                    // pthreadtypes.h:20:1:
	D_BITS_STDINT_INTN_H                             = 1                    // stdint-intn.h:20:1:
	D_BITS_STDINT_UINTN_H                            = 1                    // stdint-uintn.h:20:1:
	D_BITS_STDIO_LIM_H                               = 1                    // stdio_lim.h:19:1:
	D_BITS_TIME64_H                                  = 1                    // time64.h:24:1:
	D_BITS_TYPESIZES_H                               = 1                    // typesizes.h:24:1:
	D_BITS_TYPES_H                                   = 1                    // types.h:24:1:
	D_BITS_TYPES_LOCALE_T_H                          = 1                    // locale_t.h:20:1:
	D_BITS_TYPES___LOCALE_T_H                        = 1                    // __locale_t.h:20:1:
	D_BITS_UINTN_IDENTITY_H                          = 1                    // uintn-identity.h:24:1:
	D_BITS_UIO_LIM_H                                 = 1                    // uio_lim.h:20:1:
	D_BITS_WCHAR_H                                   = 1                    // wchar.h:20:1:
	D_BSD_PTRDIFF_T_                                 = 0                    // stddef.h:136:1:
	D_BSD_SIZE_T_                                    = 0                    // stddef.h:189:1:
	D_BSD_SIZE_T_DEFINED_                            = 0                    // stddef.h:192:1:
	D_CTYPE_H                                        = 1                    // ctype.h:23:1:
	D_DARWIN_C_SOURCE                                = 1                    // config.h:347:1:
	D_DEFAULT_SOURCE                                 = 1                    // features.h:236:1:
	D_DYNAMIC_STACK_SIZE_SOURCE                      = 1                    // features.h:224:1:
	D_ENDIAN_H                                       = 1                    // endian.h:19:1:
	D_FEATURES_H                                     = 1                    // features.h:19:1:
	D_FILE_OFFSET_BITS                               = 64                   // <builtin>:25:1:
	D_GCC_LIMITS_H_                                  = 0                    // limits.h:30:1:
	D_GCC_MAX_ALIGN_T                                = 0                    // stddef.h:411:1:
	D_GCC_PTRDIFF_T                                  = 0                    // stddef.h:138:1:
	D_GCC_SIZE_T                                     = 0                    // stddef.h:195:1:
	D_GCC_WCHAR_T                                    = 0                    // stddef.h:273:1:
	D_GCC_WRAP_STDINT_H                              = 0                    // stdint.h:13:1:
	D_GNU_SOURCE                                     = 1                    // config.h:355:1:
	D_HPUX_ALT_XOPEN_SOCKET_API                      = 1                    // config.h:360:1:
	D_INTTYPES_H                                     = 1                    // inttypes.h:23:1:
	D_IOFBF                                          = 0                    // stdio.h:93:1:
	D_IOLBF                                          = 1                    // stdio.h:94:1:
	D_IONBF                                          = 2                    // stdio.h:95:1:
	D_IO_EOF_SEEN                                    = 0x0010               // struct_FILE.h:111:1:
	D_IO_ERR_SEEN                                    = 0x0020               // struct_FILE.h:114:1:
	D_IO_USER_LOCK                                   = 0x8000               // struct_FILE.h:117:1:
	D_ISOC11_SOURCE                                  = 1                    // features.h:206:1:
	D_ISOC2X_SOURCE                                  = 1                    // features.h:208:1:
	D_ISOC95_SOURCE                                  = 1                    // features.h:202:1:
	D_ISOC99_SOURCE                                  = 1                    // features.h:204:1:
	D_LARGEFILE64_SOURCE                             = 1                    // features.h:218:1:
	D_LARGEFILE_SOURCE                               = 1                    // features.h:360:1:
	D_LIBC_LIMITS_H_                                 = 1                    // limits.h:23:1:
	D_LIMITS_H___                                    = 0                    // limits.h:60:1:
	D_LINUX_LIMITS_H                                 = 0                    // limits.h:3:1:
	D_LP64                                           = 1                    // <predefined>:297:1:
	D_NETBSD_SOURCE                                  = 1                    // config.h:371:1:
	D_OPENBSD_SOURCE                                 = 1                    // config.h:376:1:
	D_POSIX2_BC_BASE_MAX                             = 99                   // posix2_lim.h:27:1:
	D_POSIX2_BC_DIM_MAX                              = 2048                 // posix2_lim.h:30:1:
	D_POSIX2_BC_SCALE_MAX                            = 99                   // posix2_lim.h:33:1:
	D_POSIX2_BC_STRING_MAX                           = 1000                 // posix2_lim.h:36:1:
	D_POSIX2_CHARCLASS_NAME_MAX                      = 14                   // posix2_lim.h:55:1:
	D_POSIX2_COLL_WEIGHTS_MAX                        = 2                    // posix2_lim.h:40:1:
	D_POSIX2_EXPR_NEST_MAX                           = 32                   // posix2_lim.h:44:1:
	D_POSIX2_LINE_MAX                                = 2048                 // posix2_lim.h:47:1:
	D_POSIX2_RE_DUP_MAX                              = 255                  // posix2_lim.h:51:1:
	D_POSIX_AIO_LISTIO_MAX                           = 2                    // posix1_lim.h:32:1:
	D_POSIX_AIO_MAX                                  = 1                    // posix1_lim.h:35:1:
	D_POSIX_ARG_MAX                                  = 4096                 // posix1_lim.h:38:1:
	D_POSIX_CHILD_MAX                                = 25                   // posix1_lim.h:42:1:
	D_POSIX_CLOCKRES_MIN                             = 20000000             // posix1_lim.h:157:1:
	D_POSIX_C_SOURCE                                 = 200809               // features.h:290:1:
	D_POSIX_DELAYTIMER_MAX                           = 32                   // posix1_lim.h:48:1:
	D_POSIX_FD_SETSIZE                               = 20                   // posix1_lim.h:93:1:
	D_POSIX_HIWAT                                    = 512                  // posix1_lim.h:150:1:
	D_POSIX_HOST_NAME_MAX                            = 255                  // posix1_lim.h:52:1:
	D_POSIX_LINK_MAX                                 = 8                    // posix1_lim.h:55:1:
	D_POSIX_LOGIN_NAME_MAX                           = 9                    // posix1_lim.h:58:1:
	D_POSIX_MAX_CANON                                = 255                  // posix1_lim.h:61:1:
	D_POSIX_MAX_INPUT                                = 255                  // posix1_lim.h:65:1:
	D_POSIX_MQ_OPEN_MAX                              = 8                    // posix1_lim.h:68:1:
	D_POSIX_MQ_PRIO_MAX                              = 32                   // posix1_lim.h:71:1:
	D_POSIX_NAME_MAX                                 = 14                   // posix1_lim.h:74:1:
	D_POSIX_NGROUPS_MAX                              = 8                    // posix1_lim.h:78:1:
	D_POSIX_OPEN_MAX                                 = 20                   // posix1_lim.h:85:1:
	D_POSIX_PATH_MAX                                 = 256                  // posix1_lim.h:97:1:
	D_POSIX_PIPE_BUF                                 = 512                  // posix1_lim.h:100:1:
	D_POSIX_PTHREAD_SEMANTICS                        = 1                    // config.h:388:1:
	D_POSIX_QLIMIT                                   = 1                    // posix1_lim.h:146:1:
	D_POSIX_RE_DUP_MAX                               = 255                  // posix1_lim.h:104:1:
	D_POSIX_RTSIG_MAX                                = 8                    // posix1_lim.h:107:1:
	D_POSIX_SEM_NSEMS_MAX                            = 256                  // posix1_lim.h:110:1:
	D_POSIX_SEM_VALUE_MAX                            = 32767                // posix1_lim.h:113:1:
	D_POSIX_SIGQUEUE_MAX                             = 32                   // posix1_lim.h:116:1:
	D_POSIX_SOURCE                                   = 1                    // features.h:288:1:
	D_POSIX_SSIZE_MAX                                = 32767                // posix1_lim.h:119:1:
	D_POSIX_STREAM_MAX                               = 8                    // posix1_lim.h:122:1:
	D_POSIX_SYMLINK_MAX                              = 255                  // posix1_lim.h:125:1:
	D_POSIX_SYMLOOP_MAX                              = 8                    // posix1_lim.h:129:1:
	D_POSIX_THREAD_DESTRUCTOR_ITERATIONS             = 4                    // local_lim.h:67:1:
	D_POSIX_THREAD_KEYS_MAX                          = 128                  // local_lim.h:62:1:
	D_POSIX_THREAD_THREADS_MAX                       = 64                   // local_lim.h:72:1:
	D_POSIX_TIMER_MAX                                = 32                   // posix1_lim.h:132:1:
	D_POSIX_TTY_NAME_MAX                             = 9                    // posix1_lim.h:135:1:
	D_POSIX_TZNAME_MAX                               = 6                    // posix1_lim.h:139:1:
	D_POSIX_UIO_MAXIOV                               = 16                   // posix1_lim.h:153:1:
	D_PRINTF_NAN_LEN_MAX                             = 4                    // stdio.h:138:1:
	D_PTRDIFF_T                                      = 0                    // stddef.h:131:1:
	D_PTRDIFF_T_                                     = 0                    // stddef.h:135:1:
	D_PTRDIFF_T_DECLARED                             = 0                    // stddef.h:139:1:
	D_RWLOCK_INTERNAL_H                              = 0                    // struct_rwlock.h:21:1:
	D_SIZET_                                         = 0                    // stddef.h:196:1:
	D_SIZE_T                                         = 0                    // stddef.h:183:1:
	D_SIZE_T_                                        = 0                    // stddef.h:188:1:
	D_SIZE_T_DECLARED                                = 0                    // stddef.h:193:1:
	D_SIZE_T_DEFINED                                 = 0                    // stddef.h:191:1:
	D_SIZE_T_DEFINED_                                = 0                    // stddef.h:190:1:
	D_STDC_PREDEF_H                                  = 1                    // <predefined>:168:1:
	D_STDDEF_H                                       = 0                    // stddef.h:39:1:
	D_STDDEF_H_                                      = 0                    // stddef.h:40:1:
	D_STDINT_H                                       = 1                    // stdint.h:23:1:
	D_STDIO_H                                        = 1                    // stdio.h:24:1:
	D_STDLIB_H                                       = 1                    // stdlib.h:36:1:
	D_STRINGS_H                                      = 1                    // strings.h:19:1:
	D_STRING_H                                       = 1                    // string.h:23:1:
	D_STRUCT_TIMESPEC                                = 1                    // struct_timespec.h:3:1:
	D_SYS_CDEFS_H                                    = 1                    // cdefs.h:20:1:
	D_SYS_SELECT_H                                   = 1                    // select.h:22:1:
	D_SYS_SIZE_T_H                                   = 0                    // stddef.h:184:1:
	D_SYS_TYPES_H                                    = 1                    // types.h:23:1:
	D_TANDEM_SOURCE                                  = 1                    // config.h:420:1:
	D_THREAD_MUTEX_INTERNAL_H                        = 1                    // struct_mutex.h:20:1:
	D_THREAD_SHARED_TYPES_H                          = 1                    // thread-shared-types.h:20:1:
	D_T_PTRDIFF                                      = 0                    // stddef.h:133:1:
	D_T_PTRDIFF_                                     = 0                    // stddef.h:132:1:
	D_T_SIZE                                         = 0                    // stddef.h:186:1:
	D_T_SIZE_                                        = 0                    // stddef.h:185:1:
	D_T_WCHAR                                        = 0                    // stddef.h:264:1:
	D_T_WCHAR_                                       = 0                    // stddef.h:263:1:
	D_VA_LIST_DEFINED                                = 0                    // stdio.h:53:1:
	D_WCHAR_T                                        = 0                    // stddef.h:262:1:
	D_WCHAR_T_                                       = 0                    // stddef.h:266:1:
	D_WCHAR_T_DECLARED                               = 0                    // stddef.h:274:1:
	D_WCHAR_T_DEFINED                                = 0                    // stddef.h:269:1:
	D_WCHAR_T_DEFINED_                               = 0                    // stddef.h:268:1:
	D_WCHAR_T_H                                      = 0                    // stddef.h:270:1:
	D_XOPEN_IOV_MAX                                  = 16                   // xopen_lim.h:62:1:
	D_XOPEN_LIM_H                                    = 1                    // xopen_lim.h:30:1:
	D_XOPEN_SOURCE                                   = 700                  // features.h:214:1:
	D_XOPEN_SOURCE_EXTENDED                          = 1                    // features.h:216:1:
	Dcbit_cntrl                                      = 288                  // pcre2_internal.h:573:1:
	Dcbit_digit                                      = 64                   // pcre2_internal.h:566:1:
	Dcbit_graph                                      = 192                  // pcre2_internal.h:570:1:
	Dcbit_length                                     = 320                  // pcre2_internal.h:574:1:
	Dcbit_lower                                      = 128                  // pcre2_internal.h:568:1:
	Dcbit_print                                      = 224                  // pcre2_internal.h:571:1:
	Dcbit_punct                                      = 256                  // pcre2_internal.h:572:1:
	Dcbit_space                                      = 0                    // pcre2_internal.h:564:1:
	Dcbit_upper                                      = 96                   // pcre2_internal.h:567:1:
	Dcbit_word                                       = 160                  // pcre2_internal.h:569:1:
	Dcbit_xdigit                                     = 32                   // pcre2_internal.h:565:1:
	Dcbits_offset                                    = 512                  // pcre2_internal.h:591:1:
	Dctype_digit                                     = 0x08                 // pcre2_internal.h:583:1:
	Dctype_lcletter                                  = 0x04                 // pcre2_internal.h:582:1:
	Dctype_letter                                    = 0x02                 // pcre2_internal.h:581:1:
	Dctype_space                                     = 0x01                 // pcre2_internal.h:580:1:
	Dctype_word                                      = 0x10                 // pcre2_internal.h:584:1:
	Dctypes_offset                                   = 832                  // pcre2_internal.h:592:1:
	Dfcc_offset                                      = 256                  // pcre2_internal.h:590:1:
	Dlcc_offset                                      = 0                    // pcre2_internal.h:589:1:
	Dlinux                                           = 1                    // <predefined>:243:1:
	Ducd_boolprop_sets_item_size                     = 2                    // pcre2_ucp.h:164:1:
	Ducd_script_sets_item_size                       = 3                    // pcre2_ucp.h:390:1:
	Dunix                                            = 1                    // <predefined>:184:1:
	DCOMPILE_WORK_SIZE                               = 6000                 // pcre2_compile.c:166:1:
	DESCAPES_FIRST                                   = 48                   // pcre2_compile.c:507:1:
	DESCAPES_LAST                                    = 122                  // pcre2_compile.c:508:1:
	DGI_FIXED_LENGTH_MASK                            = 0x0000ffff           // pcre2_compile.c:402:1:
	DGI_NOT_FIXED_LENGTH                             = 0x40000000           // pcre2_compile.c:401:1:
	DGI_SET_FIXED_LENGTH                             = 0x80000000           // pcre2_compile.c:400:1:
	DGROUPINFO_DEFAULT_SIZE                          = 256                  // pcre2_compile.c:175:1:
	DMAX_GROUP_NUMBER                                = 65535                // pcre2_compile.c:147:1:
	DMAX_REPEAT_COUNT                                = 65535                // pcre2_compile.c:148:1:
	DMETA_ACCEPT                                     = 0x802a0000           // pcre2_compile.c:266:1:
	DMETA_ALT                                        = 0x80010000           // pcre2_compile.c:213:1:
	DMETA_ASTERISK                                   = 0x80340000           // pcre2_compile.c:279:1:
	DMETA_ASTERISK_PLUS                              = 0x80350000           // pcre2_compile.c:280:1:
	DMETA_ASTERISK_QUERY                             = 0x80360000           // pcre2_compile.c:281:1:
	DMETA_ATOMIC                                     = 0x80020000           // pcre2_compile.c:214:1:
	DMETA_ATOMIC_SCRIPT_RUN                          = 0x8fff0000           // pcre2_compile.c:300:1:
	DMETA_BACKREF                                    = 0x80030000           // pcre2_compile.c:215:1:
	DMETA_BACKREF_BYNAME                             = 0x80040000           // pcre2_compile.c:216:1:
	DMETA_BIGVALUE                                   = 0x80050000           // pcre2_compile.c:217:1:
	DMETA_CALLOUT_NUMBER                             = 0x80060000           // pcre2_compile.c:218:1:
	DMETA_CALLOUT_STRING                             = 0x80070000           // pcre2_compile.c:219:1:
	DMETA_CAPTURE                                    = 0x80080000           // pcre2_compile.c:220:1:
	DMETA_CIRCUMFLEX                                 = 0x80090000           // pcre2_compile.c:221:1:
	DMETA_CLASS                                      = 0x800a0000           // pcre2_compile.c:222:1:
	DMETA_CLASS_EMPTY                                = 0x800b0000           // pcre2_compile.c:223:1:
	DMETA_CLASS_EMPTY_NOT                            = 0x800c0000           // pcre2_compile.c:224:1:
	DMETA_CLASS_END                                  = 0x800d0000           // pcre2_compile.c:225:1:
	DMETA_CLASS_NOT                                  = 0x800e0000           // pcre2_compile.c:226:1:
	DMETA_COMMIT                                     = 0x802c0000           // pcre2_compile.c:268:1:
	DMETA_COMMIT_ARG                                 = 0x802d0000           // pcre2_compile.c:269:1:
	DMETA_COND_ASSERT                                = 0x800f0000           // pcre2_compile.c:227:1:
	DMETA_COND_DEFINE                                = 0x80100000           // pcre2_compile.c:228:1:
	DMETA_COND_NAME                                  = 0x80110000           // pcre2_compile.c:229:1:
	DMETA_COND_NUMBER                                = 0x80120000           // pcre2_compile.c:230:1:
	DMETA_COND_RNAME                                 = 0x80130000           // pcre2_compile.c:231:1:
	DMETA_COND_RNUMBER                               = 0x80140000           // pcre2_compile.c:232:1:
	DMETA_COND_VERSION                               = 0x80150000           // pcre2_compile.c:233:1:
	DMETA_DOLLAR                                     = 0x80160000           // pcre2_compile.c:234:1:
	DMETA_DOT                                        = 0x80170000           // pcre2_compile.c:235:1:
	DMETA_END                                        = 0x80000000           // pcre2_compile.c:211:1:
	DMETA_ESCAPE                                     = 0x80180000           // pcre2_compile.c:236:1:
	DMETA_FAIL                                       = 0x802b0000           // pcre2_compile.c:267:1:
	DMETA_FIRST_QUANTIFIER                           = 2150891520           // pcre2_compile.c:292:1:
	DMETA_KET                                        = 0x80190000           // pcre2_compile.c:237:1:
	DMETA_LAST_QUANTIFIER                            = 2151612416           // pcre2_compile.c:293:1:
	DMETA_LOOKAHEAD                                  = 0x80230000           // pcre2_compile.c:251:1:
	DMETA_LOOKAHEADNOT                               = 0x80240000           // pcre2_compile.c:252:1:
	DMETA_LOOKAHEAD_NA                               = 0x80270000           // pcre2_compile.c:258:1:
	DMETA_LOOKBEHIND                                 = 0x80250000           // pcre2_compile.c:253:1:
	DMETA_LOOKBEHINDNOT                              = 0x80260000           // pcre2_compile.c:254:1:
	DMETA_LOOKBEHIND_NA                              = 0x80280000           // pcre2_compile.c:259:1:
	DMETA_MARK                                       = 0x80290000           // pcre2_compile.c:265:1:
	DMETA_MINMAX                                     = 0x803d0000           // pcre2_compile.c:288:1:
	DMETA_MINMAX_PLUS                                = 0x803e0000           // pcre2_compile.c:289:1:
	DMETA_MINMAX_QUERY                               = 0x803f0000           // pcre2_compile.c:290:1:
	DMETA_NOCAPTURE                                  = 0x801a0000           // pcre2_compile.c:238:1:
	DMETA_OPTIONS                                    = 0x801b0000           // pcre2_compile.c:239:1:
	DMETA_PLUS                                       = 0x80370000           // pcre2_compile.c:282:1:
	DMETA_PLUS_PLUS                                  = 0x80380000           // pcre2_compile.c:283:1:
	DMETA_PLUS_QUERY                                 = 0x80390000           // pcre2_compile.c:284:1:
	DMETA_POSIX                                      = 0x801c0000           // pcre2_compile.c:240:1:
	DMETA_POSIX_NEG                                  = 0x801d0000           // pcre2_compile.c:241:1:
	DMETA_PRUNE                                      = 0x802e0000           // pcre2_compile.c:270:1:
	DMETA_PRUNE_ARG                                  = 0x802f0000           // pcre2_compile.c:271:1:
	DMETA_QUERY                                      = 0x803a0000           // pcre2_compile.c:285:1:
	DMETA_QUERY_PLUS                                 = 0x803b0000           // pcre2_compile.c:286:1:
	DMETA_QUERY_QUERY                                = 0x803c0000           // pcre2_compile.c:287:1:
	DMETA_RANGE_ESCAPED                              = 0x801e0000           // pcre2_compile.c:242:1:
	DMETA_RANGE_LITERAL                              = 0x801f0000           // pcre2_compile.c:243:1:
	DMETA_RECURSE                                    = 0x80200000           // pcre2_compile.c:244:1:
	DMETA_RECURSE_BYNAME                             = 0x80210000           // pcre2_compile.c:245:1:
	DMETA_SCRIPT_RUN                                 = 0x80220000           // pcre2_compile.c:246:1:
	DMETA_SKIP                                       = 0x80300000           // pcre2_compile.c:272:1:
	DMETA_SKIP_ARG                                   = 0x80310000           // pcre2_compile.c:273:1:
	DMETA_THEN                                       = 0x80320000           // pcre2_compile.c:274:1:
	DMETA_THEN_ARG                                   = 0x80330000           // pcre2_compile.c:275:1:
	DNAMED_GROUP_LIST_SIZE                           = 20                   // pcre2_compile.c:187:1:
	DNSF_ATOMICSR                                    = 0x0004               // pcre2_compile.c:2565:1:
	DNSF_CONDASSERT                                  = 0x0002               // pcre2_compile.c:2564:1:
	DNSF_RESET                                       = 0x0001               // pcre2_compile.c:2563:1:
	DOFLOW_MAX                                       = 2147483627           // pcre2_compile.c:200:1:
	DPARSED_PATTERN_DEFAULT_SIZE                     = 1024                 // pcre2_compile.c:193:1:
	DPARSE_TRACKED_OPTIONS                           = 17048808             // pcre2_compile.c:2572:1:
	DPC_GRAPH                                        = 8                    // pcre2_compile.c:709:1:
	DPC_PRINT                                        = 9                    // pcre2_compile.c:710:1:
	DPC_PUNCT                                        = 10                   // pcre2_compile.c:711:1:
	DPUBLIC_COMPILE_EXTRA_OPTIONS                    = 127                  // pcre2_compile.c:784:1:
	DPUBLIC_COMPILE_OPTIONS                          = 3892314111           // pcre2_compile.c:772:1:
	DPUBLIC_LITERAL_COMPILE_EXTRA_OPTIONS            = 12                   // pcre2_compile.c:781:1:
	DPUBLIC_LITERAL_COMPILE_OPTIONS                  = 3867738380           // pcre2_compile.c:767:1:
	DREPEAT_UNLIMITED                                = 65536                // pcre2_compile.c:149:1:
	DREQ_CASELESS                                    = 0x00000001           // pcre2_compile.c:395:1:
	DREQ_NONE                                        = 0xfffffffe           // pcre2_compile.c:394:1:
	DREQ_UNSET                                       = 0xffffffff           // pcre2_compile.c:393:1:
	DREQ_VARY                                        = 0x00000002           // pcre2_compile.c:396:1:
	DRSCAN_CACHE_SIZE                                = 8                    // pcre2_compile.c:10359:1:
	DSIZEOFFSET                                      = 2                    // pcre2_compile.c:108:1:
	DWORK_SIZE_SAFETY_MARGIN                         = 100                  // pcre2_compile.c:180:1:
	DALL_OPTIONS                                     = 127                  // pcre2_convert.c:51:1:
	DDUMMY_BUFFER_SIZE                               = 100                  // pcre2_convert.c:56:1:
	DTYPE_OPTIONS                                    = 28                   // pcre2_convert.c:48:1:
	DOP_ANYNL_EXTRA                                  = 340                  // pcre2_dfa_match.c:103:1:
	DOP_EXTUNI_EXTRA                                 = 320                  // pcre2_dfa_match.c:102:1:
	DOP_HSPACE_EXTRA                                 = 360                  // pcre2_dfa_match.c:104:1:
	DOP_PROP_EXTRA                                   = 300                  // pcre2_dfa_match.c:101:1:
	DOP_VSPACE_EXTRA                                 = 380                  // pcre2_dfa_match.c:105:1:
	DPUBLIC_DFA_MATCH_OPTIONS                        = 3758113023           // pcre2_dfa_match.c:85:1:
	DRWS_RSIZE                                       = 1000                 // pcre2_dfa_match.c:318:1:
	DINCLUDED_FROM_PCRE2_JIT_COMPILE                 = 0                    // pcre2_jit_compile.c:14504:1:
	DPUBLIC_JIT_COMPILE_OPTIONS                      = 263                  // pcre2_jit_compile.c:14378:1:
	DGF_CAPTURE                                      = 0x00010000           // pcre2_match.c:106:1:
	DGF_CONDASSERT                                   = 0x00030000           // pcre2_match.c:108:1:
	DGF_NOCAPTURE                                    = 0x00020000           // pcre2_match.c:107:1:
	DGF_RECURSE                                      = 0x00040000           // pcre2_match.c:109:1:
	DMATCH_ACCEPT                                    = -999                 // pcre2_match.c:88:1:
	DMATCH_BACKTRACK_MAX                             = -993                 // pcre2_match.c:97:1:
	DMATCH_BACKTRACK_MIN                             = -997                 // pcre2_match.c:98:1:
	DMATCH_COMMIT                                    = -997                 // pcre2_match.c:92:1:
	DMATCH_KETRPOS                                   = -998                 // pcre2_match.c:89:1:
	DMATCH_MATCH                                     = 1                    // pcre2_match.c:82:1:
	DMATCH_NOMATCH                                   = 0                    // pcre2_match.c:83:1:
	DMATCH_PRUNE                                     = -996                 // pcre2_match.c:93:1:
	DMATCH_SKIP                                      = -995                 // pcre2_match.c:94:1:
	DMATCH_SKIP_ARG                                  = -994                 // pcre2_match.c:95:1:
	DMATCH_THEN                                      = -993                 // pcre2_match.c:96:1:
	DPUBLIC_JIT_MATCH_OPTIONS                        = 1073758271           // pcre2_match.c:74:1:
	DPUBLIC_MATCH_OPTIONS                            = 3758121023           // pcre2_match.c:69:1:
	DRECURSE_UNSET                                   = 0xffffffff           // pcre2_match.c:65:1:
	DFOUND_BOPOMOFO                                  = 1                    // pcre2_script_run.c:199:1:
	DFOUND_HANGUL                                    = 8                    // pcre2_script_run.c:202:1:
	DFOUND_HIRAGANA                                  = 2                    // pcre2_script_run.c:200:1:
	DFOUND_KATAKANA                                  = 4                    // pcre2_script_run.c:201:1:
	DSERIALIZED_DATA_MAGIC                           = 0x50523253           // pcre2_serialize.c:54:1:
	DSERIALIZED_DATA_VERSION                         = 2621450              // pcre2_serialize.c:59:1:
	DMAX_CACHE_BACKREF                               = 128                  // pcre2_study.c:53:1:
	DPTR_STACK_SIZE                                  = 20                   // pcre2_substitute.c:48:1:
	DSUBSTITUTE_OPTIONS                              = 237312               // pcre2_substitute.c:50:1:
)

// Seconds since the Epoch, visible to user code when time_t is too
//    narrow only for consistency with the old way of widening too-narrow
//    types.  User code should never use __time64_t.

// These are all the characteristics of characters.
//    If there get to be more than 16 distinct characteristics,
//    many things must be changed that use `unsigned short int's.
//
//    The characteristics are stored always in network byte order (big
//    endian).  We define the bit value interpretations here dependent on the
//    machine's byte order.

// Endian macros for string.h functions
//    Copyright (C) 1992-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Definitions for byte order, according to significance of bytes,
//    from low addresses to high addresses.  The value is what you get by
//    putting '4' in the most significant byte, '3' in the second most
//    significant byte, '2' in the second least significant byte, and '1'
//    in the least significant byte, and then writing down one digit for
//    each byte, starting with the byte at the lowest address at the left,
//    and proceeding to the byte with the highest address at the right.

// This file defines `__BYTE_ORDER' for the particular machine.

// i386/x86_64 are little-endian.

// Some machines may need to use a different endianness for floating point
//    values.

const ( /* ctype.h:46:1: */
	_ISupper  = 256   // UPPERCASE.
	_ISlower  = 512   // lowercase.
	_ISalpha  = 1024  // Alphabetic.
	_ISdigit  = 2048  // Numeric.
	_ISxdigit = 4096  // Hexadecimal numeric.
	_ISspace  = 8192  // Whitespace.
	_ISprint  = 16384 // Printing.
	_ISgraph  = 32768 // Graphical.
	_ISblank  = 1     // Blank (usually SPC and TAB).
	_IScntrl  = 2     // Control character.
	_ISpunct  = 4     // Punctuation.
	_ISalnum  = 8
)

// Options that are changeable within the pattern must be tracked during
// parsing. Some (e.g. PCRE2_EXTENDED) are implemented entirely during parsing,
// but all must be tracked so that META_OPTIONS items set the correct values for
// the main compiling phase.

// States used for analyzing ranges in character classes. The two OK values
// must be last.

const ( /* pcre2_compile.c:2579:1: */
	RANGE_NO         = 0
	RANGE_OK_ESCAPED = 2
	RANGE_OK_LITERAL = 3
)

// Types for skipping parts of a parsed pattern.

const ( /* pcre2_compile.c:375:1: */
	PSKIP_ALT   = 0
	PSKIP_CLASS = 1
	PSKIP_KET   = 2
)

// Masks for checking option settings. When PCRE2_LITERAL is set, only a subset
// are allowed.

// Compile time error code numbers. They are given names so that they can more
// easily be tracked. When a new number is added, the tables called eint1 and
// eint2 in pcre2posix.c may need to be updated, and a new error text must be
// added to compile_error_texts in pcre2_error.c. Also, the error codes in
// pcre2.h.in must be updated - their values are exactly 100 greater than these
// values.

const ( /* pcre2_compile.c:797:1: */
	ERR0  = 100
	ERR1  = 101
	ERR2  = 102
	ERR3  = 103
	ERR4  = 104
	ERR5  = 105
	ERR6  = 106
	ERR7  = 107
	ERR8  = 108
	ERR9  = 109
	ERR10 = 110
	ERR11 = 111
	ERR12 = 112
	ERR13 = 113
	ERR14 = 114
	ERR15 = 115
	ERR16 = 116
	ERR17 = 117
	ERR18 = 118
	ERR19 = 119
	ERR20 = 120
	ERR21 = 121
	ERR22 = 122
	ERR23 = 123
	ERR24 = 124
	ERR25 = 125
	ERR26 = 126
	ERR27 = 127
	ERR28 = 128
	ERR29 = 129
	ERR30 = 130
	ERR31 = 131
	ERR32 = 132
	ERR33 = 133
	ERR34 = 134
	ERR35 = 135
	ERR36 = 136
	ERR37 = 137
	ERR38 = 138
	ERR39 = 139
	ERR40 = 140
	ERR41 = 141
	ERR42 = 142
	ERR43 = 143
	ERR44 = 144
	ERR45 = 145
	ERR46 = 146
	ERR47 = 147
	ERR48 = 148
	ERR49 = 149
	ERR50 = 150
	ERR51 = 151
	ERR52 = 152
	ERR53 = 153
	ERR54 = 154
	ERR55 = 155
	ERR56 = 156
	ERR57 = 157
	ERR58 = 158
	ERR59 = 159
	ERR60 = 160
	ERR61 = 161
	ERR62 = 162
	ERR63 = 163
	ERR64 = 164
	ERR65 = 165
	ERR66 = 166
	ERR67 = 167
	ERR68 = 168
	ERR69 = 169
	ERR70 = 170
	ERR71 = 171
	ERR72 = 172
	ERR73 = 173
	ERR74 = 174
	ERR75 = 175
	ERR76 = 176
	ERR77 = 177
	ERR78 = 178
	ERR79 = 179
	ERR80 = 180
	ERR81 = 181
	ERR82 = 182
	ERR83 = 183
	ERR84 = 184
	ERR85 = 185
	ERR86 = 186
	ERR87 = 187
	ERR88 = 188
	ERR89 = 189
	ERR90 = 190
	ERR91 = 191
	ERR92 = 192
	ERR93 = 193
	ERR94 = 194
	ERR95 = 195
	ERR96 = 196
	ERR97 = 197
	ERR98 = 198
	ERR99 = 199
)

// This is a table of start-of-pattern options such as (*UTF) and settings such
// as (*LIMIT_MATCH=nnnn) and (*CRLF). For completeness and backward
// compatibility, (*UTFn) is supported in the relevant libraries, but (*UTF) is
// generic and always supported.

const ( /* pcre2_compile.c:814:1: */
	PSO_OPT  = 0 // Value is an option bit
	PSO_FLG  = 1 // Value is a flag bit
	PSO_NL   = 2 // Value is a newline type
	PSO_BSR  = 3 // Value is a \R type
	PSO_LIMH = 4 // Read integer value for heap limit
	PSO_LIMM = 5 // Read integer value for match limit
	PSO_LIMD = 6
)

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// Generated pattern fragments

// States for range and POSIX processing

const ( /* pcre2_convert.c:70:1: */
	RANGE_NOT_STARTED = 0
	RANGE_STARTING    = 1
)
const ( /* pcre2_convert.c:71:1: */
	POSIX_START_REGEX       = 0
	POSIX_ANCHORED          = 1
	POSIX_NOT_BRACKET       = 2
	POSIX_CLASS_NOT_STARTED = 3
	POSIX_CLASS_STARTING    = 4
	POSIX_CLASS_STARTED     = 5
) // pcre2_jit_match()

// Values for the flags field in a match data block.

// Magic number to provide a small check against being handed junk.

// The maximum remaining length of subject we are prepared to search for a
// req_unit match from an anchored pattern. In 8-bit mode, memchr() is used and is
// much faster than the search loop that has to be used in 16-bit and 32-bit
// modes.

// Offsets for the bitmap tables in the cbits set of tables. Each table
// contains a set of bits for a class map. Some classes are built by combining
// these tables.

// Bit definitions for entries in the ctypes table. Do not change these values
// without checking pcre2_jit_compile.c, which has an assertion to ensure that
// ctype_word has the value 16.

// Offsets of the various tables from the base tables pointer, and
// total length of the tables.

// -------------------- Character and string names ------------------------

// If PCRE2 is to support UTF-8 on EBCDIC platforms, we cannot use normal
// character constants like '*' because the compiler would emit their EBCDIC code,
// which is different from their ASCII/UTF-8 code. Instead we define macros for
// the characters so that they always use the ASCII/UTF-8 code when UTF-8 support
// is enabled. When UTF-8 support is not enabled, the definitions use character
// literals. Both character and string versions of each character are needed, and
// there are some longer strings as well.
//
// This means that, on EBCDIC platforms, the PCRE2 library can handle either
// EBCDIC, or UTF-8, but not both. To support both in the same compiled library
// would need different lookups depending on whether PCRE2_UTF was set or not.
// This would make it impossible to use characters in switch/case statements,
// which would reduce performance. For a theoretical use (which nobody has asked
// for) in a minority area (EBCDIC platforms), this is not sensible. Any
// application that did need both could compile two versions of the library, using
// macros to give the functions distinct names.

// UTF-8 support is enabled; always use UTF-8 (=ASCII) character codes. This
// works in both modes non-EBCDIC platforms, and on EBCDIC platforms in UTF-8 mode
// only.

// -------------------- End of character and string names -------------------

// -------------------- Definitions for compiled patterns -------------------

// Codes for different types of Unicode property. If these definitions are
// changed, the autopossessifying table in pcre2_auto_possess.c must be updated to
// match.

// The following special properties are used only in XCLASS items, when POSIX
// classes are specified and PCRE2_UCP is set - in other words, for Unicode
// handling of these classes. They are not available via the \p or \P escapes like
// those in the above list, and so they do not take part in the autopossessifying
// table.

// This value is used when parsing \p and \P escapes to indicate that neither
// \p{script:...} nor \p{scx:...} has been encountered.

// Flag bits and data types for the extended class (OP_XCLASS) for classes that
// contain characters with values greater than 255.

// These are escaped items that aren't just an encoding of a particular data
// value such as \n. They must have non-zero values, as check_escape() returns 0
// for a data character. In the escapes[] table in pcre2_compile.c their values
// are negated in order to distinguish them from data values.
//
// They must appear here in the same order as in the opcode definitions below, up
// to ESC_z. There's a dummy for OP_ALLANY because it corresponds to "." in DOTALL
// mode rather than an escape sequence. It is also used for [^] in JavaScript
// compatibility mode, and for \C in non-utf mode. In non-DOTALL mode, "." behaves
// like \N.
//
// Negative numbers are used to encode a backreference (\1, \2, \3, etc.) in
// check_escape(). There are tests in the code for an escape greater than ESC_b
// and less than ESC_Z to detect the types that may be repeated. These are the
// types that consume characters. If any new escapes are put in between that don't
// consume a character, that code will have to change.

const ( /* pcre2_internal.h:1337:1: */
	ESC_A   = 1
	ESC_G   = 2
	ESC_K   = 3
	ESC_B   = 4
	ESC_b   = 5
	ESC_D   = 6
	ESC_d   = 7
	ESC_S   = 8
	ESC_s   = 9
	ESC_W   = 10
	ESC_w   = 11
	ESC_N   = 12
	ESC_dum = 13
	ESC_C   = 14
	ESC_P   = 15
	ESC_p   = 16
	ESC_R   = 17
	ESC_H   = 18
	ESC_h   = 19
	ESC_V   = 20
	ESC_v   = 21
	ESC_X   = 22
	ESC_Z   = 23
	ESC_z   = 24
	ESC_E   = 25
	ESC_Q   = 26
	ESC_g   = 27
	ESC_k   = 28
)

//********************* Opcode definitions *****************

//***** NOTE NOTE NOTE ******
//
// Starting from 1 (i.e. after OP_END), the values up to OP_EOD must correspond in
// order to the list of escapes immediately above. Furthermore, values up to
// OP_DOLLM must not be changed without adjusting the table called autoposstab in
// pcre2_auto_possess.c.
//
// Whenever this list is updated, the two macro definitions that follow must be
// updated to match. The possessification table called "opcode_possessify" in
// pcre2_compile.c must also be updated, and also the tables called "coptable"
// and "poptable" in pcre2_dfa_match.c.
//
// ****** NOTE NOTE NOTE *****

// The values between FIRST_AUTOTAB_OP and LAST_AUTOTAB_RIGHT_OP, inclusive,
// are used in a table for deciding whether a repeated character type can be
// auto-possessified.

const ( /* pcre2_internal.h:1368:1: */
	OP_END = 0 // 0 End of pattern

	// Values corresponding to backslashed metacharacters

	OP_SOD               = 1  // 1 Start of data: \A
	OP_SOM               = 2  // 2 Start of match (subject + offset): \G
	OP_SET_SOM           = 3  // 3 Set start of match (\K)
	OP_NOT_WORD_BOUNDARY = 4  //  4 \B
	OP_WORD_BOUNDARY     = 5  //  5 \b
	OP_NOT_DIGIT         = 6  //  6 \D
	OP_DIGIT             = 7  //  7 \d
	OP_NOT_WHITESPACE    = 8  //  8 \S
	OP_WHITESPACE        = 9  //  9 \s
	OP_NOT_WORDCHAR      = 10 // 10 \W
	OP_WORDCHAR          = 11 // 11 \w

	OP_ANY        = 12 // 12 Match any character except newline (\N)
	OP_ALLANY     = 13 // 13 Match any character
	OP_ANYBYTE    = 14 // 14 Match any byte (\C); different to OP_ANY for UTF-8
	OP_NOTPROP    = 15 // 15 \P (not Unicode property)
	OP_PROP       = 16 // 16 \p (Unicode property)
	OP_ANYNL      = 17 // 17 \R (any newline sequence)
	OP_NOT_HSPACE = 18 // 18 \H (not horizontal whitespace)
	OP_HSPACE     = 19 // 19 \h (horizontal whitespace)
	OP_NOT_VSPACE = 20 // 20 \V (not vertical whitespace)
	OP_VSPACE     = 21 // 21 \v (vertical whitespace)
	OP_EXTUNI     = 22 // 22 \X (extended Unicode sequence
	OP_EODN       = 23 // 23 End of data or \n at end of data (\Z)
	OP_EOD        = 24 // 24 End of data (\z)

	// Line end assertions

	OP_DOLL  = 25 // 25 End of line - not multiline
	OP_DOLLM = 26 // 26 End of line - multiline
	OP_CIRC  = 27 // 27 Start of line - not multiline
	OP_CIRCM = 28 // 28 Start of line - multiline

	// Single characters; caseful must precede the caseless ones, and these
	//   must remain in this order, and adjacent.

	OP_CHAR  = 29 // 29 Match one character, casefully
	OP_CHARI = 30 // 30 Match one character, caselessly
	OP_NOT   = 31 // 31 Match one character, not the given one, casefully
	OP_NOTI  = 32 // 32 Match one character, not the given one, caselessly

	// The following sets of 13 opcodes must always be kept in step because
	//   the offset from the first one is used to generate the others.

	// Repeated characters; caseful must precede the caseless ones

	OP_STAR     = 33 // 33 The maximizing and minimizing versions of
	OP_MINSTAR  = 34 // 34 these six opcodes must come in pairs, with
	OP_PLUS     = 35 // 35 the minimizing one second.
	OP_MINPLUS  = 36 // 36
	OP_QUERY    = 37 // 37
	OP_MINQUERY = 38 // 38

	OP_UPTO    = 39 // 39 From 0 to n matches of one character, caseful
	OP_MINUPTO = 40 // 40
	OP_EXACT   = 41 // 41 Exactly n matches

	OP_POSSTAR  = 42 // 42 Possessified star, caseful
	OP_POSPLUS  = 43 // 43 Possessified plus, caseful
	OP_POSQUERY = 44 // 44 Posesssified query, caseful
	OP_POSUPTO  = 45 // 45 Possessified upto, caseful

	// Repeated characters; caseless must follow the caseful ones

	OP_STARI     = 46 // 46
	OP_MINSTARI  = 47 // 47
	OP_PLUSI     = 48 // 48
	OP_MINPLUSI  = 49 // 49
	OP_QUERYI    = 50 // 50
	OP_MINQUERYI = 51 // 51

	OP_UPTOI    = 52 // 52 From 0 to n matches of one character, caseless
	OP_MINUPTOI = 53 // 53
	OP_EXACTI   = 54 // 54

	OP_POSSTARI  = 55 // 55 Possessified star, caseless
	OP_POSPLUSI  = 56 // 56 Possessified plus, caseless
	OP_POSQUERYI = 57 // 57 Posesssified query, caseless
	OP_POSUPTOI  = 58 // 58 Possessified upto, caseless

	// The negated ones must follow the non-negated ones, and match them
	// Negated repeated character, caseful; must precede the caseless ones

	OP_NOTSTAR     = 59 // 59 The maximizing and minimizing versions of
	OP_NOTMINSTAR  = 60 // 60 these six opcodes must come in pairs, with
	OP_NOTPLUS     = 61 // 61 the minimizing one second. They must be in
	OP_NOTMINPLUS  = 62 // 62 exactly the same order as those above.
	OP_NOTQUERY    = 63 // 63
	OP_NOTMINQUERY = 64 // 64

	OP_NOTUPTO    = 65 // 65 From 0 to n matches, caseful
	OP_NOTMINUPTO = 66 // 66
	OP_NOTEXACT   = 67 // 67 Exactly n matches

	OP_NOTPOSSTAR  = 68 // 68 Possessified versions, caseful
	OP_NOTPOSPLUS  = 69 // 69
	OP_NOTPOSQUERY = 70 // 70
	OP_NOTPOSUPTO  = 71 // 71

	// Negated repeated character, caseless; must follow the caseful ones

	OP_NOTSTARI     = 72 // 72
	OP_NOTMINSTARI  = 73 // 73
	OP_NOTPLUSI     = 74 // 74
	OP_NOTMINPLUSI  = 75 // 75
	OP_NOTQUERYI    = 76 // 76
	OP_NOTMINQUERYI = 77 // 77

	OP_NOTUPTOI    = 78 // 78 From 0 to n matches, caseless
	OP_NOTMINUPTOI = 79 // 79
	OP_NOTEXACTI   = 80 // 80 Exactly n matches

	OP_NOTPOSSTARI  = 81 // 81 Possessified versions, caseless
	OP_NOTPOSPLUSI  = 82 // 82
	OP_NOTPOSQUERYI = 83 // 83
	OP_NOTPOSUPTOI  = 84 // 84

	// Character types

	OP_TYPESTAR     = 85 // 85 The maximizing and minimizing versions of
	OP_TYPEMINSTAR  = 86 // 86 these six opcodes must come in pairs, with
	OP_TYPEPLUS     = 87 // 87 the minimizing one second. These codes must
	OP_TYPEMINPLUS  = 88 // 88 be in exactly the same order as those above.
	OP_TYPEQUERY    = 89 // 89
	OP_TYPEMINQUERY = 90 // 90

	OP_TYPEUPTO    = 91 // 91 From 0 to n matches
	OP_TYPEMINUPTO = 92 // 92
	OP_TYPEEXACT   = 93 // 93 Exactly n matches

	OP_TYPEPOSSTAR  = 94 // 94 Possessified versions
	OP_TYPEPOSPLUS  = 95 // 95
	OP_TYPEPOSQUERY = 96 // 96
	OP_TYPEPOSUPTO  = 97 // 97

	// These are used for character classes and back references; only the
	//   first six are the same as the sets above.

	OP_CRSTAR     = 98  // 98 The maximizing and minimizing versions of
	OP_CRMINSTAR  = 99  // 99 all these opcodes must come in pairs, with
	OP_CRPLUS     = 100 // 100 the minimizing one second. These codes must
	OP_CRMINPLUS  = 101 // 101 be in exactly the same order as those above.
	OP_CRQUERY    = 102 // 102
	OP_CRMINQUERY = 103 // 103

	OP_CRRANGE    = 104 // 104 These are different to the three sets above.
	OP_CRMINRANGE = 105 // 105

	OP_CRPOSSTAR  = 106 // 106 Possessified versions
	OP_CRPOSPLUS  = 107 // 107
	OP_CRPOSQUERY = 108 // 108
	OP_CRPOSRANGE = 109 // 109

	// End of quantifier opcodes

	OP_CLASS  = 110 // 110 Match a character class, chars < 256 only
	OP_NCLASS = 111 // 111 Same, but the bitmap was created from a negative
	//                               class - the difference is relevant only when a
	//                               character > 255 is encountered.
	OP_XCLASS = 112 // 112 Extended class for handling > 255 chars within the
	//                               class. This does both positive and negative.
	OP_REF         = 113 // 113 Match a back reference, casefully
	OP_REFI        = 114 // 114 Match a back reference, caselessly
	OP_DNREF       = 115 // 115 Match a duplicate name backref, casefully
	OP_DNREFI      = 116 // 116 Match a duplicate name backref, caselessly
	OP_RECURSE     = 117 // 117 Match a numbered subpattern (possibly recursive)
	OP_CALLOUT     = 118 // 118 Call out to external function if provided
	OP_CALLOUT_STR = 119 // 119 Call out with string argument

	OP_ALT     = 120 // 120 Start of alternation
	OP_KET     = 121 // 121 End of group that doesn't have an unbounded repeat
	OP_KETRMAX = 122 // 122 These two must remain together and in this
	OP_KETRMIN = 123 // 123 order. They are for groups the repeat for ever.
	OP_KETRPOS = 124 // 124 Possessive unlimited repeat.

	// The assertions must come before BRA, CBRA, ONCE, and COND.

	OP_REVERSE        = 125 // 125 Move pointer back - used in lookbehind assertions
	OP_ASSERT         = 126 // 126 Positive lookahead
	OP_ASSERT_NOT     = 127 // 127 Negative lookahead
	OP_ASSERTBACK     = 128 // 128 Positive lookbehind
	OP_ASSERTBACK_NOT = 129 // 129 Negative lookbehind
	OP_ASSERT_NA      = 130 // 130 Positive non-atomic lookahead
	OP_ASSERTBACK_NA  = 131 // 131 Positive non-atomic lookbehind

	// ONCE, SCRIPT_RUN, BRA, BRAPOS, CBRA, CBRAPOS, and COND must come
	//   immediately after the assertions, with ONCE first, as there's a test for >=
	//   ONCE for a subpattern that isn't an assertion. The POS versions must
	//   immediately follow the non-POS versions in each case.

	OP_ONCE       = 132 // 132 Atomic group, contains captures
	OP_SCRIPT_RUN = 133 // 133 Non-capture, but check characters' scripts
	OP_BRA        = 134 // 134 Start of non-capturing bracket
	OP_BRAPOS     = 135 // 135 Ditto, with unlimited, possessive repeat
	OP_CBRA       = 136 // 136 Start of capturing bracket
	OP_CBRAPOS    = 137 // 137 Ditto, with unlimited, possessive repeat
	OP_COND       = 138 // 138 Conditional group

	// These five must follow the previous five, in the same order. There's a
	//   check for >= SBRA to distinguish the two sets.

	OP_SBRA     = 139 // 139 Start of non-capturing bracket, check empty
	OP_SBRAPOS  = 140 // 149 Ditto, with unlimited, possessive repeat
	OP_SCBRA    = 141 // 141 Start of capturing bracket, check empty
	OP_SCBRAPOS = 142 // 142 Ditto, with unlimited, possessive repeat
	OP_SCOND    = 143 // 143 Conditional group, check empty

	// The next two pairs must (respectively) be kept together.

	OP_CREF   = 144 // 144 Used to hold a capture number as condition
	OP_DNCREF = 145 // 145 Used to point to duplicate names as a condition
	OP_RREF   = 146 // 146 Used to hold a recursion number as condition
	OP_DNRREF = 147 // 147 Used to point to duplicate names as a condition
	OP_FALSE  = 148 // 148 Always false (used by DEFINE and VERSION)
	OP_TRUE   = 149 // 149 Always true (used by VERSION)

	OP_BRAZERO    = 150 // 150 These two must remain together and in this
	OP_BRAMINZERO = 151 // 151 order.
	OP_BRAPOSZERO = 152 // 152

	// These are backtracking control verbs

	OP_MARK       = 153 // 153 always has an argument
	OP_PRUNE      = 154 // 154
	OP_PRUNE_ARG  = 155 // 155 same, but with argument
	OP_SKIP       = 156 // 156
	OP_SKIP_ARG   = 157 // 157 same, but with argument
	OP_THEN       = 158 // 158
	OP_THEN_ARG   = 159 // 159 same, but with argument
	OP_COMMIT     = 160 // 160
	OP_COMMIT_ARG = 161 // 161 same, but with argument

	// These are forced failure and success verbs. FAIL and ACCEPT do accept an
	//   argument, but these cases can be compiled as, for example, (*MARK:X)(*FAIL)
	//   without the need for a special opcode.

	OP_FAIL          = 162 // 162
	OP_ACCEPT        = 163 // 163
	OP_ASSERT_ACCEPT = 164 // 164 Used inside assertions
	OP_CLOSE         = 165 // 165 Used before OP_ACCEPT to close open captures

	// This is used to skip a subpattern with a {0} quantifier

	OP_SKIPZERO = 166 // 166

	// This is used to identify a DEFINE group during compilation so that it can
	//   be checked for having only one branch. It is changed to OP_FALSE before
	//   compilation finishes.

	OP_DEFINE = 167 // 167

	// This is not an opcode, but is used to check that tables indexed by opcode
	//   are the correct length, in order to catch updating errors - there have been
	//   some in the past.

	OP_TABLE_LENGTH = 168
)

// Size of entries in ucd_script_sets[]

// End of pcre2_ucp.h

// When PCRE2 is compiled as a C++ library, the subject pointer can be replaced
// with a custom type. This makes it possible, for example, to allow pcre2_match()
// to process subject strings that are discontinuous by using a smart pointer
// class. It must always be possible to inspect all of the subject string in
// pcre2_match() because of the way it backtracks.

// WARNING: This is as yet untested for PCRE2.

// When checking for integer overflow in pcre2_compile(), we need to handle
// large integers. If a 64-bit integer type is available, we can use that.
// Otherwise we have to cast to double, which of course requires floating point
// arithmetic. Handle this by defining a macro for the appropriate type.

// External (in the C sense) functions and tables that are private to the
// libraries are always referenced using the PRIV macro. This makes it possible
// for pcre2test.c to include some of the source files from the libraries using a
// different PRIV definition to avoid name clashes. It also makes it clear in the
// code that a non-static object is being referenced.

// When compiling for use with the Virtual Pascal compiler, these functions
// need to have their names changed. PCRE2 must be compiled with the -DVPCOMPAT
// option on the command line.

// Otherwise, to cope with SunOS4 and other systems that lack memmove(), define
// a macro that calls an emulating function.

// This is an unsigned int value that no UTF character can ever have, as
// Unicode doesn't go beyond 0x0010ffff.

// This is the largest valid UTF/Unicode code point.

// Compile-time positive error numbers (all except UTF errors, which are
// negative) start at this value. It should probably never be changed, in case
// some application is checking for specific numbers. There is a copy of this
// #define in pcre2posix.c (which now no longer includes this file). Ideally, a
// way of having a single definition should be found, but as the number is
// unlikely to change, this is not a pressing issue. The original reason for
// having a base other than 0 was to keep the absolute values of compile-time and
// run-time error numbers numerically different, but in the event the code does
// not rely on this.

// The initial frames vector for remembering backtracking points in
// pcre2_match() is allocated on the system stack, of this size (bytes). The size
// must be a multiple of sizeof(PCRE2_SPTR) in all environments, so making it a
// multiple of 8 is best. Typical frame sizes are a few hundred bytes (it depends
// on the number of capturing parentheses) so 20KiB handles quite a few frames. A
// larger vector on the heap is obtained for patterns that need more frames. The
// maximum size of this can be limited.

// Similarly, for DFA matching, an initial internal workspace vector is
// allocated on the stack.

// Define the default BSR convention.

// ---------------- Basic UTF-8 macros ----------------

// These UTF-8 macros are always defined because they are used in pcre2test for
// handling wide characters in 16-bit and 32-bit modes, even if an 8-bit library
// is not supported.

// Tests whether a UTF-8 code point needs extra bytes to decode.

// The following macros were originally written in the form of loops that used
// data from the tables whose names start with PRIV(utf8_table). They were
// rewritten by a user so as not to use loops, because in some environments this
// gives a significant performance advantage, and it seems never to do any harm.

// Base macro to pick up the remaining bytes of a UTF-8 character, not
// advancing the pointer.

// Base macro to pick up the remaining bytes of a UTF-8 character, advancing
// the pointer.

// Base macro to pick up the remaining bytes of a UTF-8 character, not
// advancing the pointer, incrementing the length.

// --------------- Whitespace macros ----------------

// Tests for Unicode horizontal and vertical whitespace characters must check a
// number of different values. Using a switch statement for this generates the
// fastest code (no loop, no memory access), and there are several places in the
// interpreter code where this happens. In order to ensure that all the case lists
// remain in step, we use macros so that there is only one place where the lists
// are defined.
//
// These values are also required as lists in pcre2_compile.c when processing \h,
// \H, \v and \V in a character class. The lists are defined in pcre2_tables.c,
// but macros that define the values are here so that all the definitions are
// together. The lists must be in ascending character order, terminated by
// NOTACHAR (which is 0xffffffff).
//
// Any changes should ensure that the various macros are kept in step with each
// other. NOTE: The values also appear in pcre2_jit_compile.c.

// -------------- ASCII/Unicode environments --------------

// Character U+180E (Mongolian Vowel Separator) is not included in the list of
// spaces in the Unicode file PropList.txt, and Perl does not recognize it as a
// space. However, in many other sources it is listed as a space and has been in
// PCRE (both APIs) for a long time.

// -------------- EBCDIC environments --------------

// -------------- End of whitespace macros --------------

// PCRE2 is able to support several different kinds of newline (CR, LF, CRLF,
// "any" and "anycrlf" at present). The following macros are used to package up
// testing for newlines. NLBLOCK, PSSTART, and PSEND are defined in the various
// modules to indicate in which datablock the parameters exist, and what the
// start/end of string field names are.

// This macro checks for a newline at the given position

// This macro checks for a newline immediately preceding the given position

// Private flags containing information about the compiled pattern. The first
// three must not be changed, because whichever is set is actually the number of
// bytes in a code unit in that mode.

// Values for the matchedby field in a match data block.

const ( /* pcre2_internal.h:537:1: */
	PCRE2_MATCHEDBY_INTERPRETER     = 0 // pcre2_match()
	PCRE2_MATCHEDBY_DFA_INTERPRETER = 1 // pcre2_dfa_match()
	PCRE2_MATCHEDBY_JIT             = 2
)

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// Masks for identifying the public options that are permitted at match time.

// Non-error returns from and within the match() function. Error returns are
// externally defined PCRE2_ERROR_xxx codes, which are all negative.

// Special internal returns used in the match() function. Make them
// sufficiently negative to avoid the external error codes.

// The next 5 must be kept together and in sequence so that a test that checks
// for any one of them can use a range.

// Group frame type values. Zero means the frame is not a group frame. The
// lower 16 bits are used for data (e.g. the capture number). Group frames are
// used for most groups so that information about the start is easily available at
// the end without having to scan back through intermediate frames (backtrack
// points).

// Masks for the identity and data parts of the group frame type.

// Repetition types

const ( /* pcre2_match.c:118:1: */
	REPTYPE_MIN = 0
	REPTYPE_MAX = 1
	REPTYPE_POS = 2
) // OP_CRPOSQUERY, OP_CRPOSRANGE

// Numbers for RMATCH calls at backtracking points. When these lists are
// changed, the code at RETURN_SWITCH below must be updated in sync.

const ( /* pcre2_match.c:150:1: */
	RM1  = 1
	RM2  = 2
	RM3  = 3
	RM4  = 4
	RM5  = 5
	RM6  = 6
	RM7  = 7
	RM8  = 8
	RM9  = 9
	RM10 = 10
	RM11 = 11
	RM12 = 12
	RM13 = 13
	RM14 = 14
	RM15 = 15
	RM16 = 16
	RM17 = 17
	RM18 = 18
	RM19 = 19
	RM20 = 20
	RM21 = 21
	RM22 = 22
	RM23 = 23
	RM24 = 24
	RM25 = 25
	RM26 = 26
	RM27 = 27
	RM28 = 28
	RM29 = 29
	RM30 = 30
	RM31 = 31
	RM32 = 32
	RM33 = 33
	RM34 = 34
	RM35 = 35
	RM36 = 36
)

const ( /* pcre2_match.c:156:1: */
	RM100 = 100
	RM101 = 101
)

const ( /* pcre2_match.c:160:1: */
	RM200 = 200
	RM201 = 201
	RM202 = 202
	RM203 = 203
	RM204 = 204
	RM205 = 205
	RM206 = 206
	RM207 = 207
	RM208 = 208
	RM209 = 209
	RM210 = 210
	RM211 = 211
	RM212 = 212
	RM213 = 213
	RM214 = 214
	RM215 = 215
	RM216 = 216
	RM217 = 217
	RM218 = 218
	RM219 = 219
	RM220 = 220
	RM221 = 221
	RM222 = 222
	RM223 = 223
	RM224 = 224
	RM225 = 225
)

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// ************************************************
//
//                Check script run                *
//

// A script run is conceptually a sequence of characters all in the same
// Unicode script. However, it isn't quite that simple. There are special rules
// for scripts that are commonly used together, and also special rules for digits.
// This function implements the appropriate checks, which is possible only when
// PCRE2 is compiled with Unicode support. The function returns TRUE if there is
// no Unicode support; however, it should never be called in that circumstance
// because an error is given by pcre2_compile() if a script run is called for in a
// version of PCRE2 compiled without Unicode support.
//
// Arguments:
//   pgr       point to the first character
//   endptr    point after the last character
//   utf       TRUE if in UTF mode
//
// Returns:    TRUE if this is a valid script run

// These are states in the checking process.

const ( /* pcre2_script_run.c:73:1: */
	SCRIPT_UNSET       = 0 // Requirement as yet unknown
	SCRIPT_MAP         = 1 // Bitmap contains acceptable scripts
	SCRIPT_HANPENDING  = 2 // Have had only Han characters
	SCRIPT_HANHIRAKATA = 3 // Expect Han or Hirikata
	SCRIPT_HANBOPOMOFO = 4 // Expect Han or Bopomofo
	SCRIPT_HANHANGUL   = 5
)

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// The maximum remembered capturing brackets minimum.

// Set a bit in the starting code unit bit map.

// Returns from set_start_bits()

const ( /* pcre2_study.c:61:1: */
	SSB_FAIL     = 0
	SSB_DONE     = 1
	SSB_CONTINUE = 2
	SSB_UNKNOWN  = 3
	SSB_TOODEEP  = 4
)

// These are Boolean properties.

const ( /* pcre2_ucp.h:105:1: */
	ucp_ASCII                        = 0
	ucp_ASCII_Hex_Digit              = 1
	ucp_Alphabetic                   = 2
	ucp_Bidi_Control                 = 3
	ucp_Bidi_Mirrored                = 4
	ucp_Case_Ignorable               = 5
	ucp_Cased                        = 6
	ucp_Changes_When_Casefolded      = 7
	ucp_Changes_When_Casemapped      = 8
	ucp_Changes_When_Lowercased      = 9
	ucp_Changes_When_Titlecased      = 10
	ucp_Changes_When_Uppercased      = 11
	ucp_Dash                         = 12
	ucp_Default_Ignorable_Code_Point = 13
	ucp_Deprecated                   = 14
	ucp_Diacritic                    = 15
	ucp_Emoji                        = 16
	ucp_Emoji_Component              = 17
	ucp_Emoji_Modifier               = 18
	ucp_Emoji_Modifier_Base          = 19
	ucp_Emoji_Presentation           = 20
	ucp_Extended_Pictographic        = 21
	ucp_Extender                     = 22
	ucp_Grapheme_Base                = 23
	ucp_Grapheme_Extend              = 24
	ucp_Grapheme_Link                = 25
	ucp_Hex_Digit                    = 26
	ucp_IDS_Binary_Operator          = 27
	ucp_IDS_Trinary_Operator         = 28
	ucp_ID_Continue                  = 29
	ucp_ID_Start                     = 30
	ucp_Ideographic                  = 31
	ucp_Join_Control                 = 32
	ucp_Logical_Order_Exception      = 33
	ucp_Lowercase                    = 34
	ucp_Math                         = 35
	ucp_Noncharacter_Code_Point      = 36
	ucp_Pattern_Syntax               = 37
	ucp_Pattern_White_Space          = 38
	ucp_Prepended_Concatenation_Mark = 39
	ucp_Quotation_Mark               = 40
	ucp_Radical                      = 41
	ucp_Regional_Indicator           = 42
	ucp_Sentence_Terminal            = 43
	ucp_Soft_Dotted                  = 44
	ucp_Terminal_Punctuation         = 45
	ucp_Unified_Ideograph            = 46
	ucp_Uppercase                    = 47
	ucp_Variation_Selector           = 48
	ucp_White_Space                  = 49
	ucp_XID_Continue                 = 50
	ucp_XID_Start                    = 51
	// This must be last
	ucp_Bprop_Count = 52
)

// Size of entries in ucd_boolprop_sets[]

// These are the bidi class values.

const ( /* pcre2_ucp.h:168:1: */
	ucp_bidiAL  = 0  // Arabic letter
	ucp_bidiAN  = 1  // Arabic number
	ucp_bidiB   = 2  // Paragraph separator
	ucp_bidiBN  = 3  // Boundary neutral
	ucp_bidiCS  = 4  // Common separator
	ucp_bidiEN  = 5  // European number
	ucp_bidiES  = 6  // European separator
	ucp_bidiET  = 7  // European terminator
	ucp_bidiFSI = 8  // First strong isolate
	ucp_bidiL   = 9  // Left to right
	ucp_bidiLRE = 10 // Left to right embedding
	ucp_bidiLRI = 11 // Left to right isolate
	ucp_bidiLRO = 12 // Left to right override
	ucp_bidiNSM = 13 // Non-spacing mark
	ucp_bidiON  = 14 // Other neutral
	ucp_bidiPDF = 15 // Pop directional format
	ucp_bidiPDI = 16 // Pop directional isolate
	ucp_bidiR   = 17 // Right to left
	ucp_bidiRLE = 18 // Right to left embedding
	ucp_bidiRLI = 19 // Right to left isolate
	ucp_bidiRLO = 20 // Right to left override
	ucp_bidiS   = 21 // Segment separator
	ucp_bidiWS  = 22
)

// These are grapheme break properties. The Extended Pictographic property
// comes from the emoji-data.txt file.

const ( /* pcre2_ucp.h:197:1: */
	ucp_gbCR                    = 0  //  0
	ucp_gbLF                    = 1  //  1
	ucp_gbControl               = 2  //  2
	ucp_gbExtend                = 3  //  3
	ucp_gbPrepend               = 4  //  4
	ucp_gbSpacingMark           = 5  //  5
	ucp_gbL                     = 6  //  6 Hangul syllable type L
	ucp_gbV                     = 7  //  7 Hangul syllable type V
	ucp_gbT                     = 8  //  8 Hangul syllable type T
	ucp_gbLV                    = 9  //  9 Hangul syllable type LV
	ucp_gbLVT                   = 10 // 10 Hangul syllable type LVT
	ucp_gbRegional_Indicator    = 11 // 11
	ucp_gbOther                 = 12 // 12
	ucp_gbZWJ                   = 13 // 13
	ucp_gbExtended_Pictographic = 14
)

// These are the script identifications.

const ( /* pcre2_ucp.h:217:1: */
	// Scripts which has characters in other scripts.
	ucp_Latin           = 0
	ucp_Greek           = 1
	ucp_Cyrillic        = 2
	ucp_Arabic          = 3
	ucp_Syriac          = 4
	ucp_Thaana          = 5
	ucp_Devanagari      = 6
	ucp_Bengali         = 7
	ucp_Gurmukhi        = 8
	ucp_Gujarati        = 9
	ucp_Oriya           = 10
	ucp_Tamil           = 11
	ucp_Telugu          = 12
	ucp_Kannada         = 13
	ucp_Malayalam       = 14
	ucp_Sinhala         = 15
	ucp_Myanmar         = 16
	ucp_Georgian        = 17
	ucp_Hangul          = 18
	ucp_Mongolian       = 19
	ucp_Hiragana        = 20
	ucp_Katakana        = 21
	ucp_Bopomofo        = 22
	ucp_Han             = 23
	ucp_Yi              = 24
	ucp_Tagalog         = 25
	ucp_Hanunoo         = 26
	ucp_Buhid           = 27
	ucp_Tagbanwa        = 28
	ucp_Limbu           = 29
	ucp_Tai_Le          = 30
	ucp_Linear_B        = 31
	ucp_Cypriot         = 32
	ucp_Buginese        = 33
	ucp_Coptic          = 34
	ucp_Glagolitic      = 35
	ucp_Syloti_Nagri    = 36
	ucp_Phags_Pa        = 37
	ucp_Nko             = 38
	ucp_Kayah_Li        = 39
	ucp_Javanese        = 40
	ucp_Kaithi          = 41
	ucp_Mandaic         = 42
	ucp_Chakma          = 43
	ucp_Sharada         = 44
	ucp_Takri           = 45
	ucp_Duployan        = 46
	ucp_Grantha         = 47
	ucp_Khojki          = 48
	ucp_Linear_A        = 49
	ucp_Mahajani        = 50
	ucp_Manichaean      = 51
	ucp_Modi            = 52
	ucp_Old_Permic      = 53
	ucp_Psalter_Pahlavi = 54
	ucp_Khudawadi       = 55
	ucp_Tirhuta         = 56
	ucp_Multani         = 57
	ucp_Adlam           = 58
	ucp_Masaram_Gondi   = 59
	ucp_Dogra           = 60
	ucp_Gunjala_Gondi   = 61
	ucp_Hanifi_Rohingya = 62
	ucp_Sogdian         = 63
	ucp_Nandinagari     = 64
	ucp_Yezidi          = 65
	ucp_Cypro_Minoan    = 66
	ucp_Old_Uyghur      = 67

	// Scripts which has no characters in other scripts.
	ucp_Unknown                = 68
	ucp_Common                 = 69
	ucp_Armenian               = 70
	ucp_Hebrew                 = 71
	ucp_Thai                   = 72
	ucp_Lao                    = 73
	ucp_Tibetan                = 74
	ucp_Ethiopic               = 75
	ucp_Cherokee               = 76
	ucp_Canadian_Aboriginal    = 77
	ucp_Ogham                  = 78
	ucp_Runic                  = 79
	ucp_Khmer                  = 80
	ucp_Old_Italic             = 81
	ucp_Gothic                 = 82
	ucp_Deseret                = 83
	ucp_Inherited              = 84
	ucp_Ugaritic               = 85
	ucp_Shavian                = 86
	ucp_Osmanya                = 87
	ucp_Braille                = 88
	ucp_New_Tai_Lue            = 89
	ucp_Tifinagh               = 90
	ucp_Old_Persian            = 91
	ucp_Kharoshthi             = 92
	ucp_Balinese               = 93
	ucp_Cuneiform              = 94
	ucp_Phoenician             = 95
	ucp_Sundanese              = 96
	ucp_Lepcha                 = 97
	ucp_Ol_Chiki               = 98
	ucp_Vai                    = 99
	ucp_Saurashtra             = 100
	ucp_Rejang                 = 101
	ucp_Lycian                 = 102
	ucp_Carian                 = 103
	ucp_Lydian                 = 104
	ucp_Cham                   = 105
	ucp_Tai_Tham               = 106
	ucp_Tai_Viet               = 107
	ucp_Avestan                = 108
	ucp_Egyptian_Hieroglyphs   = 109
	ucp_Samaritan              = 110
	ucp_Lisu                   = 111
	ucp_Bamum                  = 112
	ucp_Meetei_Mayek           = 113
	ucp_Imperial_Aramaic       = 114
	ucp_Old_South_Arabian      = 115
	ucp_Inscriptional_Parthian = 116
	ucp_Inscriptional_Pahlavi  = 117
	ucp_Old_Turkic             = 118
	ucp_Batak                  = 119
	ucp_Brahmi                 = 120
	ucp_Meroitic_Cursive       = 121
	ucp_Meroitic_Hieroglyphs   = 122
	ucp_Miao                   = 123
	ucp_Sora_Sompeng           = 124
	ucp_Caucasian_Albanian     = 125
	ucp_Bassa_Vah              = 126
	ucp_Elbasan                = 127
	ucp_Pahawh_Hmong           = 128
	ucp_Mende_Kikakui          = 129
	ucp_Mro                    = 130
	ucp_Old_North_Arabian      = 131
	ucp_Nabataean              = 132
	ucp_Palmyrene              = 133
	ucp_Pau_Cin_Hau            = 134
	ucp_Siddham                = 135
	ucp_Warang_Citi            = 136
	ucp_Ahom                   = 137
	ucp_Anatolian_Hieroglyphs  = 138
	ucp_Hatran                 = 139
	ucp_Old_Hungarian          = 140
	ucp_SignWriting            = 141
	ucp_Bhaiksuki              = 142
	ucp_Marchen                = 143
	ucp_Newa                   = 144
	ucp_Osage                  = 145
	ucp_Tangut                 = 146
	ucp_Nushu                  = 147
	ucp_Soyombo                = 148
	ucp_Zanabazar_Square       = 149
	ucp_Makasar                = 150
	ucp_Medefaidrin            = 151
	ucp_Old_Sogdian            = 152
	ucp_Elymaic                = 153
	ucp_Nyiakeng_Puachue_Hmong = 154
	ucp_Wancho                 = 155
	ucp_Chorasmian             = 156
	ucp_Dives_Akuru            = 157
	ucp_Khitan_Small_Script    = 158
	ucp_Tangsa                 = 159
	ucp_Toto                   = 160
	ucp_Vithkuqi               = 161

	// This must be last
	ucp_Script_Count = 162
)

// Undefine the list macros; they are no longer needed.

// PCRE2_CODE_UNIT_WIDTH must be defined. If it is 8, 16, or 32, redefine
// PCRE2_SUFFIX to use it. If it is 0, undefine the other macros and make
// PCRE2_SUFFIX a no-op. Otherwise, generate an error.

// End of pcre2.h
// ************************************************
//
//      Perl-Compatible Regular Expressions       *
//

// PCRE is a library of functions to support regular expressions whose syntax
// and semantics are as close as possible to those of the Perl 5 language.
//
//                        Written by Philip Hazel
//      Original API code Copyright (c) 1997-2012 University of Cambridge
//           New API code Copyright (c) 2016-2022 University of Cambridge
//
// This module is auto-generated from Unicode data files. DO NOT EDIT MANUALLY!
// Instead, modify the maint/GenerateUcpHeader.py script and run it to generate
// a new version of this code.
//
// -----------------------------------------------------------------------------
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//
//     * Neither the name of the University of Cambridge nor the names of its
//       contributors may be used to endorse or promote products derived from
//       this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
// -----------------------------------------------------------------------------

// This file contains definitions of the Unicode property values that are
// returned by the UCD access macros and used throughout PCRE2.
//
// IMPORTANT: The specific values of the first two enums (general and particular
// character categories) are assumed by the table called catposstab in the file
// pcre2_auto_possess.c. They are unlikely to change, but should be checked after
// an update.

// These are the general character categories.

const ( /* pcre2_ucp.h:58:1: */
	ucp_C = 0
	ucp_L = 1
	ucp_M = 2
	ucp_N = 3
	ucp_P = 4
	ucp_S = 5
	ucp_Z = 6
)

// These are the particular character categories.

const ( /* pcre2_ucp.h:70:1: */
	ucp_Cc = 0  // Control
	ucp_Cf = 1  // Format
	ucp_Cn = 2  // Unassigned
	ucp_Co = 3  // Private use
	ucp_Cs = 4  // Surrogate
	ucp_Ll = 5  // Lower case letter
	ucp_Lm = 6  // Modifier letter
	ucp_Lo = 7  // Other letter
	ucp_Lt = 8  // Title case letter
	ucp_Lu = 9  // Upper case letter
	ucp_Mc = 10 // Spacing mark
	ucp_Me = 11 // Enclosing mark
	ucp_Mn = 12 // Non-spacing mark
	ucp_Nd = 13 // Decimal number
	ucp_Nl = 14 // Letter number
	ucp_No = 15 // Other number
	ucp_Pc = 16 // Connector punctuation
	ucp_Pd = 17 // Dash punctuation
	ucp_Pe = 18 // Close punctuation
	ucp_Pf = 19 // Final punctuation
	ucp_Pi = 20 // Initial punctuation
	ucp_Po = 21 // Other punctuation
	ucp_Ps = 22 // Open punctuation
	ucp_Sc = 23 // Currency symbol
	ucp_Sk = 24 // Modifier symbol
	ucp_Sm = 25 // Mathematical symbol
	ucp_So = 26 // Other symbol
	ucp_Zl = 27 // Line separator
	ucp_Zp = 28 // Paragraph separator
	ucp_Zs = 29
)

type Tptrdiff_t = int64 /* <builtin>:3:26 */

type Tsize_t = uint64 /* <builtin>:9:23 */

type Twchar_t = int32 /* <builtin>:15:24 */

type T__int128_t = struct {
	Flo int64
	Fhi int64
} /* <builtin>:21:43 */ // must match modernc.org/mathutil.Int128
type T__uint128_t = struct {
	Flo uint64
	Fhi uint64
} /* <builtin>:22:44 */ // must match modernc.org/mathutil.Int128

type T__builtin_va_list = uintptr /* <builtin>:46:14 */
type T__float128 = float64        /* <builtin>:47:21 */

// ************************************************
//
//      Perl-Compatible Regular Expressions       *
//

// PCRE is a library of functions to support regular expressions whose syntax
// and semantics are as close as possible to those of the Perl 5 language.
//
//                        Written by Philip Hazel
//      Original API code Copyright (c) 1997-2012 University of Cambridge
//           New API code Copyright (c) 2016-2022 University of Cambridge
//
// -----------------------------------------------------------------------------
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//
//     * Neither the name of the University of Cambridge nor the names of its
//       contributors may be used to endorse or promote products derived from
//       this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
// -----------------------------------------------------------------------------

// This module contains functions that scan a compiled pattern and change
// repeats into possessive repeats where possible.

// src/config.h.  Generated from config.h.in by configure.
// src/config.h.in.  Generated from configure.ac by autoheader.

// PCRE2 is written in Standard C, but there are a few non-standard things it
// can cope with, allowing it to run on SunOS4 and other "close to standard"
// systems.
//
// In environments that support the GNU autotools, config.h.in is converted into
// config.h by the "configure" script. In environments that use CMake,
// config-cmake.in is converted into config.h. If you are going to build PCRE2 "by
// hand" without using "configure" or CMake, you should copy the distributed
// config.h.generic to config.h, and edit the macro definitions to be the way you
// need them. You must then add -DHAVE_CONFIG_H to all of your compile commands,
// so that config.h is included at the start of every source.
//
// Alternatively, you can avoid editing by using -D on the compiler command line
// to set the macro values. In this case, you do not have to set -DHAVE_CONFIG_H,
// but if you do, default values will be taken from config.h for non-boolean
// macros that are not defined on the command line.
//
// Boolean macros such as HAVE_STDLIB_H and SUPPORT_PCRE2_8 should either be
// defined (conventionally to 1) for TRUE, and not defined at all for FALSE. All
// such macros are listed as a commented #undef in config.h.generic. Macros such
// as MATCH_LIMIT, whose actual value is relevant, have defaults defined, but are
// surrounded by #ifndef/#endif lines so that the value can be overridden by -D.
//
// PCRE2 uses memmove() if HAVE_MEMMOVE is defined; otherwise it uses bcopy() if
// HAVE_BCOPY is defined. If your system has neither bcopy() nor memmove(), make
// sure both macros are undefined; an emulation function will then be used.

// By default, the \R escape sequence matches any Unicode line ending
//    character or sequence of characters. If BSR_ANYCRLF is defined (to any
//    value), this is changed so that backslash-R matches only CR, LF, or CRLF.
//    The build-time default can be overridden by the user of PCRE2 at runtime.
//
// #undef BSR_ANYCRLF

// Define to any value to disable the use of the z and t modifiers in
//    formatting settings such as %zu or %td (this is rarely needed).
// #undef DISABLE_PERCENT_ZT

// If you are compiling for a system that uses EBCDIC instead of ASCII
//    character codes, define this macro to any value. When EBCDIC is set, PCRE2
//    assumes that all input strings are in EBCDIC. If you do not define this
//    macro, PCRE2 will assume input strings are ASCII or UTF-8/16/32 Unicode. It
//    is not possible to build a version of PCRE2 that supports both EBCDIC and
//    UTF-8/16/32.
// #undef EBCDIC

// In an EBCDIC environment, define this macro to any value to arrange for the
//    NL character to be 0x25 instead of the default 0x15. NL plays the role that
//    LF does in an ASCII/Unicode environment.
// #undef EBCDIC_NL25

// Define this if your compiler supports __attribute__((uninitialized))
// #undef HAVE_ATTRIBUTE_UNINITIALIZED

// Define to 1 if you have the `bcopy' function.

// Define to 1 if you have the <bzlib.h> header file.

// Define to 1 if you have the <dirent.h> header file.

// Define to 1 if you have the <dlfcn.h> header file.

// Define to 1 if you have the <editline/readline.h> header file.
// #undef HAVE_EDITLINE_READLINE_H

// Define to 1 if you have the <edit/readline/readline.h> header file.
// #undef HAVE_EDIT_READLINE_READLINE_H

// Define to 1 if you have the <inttypes.h> header file.

// Define to 1 if you have the <limits.h> header file.

// Define to 1 if you have the `memfd_create' function.

// Define to 1 if you have the `memmove' function.

// Define to 1 if you have the <minix/config.h> header file.
// #undef HAVE_MINIX_CONFIG_H

// Define to 1 if you have the `mkostemp' function.

// Define if you have POSIX threads libraries and header files.
// #undef HAVE_PTHREAD

// Have PTHREAD_PRIO_INHERIT.
// #undef HAVE_PTHREAD_PRIO_INHERIT

// Define to 1 if you have the <readline.h> header file.
// #undef HAVE_READLINE_H

// Define to 1 if you have the <readline/history.h> header file.
// #undef HAVE_READLINE_HISTORY_H

// Define to 1 if you have the <readline/readline.h> header file.
// #undef HAVE_READLINE_READLINE_H

// Define to 1 if you have the `realpath' function.

// Define to 1 if you have the `secure_getenv' function.

// Define to 1 if you have the <stdint.h> header file.

// Define to 1 if you have the <stdio.h> header file.

// Define to 1 if you have the <stdlib.h> header file.

// Define to 1 if you have the `strerror' function.

// Define to 1 if you have the <strings.h> header file.

// Define to 1 if you have the <string.h> header file.

// Define to 1 if you have the <sys/stat.h> header file.

// Define to 1 if you have the <sys/types.h> header file.

// Define to 1 if you have the <sys/wait.h> header file.

// Define to 1 if you have the <unistd.h> header file.

// Define to 1 if the compiler supports simple visibility declarations.

// Define to 1 if you have the <wchar.h> header file.

// Define to 1 if you have the <windows.h> header file.
// #undef HAVE_WINDOWS_H

// Define to 1 if you have the <zlib.h> header file.

// This limits the amount of memory that may be used while matching a pattern.
//    It applies to both pcre2_match() and pcre2_dfa_match(). It does not apply
//    to JIT matching. The value is in kibibytes (units of 1024 bytes).

// The value of LINK_SIZE determines the number of bytes used to store links
//    as offsets within the compiled regex. The default is 2, which allows for
//    compiled patterns up to 65535 code units long. This covers the vast
//    majority of cases. However, PCRE2 can also be compiled to use 3 or 4 bytes
//    instead. This allows for longer patterns in extreme cases.

// Define to the sub-directory where libtool stores uninstalled libraries.

// The value of MATCH_LIMIT determines the default number of times the
//    pcre2_match() function can record a backtrack position during a single
//    matching attempt. The value is also used to limit a loop counter in
//    pcre2_dfa_match(). There is a runtime interface for setting a different
//    limit. The limit exists in order to catch runaway regular expressions that
//    take for ever to determine that they do not match. The default is set very
//    large so that it does not accidentally catch legitimate cases.

// The above limit applies to all backtracks, whether or not they are nested.
//    In some environments it is desirable to limit the nesting of backtracking
//    (that is, the depth of tree that is searched) more strictly, in order to
//    restrict the maximum amount of heap memory that is used. The value of
//    MATCH_LIMIT_DEPTH provides this facility. To have any useful effect, it
//    must be less than the value of MATCH_LIMIT. The default is to use the same
//    value as MATCH_LIMIT. There is a runtime method for setting a different
//    limit. In the case of pcre2_dfa_match(), this limit controls the depth of
//    the internal nested function calls that are used for pattern recursions,
//    lookarounds, and atomic groups.

// This limit is parameterized just in case anybody ever wants to change it.
//    Care must be taken if it is increased, because it guards against integer
//    overflow caused by enormously large patterns.

// This limit is parameterized just in case anybody ever wants to change it.
//    Care must be taken if it is increased, because it guards against integer
//    overflow caused by enormously large patterns.

// Defining NEVER_BACKSLASH_C locks out the use of \C in all patterns.
// #undef NEVER_BACKSLASH_C

// The value of NEWLINE_DEFAULT determines the default newline character
//    sequence. PCRE2 client programs can override this by selecting other values
//    at run time. The valid values are 1 (CR), 2 (LF), 3 (CRLF), 4 (ANY), 5
//    (ANYCRLF), and 6 (NUL).

// Name of package

// Define to the address where bug reports for this package should be sent.

// Define to the full name of this package.

// Define to the full name and version of this package.

// Define to the one symbol short name of this package.

// Define to the home page for this package.

// Define to the version of this package.

// The value of PARENS_NEST_LIMIT specifies the maximum depth of nested
//    parentheses (of any kind) in a pattern. This limits the amount of system
//    stack that is used while compiling a pattern.

// The value of PCRE2GREP_BUFSIZE is the starting size of the buffer used by
//    pcre2grep to hold parts of the file it is searching. The buffer will be
//    expanded up to PCRE2GREP_MAX_BUFSIZE if necessary, for files containing
//    very long lines. The actual amount of memory used by pcre2grep is three
//    times this number, because it allows for the buffering of "before" and
//    "after" lines.

// The value of PCRE2GREP_MAX_BUFSIZE specifies the maximum size of the buffer
//    used by pcre2grep to hold parts of the file it is searching. The actual
//    amount of memory used by pcre2grep is three times this number, because it
//    allows for the buffering of "before" and "after" lines.

// to make a symbol visible

// to make a symbol visible

// Define to any value to include debugging code.
// #undef PCRE2_DEBUG

// to make a symbol visible

// If you are compiling for a system other than a Unix-like system or
//    Win32, and it needs some magic to be inserted before the definition
//    of a function that is exported by the library, define this macro to
//    contain the relevant magic. If you do not define this macro, a suitable
//     __declspec value is used for Windows systems; in other environments
//    "extern" is used for a C compiler and "extern C" for a C++ compiler.
//    This macro apears at the start of every exported function that is part
//    of the external API. It does not appear on functions that are "external"
//    in the C sense, but which are internal to the library.

// Define to any value if linking statically (TODO: make nice with Libtool)
// #undef PCRE2_STATIC

// Define to necessary symbol if this constant uses a non-standard name on
//    your system.
// #undef PTHREAD_CREATE_JOINABLE

// Define to any non-zero number to enable support for SELinux compatible
//    executable memory allocator in JIT. Note that this will have no effect
//    unless SUPPORT_JIT is also defined.
// #undef SLJIT_PROT_EXECUTABLE_ALLOCATOR

// Define to 1 if all of the C90 standard headers exist (not just the ones
//    required in a freestanding environment). This macro is provided for
//    backward compatibility; new code need not use it.

// Define to any value to enable support for Just-In-Time compiling.
// #undef SUPPORT_JIT

// Define to any value to allow pcre2grep to be linked with libbz2, so that it
//    is able to handle .bz2 files.
// #undef SUPPORT_LIBBZ2

// Define to any value to allow pcre2test to be linked with libedit.
// #undef SUPPORT_LIBEDIT

// Define to any value to allow pcre2test to be linked with libreadline.
// #undef SUPPORT_LIBREADLINE

// Define to any value to allow pcre2grep to be linked with libz, so that it
//    is able to handle .gz files.
// #undef SUPPORT_LIBZ

// Define to any value to enable callout script support in pcre2grep.

// Define to any value to enable fork support in pcre2grep callout scripts.
//    This will have no effect unless SUPPORT_PCRE2GREP_CALLOUT is also defined.
//

// Define to any value to enable JIT support in pcre2grep. Note that this will
//    have no effect unless SUPPORT_JIT is also defined.
// #undef SUPPORT_PCRE2GREP_JIT

// Define to any value to enable the 16 bit PCRE2 library.
// #undef SUPPORT_PCRE2_16

// Define to any value to enable the 32 bit PCRE2 library.
// #undef SUPPORT_PCRE2_32

// Define to any value to enable the 8 bit PCRE2 library.

// Define to any value to enable support for Unicode and UTF encoding. This
//    will work even in an EBCDIC environment, but it is incompatible with the
//    EBCDIC macro. That is, PCRE2 can support *either* EBCDIC code *or*
//    ASCII/Unicode, but not both at once.

// Define to any value for valgrind support to find invalid memory reads.
// #undef SUPPORT_VALGRIND

// Enable extensions on AIX 3, Interix.
// Enable general extensions on macOS.
// Enable general extensions on Solaris.
// Enable GNU extensions on systems that have them.
// Enable X/Open compliant socket functions that do not require linking
//    with -lxnet on HP-UX 11.11.
// Identify the host operating system as Minix.
//    This macro does not affect the system headers' behavior.
//    A future release of Autoconf may stop defining this macro.
// # undef _MINIX
// Enable general extensions on NetBSD.
//    Enable NetBSD compatibility extensions on Minix.
// Enable OpenBSD compatibility extensions on NetBSD.
//    Oddly enough, this does nothing on OpenBSD.
// Define to 1 if needed for POSIX-compatible behavior.
// # undef _POSIX_SOURCE
// Define to 2 if needed for POSIX-compatible behavior.
// # undef _POSIX_1_SOURCE
// Enable POSIX-compatible threading on Solaris.
// Enable extensions specified by ISO/IEC TS 18661-5:2014.
// Enable extensions specified by ISO/IEC TS 18661-1:2014.
// Enable extensions specified by ISO/IEC TS 18661-2:2015.
// Enable extensions specified by ISO/IEC TS 18661-4:2015.
// Enable extensions specified by ISO/IEC TS 18661-3:2015.
// Enable extensions specified by ISO/IEC TR 24731-2:2010.
// Enable extensions specified by ISO/IEC 24747:2009.
// Enable extensions on HP NonStop.
// Enable X/Open extensions.  Define to 500 only if necessary
//    to make mbstate_t available.
// # undef _XOPEN_SOURCE

// Version number of package

// Define to empty if `const' does not conform to ANSI C.
// #undef const

// Define to the type of a signed integer type of width exactly 64 bits if
//    such a type exists and the standard includes do not define it.
// #undef int64_t

// Define to `unsigned int' if <sys/types.h> does not define.
// #undef size_t

// ************************************************
//
//      Perl-Compatible Regular Expressions       *
//

// PCRE2 is a library of functions to support regular expressions whose syntax
// and semantics are as close as possible to those of the Perl 5 language.
//
//                        Written by Philip Hazel
//      Original API code Copyright (c) 1997-2012 University of Cambridge
//           New API code Copyright (c) 2016-2022 University of Cambridge
//
// -----------------------------------------------------------------------------
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//
//     * Neither the name of the University of Cambridge nor the names of its
//       contributors may be used to endorse or promote products derived from
//       this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
// -----------------------------------------------------------------------------

// We do not support both EBCDIC and Unicode at the same time. The "configure"
// script prevents both being selected, but not everybody uses "configure". EBCDIC
// is only supported for the 8-bit library, but the check for this has to be later
// in this file, because the first part is not width-dependent, and is included by
// pcre2test.c with CODE_UNIT_WIDTH == 0.

// Standard C headers

// Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard 7.4: Character handling	<ctype.h>

// Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// These are defined by the user (or the compiler)
//    to specify the desired environment:
//
//    __STRICT_ANSI__	ISO Standard C.
//    _ISOC99_SOURCE	Extensions to ISO C89 from ISO C99.
//    _ISOC11_SOURCE	Extensions to ISO C99 from ISO C11.
//    _ISOC2X_SOURCE	Extensions to ISO C99 from ISO C2X.
//    __STDC_WANT_LIB_EXT2__
// 			Extensions to ISO C99 from TR 27431-2:2010.
//    __STDC_WANT_IEC_60559_BFP_EXT__
// 			Extensions to ISO C11 from TS 18661-1:2014.
//    __STDC_WANT_IEC_60559_FUNCS_EXT__
// 			Extensions to ISO C11 from TS 18661-4:2015.
//    __STDC_WANT_IEC_60559_TYPES_EXT__
// 			Extensions to ISO C11 from TS 18661-3:2015.
//    __STDC_WANT_IEC_60559_EXT__
// 			ISO C2X interfaces defined only in Annex F.
//
//    _POSIX_SOURCE	IEEE Std 1003.1.
//    _POSIX_C_SOURCE	If ==1, like _POSIX_SOURCE; if >=2 add IEEE Std 1003.2;
// 			if >=199309L, add IEEE Std 1003.1b-1993;
// 			if >=199506L, add IEEE Std 1003.1c-1995;
// 			if >=200112L, all of IEEE 1003.1-2004
// 			if >=200809L, all of IEEE 1003.1-2008
//    _XOPEN_SOURCE	Includes POSIX and XPG things.  Set to 500 if
// 			Single Unix conformance is wanted, to 600 for the
// 			sixth revision, to 700 for the seventh revision.
//    _XOPEN_SOURCE_EXTENDED XPG things and X/Open Unix extensions.
//    _LARGEFILE_SOURCE	Some more functions for correct standard I/O.
//    _LARGEFILE64_SOURCE	Additional functionality from LFS for large files.
//    _FILE_OFFSET_BITS=N	Select default filesystem interface.
//    _ATFILE_SOURCE	Additional *at interfaces.
//    _DYNAMIC_STACK_SIZE_SOURCE Select correct (but non compile-time constant)
// 			MINSIGSTKSZ, SIGSTKSZ and PTHREAD_STACK_MIN.
//    _GNU_SOURCE		All of the above, plus GNU extensions.
//    _DEFAULT_SOURCE	The default set of features (taking precedence over
// 			__STRICT_ANSI__).
//
//    _FORTIFY_SOURCE	Add security hardening to many library functions.
// 			Set to 1 or 2; 2 performs stricter checks than 1.
//
//    _REENTRANT, _THREAD_SAFE
// 			Obsolete; equivalent to _POSIX_C_SOURCE=199506L.
//
//    The `-ansi' switch to the GNU C compiler, and standards conformance
//    options such as `-std=c99', define __STRICT_ANSI__.  If none of
//    these are defined, or if _DEFAULT_SOURCE is defined, the default is
//    to have _POSIX_SOURCE set to one and _POSIX_C_SOURCE set to
//    200809L, as well as enabling miscellaneous functions from BSD and
//    SVID.  If more than one of these are defined, they accumulate.  For
//    example __STRICT_ANSI__, _POSIX_SOURCE and _POSIX_C_SOURCE together
//    give you ISO C, 1003.1, and 1003.2, but nothing else.
//
//    These are defined by this file and are used by the
//    header files to decide what to declare or define:
//
//    __GLIBC_USE (F)	Define things from feature set F.  This is defined
// 			to 1 or 0; the subsequent macros are either defined
// 			or undefined, and those tests should be moved to
// 			__GLIBC_USE.
//    __USE_ISOC11		Define ISO C11 things.
//    __USE_ISOC99		Define ISO C99 things.
//    __USE_ISOC95		Define ISO C90 AMD1 (C95) things.
//    __USE_ISOCXX11	Define ISO C++11 things.
//    __USE_POSIX		Define IEEE Std 1003.1 things.
//    __USE_POSIX2		Define IEEE Std 1003.2 things.
//    __USE_POSIX199309	Define IEEE Std 1003.1, and .1b things.
//    __USE_POSIX199506	Define IEEE Std 1003.1, .1b, .1c and .1i things.
//    __USE_XOPEN		Define XPG things.
//    __USE_XOPEN_EXTENDED	Define X/Open Unix things.
//    __USE_UNIX98		Define Single Unix V2 things.
//    __USE_XOPEN2K        Define XPG6 things.
//    __USE_XOPEN2KXSI     Define XPG6 XSI things.
//    __USE_XOPEN2K8       Define XPG7 things.
//    __USE_XOPEN2K8XSI    Define XPG7 XSI things.
//    __USE_LARGEFILE	Define correct standard I/O things.
//    __USE_LARGEFILE64	Define LFS things with separate names.
//    __USE_FILE_OFFSET64	Define 64bit interface as default.
//    __USE_MISC		Define things from 4.3BSD or System V Unix.
//    __USE_ATFILE		Define *at interfaces and AT_* constants for them.
//    __USE_DYNAMIC_STACK_SIZE Define correct (but non compile-time constant)
// 			MINSIGSTKSZ, SIGSTKSZ and PTHREAD_STACK_MIN.
//    __USE_GNU		Define GNU extensions.
//    __USE_FORTIFY_LEVEL	Additional security measures used, according to level.
//
//    The macros `__GNU_LIBRARY__', `__GLIBC__', and `__GLIBC_MINOR__' are
//    defined by this file unconditionally.  `__GNU_LIBRARY__' is provided
//    only for compatibility.  All new code should use the other symbols
//    to test for features.
//
//    All macros listed above as possibly being defined by this file are
//    explicitly undefined if they are not explicitly defined.
//    Feature-test macros that are not defined by the user or compiler
//    but are implied by the other feature-test macros defined (or by the
//    lack of any definitions) are defined by the file.
//
//    ISO C feature test macros depend on the definition of the macro
//    when an affected header is included, not when the first system
//    header is included, and so they are handled in
//    <bits/libc-header-start.h>, which does not have a multiple include
//    guard.  Feature test macros that can be handled from the first
//    system header included are handled here.

// Undefine everything, so we get a clean slate.

// Suppress kernel-name space pollution unless user expressedly asks
//    for it.

// Convenience macro to test the version of gcc.
//    Use like this:
//    #if __GNUC_PREREQ (2,8)
//    ... code requiring gcc 2.8 or later ...
//    #endif
//    Note: only works for GCC 2.0 and later, because __GNUC_MINOR__ was
//    added in 2.0.

// Similarly for clang.  Features added to GCC after version 4.2 may
//    or may not also be available in clang, and clang's definitions of
//    __GNUC(_MINOR)__ are fixed at 4 and 2 respectively.  Not all such
//    features can be queried via __has_extension/__has_feature.

// Whether to use feature set F.

// _BSD_SOURCE and _SVID_SOURCE are deprecated aliases for
//    _DEFAULT_SOURCE.  If _DEFAULT_SOURCE is present we do not
//    issue a warning; the expectation is that the source is being
//    transitioned to use the new macro.

// If _GNU_SOURCE was defined by the user, turn on all the other features.

// If nothing (other than _GNU_SOURCE and _DEFAULT_SOURCE) is defined,
//    define _DEFAULT_SOURCE.

// This is to enable the ISO C2X extension.

// This is to enable the ISO C11 extension.

// This is to enable the ISO C99 extension.

// This is to enable the ISO C90 Amendment 1:1995 extension.

// If none of the ANSI/POSIX macros are defined, or if _DEFAULT_SOURCE
//    is defined, use POSIX.1-2008 (or another version depending on
//    _XOPEN_SOURCE).

// Some C libraries once required _REENTRANT and/or _THREAD_SAFE to be
//    defined in all multithreaded code.  GNU libc has not required this
//    for many years.  We now treat them as compatibility synonyms for
//    _POSIX_C_SOURCE=199506L, which is the earliest level of POSIX with
//    comprehensive support for multithreaded code.  Using them never
//    lowers the selected level of POSIX conformance, only raises it.

// Features part to handle 64-bit time_t support.
//    Copyright (C) 2021-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// We need to know the word size in order to check the time size.
// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.
// Bit size of the time_t type at glibc build time, x86-64 and x32 case.
//    Copyright (C) 2018-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.

// For others, time size is word size.

// The function 'gets' existed in C89, but is impossible to use
//    safely.  It has been removed from ISO C11 and ISO C++14.  Note: for
//    compatibility with various implementations of <cstdio>, this test
//    must consider only the value of __cplusplus when compiling C++.

// GNU formerly extended the scanf functions with modified format
//    specifiers %as, %aS, and %a[...] that allocate a buffer for the
//    input using malloc.  This extension conflicts with ISO C99, which
//    defines %a as a standalone format specifier that reads a floating-
//    point number; moreover, POSIX.1-2008 provides the same feature
//    using the modifier letter 'm' instead (%ms, %mS, %m[...]).
//
//    We now follow C99 unless GNU extensions are active and the compiler
//    is specifically in C89 or C++98 mode (strict or not).  For
//    instance, with GCC, -std=gnu11 will have C99-compliant scanf with
//    or without -D_GNU_SOURCE, but -std=c89 -D_GNU_SOURCE will have the
//    old extension.

// Get definitions of __STDC_* predefined macros, if the compiler has
//    not preincluded this header automatically.
// Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// This macro indicates that the installed library is the GNU C Library.
//    For historic reasons the value now is 6 and this will stay from now
//    on.  The use of this variable is deprecated.  Use __GLIBC__ and
//    __GLIBC_MINOR__ now (see below) when you want to test for a specific
//    GNU C library version and use the values in <gnu/lib-names.h> to get
//    the sonames of the shared libraries.

// Major and minor version number of the GNU C library package.  Use
//    these macros to test for features in specific releases.

// This is here only because every header file already includes this one.
// Copyright (C) 1992-2022 Free Software Foundation, Inc.
//    Copyright The GNU Toolchain Authors.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// We are almost always included from features.h.

// The GNU libc does not support any K&R compilers or the traditional mode
//    of ISO C compilers anymore.  Check for some of the combinations not
//    supported anymore.

// Some user header file might have defined this before.

// Compilers that lack __has_attribute may object to
//        #if defined __has_attribute && __has_attribute (...)
//    even though they do not need to evaluate the right-hand side of the &&.
//    Similarly for __has_builtin, etc.

// All functions, except those with callbacks or those that
//    synchronize memory, are leaf functions.

// GCC can always grok prototypes.  For C++ programs we add throw()
//    to help it optimize the function calls.  But this only works with
//    gcc 2.8.x and egcs.  For gcc 3.4 and up we even mark C functions
//    as non-throwing using a function attribute since programs can use
//    the -fexceptions options for C code as well.

// These two macros are not used in glibc anymore.  They are kept here
//    only because some other projects expect the macros to be defined.

// For these things, GCC behaves the ANSI way normally,
//    and the non-ANSI way under -traditional.

// This is not a typedef so `const __ptr_t' does the right thing.

// C++ needs to know that types and declarations are C, not C++.

// Fortify support.

// Use __builtin_dynamic_object_size at _FORTIFY_SOURCE=3 when available.

// Compile time conditions to choose between the regular, _chk and _chk_warn
//    variants.  These conditions should get evaluated to constant and optimized
//    away.

// Length is known to be safe at compile time if the __L * __S <= __OBJSZ
//    condition can be folded to a constant and if it is true.  The -1 check is
//    redundant because since it implies that __glibc_safe_len_cond is true.

// Conversely, we know at compile time that the length is unsafe if the
//    __L * __S <= __OBJSZ condition can be folded to a constant and if it is
//    false.

// Fortify function f.  __f_alias, __f_chk and __f_chk_warn must be
//    declared.

// Fortify function f, where object size argument passed to f is the number of
//    elements and not total size.

// Support for flexible arrays.
//    Headers that should use flexible arrays only if they're "real"
//    (e.g. only if they won't affect sizeof()) should test
//    #if __glibc_c99_flexarr_available.

// __asm__ ("xyz") is used throughout the headers to rename functions
//    at the assembly language level.  This is wrapped by the __REDIRECT
//    macro, in order to support compilers that can do this some other
//    way.  When compilers don't support asm-names at all, we have to do
//    preprocessor tricks instead (which don't have exactly the right
//    semantics, but it's the best we can do).
//
//    Example:
//    int __REDIRECT(setpgrp, (__pid_t pid, __pid_t pgrp), setpgid);

//
// #elif __SOME_OTHER_COMPILER__
//
// # define __REDIRECT(name, proto, alias) name proto; 	_Pragma("let " #name " = " #alias)

// GCC and clang have various useful declarations that can be made with
//    the '__attribute__' syntax.  All of the ways we use this do fine if
//    they are omitted for compilers that don't understand it.

// At some point during the gcc 2.96 development the `malloc' attribute
//    for functions was introduced.  We don't want to use it unconditionally
//    (although this would be possible) since it generates warnings.

// Tell the compiler which arguments to an allocation function
//    indicate the size of the allocation.

// Tell the compiler which argument to an allocation function
//    indicates the alignment of the allocation.

// At some point during the gcc 2.96 development the `pure' attribute
//    for functions was introduced.  We don't want to use it unconditionally
//    (although this would be possible) since it generates warnings.

// This declaration tells the compiler that the value is constant.

// At some point during the gcc 3.1 development the `used' attribute
//    for functions was introduced.  We don't want to use it unconditionally
//    (although this would be possible) since it generates warnings.

// Since version 3.2, gcc allows marking deprecated functions.

// Since version 4.5, gcc also allows one to specify the message printed
//    when a deprecated function is used.  clang claims to be gcc 4.2, but
//    may also support this feature.

// At some point during the gcc 2.8 development the `format_arg' attribute
//    for functions was introduced.  We don't want to use it unconditionally
//    (although this would be possible) since it generates warnings.
//    If several `format_arg' attributes are given for the same function, in
//    gcc-3.0 and older, all but the last one are ignored.  In newer gccs,
//    all designated arguments are considered.

// At some point during the gcc 2.97 development the `strfmon' format
//    attribute for functions was introduced.  We don't want to use it
//    unconditionally (although this would be possible) since it
//    generates warnings.

// The nonnull function attribute marks pointer parameters that
//    must not be NULL.  This has the name __nonnull in glibc,
//    and __attribute_nonnull__ in files shared with Gnulib to avoid
//    collision with a different __nonnull in DragonFlyBSD 5.9.

// The returns_nonnull function attribute marks the return type of the function
//    as always being non-null.

// If fortification mode, we warn about unused results of certain
//    function calls which can lead to problems.

// Forces a function to be always inlined.
// The Linux kernel defines __always_inline in stddef.h (283d7573), and
//    it conflicts with this definition.  Therefore undefine it first to
//    allow either header to be included first.

// Associate error messages with the source location of the call site rather
//    than with the source location inside the function.

// GCC 4.3 and above with -std=c99 or -std=gnu99 implements ISO C99
//    inline semantics, unless -fgnu89-inline is used.  Using __GNUC_STDC_INLINE__
//    or __GNUC_GNU_INLINE is not a good enough check for gcc because gcc versions
//    older than 4.3 may define these macros and still not guarantee GNU inlining
//    semantics.
//
//    clang++ identifies itself as gcc-4.2, but has support for GNU inlining
//    semantics, that can be checked for by using the __GNUC_STDC_INLINE_ and
//    __GNUC_GNU_INLINE__ macro definitions.

// GCC 4.3 and above allow passing all anonymous arguments of an
//    __extern_always_inline function to some other vararg function.

// It is possible to compile containing GCC extensions even if GCC is
//    run in pedantic mode if the uses are carefully marked using the
//    `__extension__' keyword.  But this is not generally available before
//    version 2.8.

// __restrict is known in EGCS 1.2 and above, and in clang.
//    It works also in C++ mode (outside of arrays), but only when spelled
//    as '__restrict', not 'restrict'.

// ISO C99 also allows to declare arrays as non-overlapping.  The syntax is
//      array_name[restrict]
//    GCC 3.1 and clang support this.
//    This syntax is not usable in C++ mode.

// Describes a char array whose address can safely be passed as the first
//    argument to strncpy and strncat, as the char array is not necessarily
//    a NUL-terminated string.

// Undefine (also defined in libc-symbols.h).
// Copies attributes from the declaration or type referenced by
//    the argument.

// Gnulib avoids including these, as they don't work on non-glibc or
//    older glibc platforms.
// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.
// Properties of long double type.  ldbl-96 version.
//    Copyright (C) 2016-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License  published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// long double is distinct from double, so there is nothing to
//    define here.

// __glibc_macro_warning (MESSAGE) issues warning MESSAGE.  This is
//    intended for use in preprocessor macros.
//
//    Note: MESSAGE must be a _single_ string; concatenation of string
//    literals is not supported.

// Generic selection (ISO C11) is a C-only feature, available in GCC
//    since version 4.9.  Previous versions do not provide generic
//    selection, even though they might set __STDC_VERSION__ to 201112L,
//    when in -std=c11 mode.  Thus, we must check for !defined __GNUC__
//    when testing __STDC_VERSION__ for generic selection support.
//    On the other hand, Clang also defines __GNUC__, so a clang-specific
//    check is required to enable the use of generic selection.

// Designates a 1-based positional argument ref-index of pointer type
//    that can be used to access size-index elements of the pointed-to
//    array according to access mode, or at least one element when
//    size-index is not provided:
//      access (access-mode, <ref-index> [, <size-index>])
// For _FORTIFY_SOURCE == 3 we use __builtin_dynamic_object_size, which may
//    use the access attribute to get object sizes from function definition
//    arguments, so we can't use them on functions we fortify.  Drop the object
//    size hints for such functions.

// Designates dealloc as a function to call to deallocate objects
//    allocated by the declared function.

// Specify that a function such as setjmp or vfork may return
//    twice.

// If we don't have __REDIRECT, prototypes will be missing if
//    __USE_FILE_OFFSET64 but not __USE_LARGEFILE[64].

// Decide whether we can define 'extern inline' functions in headers.

// This is here only because every header file already includes this one.
//    Get the definitions of all the appropriate `__stub_FUNCTION' symbols.
//    <gnu/stubs.h> contains `#define __stub_FUNCTION' when FUNCTION is a stub
//    that will always return failure (and set errno to ENOSYS).
// This file is automatically generated.
//    This file selects the right generated file of `__stub_FUNCTION' macros
//    based on the architecture being compiled for.

// This file is automatically generated.
//    It defines a symbol `__stub_FUNCTION' for each function
//    in the C library which is a stub, meaning it will fail
//    every time called, usually setting errno to ENOSYS.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.
// Bit size of the time_t type at glibc build time, x86-64 and x32 case.
//    Copyright (C) 2018-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.

// For others, time size is word size.

// Convenience types.
type T__u_char = uint8   /* types.h:31:23 */
type T__u_short = uint16 /* types.h:32:28 */
type T__u_int = uint32   /* types.h:33:22 */
type T__u_long = uint64  /* types.h:34:27 */

// Fixed-size types, underlying types depend on word size and compiler.
type T__int8_t = int8     /* types.h:37:21 */
type T__uint8_t = uint8   /* types.h:38:23 */
type T__int16_t = int16   /* types.h:39:26 */
type T__uint16_t = uint16 /* types.h:40:28 */
type T__int32_t = int32   /* types.h:41:20 */
type T__uint32_t = uint32 /* types.h:42:22 */
type T__int64_t = int64   /* types.h:44:25 */
type T__uint64_t = uint64 /* types.h:45:27 */

// Smallest types with at least a given width.
type T__int_least8_t = T__int8_t     /* types.h:52:18 */
type T__uint_least8_t = T__uint8_t   /* types.h:53:19 */
type T__int_least16_t = T__int16_t   /* types.h:54:19 */
type T__uint_least16_t = T__uint16_t /* types.h:55:20 */
type T__int_least32_t = T__int32_t   /* types.h:56:19 */
type T__uint_least32_t = T__uint32_t /* types.h:57:20 */
type T__int_least64_t = T__int64_t   /* types.h:58:19 */
type T__uint_least64_t = T__uint64_t /* types.h:59:20 */

// quad_t is also 64 bits.
type T__quad_t = int64    /* types.h:63:18 */
type T__u_quad_t = uint64 /* types.h:64:27 */

// Largest integral types.
type T__intmax_t = int64   /* types.h:72:18 */
type T__uintmax_t = uint64 /* types.h:73:27 */

// The machine-dependent file <bits/typesizes.h> defines __*_T_TYPE
//    macros for each of the OS types we define below.  The definitions
//    of those macros must use the following macros for underlying types.
//    We define __S<SIZE>_TYPE and __U<SIZE>_TYPE for the signed and unsigned
//    variants of each of the following integer types on this machine.
//
// 	16		-- "natural" 16-bit type (always short)
// 	32		-- "natural" 32-bit type (always int)
// 	64		-- "natural" 64-bit type (long or long long)
// 	LONG32		-- 32-bit type, traditionally long
// 	QUAD		-- 64-bit type, traditionally long long
// 	WORD		-- natural type of __WORDSIZE bits (int or long)
// 	LONGWORD	-- type of __WORDSIZE bits, traditionally long
//
//    We distinguish WORD/LONGWORD, 32/LONG32, and 64/QUAD so that the
//    conventional uses of `long' or `long long' type modifiers match the
//    types we define, even when a less-adorned type would be the same size.
//    This matters for (somewhat) portably writing printf/scanf formats for
//    these types, where using the appropriate l or ll format modifiers can
//    make the typedefs and the formats match up across all GNU platforms.  If
//    we used `long' when it's 64 bits where `long long' is expected, then the
//    compiler would warn about the formats not matching the argument types,
//    and the programmer changing them to shut up the compiler would break the
//    program's portability.
//
//    Here we assume what is presently the case in all the GCC configurations
//    we support: long long is always 64 bits, long is always word/address size,
//    and int is always 32 bits.

// No need to mark the typedef with __extension__.
// bits/typesizes.h -- underlying types for *_t.  Linux/x86-64 version.
//    Copyright (C) 2012-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// See <bits/types.h> for the meaning of these macros.  This file exists so
//    that <bits/types.h> need not vary across different GNU platforms.

// X32 kernel interface is 64-bit.

// Tell the libc code that off_t and off64_t are actually the same type
//    for all ABI purposes, even if possibly expressed as different base types
//    for C type-checking purposes.

// Same for ino_t and ino64_t.

// And for __rlim_t and __rlim64_t.

// And for fsblkcnt_t, fsblkcnt64_t, fsfilcnt_t and fsfilcnt64_t.

// And for getitimer, setitimer and rusage

// Number of descriptors that can fit in an `fd_set'.

// bits/time64.h -- underlying types for __time64_t.  Generic version.
//    Copyright (C) 2018-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Define __TIME64_T_TYPE so that it is always a 64-bit type.

// If we already have 64-bit time type then use it.

type T__dev_t = uint64                     /* types.h:145:25 */ // Type of device numbers.
type T__uid_t = uint32                     /* types.h:146:25 */ // Type of user identifications.
type T__gid_t = uint32                     /* types.h:147:25 */ // Type of group identifications.
type T__ino_t = uint64                     /* types.h:148:25 */ // Type of file serial numbers.
type T__ino64_t = uint64                   /* types.h:149:27 */ // Type of file serial numbers (LFS).
type T__mode_t = uint32                    /* types.h:150:26 */ // Type of file attribute bitmasks.
type T__nlink_t = uint64                   /* types.h:151:27 */ // Type of file link counts.
type T__off_t = int64                      /* types.h:152:25 */ // Type of file sizes and offsets.
type T__off64_t = int64                    /* types.h:153:27 */ // Type of file sizes and offsets (LFS).
type T__pid_t = int32                      /* types.h:154:25 */ // Type of process identifications.
type T__fsid_t = struct{ F__val [2]int32 } /* types.h:155:26 */ // Type of file system IDs.
type T__clock_t = int64                    /* types.h:156:27 */ // Type of CPU usage counts.
type T__rlim_t = uint64                    /* types.h:157:26 */ // Type for resource measurement.
type T__rlim64_t = uint64                  /* types.h:158:28 */ // Type for resource measurement (LFS).
type T__id_t = uint32                      /* types.h:159:24 */ // General type for IDs.
type T__time_t = int64                     /* types.h:160:26 */ // Seconds since the Epoch.
type T__useconds_t = uint32                /* types.h:161:30 */ // Count of microseconds.
type T__suseconds_t = int64                /* types.h:162:31 */ // Signed count of microseconds.
type T__suseconds64_t = int64              /* types.h:163:33 */

type T__daddr_t = int32 /* types.h:165:27 */ // The type of a disk address.
type T__key_t = int32   /* types.h:166:25 */ // Type of an IPC key.

// Clock ID used in clock and timer functions.
type T__clockid_t = int32 /* types.h:169:29 */

// Timer ID returned by `timer_create'.
type T__timer_t = uintptr /* types.h:172:12 */

// Type to represent block size.
type T__blksize_t = int64 /* types.h:175:29 */

// Types from the Large File Support interface.

// Type to count number of disk blocks.
type T__blkcnt_t = int64   /* types.h:180:28 */
type T__blkcnt64_t = int64 /* types.h:181:30 */

// Type to count file system blocks.
type T__fsblkcnt_t = uint64   /* types.h:184:30 */
type T__fsblkcnt64_t = uint64 /* types.h:185:32 */

// Type to count file system nodes.
type T__fsfilcnt_t = uint64   /* types.h:188:30 */
type T__fsfilcnt64_t = uint64 /* types.h:189:32 */

// Type of miscellaneous file system fields.
type T__fsword_t = int64 /* types.h:192:28 */

type T__ssize_t = int64 /* types.h:194:27 */ // Type of a byte count, or error.

// Signed long type used in system calls.
type T__syscall_slong_t = int64 /* types.h:197:33 */
// Unsigned long type used in system calls.
type T__syscall_ulong_t = uint64 /* types.h:199:33 */

// These few don't really vary by system, they always correspond
//    to one of the other defined types.
type T__loff_t = T__off64_t /* types.h:203:19 */ // Type of file sizes and offsets (LFS).
type T__caddr_t = uintptr   /* types.h:204:14 */

// Duplicates info from stdint.h but this is used in unistd.h.
type T__intptr_t = int64 /* types.h:207:25 */

// Duplicate info from sys/socket.h.
type T__socklen_t = uint32 /* types.h:210:23 */

// C99: An integer type that can be accessed as an atomic entity,
//    even in the presence of asynchronous interrupts.
//    It is not currently necessary for this to be machine-specific.
type T__sig_atomic_t = int32 /* types.h:215:13 */

// This code is needed for the optimized mapping functions.

// POSIX.1-2008 extended locale interface (see locale.h).
// Definition of locale_t.
//    Copyright (C) 2017-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Definition of struct __locale_struct and __locale_t.
//    Copyright (C) 1997-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// POSIX.1-2008: the locale_t type, representing a locale context
//    (implementation-namespace version).  This type should be treated
//    as opaque by applications; some details are exposed for the sake of
//    efficiency in e.g. ctype functions.

type S__locale_struct = struct {
	F__locales       [13]uintptr
	F__ctype_b       uintptr
	F__ctype_tolower uintptr
	F__ctype_toupper uintptr
	F__names         [13]uintptr
} /* __locale_t.h:27:1 */

type T__locale_t = uintptr /* __locale_t.h:41:32 */

type Tlocale_t = T__locale_t /* locale_t.h:24:20 */

// A null pointer constant.

// Offset of member MEMBER in a struct of type TYPE.

// Type whose alignment is supported in every context and is at least
//    as great as that of any standard type not using alignment
//    specifiers.
type Tmax_align_t = struct {
	F__max_align_ll int64
	F__max_align_ld float64
} /* stddef.h:426:3 */

// Define ISO C stdio on top of C++ iostreams.
//    Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.19 Input/output	<stdio.h>

// Handle feature test macros at the start of a header.
//    Copyright (C) 2016-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// This header is internal to glibc and should not be included outside
//    of glibc headers.  Headers including it must define
//    __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION first.  This header
//    cannot have multiple include guards because ISO C feature test
//    macros depend on the definition of the macro when an affected
//    header is included, not when the first system header is
//    included.

// Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// ISO/IEC TR 24731-2:2010 defines the __STDC_WANT_LIB_EXT2__
//    macro.

// ISO/IEC TS 18661-1:2014 defines the __STDC_WANT_IEC_60559_BFP_EXT__
//    macro.  Most but not all symbols enabled by that macro in TS
//    18661-1 are enabled unconditionally in C2X.  In C2X, the symbols in
//    Annex F still require a new feature test macro
//    __STDC_WANT_IEC_60559_EXT__ instead (C2X does not define
//    __STDC_WANT_IEC_60559_BFP_EXT__), while a few features from TS
//    18661-1 are not included in C2X (and thus should depend on
//    __STDC_WANT_IEC_60559_BFP_EXT__ even when C2X features are
//    enabled).
//
//    __GLIBC_USE (IEC_60559_BFP_EXT) controls those features from TS
//    18661-1 not included in C2X.
//
//    __GLIBC_USE (IEC_60559_BFP_EXT_C2X) controls those features from TS
//    18661-1 that are also included in C2X (with no feature test macro
//    required in C2X).
//
//    __GLIBC_USE (IEC_60559_EXT) controls those features from TS 18661-1
//    that are included in C2X but conditional on
//    __STDC_WANT_IEC_60559_EXT__.  (There are currently no features
//    conditional on __STDC_WANT_IEC_60559_EXT__ that are not in TS
//    18661-1.)

// ISO/IEC TS 18661-4:2015 defines the
//    __STDC_WANT_IEC_60559_FUNCS_EXT__ macro.  Other than the reduction
//    functions, the symbols from this TS are enabled unconditionally in
//    C2X.

// ISO/IEC TS 18661-3:2015 defines the
//    __STDC_WANT_IEC_60559_TYPES_EXT__ macro.

// Copyright (C) 1989-2021 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//    wants us just to define one data type.  So don't define
//    the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//    There's no way to win with the other order!  Sun lossage.

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//    Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//    _TYPE_size_t which will typedef size_t.  fixincludes patched the
//    vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//    not defined, and so that defining this macro defines _GCC_SIZE_T.
//    If we find that the macros are still defined at this point, we must
//    invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//    GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//    __WCHAR_TYPE__ have reasonable values.  This can happen if the
//    parts of GCC is compiled by an older compiler, that actually
//    include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// If this symbol has done its job, get rid of it.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// A null pointer constant.

// Offset of member MEMBER in a struct of type TYPE.

// Copyright (C) 1989-2021 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.15  Variable arguments  <stdarg.h>

// Define __gnuc_va_list.

type T__gnuc_va_list = T__builtin_va_list /* stdarg.h:40:27 */

// Define the standard macros for the user,
//    if this invocation was from the user program.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Integral type unchanged by default argument promotions that can
//    hold any value corresponding to members of the extended character
//    set, as well as at least one value that does not correspond to any
//    member of the extended character set.

// Conversion state information.
type T__mbstate_t = struct {
	F__count int32
	F__value struct{ F__wch uint32 }
} /* __mbstate_t.h:21:3 */

// The tag name of this struct is _G_fpos_t to preserve historic
//    C++ mangled names for functions taking fpos_t arguments.
//    That name should not be used in new code.
type S_G_fpos_t = struct {
	F__pos   T__off_t
	F__state T__mbstate_t
} /* __fpos_t.h:10:9 */

// The tag name of this struct is _G_fpos_t to preserve historic
//    C++ mangled names for functions taking fpos_t arguments.
//    That name should not be used in new code.
type T__fpos_t = S_G_fpos_t /* __fpos_t.h:14:3 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// The tag name of this struct is _G_fpos64_t to preserve historic
//    C++ mangled names for functions taking fpos_t and/or fpos64_t
//    arguments.  That name should not be used in new code.
type S_G_fpos64_t = struct {
	F__pos   T__off64_t
	F__state T__mbstate_t
} /* __fpos64_t.h:10:9 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// The tag name of this struct is _G_fpos64_t to preserve historic
//    C++ mangled names for functions taking fpos_t and/or fpos64_t
//    arguments.  That name should not be used in new code.
type T__fpos64_t = S_G_fpos64_t /* __fpos64_t.h:14:3 */

type S_IO_FILE = struct {
	F_flags          int32
	F__ccgo_pad1     [4]byte
	F_IO_read_ptr    uintptr
	F_IO_read_end    uintptr
	F_IO_read_base   uintptr
	F_IO_write_base  uintptr
	F_IO_write_ptr   uintptr
	F_IO_write_end   uintptr
	F_IO_buf_base    uintptr
	F_IO_buf_end     uintptr
	F_IO_save_base   uintptr
	F_IO_backup_base uintptr
	F_IO_save_end    uintptr
	F_markers        uintptr
	F_chain          uintptr
	F_fileno         int32
	F_flags2         int32
	F_old_offset     T__off_t
	F_cur_column     uint16
	F_vtable_offset  int8
	F_shortbuf       [1]uint8
	F__ccgo_pad2     [4]byte
	F_lock           uintptr
	F_offset         T__off64_t
	F_codecvt        uintptr
	F_wide_data      uintptr
	F_freeres_list   uintptr
	F_freeres_buf    uintptr
	F__pad5          Tsize_t
	F_mode           int32
	F_unused2        [20]uint8
} /* __FILE.h:4:1 */

type T__FILE = S_IO_FILE /* __FILE.h:5:25 */

// The opaque type of streams.  This is the definition used elsewhere.
type TFILE = S_IO_FILE /* FILE.h:7:25 */

// The structure with the cookie function pointers.
//    The tag name of this struct is _IO_cookie_io_functions_t to
//    preserve historic C++ mangled names for functions taking
//    cookie_io_functions_t arguments.  That name should not be used in
//    new code.
type S_IO_cookie_io_functions_t = struct {
	Fread  uintptr
	Fwrite uintptr
	Fseek  uintptr
	Fclose uintptr
} /* cookie_io_functions_t.h:55:9 */

// The structure with the cookie function pointers.
//    The tag name of this struct is _IO_cookie_io_functions_t to
//    preserve historic C++ mangled names for functions taking
//    cookie_io_functions_t arguments.  That name should not be used in
//    new code.
type Tcookie_io_functions_t = S_IO_cookie_io_functions_t /* cookie_io_functions_t.h:61:3 */

type Tva_list = T__gnuc_va_list /* stdio.h:52:24 */

type Toff_t = T__off64_t   /* stdio.h:65:19 */
type Toff64_t = T__off64_t /* stdio.h:70:19 */

type Tssize_t = T__ssize_t /* stdio.h:77:19 */

// The type of the second argument to `fgetpos' and `fsetpos'.
type Tfpos_t = T__fpos64_t   /* stdio.h:86:20 */
type Tfpos64_t = T__fpos64_t /* stdio.h:89:20 */

// If we are compiling with optimizing read this file.  It contains
//    several optimizing inline functions and macros.

// Macros to control TS 18661-3 glibc features on x86.
//    Copyright (C) 2017-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    Copyright The GNU Toolchain Authors.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Handle feature test macros at the start of a header.
//    Copyright (C) 2016-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// This header is internal to glibc and should not be included outside
//    of glibc headers.  Headers including it must define
//    __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION first.  This header
//    cannot have multiple include guards because ISO C feature test
//    macros depend on the definition of the macro when an affected
//    header is included, not when the first system header is
//    included.

// Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// ISO/IEC TR 24731-2:2010 defines the __STDC_WANT_LIB_EXT2__
//    macro.

// ISO/IEC TS 18661-1:2014 defines the __STDC_WANT_IEC_60559_BFP_EXT__
//    macro.  Most but not all symbols enabled by that macro in TS
//    18661-1 are enabled unconditionally in C2X.  In C2X, the symbols in
//    Annex F still require a new feature test macro
//    __STDC_WANT_IEC_60559_EXT__ instead (C2X does not define
//    __STDC_WANT_IEC_60559_BFP_EXT__), while a few features from TS
//    18661-1 are not included in C2X (and thus should depend on
//    __STDC_WANT_IEC_60559_BFP_EXT__ even when C2X features are
//    enabled).
//
//    __GLIBC_USE (IEC_60559_BFP_EXT) controls those features from TS
//    18661-1 not included in C2X.
//
//    __GLIBC_USE (IEC_60559_BFP_EXT_C2X) controls those features from TS
//    18661-1 that are also included in C2X (with no feature test macro
//    required in C2X).
//
//    __GLIBC_USE (IEC_60559_EXT) controls those features from TS 18661-1
//    that are included in C2X but conditional on
//    __STDC_WANT_IEC_60559_EXT__.  (There are currently no features
//    conditional on __STDC_WANT_IEC_60559_EXT__ that are not in TS
//    18661-1.)

// ISO/IEC TS 18661-4:2015 defines the
//    __STDC_WANT_IEC_60559_FUNCS_EXT__ macro.  Other than the reduction
//    functions, the symbols from this TS are enabled unconditionally in
//    C2X.

// ISO/IEC TS 18661-3:2015 defines the
//    __STDC_WANT_IEC_60559_TYPES_EXT__ macro.

// Get size_t, wchar_t and NULL from <stddef.h>.
// Copyright (C) 1989-2021 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//    wants us just to define one data type.  So don't define
//    the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//    There's no way to win with the other order!  Sun lossage.

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//    Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//    _TYPE_size_t which will typedef size_t.  fixincludes patched the
//    vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//    not defined, and so that defining this macro defines _GCC_SIZE_T.
//    If we find that the macros are still defined at this point, we must
//    invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//    GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//    __WCHAR_TYPE__ have reasonable values.  This can happen if the
//    parts of GCC is compiled by an older compiler, that actually
//    include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// If this symbol has done its job, get rid of it.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// A null pointer constant.

// Offset of member MEMBER in a struct of type TYPE.

// XPG requires a few symbols from <sys/wait.h> being defined.
// Definitions of flag bits for `waitpid' et al.
//    Copyright (C) 1992-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Bits in the third argument to `waitpid'.

// Bits in the fourth argument to `waitid'.

// Definitions of status bits for `wait' et al.
//    Copyright (C) 1992-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Everything extant so far uses these same bits.

// If WIFEXITED(STATUS), the low-order 8 bits of the status.

// If WIFSIGNALED(STATUS), the terminating signal.

// If WIFSTOPPED(STATUS), the signal that stopped the child.

// Nonzero if STATUS indicates normal termination.

// Nonzero if STATUS indicates termination by a signal.

// Nonzero if STATUS indicates the child is stopped.

// Nonzero if STATUS indicates the child continued after a stop.  We only
//    define this if <bits/waitflags.h> provides the WCONTINUED flag bit.

// Nonzero if STATUS indicates the child dumped core.

// Macros for constructing status values.

// Define the macros <sys/wait.h> also would define this way.

// _FloatN API tests for enablement.
// Macros to control TS 18661-3 glibc features on x86.
//    Copyright (C) 2017-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Returned by `div'.
type Tdiv_t = struct {
	Fquot int32
	Frem  int32
} /* stdlib.h:63:5 */

// Returned by `ldiv'.
type Tldiv_t = struct {
	Fquot int64
	Frem  int64
} /* stdlib.h:71:5 */

// Returned by `lldiv'.
type Tlldiv_t = struct {
	Fquot int64
	Frem  int64
} /* stdlib.h:81:5 */

// Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>

// Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

type Tu_char = T__u_char     /* types.h:33:18 */
type Tu_short = T__u_short   /* types.h:34:19 */
type Tu_int = T__u_int       /* types.h:35:17 */
type Tu_long = T__u_long     /* types.h:36:18 */
type Tquad_t = T__quad_t     /* types.h:37:18 */
type Tu_quad_t = T__u_quad_t /* types.h:38:20 */
type Tfsid_t = T__fsid_t     /* types.h:39:18 */
type Tloff_t = T__loff_t     /* types.h:42:18 */

type Tino_t = T__ino64_t   /* types.h:49:19 */
type Tino64_t = T__ino64_t /* types.h:54:19 */

type Tdev_t = T__dev_t /* types.h:59:17 */

type Tgid_t = T__gid_t /* types.h:64:17 */

type Tmode_t = T__mode_t /* types.h:69:18 */

type Tnlink_t = T__nlink_t /* types.h:74:19 */

type Tuid_t = T__uid_t /* types.h:79:17 */

type Tpid_t = T__pid_t /* types.h:97:17 */

type Tid_t = T__id_t /* types.h:103:16 */

type Tdaddr_t = T__daddr_t /* types.h:114:19 */
type Tcaddr_t = T__caddr_t /* types.h:115:19 */

type Tkey_t = T__key_t /* types.h:121:17 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Returned by `clock'.
type Tclock_t = T__clock_t /* clock_t.h:7:19 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Clock ID used in clock and timer functions.
type Tclockid_t = T__clockid_t /* clockid_t.h:7:21 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Returned by `time'.
type Ttime_t = T__time_t /* time_t.h:10:18 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Timer ID returned by `timer_create'.
type Ttimer_t = T__timer_t /* timer_t.h:7:19 */

type Tuseconds_t = T__useconds_t   /* types.h:134:22 */
type Tsuseconds_t = T__suseconds_t /* types.h:138:23 */

// Copyright (C) 1989-2021 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//    wants us just to define one data type.  So don't define
//    the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//    There's no way to win with the other order!  Sun lossage.

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//    Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//    _TYPE_size_t which will typedef size_t.  fixincludes patched the
//    vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//    not defined, and so that defining this macro defines _GCC_SIZE_T.
//    If we find that the macros are still defined at this point, we must
//    invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//    GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//    __WCHAR_TYPE__ have reasonable values.  This can happen if the
//    parts of GCC is compiled by an older compiler, that actually
//    include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// If this symbol has done its job, get rid of it.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// A null pointer constant.

// Offset of member MEMBER in a struct of type TYPE.

// Old compatibility names for C types.
type Tulong = uint64  /* types.h:148:27 */
type Tushort = uint16 /* types.h:149:28 */
type Tuint = uint32   /* types.h:150:22 */

// These size-specific names are used by some of the inet code.

// Define intN_t types.
//    Copyright (C) 2017-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

type Tint8_t = T__int8_t   /* stdint-intn.h:24:18 */
type Tint16_t = T__int16_t /* stdint-intn.h:25:19 */
type Tint32_t = T__int32_t /* stdint-intn.h:26:19 */
type Tint64_t = T__int64_t /* stdint-intn.h:27:19 */

// These were defined by ISO C without the first `_'.
type Tu_int8_t = T__uint8_t   /* types.h:158:19 */
type Tu_int16_t = T__uint16_t /* types.h:159:20 */
type Tu_int32_t = T__uint32_t /* types.h:160:20 */
type Tu_int64_t = T__uint64_t /* types.h:161:20 */

type Tregister_t = int32 /* types.h:164:13 */

// It also defines `fd_set' and the FD_* macros for `select'.
// `fd_set' type and related macros, and `select'/`pselect' declarations.
//    Copyright (C) 1996-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	POSIX 1003.1g: 6.2 Select from File Descriptor Sets <sys/select.h>

// Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Get definition of needed basic types.
// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Get __FD_* definitions.
// Copyright (C) 1997-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// We don't use `memset' because this would require a prototype and
//    the array isn't too big.

// Get sigset_t.

type T__sigset_t = struct{ F__val [16]uint64 } /* __sigset_t.h:8:3 */

// A set of signals to be blocked, unblocked, or waited for.
type Tsigset_t = T__sigset_t /* sigset_t.h:7:20 */

// Get definition of timer specification structures.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// A time value that is accurate to the nearest
//    microsecond but also has a range of years.
type Stimeval = struct {
	Ftv_sec  T__time_t
	Ftv_usec T__suseconds_t
} /* struct_timeval.h:8:1 */

// NB: Include guard matches what <linux/time.h> uses.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Endian macros for string.h functions
//    Copyright (C) 1992-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// POSIX.1b structure for a time value.  This is like a `struct timeval' but
//    has nanoseconds instead of microseconds.
type Stimespec = struct {
	Ftv_sec  T__time_t
	Ftv_nsec T__syscall_slong_t
} /* struct_timespec.h:11:1 */

// The fd_set member is required to be an array of longs.
type T__fd_mask = int64 /* select.h:49:18 */

// Some versions of <linux/posix_types.h> define this macros.
// It's easier to assume 8-bit bytes than to get CHAR_BIT.

// fd_set for select and pselect.
type Tfd_set = struct{ Ffds_bits [16]T__fd_mask } /* select.h:70:5 */

// Maximum number of file descriptors in `fd_set'.

// Sometimes the fd_set member is assumed to have this type.
type Tfd_mask = T__fd_mask /* select.h:77:19 */

// Define some inlines helping to catch common problems.

type Tblksize_t = T__blksize_t /* types.h:185:21 */

// Types from the Large File Support interface.
type Tblkcnt_t = T__blkcnt64_t     /* types.h:205:22 */ // Type to count number of disk blocks.
type Tfsblkcnt_t = T__fsblkcnt64_t /* types.h:209:24 */ // Type to count file system blocks.
type Tfsfilcnt_t = T__fsfilcnt64_t /* types.h:213:24 */ // Type to count file system inodes.

type Tblkcnt64_t = T__blkcnt64_t     /* types.h:219:22 */ // Type to count number of disk blocks.
type Tfsblkcnt64_t = T__fsblkcnt64_t /* types.h:220:24 */ // Type to count file system blocks.
type Tfsfilcnt64_t = T__fsfilcnt64_t /* types.h:221:24 */ // Type to count file system inodes.

// Now add the thread types.
// Declaration of common pthread types for all architectures.
//    Copyright (C) 2017-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// For internal mutex and condition variable definitions.
// Common threading primitives definitions for both POSIX and C11.
//    Copyright (C) 2017-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Arch-specific definitions.  Each architecture must define the following
//    macros to define the expected sizes of pthread data types:
//
//    __SIZEOF_PTHREAD_ATTR_T        - size of pthread_attr_t.
//    __SIZEOF_PTHREAD_MUTEX_T       - size of pthread_mutex_t.
//    __SIZEOF_PTHREAD_MUTEXATTR_T   - size of pthread_mutexattr_t.
//    __SIZEOF_PTHREAD_COND_T        - size of pthread_cond_t.
//    __SIZEOF_PTHREAD_CONDATTR_T    - size of pthread_condattr_t.
//    __SIZEOF_PTHREAD_RWLOCK_T      - size of pthread_rwlock_t.
//    __SIZEOF_PTHREAD_RWLOCKATTR_T  - size of pthread_rwlockattr_t.
//    __SIZEOF_PTHREAD_BARRIER_T     - size of pthread_barrier_t.
//    __SIZEOF_PTHREAD_BARRIERATTR_T - size of pthread_barrierattr_t.
//
//    The additional macro defines any constraint for the lock alignment
//    inside the thread structures:
//
//    __LOCK_ALIGNMENT - for internal lock/futex usage.
//
//    Same idea but for the once locking primitive:
//
//    __ONCE_ALIGNMENT - for pthread_once_t/once_flag definition.

// Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.

// Monotonically increasing wide counters (at least 62 bits).
//    Copyright (C) 2016-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Counter that is monotonically increasing (by less than 2**31 per
//    increment), with a single writer, and an arbitrary number of
//    readers.
type T__atomic_wide_counter = struct{ F__value64 uint64 } /* atomic_wide_counter.h:33:3 */

// Common definition of pthread_mutex_t.

type S__pthread_internal_list = struct {
	F__prev uintptr
	F__next uintptr
} /* thread-shared-types.h:51:9 */

// Common definition of pthread_mutex_t.

type T__pthread_list_t = S__pthread_internal_list /* thread-shared-types.h:55:3 */

type S__pthread_internal_slist = struct{ F__next uintptr } /* thread-shared-types.h:57:9 */

type T__pthread_slist_t = S__pthread_internal_slist /* thread-shared-types.h:60:3 */

// Arch-specific mutex definitions.  A generic implementation is provided
//    by sysdeps/nptl/bits/struct_mutex.h.  If required, an architecture
//    can override it by defining:
//
//    1. struct __pthread_mutex_s (used on both pthread_mutex_t and mtx_t
//       definition).  It should contains at least the internal members
//       defined in the generic version.
//
//    2. __LOCK_ALIGNMENT for any extra attribute for internal lock used with
//       atomic operations.
//
//    3. The macro __PTHREAD_MUTEX_INITIALIZER used for static initialization.
//       It should initialize the mutex internal flag.

// x86 internal mutex struct definitions.
//    Copyright (C) 2019-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

type S__pthread_mutex_s = struct {
	F__lock    int32
	F__count   uint32
	F__owner   int32
	F__nusers  uint32
	F__kind    int32
	F__spins   int16
	F__elision int16
	F__list    T__pthread_list_t
} /* struct_mutex.h:22:1 */

// Arch-sepecific read-write lock definitions.  A generic implementation is
//    provided by struct_rwlock.h.  If required, an architecture can override it
//    by defining:
//
//    1. struct __pthread_rwlock_arch_t (used on pthread_rwlock_t definition).
//       It should contain at least the internal members defined in the
//       generic version.
//
//    2. The macro __PTHREAD_RWLOCK_INITIALIZER used for static initialization.
//       It should initialize the rwlock internal type.

// x86 internal rwlock struct definitions.
//    Copyright (C) 2019-2022 Free Software Foundation, Inc.
//
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

type S__pthread_rwlock_arch_t = struct {
	F__readers       uint32
	F__writers       uint32
	F__wrphase_futex uint32
	F__writers_futex uint32
	F__pad3          uint32
	F__pad4          uint32
	F__cur_writer    int32
	F__shared        int32
	F__rwelision     int8
	F__pad1          [7]uint8
	F__pad2          uint64
	F__flags         uint32
	F__ccgo_pad1     [4]byte
} /* struct_rwlock.h:23:1 */

// Common definition of pthread_cond_t.

type S__pthread_cond_s = struct {
	F__wseq         T__atomic_wide_counter
	F__g1_start     T__atomic_wide_counter
	F__g_refs       [2]uint32
	F__g_size       [2]uint32
	F__g1_orig_size uint32
	F__wrefs        uint32
	F__g_signals    [2]uint32
} /* thread-shared-types.h:94:1 */

type T__tss_t = uint32  /* thread-shared-types.h:105:22 */
type T__thrd_t = uint64 /* thread-shared-types.h:106:27 */

type T__once_flag = struct{ F__data int32 } /* thread-shared-types.h:111:3 */

// Thread identifiers.  The structure of the attribute type is not
//    exposed on purpose.
type Tpthread_t = uint64 /* pthreadtypes.h:27:27 */

// Data structures for mutex handling.  The structure of the attribute
//    type is not exposed on purpose.
type Tpthread_mutexattr_t = struct {
	F__ccgo_pad1 [0]uint32
	F__size      [4]uint8
} /* pthreadtypes.h:36:3 */

// Data structure for condition variable handling.  The structure of
//    the attribute type is not exposed on purpose.
type Tpthread_condattr_t = struct {
	F__ccgo_pad1 [0]uint32
	F__size      [4]uint8
} /* pthreadtypes.h:45:3 */

// Keys for thread-specific data
type Tpthread_key_t = uint32 /* pthreadtypes.h:49:22 */

// Once-only execution
type Tpthread_once_t = int32 /* pthreadtypes.h:53:30 */

type Spthread_attr_t = struct {
	F__ccgo_pad1 [0]uint64
	F__size      [56]uint8
} /* pthreadtypes.h:56:1 */

type Tpthread_attr_t = Spthread_attr_t /* pthreadtypes.h:62:30 */

type Tpthread_mutex_t = struct{ F__data S__pthread_mutex_s } /* pthreadtypes.h:72:3 */

type Tpthread_cond_t = struct{ F__data S__pthread_cond_s } /* pthreadtypes.h:80:3 */

// Data structure for reader-writer lock variable handling.  The
//    structure of the attribute type is deliberately not exposed.
type Tpthread_rwlock_t = struct{ F__data S__pthread_rwlock_arch_t } /* pthreadtypes.h:91:3 */

type Tpthread_rwlockattr_t = struct {
	F__ccgo_pad1 [0]uint64
	F__size      [8]uint8
} /* pthreadtypes.h:97:3 */

// POSIX spinlock data type.
type Tpthread_spinlock_t = int32 /* pthreadtypes.h:103:22 */

// POSIX barriers data type.  The structure of the type is
//    deliberately not exposed.
type Tpthread_barrier_t = struct {
	F__ccgo_pad1 [0]uint64
	F__size      [32]uint8
} /* pthreadtypes.h:112:3 */

type Tpthread_barrierattr_t = struct {
	F__ccgo_pad1 [0]uint32
	F__size      [4]uint8
} /* pthreadtypes.h:118:3 */

// Reentrant versions of the `random' family of functions.
//    These functions all use the following data structure to contain
//    state, rather than global state variables.

type Srandom_data = struct {
	Ffptr        uintptr
	Frptr        uintptr
	Fstate       uintptr
	Frand_type   int32
	Frand_deg    int32
	Frand_sep    int32
	F__ccgo_pad1 [4]byte
	Fend_ptr     uintptr
} /* stdlib.h:424:1 */

// Data structure for communication with thread safe versions.  This
//    type is to be regarded as opaque.  It's only exported because users
//    have to allocate objects of this type.
type Sdrand48_data = struct {
	F__x     [3]uint16
	F__old_x [3]uint16
	F__c     uint16
	F__init  uint16
	F__a     uint64
} /* stdlib.h:491:1 */

// Shorthand for type of comparison functions.
type T__compar_fn_t = uintptr /* stdlib.h:816:13 */

type Tcomparison_fn_t = T__compar_fn_t /* stdlib.h:819:23 */
type T__compar_d_fn_t = uintptr        /* stdlib.h:823:13 */

// Macros to make boolean values more obvious. The #ifndef is to pacify
// compiler warnings in environments where these macros are defined elsewhere.
// Unfortunately, there is no way to do the same for the typedef.

type TBOOL = int32 /* pcre2_internal.h:67:13 */

// Valgrind (memcheck) support

// -ftrivial-auto-var-init support supports initializing all local variables
// to avoid some classes of bug, but this can cause an unacceptable slowdown
// for large on-stack arrays in hot functions. This macro lets us annotate
// such arrays.

// Older versions of MSVC lack snprintf(). This define allows for
// warning/error-free compilation and testing with MSVC compilers back to at least
// MSVC 10/2010. Except for VC6 (which is missing some fundamentals and fails).

// When compiling a DLL for Windows, the exported symbols have to be declared
// using some MS magic. I found some useful information on this web page:
// http://msdn2.microsoft.com/en-us/library/y4h7bcy6(VS.80).aspx. According to the
// information there, using __declspec(dllexport) without "extern" we have a
// definition; with "extern" we have a declaration. The settings here override the
// setting in pcre2.h (which is included below); it defines only PCRE2_EXP_DECL,
// which is all that is needed for applications (they just import the symbols). We
// use:
//
//   PCRE2_EXP_DECL    for declarations
//   PCRE2_EXP_DEFN    for definitions
//
// The reason for wrapping this in #ifndef PCRE2_EXP_DECL is so that pcre2test,
// which is an application, but needs to import this file in order to "peek" at
// internals, can #include pcre2.h first to get an application's-eye view.
//
// In principle, people compiling for non-Windows, non-Unix-like (i.e. uncommon,
// special-purpose environments) might want to stick other stuff in front of
// exported symbols. That's why, in the non-Windows case, we set PCRE2_EXP_DEFN
// only if it is not already set.

// Include the public PCRE2 header and the definitions of UCP character
// property values. This must follow the setting of PCRE2_EXP_DECL above.

// ************************************************
//
//       Perl-Compatible Regular Expressions      *
//

// This is the public header file for the PCRE library, second API, to be
// #included by applications that call PCRE2 functions.
//
//            Copyright (c) 2016-2021 University of Cambridge
//
// -----------------------------------------------------------------------------
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//
//     * Neither the name of the University of Cambridge nor the names of its
//       contributors may be used to endorse or promote products derived from
//       this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
// -----------------------------------------------------------------------------

// The current PCRE version information.

// When an application links to a PCRE DLL in Windows, the symbols that are
// imported have to be identified as such. When building PCRE2, the appropriate
// export setting is defined in pcre2_internal.h, which includes this file. So we
// don't change existing definitions of PCRE2_EXP_DECL.

// By default, we use the standard "extern" declarations.

// When compiling with the MSVC compiler, it is sometimes necessary to include
// a "calling convention" before exported function names. (This is secondhand
// information; I know nothing about MSVC myself). For example, something like
//
//   void __cdecl function(....)
//
// might be needed. In order so make this easy, all the exported functions have
// PCRE2_CALL_CONVENTION just before their names. It is rarely needed; if not
// set, we ensure here that it has no effect.

// Have to include limits.h, stdlib.h, and inttypes.h to ensure that size_t and
// uint8_t, UCHAR_MAX, etc are defined. Some systems that do have inttypes.h do
// not have stdint.h, which is why we use inttypes.h, which according to the C
// standard is a superset of stdint.h. If inttypes.h is not available the build
// will break and the relevant values must be provided by some other means.

// Copyright (C) 1992-2021 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 3, or (at your option) any later
// version.
//
// GCC is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// This administrivia gets added to the beginning of limits.h
//    if the system has its own version of limits.h.

// We use _GCC_LIMITS_H_ because we want this not to match
//    any macros that the system's limits.h uses for its own purposes.

// Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    Copyright The GNU Toolchain Authors.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Copyright (C) 1997-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99: 7.8 Format conversion of integer types	<inttypes.h>

// Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Get the type definitions.
// Copyright (C) 1997-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99: 7.18 Integer types <stdint.h>

// Handle feature test macros at the start of a header.
//    Copyright (C) 2016-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// This header is internal to glibc and should not be included outside
//    of glibc headers.  Headers including it must define
//    __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION first.  This header
//    cannot have multiple include guards because ISO C feature test
//    macros depend on the definition of the macro when an affected
//    header is included, not when the first system header is
//    included.

// Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// ISO/IEC TR 24731-2:2010 defines the __STDC_WANT_LIB_EXT2__
//    macro.

// ISO/IEC TS 18661-1:2014 defines the __STDC_WANT_IEC_60559_BFP_EXT__
//    macro.  Most but not all symbols enabled by that macro in TS
//    18661-1 are enabled unconditionally in C2X.  In C2X, the symbols in
//    Annex F still require a new feature test macro
//    __STDC_WANT_IEC_60559_EXT__ instead (C2X does not define
//    __STDC_WANT_IEC_60559_BFP_EXT__), while a few features from TS
//    18661-1 are not included in C2X (and thus should depend on
//    __STDC_WANT_IEC_60559_BFP_EXT__ even when C2X features are
//    enabled).
//
//    __GLIBC_USE (IEC_60559_BFP_EXT) controls those features from TS
//    18661-1 not included in C2X.
//
//    __GLIBC_USE (IEC_60559_BFP_EXT_C2X) controls those features from TS
//    18661-1 that are also included in C2X (with no feature test macro
//    required in C2X).
//
//    __GLIBC_USE (IEC_60559_EXT) controls those features from TS 18661-1
//    that are included in C2X but conditional on
//    __STDC_WANT_IEC_60559_EXT__.  (There are currently no features
//    conditional on __STDC_WANT_IEC_60559_EXT__ that are not in TS
//    18661-1.)

// ISO/IEC TS 18661-4:2015 defines the
//    __STDC_WANT_IEC_60559_FUNCS_EXT__ macro.  Other than the reduction
//    functions, the symbols from this TS are enabled unconditionally in
//    C2X.

// ISO/IEC TS 18661-3:2015 defines the
//    __STDC_WANT_IEC_60559_TYPES_EXT__ macro.
// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// wchar_t type related definitions.
//    Copyright (C) 2000-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// The fallback definitions, for when __WCHAR_MAX__ or __WCHAR_MIN__
//    are not defined, give the right value and type as long as both int
//    and wchar_t are 32-bit types.  Adding L'\0' to a constant value
//    ensures that the type is correct; it is necessary to use (L'\0' +
//    0) rather than just L'\0' so that the type in C++ is the promoted
//    version of wchar_t rather than the distinct wchar_t type itself.
//    Because wchar_t in preprocessor #if expressions is treated as
//    intmax_t or uintmax_t, the expression (L'\0' - 1) would have the
//    wrong value for WCHAR_MAX in such expressions and so cannot be used
//    to define __WCHAR_MAX in the unsigned case.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.

// Exact integral types.

// Signed.
// Define intN_t types.
//    Copyright (C) 2017-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Unsigned.
// Define uintN_t types.
//    Copyright (C) 2017-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

type Tuint8_t = T__uint8_t   /* stdint-uintn.h:24:19 */
type Tuint16_t = T__uint16_t /* stdint-uintn.h:25:20 */
type Tuint32_t = T__uint32_t /* stdint-uintn.h:26:20 */
type Tuint64_t = T__uint64_t /* stdint-uintn.h:27:20 */

// Small types.

// Signed.
type Tint_least8_t = T__int_least8_t   /* stdint.h:43:24 */
type Tint_least16_t = T__int_least16_t /* stdint.h:44:25 */
type Tint_least32_t = T__int_least32_t /* stdint.h:45:25 */
type Tint_least64_t = T__int_least64_t /* stdint.h:46:25 */

// Unsigned.
type Tuint_least8_t = T__uint_least8_t   /* stdint.h:49:25 */
type Tuint_least16_t = T__uint_least16_t /* stdint.h:50:26 */
type Tuint_least32_t = T__uint_least32_t /* stdint.h:51:26 */
type Tuint_least64_t = T__uint_least64_t /* stdint.h:52:26 */

// Fast types.

// Signed.
type Tint_fast8_t = int8   /* stdint.h:58:22 */
type Tint_fast16_t = int64 /* stdint.h:60:19 */
type Tint_fast32_t = int64 /* stdint.h:61:19 */
type Tint_fast64_t = int64 /* stdint.h:62:19 */

// Unsigned.
type Tuint_fast8_t = uint8   /* stdint.h:71:24 */
type Tuint_fast16_t = uint64 /* stdint.h:73:27 */
type Tuint_fast32_t = uint64 /* stdint.h:74:27 */
type Tuint_fast64_t = uint64 /* stdint.h:75:27 */

// Types for `void *' pointers.
type Tintptr_t = int64   /* stdint.h:87:19 */
type Tuintptr_t = uint64 /* stdint.h:90:27 */

// Largest integral types.
type Tintmax_t = T__intmax_t   /* stdint.h:101:21 */
type Tuintmax_t = T__uintmax_t /* stdint.h:102:22 */

// Limits of integral types.

// Minimum of signed integral types.
// Maximum of signed integral types.

// Maximum of unsigned integral types.

// Minimum of signed integral types having a minimum size.
// Maximum of signed integral types having a minimum size.

// Maximum of unsigned integral types having a minimum size.

// Minimum of fast signed integral types having a minimum size.
// Maximum of fast signed integral types having a minimum size.

// Maximum of fast unsigned integral types having a minimum size.

// Values to test for integral types holding `void *' pointer.

// Minimum for largest signed integral type.
// Maximum for largest signed integral type.

// Maximum for largest unsigned integral type.

// Limits of other integer types.

// Limits of `ptrdiff_t' type.

// Limits of `sig_atomic_t'.

// Limit of `size_t' type.

// Limits of `wchar_t'.
// These constants might also be defined in <wchar.h>.

// Limits of `wint_t'.

// Signed.

// Unsigned.

// Maximal type.

// Get a definition for wchar_t.  But we must not define wchar_t itself.
type T__gwchar_t = int32 /* inttypes.h:34:24 */

// Macros for printing format specifiers.

// Decimal notation.

// Octal notation.

// Unsigned integers.

// lowercase hexadecimal notation.

// UPPERCASE hexadecimal notation.

// Macros for printing `intmax_t' and `uintmax_t'.

// Macros for printing `intptr_t' and `uintptr_t'.

// Macros for scanning format specifiers.

// Signed decimal notation.

// Signed decimal notation.

// Unsigned decimal notation.

// Octal notation.

// Hexadecimal notation.

// Macros for scanning `intmax_t' and `uintmax_t'.

// Macros for scaning `intptr_t' and `uintptr_t'.

// We have to define the `uintmax_t' type using `ldiv_t'.
type Timaxdiv_t = struct {
	Fquot int64
	Frem  int64
} /* inttypes.h:275:5 */

// Allow for C++ users compiling this directly.

// The following option bits can be passed to pcre2_compile(), pcre2_match(),
// or pcre2_dfa_match(). PCRE2_NO_UTF_CHECK affects only the function to which it
// is passed. Put these bits at the most significant end of the options word so
// others can be added next to them

// The following option bits can be passed only to pcre2_compile(). However,
// they may affect compilation, JIT compilation, and/or interpretive execution.
// The following tags indicate which:
//
// C   alters what is compiled by pcre2_compile()
// J   alters what is compiled by pcre2_jit_compile()
// M   is inspected during pcre2_match() execution
// D   is inspected during pcre2_dfa_match() execution

// An additional compile options word is available in the compile context.

// These are for pcre2_jit_compile().

// These are for pcre2_match(), pcre2_dfa_match(), pcre2_jit_match(), and
// pcre2_substitute(). Some are allowed only for one of the functions, and in
// these cases it is noted below. Note that PCRE2_ANCHORED, PCRE2_ENDANCHORED and
// PCRE2_NO_UTF_CHECK can also be passed to these functions (though
// pcre2_jit_match() ignores the latter since it bypasses all sanity checks).

// Options for pcre2_pattern_convert().

// Newline and \R settings, for use in compile contexts. The newline values
// must be kept in step with values set in config.h and both sets must all be
// greater than zero.

// Error codes for pcre2_compile(). Some of these are also used by
// pcre2_pattern_convert().

// Error 159 is obsolete and should now never occur

// "Expected" matching error codes: no match and partial match.

// Error codes for UTF-8 validity checks

// Error codes for UTF-16 validity checks

// Error codes for UTF-32 validity checks

// Miscellaneous error codes for pcre2[_dfa]_match(), substring extraction
// functions, context functions, and serializing functions. They are in numerical
// order. Originally they were in alphabetical order too, but now that PCRE2 is
// released, the numbers must not be changed.

// Request types for pcre2_pattern_info()

// Request types for pcre2_config().

// Types for code units in patterns and subject strings.

type TPCRE2_UCHAR8 = Tuint8_t   /* pcre2.h:458:18 */
type TPCRE2_UCHAR16 = Tuint16_t /* pcre2.h:459:18 */
type TPCRE2_UCHAR32 = Tuint32_t /* pcre2.h:460:18 */

type TPCRE2_SPTR8 = uintptr  /* pcre2.h:462:29 */
type TPCRE2_SPTR16 = uintptr /* pcre2.h:463:29 */
type TPCRE2_SPTR32 = uintptr /* pcre2.h:464:29 */

// The PCRE2_SIZE type is used for all string lengths and offsets in PCRE2,
// including pattern offsets for errors and subject offsets after a match. We
// define special values to indicate zero-terminated strings and unset offsets in
// the offset vector (ovector).

// Generic types for opaque structures and JIT callback functions. These
// declarations are defined in a macro that is expanded for each width later.

// The structures for passing out data via callout functions. We use structures
// so that new fields can be added on the end in future versions, without changing
// the API of the function, thereby allowing old clients to work without
// modification. Define the generic versions in a macro; the width-specific
// versions are generated from this macro below.

// Flags for the callout_flags field. These are cleared after a callout.

// List the generic forms of all other functions in macros, which will be
// expanded for each width below. Start with functions that give general
// information.

// Functions for manipulating contexts.

// Functions concerned with compiling a pattern to PCRE internal code.

// Functions that give information about a compiled pattern.

// Functions for running a match and inspecting the result.

// Convenience functions for handling matched substrings.

// Functions for serializing / deserializing compiled patterns.

// Convenience function for match + substitute.

// Functions for converting pattern source strings.

// Functions for JIT processing

// Other miscellaneous functions.

// Define macros that generate width-specific names from generic versions. The
// three-level macro scheme is necessary to get the macros expanded when we want
// them to be. First we get the width from PCRE2_LOCAL_WIDTH, which is used for
// generating three versions of everything below. After that, PCRE2_SUFFIX will be
// re-defined to use PCRE2_CODE_UNIT_WIDTH, for use when macros such as
// pcre2_compile are called by application code.

// Data types

// Data blocks

// Functions: the complete list in alphabetical order

// Keep this old function name for backwards compatibility

// Keep this obsolete function for backwards compatibility: it is now a noop.

// Now generate all three sets of width-specific structures and function
// prototypes.

type Spcre2_real_general_context_8 = struct{ Fmemctl Tpcre2_memctl } /* pcre2.h:935:1 */

type Tpcre2_general_context_8 = Spcre2_real_general_context_8 /* pcre2.h:935:1 */
type Spcre2_real_compile_context_8 = struct {
	Fmemctl             Tpcre2_memctl
	Fstack_guard        uintptr
	Fstack_guard_data   uintptr
	Ftables             uintptr
	Fmax_pattern_length Tsize_t
	Fbsr_convention     Tuint16_t
	Fnewline_convention Tuint16_t
	Fparens_nest_limit  Tuint32_t
	Fextra_options      Tuint32_t
	F__ccgo_pad1        [4]byte
} /* pcre2.h:935:1 */

type Tpcre2_compile_context_8 = Spcre2_real_compile_context_8 /* pcre2.h:935:1 */
type Spcre2_real_match_context_8 = struct {
	Fmemctl                  Tpcre2_memctl
	Fcallout                 uintptr
	Fcallout_data            uintptr
	Fsubstitute_callout      uintptr
	Fsubstitute_callout_data uintptr
	Foffset_limit            Tsize_t
	Fheap_limit              Tuint32_t
	Fmatch_limit             Tuint32_t
	Fdepth_limit             Tuint32_t
	F__ccgo_pad1             [4]byte
} /* pcre2.h:935:1 */

type Tpcre2_match_context_8 = Spcre2_real_match_context_8 /* pcre2.h:935:1 */
type Spcre2_real_convert_context_8 = struct {
	Fmemctl         Tpcre2_memctl
	Fglob_separator Tuint32_t
	Fglob_escape    Tuint32_t
} /* pcre2.h:935:1 */

type Tpcre2_convert_context_8 = Spcre2_real_convert_context_8 /* pcre2.h:935:1 */
type Spcre2_real_code_8 = struct {
	Fmemctl             Tpcre2_memctl
	Ftables             uintptr
	Fexecutable_jit     uintptr
	Fstart_bitmap       [32]Tuint8_t
	Fblocksize          Tsize_t
	Fmagic_number       Tuint32_t
	Fcompile_options    Tuint32_t
	Foverall_options    Tuint32_t
	Fextra_options      Tuint32_t
	Fflags              Tuint32_t
	Flimit_heap         Tuint32_t
	Flimit_match        Tuint32_t
	Flimit_depth        Tuint32_t
	Ffirst_codeunit     Tuint32_t
	Flast_codeunit      Tuint32_t
	Fbsr_convention     Tuint16_t
	Fnewline_convention Tuint16_t
	Fmax_lookbehind     Tuint16_t
	Fminlength          Tuint16_t
	Ftop_bracket        Tuint16_t
	Ftop_backref        Tuint16_t
	Fname_entry_size    Tuint16_t
	Fname_count         Tuint16_t
} /* pcre2.h:935:1 */

type Tpcre2_code_8 = Spcre2_real_code_8 /* pcre2.h:935:1 */
type Spcre2_real_match_data_8 = struct {
	Fmemctl    Tpcre2_memctl
	Fcode      uintptr
	Fsubject   TPCRE2_SPTR8
	Fmark      TPCRE2_SPTR8
	Fleftchar  Tsize_t
	Frightchar Tsize_t
	Fstartchar Tsize_t
	Fmatchedby Tuint8_t
	Fflags     Tuint8_t
	Foveccount Tuint16_t
	Frc        int32
	Fovector   [131072]Tsize_t
} /* pcre2.h:935:1 */

type Tpcre2_match_data_8 = Spcre2_real_match_data_8 /* pcre2.h:935:1 */
type Spcre2_real_jit_stack_8 = struct {
	Fmemctl Tpcre2_memctl
	Fstack  uintptr
} /* pcre2.h:935:1 */

type Tpcre2_jit_stack_8 = Spcre2_real_jit_stack_8 /* pcre2.h:935:1 */
type Tpcre2_jit_callback_8 = uintptr              /* pcre2.h:935:1 */
type Spcre2_callout_block_8 = struct {
	Fversion               Tuint32_t
	Fcallout_number        Tuint32_t
	Fcapture_top           Tuint32_t
	Fcapture_last          Tuint32_t
	Foffset_vector         uintptr
	Fmark                  TPCRE2_SPTR8
	Fsubject               TPCRE2_SPTR8
	Fsubject_length        Tsize_t
	Fstart_match           Tsize_t
	Fcurrent_position      Tsize_t
	Fpattern_position      Tsize_t
	Fnext_item_length      Tsize_t
	Fcallout_string_offset Tsize_t
	Fcallout_string_length Tsize_t
	Fcallout_string        TPCRE2_SPTR8
	Fcallout_flags         Tuint32_t
	F__ccgo_pad1           [4]byte
} /* pcre2.h:935:1 */

type Tpcre2_callout_block_8 = Spcre2_callout_block_8 /* pcre2.h:935:1 */
type Spcre2_callout_enumerate_block_8 = struct {
	Fversion               Tuint32_t
	F__ccgo_pad1           [4]byte
	Fpattern_position      Tsize_t
	Fnext_item_length      Tsize_t
	Fcallout_number        Tuint32_t
	F__ccgo_pad2           [4]byte
	Fcallout_string_offset Tsize_t
	Fcallout_string_length Tsize_t
	Fcallout_string        TPCRE2_SPTR8
} /* pcre2.h:935:1 */

type Tpcre2_callout_enumerate_block_8 = Spcre2_callout_enumerate_block_8 /* pcre2.h:935:1 */
type Spcre2_substitute_callout_block_8 = struct {
	Fversion        Tuint32_t
	F__ccgo_pad1    [4]byte
	Finput          TPCRE2_SPTR8
	Foutput         TPCRE2_SPTR8
	Foutput_offsets [2]Tsize_t
	Fovector        uintptr
	Foveccount      Tuint32_t
	Fsubscount      Tuint32_t
} /* pcre2.h:935:1 */

type Tpcre2_substitute_callout_block_8 = Spcre2_substitute_callout_block_8 /* pcre2.h:935:1 */
type Tpcre2_jit_callback_16 = uintptr                                      /* pcre2.h:939:1 */
type Spcre2_callout_block_16 = struct {
	Fversion               Tuint32_t
	Fcallout_number        Tuint32_t
	Fcapture_top           Tuint32_t
	Fcapture_last          Tuint32_t
	Foffset_vector         uintptr
	Fmark                  TPCRE2_SPTR16
	Fsubject               TPCRE2_SPTR16
	Fsubject_length        Tsize_t
	Fstart_match           Tsize_t
	Fcurrent_position      Tsize_t
	Fpattern_position      Tsize_t
	Fnext_item_length      Tsize_t
	Fcallout_string_offset Tsize_t
	Fcallout_string_length Tsize_t
	Fcallout_string        TPCRE2_SPTR16
	Fcallout_flags         Tuint32_t
	F__ccgo_pad1           [4]byte
} /* pcre2.h:939:1 */

type Tpcre2_callout_block_16 = Spcre2_callout_block_16 /* pcre2.h:939:1 */
type Spcre2_callout_enumerate_block_16 = struct {
	Fversion               Tuint32_t
	F__ccgo_pad1           [4]byte
	Fpattern_position      Tsize_t
	Fnext_item_length      Tsize_t
	Fcallout_number        Tuint32_t
	F__ccgo_pad2           [4]byte
	Fcallout_string_offset Tsize_t
	Fcallout_string_length Tsize_t
	Fcallout_string        TPCRE2_SPTR16
} /* pcre2.h:939:1 */

type Tpcre2_callout_enumerate_block_16 = Spcre2_callout_enumerate_block_16 /* pcre2.h:939:1 */
type Spcre2_substitute_callout_block_16 = struct {
	Fversion        Tuint32_t
	F__ccgo_pad1    [4]byte
	Finput          TPCRE2_SPTR16
	Foutput         TPCRE2_SPTR16
	Foutput_offsets [2]Tsize_t
	Fovector        uintptr
	Foveccount      Tuint32_t
	Fsubscount      Tuint32_t
} /* pcre2.h:939:1 */

type Tpcre2_substitute_callout_block_16 = Spcre2_substitute_callout_block_16 /* pcre2.h:939:1 */
type Tpcre2_jit_callback_32 = uintptr                                        /* pcre2.h:943:1 */
type Spcre2_callout_block_32 = struct {
	Fversion               Tuint32_t
	Fcallout_number        Tuint32_t
	Fcapture_top           Tuint32_t
	Fcapture_last          Tuint32_t
	Foffset_vector         uintptr
	Fmark                  TPCRE2_SPTR32
	Fsubject               TPCRE2_SPTR32
	Fsubject_length        Tsize_t
	Fstart_match           Tsize_t
	Fcurrent_position      Tsize_t
	Fpattern_position      Tsize_t
	Fnext_item_length      Tsize_t
	Fcallout_string_offset Tsize_t
	Fcallout_string_length Tsize_t
	Fcallout_string        TPCRE2_SPTR32
	Fcallout_flags         Tuint32_t
	F__ccgo_pad1           [4]byte
} /* pcre2.h:943:1 */

type Tpcre2_callout_block_32 = Spcre2_callout_block_32 /* pcre2.h:943:1 */
type Spcre2_callout_enumerate_block_32 = struct {
	Fversion               Tuint32_t
	F__ccgo_pad1           [4]byte
	Fpattern_position      Tsize_t
	Fnext_item_length      Tsize_t
	Fcallout_number        Tuint32_t
	F__ccgo_pad2           [4]byte
	Fcallout_string_offset Tsize_t
	Fcallout_string_length Tsize_t
	Fcallout_string        TPCRE2_SPTR32
} /* pcre2.h:943:1 */

type Tpcre2_callout_enumerate_block_32 = Spcre2_callout_enumerate_block_32 /* pcre2.h:943:1 */
type Spcre2_substitute_callout_block_32 = struct {
	Fversion        Tuint32_t
	F__ccgo_pad1    [4]byte
	Finput          TPCRE2_SPTR32
	Foutput         TPCRE2_SPTR32
	Foutput_offsets [2]Tsize_t
	Fovector        uintptr
	Foveccount      Tuint32_t
	Fsubscount      Tuint32_t
} /* pcre2.h:943:1 */

type Tpcre2_substitute_callout_block_32 = Spcre2_substitute_callout_block_32 /* pcre2.h:943:1 */

// *** NOTE NOTE NOTE *** Whenever the list above is updated, the two macro
// definitions that follow must also be updated to match. There are also tables
// called "opcode_possessify" in pcre2_compile.c and "coptable" and "poptable" in
// pcre2_dfa_match.c that must be updated.

// This macro defines textual names for all the opcodes. These are used only
// for debugging, and some of them are only partial names. The macro is referenced
// only in pcre2_printint.c, which fills out the full names in many cases (and in
// some cases doesn't actually use these names at all).

// This macro defines the length of fixed length operations in the compiled
// regex. The lengths are used when searching for specific things, and also in the
// debugging printing of a compiled regex. We use a macro so that it can be
// defined close to the definitions of the opcodes themselves.
//
// As things have been extended, some of these are no longer fixed lenths, but are
// minima instead. For example, the length of a single-character repeat may vary
// in UTF-8 mode. The code that uses this table must know about such things.

// A magic value for OP_RREF to indicate the "any recursion" condition.

// ---------- Private structures that are mode-independent. ----------

// Structure to hold data for custom memory management.

type Spcre2_memctl = struct {
	Fmalloc      uintptr
	Ffree        uintptr
	Fmemory_data uintptr
} /* pcre2.h:935:1 */

// *** NOTE NOTE NOTE *** Whenever the list above is updated, the two macro
// definitions that follow must also be updated to match. There are also tables
// called "opcode_possessify" in pcre2_compile.c and "coptable" and "poptable" in
// pcre2_dfa_match.c that must be updated.

// This macro defines textual names for all the opcodes. These are used only
// for debugging, and some of them are only partial names. The macro is referenced
// only in pcre2_printint.c, which fills out the full names in many cases (and in
// some cases doesn't actually use these names at all).

// This macro defines the length of fixed length operations in the compiled
// regex. The lengths are used when searching for specific things, and also in the
// debugging printing of a compiled regex. We use a macro so that it can be
// defined close to the definitions of the opcodes themselves.
//
// As things have been extended, some of these are no longer fixed lenths, but are
// minima instead. For example, the length of a single-character repeat may vary
// in UTF-8 mode. The code that uses this table must know about such things.

// A magic value for OP_RREF to indicate the "any recursion" condition.

// ---------- Private structures that are mode-independent. ----------

// Structure to hold data for custom memory management.

type Tpcre2_memctl = Spcre2_memctl /* pcre2_internal.h:1794:3 */

// Structure for building a chain of open capturing subpatterns during
// compiling, so that instructions to close them can be compiled when (*ACCEPT) is
// encountered.

type Sopen_capitem = struct {
	Fnext         uintptr
	Fnumber       Tuint16_t
	Fassert_depth Tuint16_t
	F__ccgo_pad1  [4]byte
} /* pcre2_internal.h:1800:9 */

// Structure for building a chain of open capturing subpatterns during
// compiling, so that instructions to close them can be compiled when (*ACCEPT) is
// encountered.

type Topen_capitem = Sopen_capitem /* pcre2_internal.h:1804:3 */

// Layout of the UCP type table that translates property names into types and
// codes. Each entry used to point directly to a name, but to reduce the number of
// relocations in shared libraries, it now has an offset into a single string
// instead.

type Tucp_type_table = struct {
	Fname_offset Tuint16_t
	Ftype        Tuint16_t
	Fvalue       Tuint16_t
} /* pcre2_internal.h:1815:3 */

// Unicode character database (UCD) record format

type Tucd_record = struct {
	Fscript            Tuint8_t
	Fchartype          Tuint8_t
	Fgbprop            Tuint8_t
	Fcaseset           Tuint8_t
	Fother_case        Tint32_t
	Fscriptx_bidiclass Tuint16_t
	Fbprops            Tuint16_t
} /* pcre2_internal.h:1827:3 */

// UCD access macros

// The "scriptx" and bprops fields contain offsets into vectors of 32-bit words
// that form a bitmap representing a list of scripts or boolean properties. These
// macros test or set a bit in the map by number.

// Header for serialized pcre2 codes.

type Spcre2_serialized_data = struct {
	Fmagic           Tuint32_t
	Fversion         Tuint32_t
	Fconfig          Tuint32_t
	Fnumber_of_codes Tint32_t
} /* pcre2_internal.h:1870:9 */

// UCD access macros

// The "scriptx" and bprops fields contain offsets into vectors of 32-bit words
// that form a bitmap representing a list of scripts or boolean properties. These
// macros test or set a bit in the map by number.

// Header for serialized pcre2 codes.

type Tpcre2_serialized_data = Spcre2_serialized_data /* pcre2_internal.h:1875:3 */

// Mode-dependent macros and hidden and private structures are defined in a
// separate file so that pcre2test can include them at all supported widths. When
// compiling the library, PCRE2_CODE_UNIT_WIDTH will be defined, and we can
// include them at the appropriate width, after setting up suffix macros for the
// private structures.

// ************************************************
//
//      Perl-Compatible Regular Expressions       *
//

// PCRE is a library of functions to support regular expressions whose syntax
// and semantics are as close as possible to those of the Perl 5 language.
//
//                        Written by Philip Hazel
//      Original API code Copyright (c) 1997-2012 University of Cambridge
//           New API code Copyright (c) 2016-2018 University of Cambridge
//
// -----------------------------------------------------------------------------
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//
//     * Neither the name of the University of Cambridge nor the names of its
//       contributors may be used to endorse or promote products derived from
//       this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
// -----------------------------------------------------------------------------

// This module contains mode-dependent macro and structure definitions. The
// file is #included by pcre2_internal.h if PCRE2_CODE_UNIT_WIDTH is defined.
// These mode-dependent items are kept in a separate file so that they can also be
// #included multiple times for different code unit widths by pcre2test in order
// to have access to the hidden structures at all supported widths.
//
// Some of the mode-dependent macros are required at different widths for
// different parts of the pcre2test code (in particular, the included
// pcre_printint.c file). We undefine them here so that they can be re-defined for
// multiple inclusions. Not all of these are used in pcre2test, but it's easier
// just to undefine them all.

// -------------------------- MACROS -----------------------------

// PCRE keeps offsets in its compiled code as at least 16-bit quantities
// (always stored in big-endian order in 8-bit mode) by default. These are used,
// for example, to link from the start of a subpattern to its alternatives and its
// end. The use of 16 bits per offset limits the size of an 8-bit compiled regex
// to around 64K, which is big enough for almost everybody. However, I received a
// request for an even bigger limit. For this reason, and also to make the code
// easier to maintain, the storing and loading of offsets from the compiled code
// unit string is now handled by the macros that are defined here.
//
// The macros are controlled by the value of LINK_SIZE. This defaults to 2, but
// values of 3 or 4 are also supported.

// ------------------- 8-bit support  ------------------

// ------------------- 16-bit support  ------------------

// --------------- Other mode-specific macros -----------------

// PCRE uses some other (at least) 16-bit quantities that do not change when
// the size of offsets changes. There are used for repeat counts and for other
// things such as capturing parenthesis numbers in back references.
//
// Define the number of code units required to hold a 16-bit count/offset, and
// macros to load and store such a value. For reasons that I do not understand,
// the expression in the 8-bit GET2 macro is treated by gcc as a signed
// expression, even when a is declared as unsigned. It seems that any kind of
// arithmetic results in a signed value. Hence the cast.

// Other macros that are different for 8-bit mode. The MAX_255 macro checks
// whether its argument, which is assumed to be one code unit, is less than 256.
// The CHMAX_255 macro does not assume one code unit. The maximum length of a MARK
// name must fit in one code unit; currently it is set to 255 or 65535. The
// TABLE_GET macro is used to access elements of tables containing exactly 256
// items. Its argument is a code unit. When code points can be greater than 255, a
// check is needed before accessing these tables.

// ----------------- Character-handling macros -----------------

// There is a proposed future special "UTF-21" mode, in which only the lowest
// 21 bits of a 32-bit character are interpreted as UTF, with the remaining 11
// high-order bits available to the application for other uses. In preparation for
// the future implementation of this mode, there are macros that load a data item
// and, if in this special mode, mask it to 21 bits. These macros all have names
// starting with UCHAR21. In all other modes, including the normal 32-bit
// library, the macros all have the same simple definitions. When the new mode is
// implemented, it is expected that these definitions will be varied appropriately
// using #ifdef when compiling the library that supports the special mode.

// When UTF encoding is being used, a character is no longer just a single
// byte in 8-bit mode or a single short in 16-bit mode. The macros for character
// handling generate simple sequences when used in the basic mode, and more
// complicated ones for UTF characters. GETCHARLENTEST and other macros are not
// used when UTF is not supported. To make sure they can never even appear when
// UTF support is omitted, we don't even define them.

// ------------------- 8-bit support  ------------------

// The largest UTF code point that can be encoded as a single code unit.

// Tests whether the code point needs extra characters to decode.

// Returns with the additional number of characters if IS_MULTICHAR(c) is TRUE.
// Otherwise it has an undefined behaviour.

// Returns TRUE, if the given value is not the first code unit of a UTF
// sequence.

// Get the next UTF-8 character, not advancing the pointer. This is called when
// we know we are in UTF-8 mode.

// Get the next UTF-8 character, testing for UTF-8 mode, and not advancing the
// pointer.

// Get the next UTF-8 character, advancing the pointer. This is called when we
// know we are in UTF-8 mode.

// Get the next character, testing for UTF-8 mode, and advancing the pointer.
// This is called when we don't know if we are in UTF-8 mode.

// Get the next UTF-8 character, not advancing the pointer, incrementing length
// if there are extra bytes. This is called when we know we are in UTF-8 mode.

// Get the next UTF-8 character, testing for UTF-8 mode, not advancing the
// pointer, incrementing length if there are extra bytes. This is called when we
// do not know if we are in UTF-8 mode.

// If the pointer is not at the start of a character, move it back until
// it is. This is called only in UTF-8 mode - we don't put a test within the macro
// because almost all calls are already within a block of UTF-8 only code.

// Same as above, just in the other direction.

// Same as above, but it allows a fully customizable form.

// Deposit a character into memory, returning the number of code units.

// ------------------- 16-bit support  ------------------

// Mode-dependent macros that have the same definition in all modes.

// ----------------------- HIDDEN STRUCTURES -----------------------------

// NOTE: All these structures *must* start with a pcre2_memctl structure. The
// code that uses them is simpler because it assumes this.

// The real general context structure. At present it holds only data for custom
// memory control.

type Tpcre2_real_general_context_8 = Spcre2_real_general_context_8 /* pcre2_intmodedep.h:561:3 */

// The real compile context structure

type Tpcre2_real_compile_context_8 = Spcre2_real_compile_context_8 /* pcre2_intmodedep.h:575:3 */

// The real match context structure.

type Tpcre2_real_match_context_8 = Spcre2_real_match_context_8 /* pcre2_intmodedep.h:593:3 */

// The real convert context structure.

type Tpcre2_real_convert_context_8 = Spcre2_real_convert_context_8 /* pcre2_intmodedep.h:601:3 */

// The real compiled code structure. The type for the blocksize field is
// defined specially because it is required in pcre2_serialize_decode() when
// copying the size from possibly unaligned memory into a variable of the same
// type. Use a macro rather than a typedef to avoid compiler warnings when this
// file is included multiple times by pcre2test. LOOKBEHIND_MAX specifies the
// largest lookbehind that is supported. (OP_REVERSE in a pattern has a 16-bit
// argument in 8-bit and 16-bit modes, so we need no more than a 16-bit field
// here.)

type Tpcre2_real_code_8 = Spcre2_real_code_8 /* pcre2_intmodedep.h:642:3 */

// The real match data structure. Define ovector as large as it can ever
// actually be so that array bound checkers don't grumble. Memory for this
// structure is obtained by calling pcre2_match_data_create(), which sets the size
// as the offset of ovector plus a pair of elements for each capturable string, so
// the size varies from call to call. As the maximum number of capturing
// subpatterns is 65535 we must allow for 65536 strings to include the overall
// match. (See also the heapframe structure below.)

type Tpcre2_real_match_data_8 = Spcre2_real_match_data_8 /* pcre2_intmodedep.h:665:3 */

// ----------------------- PRIVATE STRUCTURES -----------------------------

// These structures are not needed for pcre2test.

// Structures for checking for mutual recursion when scanning compiled or
// parsed code.

type Srecurse_check = struct {
	Fprev  uintptr
	Fgroup TPCRE2_SPTR8
} /* pcre2_intmodedep.h:677:9 */

// ----------------------- PRIVATE STRUCTURES -----------------------------

// These structures are not needed for pcre2test.

// Structures for checking for mutual recursion when scanning compiled or
// parsed code.

type Trecurse_check = Srecurse_check /* pcre2_intmodedep.h:680:3 */

type Sparsed_recurse_check = struct {
	Fprev     uintptr
	Fgroupptr uintptr
} /* pcre2_intmodedep.h:682:9 */

type Tparsed_recurse_check = Sparsed_recurse_check /* pcre2_intmodedep.h:685:3 */

// Structure for building a cache when filling in recursion offsets.

type Srecurse_cache = struct {
	Fgroup       TPCRE2_SPTR8
	Fgroupnumber int32
	F__ccgo_pad1 [4]byte
} /* pcre2_intmodedep.h:689:9 */

// Structure for building a cache when filling in recursion offsets.

type Trecurse_cache = Srecurse_cache /* pcre2_intmodedep.h:692:3 */

// Structure for maintaining a chain of pointers to the currently incomplete
// branches, for testing for left recursion while compiling.

type Sbranch_chain_8 = struct {
	Fouter          uintptr
	Fcurrent_branch uintptr
} /* pcre2_intmodedep.h:697:9 */

// Structure for maintaining a chain of pointers to the currently incomplete
// branches, for testing for left recursion while compiling.

type Tbranch_chain_8 = Sbranch_chain_8 /* pcre2_intmodedep.h:700:3 */

// Structure for building a list of named groups during the first pass of
// compiling.

type Snamed_group_8 = struct {
	Fname   TPCRE2_SPTR8
	Fnumber Tuint32_t
	Flength Tuint16_t
	Fisdup  Tuint16_t
} /* pcre2_intmodedep.h:705:9 */

// Structure for building a list of named groups during the first pass of
// compiling.

type Tnamed_group_8 = Snamed_group_8 /* pcre2_intmodedep.h:710:3 */

// Structure for passing "static" information around between the functions
// doing the compiling, so that they are thread-safe.

type Scompile_block_8 = struct {
	Fcx                    uintptr
	Flcc                   uintptr
	Ffcc                   uintptr
	Fcbits                 uintptr
	Fctypes                uintptr
	Fstart_workspace       TPCRE2_SPTR8
	Fstart_code            TPCRE2_SPTR8
	Fstart_pattern         TPCRE2_SPTR8
	Fend_pattern           TPCRE2_SPTR8
	Fname_table            uintptr
	Fworkspace_size        Tsize_t
	Fsmall_ref_offset      [10]Tsize_t
	Ferroroffset           Tsize_t
	Fnames_found           Tuint16_t
	Fname_entry_size       Tuint16_t
	Fparens_depth          Tuint16_t
	Fassert_depth          Tuint16_t
	Fopen_caps             uintptr
	Fnamed_groups          uintptr
	Fnamed_group_list_size Tuint32_t
	Fexternal_options      Tuint32_t
	Fexternal_flags        Tuint32_t
	Fbracount              Tuint32_t
	Flastcapture           Tuint32_t
	F__ccgo_pad1           [4]byte
	Fparsed_pattern        uintptr
	Fparsed_pattern_end    uintptr
	Fgroupinfo             uintptr
	Ftop_backref           Tuint32_t
	Fbackref_map           Tuint32_t
	Fnltype                Tuint32_t
	Fnllen                 Tuint32_t
	Fclass_range_start     Tuint32_t
	Fclass_range_end       Tuint32_t
	Fnl                    [4]TPCRE2_UCHAR8
	Freq_varyopt           Tuint32_t
	Fmax_lookbehind        int32
	Fhad_accept            TBOOL
	Fhad_pruneorskip       TBOOL
	Fhad_recurse           TBOOL
	Fdupnames              TBOOL
	F__ccgo_pad2           [4]byte
} /* pcre2_intmodedep.h:715:9 */

// Structure for passing "static" information around between the functions
// doing the compiling, so that they are thread-safe.

type Tcompile_block_8 = Scompile_block_8 /* pcre2_intmodedep.h:756:3 */

// Structure for keeping the properties of the in-memory stack used
// by the JIT matcher.

type Tpcre2_real_jit_stack_8 = Spcre2_real_jit_stack_8 /* pcre2_intmodedep.h:764:3 */

// Structure for items in a linked list that represents an explicit recursive
// call within the pattern when running pcre2_dfa_match().

type Sdfa_recursion_info = struct {
	Fprevrec          uintptr
	Fsubject_position TPCRE2_SPTR8
	Fgroup_num        Tuint32_t
	F__ccgo_pad1      [4]byte
} /* pcre2_intmodedep.h:769:9 */

// Structure for items in a linked list that represents an explicit recursive
// call within the pattern when running pcre2_dfa_match().

type Tdfa_recursion_info = Sdfa_recursion_info /* pcre2_intmodedep.h:773:3 */

// Structure for "stack" frames that are used for remembering backtracking
// positions during matching. As these are used in a vector, with the ovector item
// being extended, the size of the structure must be a multiple of PCRE2_SIZE. The
// only way to check this at compile time is to force an error by generating an
// array with a negative size. By putting this in a typedef (which is never used),
// we don't generate any code when all is well.

type Sheapframe = struct {
	Fecode             TPCRE2_SPTR8
	Ftemp_sptr         [2]TPCRE2_SPTR8
	Flength            Tsize_t
	Fback_frame        Tsize_t
	Ftemp_size         Tsize_t
	Frdepth            Tuint32_t
	Fgroup_frame_type  Tuint32_t
	Ftemp_32           [4]Tuint32_t
	Freturn_id         Tuint8_t
	Fop                Tuint8_t
	Foccu              [6]TPCRE2_UCHAR8
	Feptr              TPCRE2_SPTR8
	Fstart_match       TPCRE2_SPTR8
	Fmark              TPCRE2_SPTR8
	Fcurrent_recurse   Tuint32_t
	Fcapture_last      Tuint32_t
	Flast_group_offset Tsize_t
	Foffset_top        Tsize_t
	Fovector           [131072]Tsize_t
} /* pcre2_intmodedep.h:782:9 */

// Structure for "stack" frames that are used for remembering backtracking
// positions during matching. As these are used in a vector, with the ovector item
// being extended, the size of the structure must be a multiple of PCRE2_SIZE. The
// only way to check this at compile time is to force an error by generating an
// array with a negative size. By putting this in a typedef (which is never used),
// we don't generate any code when all is well.

type Theapframe = Sheapframe /* pcre2_intmodedep.h:833:3 */

// This typedef is a check that the size of the heapframe structure is a
// multiple of PCRE2_SIZE. See various comments above.

type Tcheck_heapframe_size = [1]uint8 /* pcre2_intmodedep.h:838:14 */

// Structure for computing the alignment of heapframe.

type Sheapframe_align = struct {
	Funalign     uint8
	F__ccgo_pad1 [7]byte
	Fframe       Theapframe
} /* pcre2_intmodedep.h:843:9 */

// Structure for computing the alignment of heapframe.

type Theapframe_align = Sheapframe_align /* pcre2_intmodedep.h:846:3 */

// This define is the minimum alignment required for a heapframe, in bytes.

// Structure for passing "static" information around between the functions
// doing traditional NFA matching (pcre2_match() and friends).

type Smatch_block_8 = struct {
	Fmemctl               Tpcre2_memctl
	Fframe_vector_size    Tsize_t
	Fmatch_frames         uintptr
	Fmatch_frames_top     uintptr
	Fstack_frames         uintptr
	Fheap_limit           Tsize_t
	Fmatch_limit          Tuint32_t
	Fmatch_limit_depth    Tuint32_t
	Fmatch_call_count     Tuint32_t
	Fhitend               TBOOL
	Fhasthen              TBOOL
	Fallowemptypartial    TBOOL
	Flcc                  uintptr
	Ffcc                  uintptr
	Fctypes               uintptr
	Fstart_offset         Tsize_t
	Fend_offset_top       Tsize_t
	Fpartial              Tuint16_t
	Fbsr_convention       Tuint16_t
	Fname_count           Tuint16_t
	Fname_entry_size      Tuint16_t
	Fname_table           TPCRE2_SPTR8
	Fstart_code           TPCRE2_SPTR8
	Fstart_subject        TPCRE2_SPTR8
	Fcheck_subject        TPCRE2_SPTR8
	Fend_subject          TPCRE2_SPTR8
	Fend_match_ptr        TPCRE2_SPTR8
	Fstart_used_ptr       TPCRE2_SPTR8
	Flast_used_ptr        TPCRE2_SPTR8
	Fmark                 TPCRE2_SPTR8
	Fnomatch_mark         TPCRE2_SPTR8
	Fverb_ecode_ptr       TPCRE2_SPTR8
	Fverb_skip_ptr        TPCRE2_SPTR8
	Fverb_current_recurse Tuint32_t
	Fmoptions             Tuint32_t
	Fpoptions             Tuint32_t
	Fskip_arg_count       Tuint32_t
	Fignore_skip_arg      Tuint32_t
	Fnltype               Tuint32_t
	Fnllen                Tuint32_t
	Fnl                   [4]TPCRE2_UCHAR8
	Fcb                   uintptr
	Fcallout_data         uintptr
	Fcallout              uintptr
} /* pcre2_intmodedep.h:855:9 */

// This define is the minimum alignment required for a heapframe, in bytes.

// Structure for passing "static" information around between the functions
// doing traditional NFA matching (pcre2_match() and friends).

type Tmatch_block_8 = Smatch_block_8 /* pcre2_intmodedep.h:900:3 */

// A similar structure is used for the same purpose by the DFA matching
// functions.

type Sdfa_match_block_8 = struct {
	Fmemctl            Tpcre2_memctl
	Fstart_code        TPCRE2_SPTR8
	Fstart_subject     TPCRE2_SPTR8
	Fend_subject       TPCRE2_SPTR8
	Fstart_used_ptr    TPCRE2_SPTR8
	Flast_used_ptr     TPCRE2_SPTR8
	Ftables            uintptr
	Fstart_offset      Tsize_t
	Fheap_limit        Tsize_t
	Fheap_used         Tsize_t
	Fmatch_limit       Tuint32_t
	Fmatch_limit_depth Tuint32_t
	Fmatch_call_count  Tuint32_t
	Fmoptions          Tuint32_t
	Fpoptions          Tuint32_t
	Fnltype            Tuint32_t
	Fnllen             Tuint32_t
	Fallowemptypartial TBOOL
	Fnl                [4]TPCRE2_UCHAR8
	Fbsr_convention    Tuint16_t
	F__ccgo_pad1       [2]byte
	Fcb                uintptr
	Fcallout_data      uintptr
	Fcallout           uintptr
	Frecursive         uintptr
} /* pcre2_intmodedep.h:905:9 */

// A similar structure is used for the same purpose by the DFA matching
// functions.

type Tdfa_match_block_8 = Sdfa_match_block_8 /* pcre2_intmodedep.h:930:3 */

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// ************************************************
//
//        Tables for auto-possessification        *
//

// This table is used to check whether auto-possessification is possible
// between adjacent character-type opcodes. The left-hand (repeated) opcode is
// used to select the row, and the right-hand opcode is use to select the column.
// A value of 1 means that auto-possessification is OK. For example, the second
// value in the first row means that \D+\d can be turned into \D++\d.
//
// The Unicode property types (\P and \p) have to be present to fill out the table
// because of what their opcode values are, but the table values should always be
// zero because property types are handled separately in the code. The last four
// columns apply to items that cannot be repeated, so there is no need to have
// rows for them. Note that OP_DIGIT etc. are generated only when PCRE_UCP is
// *not* set. When it is set, \d etc. are converted into OP_(NOT_)PROP codes.

var autoposstab = [17][21]Tuint8_t{
	// \D \d \S \s \W \w  . .+ \C \P \p \R \H \h \V \v \X \Z \z  $ $M
	{Tuint8_t(0), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0)}, // \D
	{Tuint8_t(1), Tuint8_t(0), Tuint8_t(0), Tuint8_t(1), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(1), Tuint8_t(0), Tuint8_t(1), Tuint8_t(0), Tuint8_t(1), Tuint8_t(0), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1)}, // \d
	{Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(1), Tuint8_t(0), Tuint8_t(1), Tuint8_t(0), Tuint8_t(1), Tuint8_t(0), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1)}, // \S
	{Tuint8_t(0), Tuint8_t(1), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0)}, // \s
	{Tuint8_t(0), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0)}, // \W
	{Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(1), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(1), Tuint8_t(0), Tuint8_t(1), Tuint8_t(0), Tuint8_t(1), Tuint8_t(0), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1)}, // \w
	{Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0)}, // .
	{Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0)}, // .+
	{Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0)}, // \C
	{Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0)}, // \P
	{Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0)}, // \p
	{Tuint8_t(0), Tuint8_t(1), Tuint8_t(0), Tuint8_t(1), Tuint8_t(0), Tuint8_t(1), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0)}, // \R
	{Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0)}, // \H
	{Tuint8_t(0), Tuint8_t(1), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(1), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0)}, // \h
	{Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0)}, // \V
	{Tuint8_t(0), Tuint8_t(1), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(1), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0)}, // \v
	{Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0)}, // \X
} /* pcre2_auto_possess.c:73:22 */

// This table is used to check whether auto-possessification is possible
// between adjacent Unicode property opcodes (OP_PROP and OP_NOTPROP). The
// left-hand (repeated) opcode is used to select the row, and the right-hand
// opcode is used to select the column. The values are as follows:
//
//   0   Always return FALSE (never auto-possessify)
//   1   Character groups are distinct (possessify if both are OP_PROP)
//   2   Check character categories in the same group (general or particular)
//   3   TRUE if the two opcodes are not the same (PROP vs NOTPROP)
//
//   4   Check left general category vs right particular category
//   5   Check right general category vs left particular category
//
//   6   Left alphanum vs right general category
//   7   Left space vs right general category
//   8   Left word vs right general category
//
//   9   Right alphanum vs left general category
//  10   Right space vs left general category
//  11   Right word vs left general category
//
//  12   Left alphanum vs right particular category
//  13   Left space vs right particular category
//  14   Left word vs right particular category
//
//  15   Right alphanum vs left particular category
//  16   Right space vs left particular category
//  17   Right word vs left particular category

var propposstab = [14][14]Tuint8_t{
	// ANY LAMP GC  PC  SC  SCX ALNUM SPACE PXSPACE WORD CLIST UCNC BIDICL BOOL
	{Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0)},     // PT_ANY
	{Tuint8_t(0), Tuint8_t(3), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(3), Tuint8_t(1), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0)},     // PT_LAMP
	{Tuint8_t(0), Tuint8_t(0), Tuint8_t(2), Tuint8_t(4), Tuint8_t(0), Tuint8_t(0), Tuint8_t(9), Tuint8_t(10), Tuint8_t(10), Tuint8_t(11), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0)},  // PT_GC
	{Tuint8_t(0), Tuint8_t(0), Tuint8_t(5), Tuint8_t(2), Tuint8_t(0), Tuint8_t(0), Tuint8_t(15), Tuint8_t(16), Tuint8_t(16), Tuint8_t(17), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0)}, // PT_PC
	{Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(2), Tuint8_t(2), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0)},     // PT_SC
	{Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(2), Tuint8_t(2), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0)},     // PT_SCX
	{Tuint8_t(0), Tuint8_t(3), Tuint8_t(6), Tuint8_t(12), Tuint8_t(0), Tuint8_t(0), Tuint8_t(3), Tuint8_t(1), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0)},    // PT_ALNUM
	{Tuint8_t(0), Tuint8_t(1), Tuint8_t(7), Tuint8_t(13), Tuint8_t(0), Tuint8_t(0), Tuint8_t(1), Tuint8_t(3), Tuint8_t(3), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0)},    // PT_SPACE
	{Tuint8_t(0), Tuint8_t(1), Tuint8_t(7), Tuint8_t(13), Tuint8_t(0), Tuint8_t(0), Tuint8_t(1), Tuint8_t(3), Tuint8_t(3), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0)},    // PT_PXSPACE
	{Tuint8_t(0), Tuint8_t(0), Tuint8_t(8), Tuint8_t(14), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(1), Tuint8_t(1), Tuint8_t(3), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0)},    // PT_WORD
	{Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0)},     // PT_CLIST
	{Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(3), Tuint8_t(0), Tuint8_t(0)},     // PT_UCNC
	{Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0)},     // PT_BIDICL
	{Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0)},     // PT_BOOL
} /* pcre2_auto_possess.c:125:22 */

// This table is used to check whether auto-possessification is possible
// between adjacent Unicode property opcodes (OP_PROP and OP_NOTPROP) when one
// specifies a general category and the other specifies a particular category. The
// row is selected by the general category and the column by the particular
// category. The value is 1 if the particular category is not part of the general
// category.

var catposstab = [7][30]Tuint8_t{
	// Cc Cf Cn Co Cs Ll Lm Lo Lt Lu Mc Me Mn Nd Nl No Pc Pd Pe Pf Pi Po Ps Sc Sk Sm So Zl Zp Zs
	{Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1)}, // C
	{Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1)}, // L
	{Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1)}, // M
	{Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1)}, // N
	{Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1)}, // P
	{Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1)}, // S
	{Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0)}, // Z
} /* pcre2_auto_possess.c:150:22 */

// This table is used when checking ALNUM, (PX)SPACE, SPACE, and WORD against
// a general or particular category. The properties in each row are those
// that apply to the character set in question. Duplication means that a little
// unnecessary work is done when checking, but this keeps things much simpler
// because they can all use the same code. For more details see the comment where
// this table is used.
//
// Note: SPACE and PXSPACE used to be different because Perl excluded VT from
// "space", but from Perl 5.18 it's included, so both categories are treated the
// same here.

var posspropstab = [3][4]Tuint8_t{
	{ucp_L, ucp_N, ucp_N, ucp_Nl}, // ALNUM, 3rd and 4th values redundant
	{ucp_Z, ucp_Z, ucp_C, ucp_Cc}, // SPACE and PXSPACE, 2nd value redundant
	{ucp_L, ucp_N, ucp_P, ucp_Po}, // WORD
} /* pcre2_auto_possess.c:172:22 */

// ************************************************
//
//        Check a character and a property        *
//

// This function is called by compare_opcodes() when a property item is
// adjacent to a fixed character.
//
// Arguments:
//   c            the character
//   ptype        the property type
//   pdata        the data for the type
//   negated      TRUE if it's a negated property (\P or \p{^)
//
// Returns:       TRUE if auto-possessifying is OK

func check_char_prop(tls *libc.TLS, c Tuint32_t, ptype uint32, pdata uint32, negated TBOOL) TBOOL { /* pcre2_auto_possess.c:199:1: */
	var ok TBOOL
	var p uintptr
	var prop uintptr = uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12

	switch ptype {
	case uint32(DPT_LAMP):
		return libc.Bool32(libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop)).Fchartype) == ucp_Lu || int32((*Tucd_record)(unsafe.Pointer(prop)).Fchartype) == ucp_Ll || int32((*Tucd_record)(unsafe.Pointer(prop)).Fchartype) == ucp_Lt) == negated)

	case uint32(DPT_GC):
		return libc.Bool32(libc.Bool32(pdata == X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype]) == negated)

	case uint32(DPT_PC):
		return libc.Bool32(libc.Bool32(pdata == uint32((*Tucd_record)(unsafe.Pointer(prop)).Fchartype)) == negated)

	case uint32(DPT_SC):
		return libc.Bool32(libc.Bool32(pdata == uint32((*Tucd_record)(unsafe.Pointer(prop)).Fscript)) == negated)

	case uint32(DPT_SCX):
		ok = libc.Bool32(pdata == uint32((*Tucd_record)(unsafe.Pointer(prop)).Fscript) ||
			*(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_script_sets_8)) + uintptr(int32((*Tucd_record)(unsafe.Pointer(prop)).Fscriptx_bidiclass)&DUCD_SCRIPTX_MASK)*4 + uintptr(pdata/uint32(32))*4))&(uint32(1)<<(pdata%uint32(32))) != Tuint32_t(0))
		return libc.Bool32(ok == negated)

	// These are specials

	case uint32(DPT_ALNUM):
		return libc.Bool32(libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_L || X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_N) == negated)

	// Perl space used to exclude VT, but from Perl 5.18 it is included, which
	//   means that Perl space and POSIX space are now identical. PCRE was changed
	//   at release 8.34.

	case uint32(DPT_SPACE):
		fallthrough // Perl space
	case uint32(DPT_PXSPACE): // POSIX space
		switch c {
		case Tuint32_t('\011'):
			fallthrough
		case Tuint32_t('\040'):
			fallthrough
		case Tuint32_t(uint8('\xa0')):
			fallthrough
		case Tuint32_t(0x1680):
			fallthrough /* OGHAM SPACE MARK */
		case Tuint32_t(0x180e):
			fallthrough /* MONGOLIAN VOWEL SEPARATOR */
		case Tuint32_t(0x2000):
			fallthrough /* EN QUAD */
		case Tuint32_t(0x2001):
			fallthrough /* EM QUAD */
		case Tuint32_t(0x2002):
			fallthrough /* EN SPACE */
		case Tuint32_t(0x2003):
			fallthrough /* EM SPACE */
		case Tuint32_t(0x2004):
			fallthrough /* THREE-PER-EM SPACE */
		case Tuint32_t(0x2005):
			fallthrough /* FOUR-PER-EM SPACE */
		case Tuint32_t(0x2006):
			fallthrough /* SIX-PER-EM SPACE */
		case Tuint32_t(0x2007):
			fallthrough /* FIGURE SPACE */
		case Tuint32_t(0x2008):
			fallthrough /* PUNCTUATION SPACE */
		case Tuint32_t(0x2009):
			fallthrough /* THIN SPACE */
		case Tuint32_t(0x200A):
			fallthrough /* HAIR SPACE */
		case Tuint32_t(0x202f):
			fallthrough /* NARROW NO-BREAK SPACE */
		case Tuint32_t(0x205f):
			fallthrough /* MEDIUM MATHEMATICAL SPACE */
		case Tuint32_t(0x3000):
			fallthrough
		case Tuint32_t('\012'):
			fallthrough
		case Tuint32_t('\013'):
			fallthrough
		case Tuint32_t('\014'):
			fallthrough
		case Tuint32_t('\015'):
			fallthrough
		case Tuint32_t(uint8('\x85')):
			fallthrough
		case Tuint32_t(0x2028):
			fallthrough /* LINE SEPARATOR */
		case Tuint32_t(0x2029):
			return negated

		default:
			return libc.Bool32(libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_Z) == negated)
		}
		break // Control never reaches here

	case uint32(DPT_WORD):
		return libc.Bool32(libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_L || X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_N || c == Tuint32_t('\137')) == negated)

	case uint32(DPT_CLIST):
		p = uintptr(unsafe.Pointer(&X_pcre2_ucd_caseless_sets_8)) + uintptr((*Tucd_record)(unsafe.Pointer(prop)).Fcaseset)*4
		for {
			if c < *(*Tuint32_t)(unsafe.Pointer(p)) {
				return libc.BoolInt32(!(negated != 0))
			}
			if c == *(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&p, 4))) {
				return negated
			}
		}
		break // Control never reaches here

	// Haven't yet thought these through.

	case uint32(DPT_BIDICL):
		return DFALSE

	case uint32(DPT_BOOL):
		return DFALSE
	}

	return DFALSE
}

// ************************************************
//
//        Base opcode of repeated opcodes         *
//

// Returns the base opcode for repeated single character type opcodes. If the
// opcode is not a repeated character type, it returns with the original value.
//
// Arguments:  c opcode
// Returns:    base opcode for the type

func get_repeat_base(tls *libc.TLS, c TPCRE2_UCHAR8) TPCRE2_UCHAR8 { /* pcre2_auto_possess.c:291:1: */
	if int32(c) > OP_TYPEPOSUPTO {
		return c
	}
	if int32(c) >= OP_TYPESTAR {
		return OP_TYPESTAR
	}
	if int32(c) >= OP_NOTSTARI {
		return OP_NOTSTARI
	}
	if int32(c) >= OP_NOTSTAR {
		return OP_NOTSTAR
	}
	if int32(c) >= OP_STARI {
		return OP_STARI
	}
	return OP_STAR
}

// ************************************************
//
//        Fill the character property list        *
//

// Checks whether the code points to an opcode that can take part in auto-
// possessification, and if so, fills a list with its properties.
//
// Arguments:
//   code        points to start of expression
//   utf         TRUE if in UTF mode
//   ucp         TRUE if in UCP mode
//   fcc         points to the case-flipping table
//   list        points to output list
//               list[0] will be filled with the opcode
//               list[1] will be non-zero if this opcode
//                 can match an empty character string
//               list[2..7] depends on the opcode
//
// Returns:      points to the start of the next opcode if *code is accepted
//               NULL if *code is not accepted

func get_chr_property_list(tls *libc.TLS, code TPCRE2_SPTR8, utf TBOOL, ucp TBOOL, fcc uintptr, list uintptr) TPCRE2_SPTR8 { /* pcre2_auto_possess.c:325:1: */
	var c TPCRE2_UCHAR8 = *(*TPCRE2_UCHAR8)(unsafe.Pointer(code))
	var base TPCRE2_UCHAR8
	var end TPCRE2_SPTR8
	var chr Tuint32_t
	var clist_dest uintptr
	var clist_src uintptr

	*(*Tuint32_t)(unsafe.Pointer(list)) = Tuint32_t(c)
	*(*Tuint32_t)(unsafe.Pointer(list + 1*4)) = Tuint32_t(DFALSE)
	code++

	if int32(c) >= OP_STAR && int32(c) <= OP_TYPEPOSUPTO {
		base = get_repeat_base(tls, c)
		c = TPCRE2_UCHAR8(int32(c) - (int32(base) - OP_STAR))

		if int32(c) == OP_UPTO || int32(c) == OP_MINUPTO || int32(c) == OP_EXACT || int32(c) == OP_POSUPTO {
			code += TPCRE2_SPTR8(DIMM2_SIZE)
		}

		*(*Tuint32_t)(unsafe.Pointer(list + 1*4)) = Tuint32_t(libc.Bool32(int32(c) != OP_PLUS && int32(c) != OP_MINPLUS && int32(c) != OP_EXACT && int32(c) != OP_POSPLUS))

		switch int32(base) {
		case OP_STAR:
			*(*Tuint32_t)(unsafe.Pointer(list)) = OP_CHAR
			break
			fallthrough

		case OP_STARI:
			*(*Tuint32_t)(unsafe.Pointer(list)) = OP_CHARI
			break
			fallthrough

		case OP_NOTSTAR:
			*(*Tuint32_t)(unsafe.Pointer(list)) = OP_NOT
			break
			fallthrough

		case OP_NOTSTARI:
			*(*Tuint32_t)(unsafe.Pointer(list)) = OP_NOTI
			break
			fallthrough

		case OP_TYPESTAR:
			*(*Tuint32_t)(unsafe.Pointer(list)) = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)))
			code++
			break
		}
		c = TPCRE2_UCHAR8(*(*Tuint32_t)(unsafe.Pointer(list)))
	}

	switch int32(c) {
	case OP_NOT_DIGIT:
		fallthrough
	case OP_DIGIT:
		fallthrough
	case OP_NOT_WHITESPACE:
		fallthrough
	case OP_WHITESPACE:
		fallthrough
	case OP_NOT_WORDCHAR:
		fallthrough
	case OP_WORDCHAR:
		fallthrough
	case OP_ANY:
		fallthrough
	case OP_ALLANY:
		fallthrough
	case OP_ANYNL:
		fallthrough
	case OP_NOT_HSPACE:
		fallthrough
	case OP_HSPACE:
		fallthrough
	case OP_NOT_VSPACE:
		fallthrough
	case OP_VSPACE:
		fallthrough
	case OP_EXTUNI:
		fallthrough
	case OP_EODN:
		fallthrough
	case OP_EOD:
		fallthrough
	case OP_DOLL:
		fallthrough
	case OP_DOLLM:
		return code

	case OP_CHAR:
		fallthrough
	case OP_NOT:
		chr = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))))
		if utf != 0 && chr >= 0xc0 {
			if chr&0x20 == Tuint32_t(0) {
				chr = chr&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))))&0x3f
			} else if chr&0x10 == Tuint32_t(0) {
				chr = chr&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))&0x3f
				code += uintptr(2)
			} else if chr&0x08 == Tuint32_t(0) {
				chr = chr&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))&0x3f
				code += uintptr(3)
			} else if chr&0x04 == Tuint32_t(0) {
				chr = chr&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3)))&0x3f
				code += uintptr(4)
			} else {
				chr = chr&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 4)))&0x3f
				code += uintptr(5)
			}
		}

		*(*Tuint32_t)(unsafe.Pointer(list + 2*4)) = chr
		*(*Tuint32_t)(unsafe.Pointer(list + 3*4)) = DNOTACHAR
		return code

	case OP_CHARI:
		fallthrough
	case OP_NOTI:
		*(*Tuint32_t)(unsafe.Pointer(list)) = func() uint32 {
			if int32(c) == OP_CHARI {
				return OP_CHAR
			}
			return OP_NOT
		}()
		chr = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))))
		if utf != 0 && chr >= 0xc0 {
			if chr&0x20 == Tuint32_t(0) {
				chr = chr&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))))&0x3f
			} else if chr&0x10 == Tuint32_t(0) {
				chr = chr&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))&0x3f
				code += uintptr(2)
			} else if chr&0x08 == Tuint32_t(0) {
				chr = chr&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))&0x3f
				code += uintptr(3)
			} else if chr&0x04 == Tuint32_t(0) {
				chr = chr&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3)))&0x3f
				code += uintptr(4)
			} else {
				chr = chr&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 4)))&0x3f
				code += uintptr(5)
			}
		}

		*(*Tuint32_t)(unsafe.Pointer(list + 2*4)) = chr

		if chr < Tuint32_t(128) || chr < Tuint32_t(256) && !(utf != 0) && !(ucp != 0) {
			*(*Tuint32_t)(unsafe.Pointer(list + 3*4)) = Tuint32_t(*(*Tuint8_t)(unsafe.Pointer(fcc + uintptr(chr))))
		} else {
			*(*Tuint32_t)(unsafe.Pointer(list + 3*4)) = Tuint32_t(int32(chr) + (*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(chr)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(chr)%DUCD_BLOCK_SIZE])*12)).Fother_case)
		}

		// The othercase might be the same value.

		if chr == *(*Tuint32_t)(unsafe.Pointer(list + 3*4)) {
			*(*Tuint32_t)(unsafe.Pointer(list + 3*4)) = DNOTACHAR
		} else {
			*(*Tuint32_t)(unsafe.Pointer(list + 4*4)) = DNOTACHAR
		}
		return code

	case OP_PROP:
		fallthrough
	case OP_NOTPROP:
		if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code))) != DPT_CLIST {
			*(*Tuint32_t)(unsafe.Pointer(list + 2*4)) = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)))
			*(*Tuint32_t)(unsafe.Pointer(list + 3*4)) = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))
			return code + uintptr(2)
		}

		// Convert only if we have enough space.

		clist_src = uintptr(unsafe.Pointer(&X_pcre2_ucd_caseless_sets_8)) + uintptr(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))*4
		clist_dest = list + uintptr(2)*4
		code += uintptr(2)

		for __ccgo := true; __ccgo; __ccgo = *(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&clist_src, 4))) != DNOTACHAR {
			if clist_dest >= list+uintptr(8)*4 {
				// Early return if there is not enough space. This should never
				//        happen, since all clists are shorter than 5 character now.
				*(*Tuint32_t)(unsafe.Pointer(list + 2*4)) = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)))
				*(*Tuint32_t)(unsafe.Pointer(list + 3*4)) = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))
				return code
			}
			*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&clist_dest, 4))) = *(*Tuint32_t)(unsafe.Pointer(clist_src))
		}

		// All characters are stored. The terminating NOTACHAR is copied from the
		//   clist itself.

		*(*Tuint32_t)(unsafe.Pointer(list)) = func() uint32 {
			if int32(c) == OP_PROP {
				return OP_CHAR
			}
			return OP_NOT
		}()
		return code

	case OP_NCLASS:
		fallthrough
	case OP_CLASS:
		fallthrough
	case OP_XCLASS:
		if int32(c) == OP_XCLASS {
			end = code + uintptr(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1))))) - uintptr(1)
		} else {
			end = code + uintptr(uint64(32)/uint64(unsafe.Sizeof(TPCRE2_UCHAR8(0))))
		}

		switch int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(end))) {
		case OP_CRSTAR:
			fallthrough
		case OP_CRMINSTAR:
			fallthrough
		case OP_CRQUERY:
			fallthrough
		case OP_CRMINQUERY:
			fallthrough
		case OP_CRPOSSTAR:
			fallthrough
		case OP_CRPOSQUERY:
			*(*Tuint32_t)(unsafe.Pointer(list + 1*4)) = Tuint32_t(DTRUE)
			end++
			break

		case OP_CRPLUS:
			fallthrough
		case OP_CRMINPLUS:
			fallthrough
		case OP_CRPOSPLUS:
			end++
			break

		case OP_CRRANGE:
			fallthrough
		case OP_CRMINRANGE:
			fallthrough
		case OP_CRPOSRANGE:
			*(*Tuint32_t)(unsafe.Pointer(list + 1*4)) = Tuint32_t(libc.Bool32(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(end + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(end + 2)))) == uint32(0)))
			end += TPCRE2_SPTR8(1 + 2*DIMM2_SIZE)
			break
		}
		*(*Tuint32_t)(unsafe.Pointer(list + 2*4)) = Tuint32_t((int64(end) - int64(code)) / 1)
		return end
	}

	return uintptr(0) // Opcode not accepted
}

// ************************************************
//
//    Scan further character sets for match       *
//

// Checks whether the base and the current opcode have a common character, in
// which case the base cannot be possessified.
//
// Arguments:
//   code        points to the byte code
//   utf         TRUE in UTF mode
//   ucp         TRUE in UCP mode
//   cb          compile data block
//   base_list   the data list of the base opcode
//   base_end    the end of the base opcode
//   rec_limit   points to recursion depth counter
//
// Returns:      TRUE if the auto-possessification is possible

func compare_opcodes(tls *libc.TLS, code TPCRE2_SPTR8, utf TBOOL, ucp TBOOL, cb uintptr, base_list uintptr, base_end TPCRE2_SPTR8, rec_limit uintptr) TBOOL { /* pcre2_auto_possess.c:536:1: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var c TPCRE2_UCHAR8
	// var list [8]Tuint32_t at bp, 32

	var chr_ptr uintptr
	var ochr_ptr uintptr
	var list_ptr uintptr
	var next_code TPCRE2_SPTR8
	var xclass_flags TPCRE2_SPTR8
	var class_bitset uintptr
	var set1 uintptr
	var set2 uintptr
	var set_end uintptr
	var chr Tuint32_t
	var accepted TBOOL
	var invert_bits TBOOL
	var entered_a_group TBOOL = DFALSE

	if libc.PreDecInt32(&*(*int32)(unsafe.Pointer(rec_limit)), 1) <= 0 {
		return DFALSE
	} // Recursion has gone too deep

	// Note: the base_list[1] contains whether the current opcode has a greedy
	// (represented by a non-zero value) quantifier. This is a different from
	// other character type lists, which store here that the character iterator
	// matches to an empty string (also represented by a non-zero value).

	for {
		// All operations move the code pointer forward.
		//   Therefore infinite recursions are not possible.

		c = *(*TPCRE2_UCHAR8)(unsafe.Pointer(code))

		// Skip over callouts

		if int32(c) == OP_CALLOUT {
			code += TPCRE2_SPTR8(X_pcre2_OP_lengths_8[c])
			continue
		}

		if int32(c) == OP_CALLOUT_STR {
			code += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 5)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 6)))))
			continue
		}

		// At the end of a branch, skip to the end of the group.

		if int32(c) == OP_ALT {
			for __ccgo := true; __ccgo; __ccgo = int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code))) == OP_ALT {
				code += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))))
			}
			c = *(*TPCRE2_UCHAR8)(unsafe.Pointer(code))
		}

		// Inspect the next opcode.

		switch int32(c) {
		// We can always possessify a greedy iterator at the end of the pattern,
		//     which is reached after skipping over the final OP_KET. A non-greedy
		//     iterator must never be possessified.

		case OP_END:
			return libc.Bool32(*(*Tuint32_t)(unsafe.Pointer(base_list + 1*4)) != Tuint32_t(0))

		// When an iterator is at the end of certain kinds of group we can inspect
		//     what follows the group by skipping over the closing ket. Note that this
		//     does not apply to OP_KETRMAX or OP_KETRMIN because what follows any given
		//     iteration is variable (could be another iteration or could be the next
		//     item). As these two opcodes are not listed in the next switch, they will
		//     end up as the next code to inspect, and return FALSE by virtue of being
		//     unsupported.

		case OP_KET:
			fallthrough
		case OP_KETRPOS:
			// The non-greedy case cannot be converted to a possessive form.

			if *(*Tuint32_t)(unsafe.Pointer(base_list + 1*4)) == Tuint32_t(0) {
				return DFALSE
			}

			// If the bracket is capturing it might be referenced by an OP_RECURSE
			//     so its last iterator can never be possessified if the pattern contains
			//     recursions. (This could be improved by keeping a list of group numbers that
			//     are called by recursion.)

			switch int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code - uintptr(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))))))) {
			case OP_CBRA:
				fallthrough
			case OP_SCBRA:
				fallthrough
			case OP_CBRAPOS:
				fallthrough
			case OP_SCBRAPOS:
				if (*Tcompile_block_8)(unsafe.Pointer(cb)).Fhad_recurse != 0 {
					return DFALSE
				}
				break

			// A script run might have to backtrack if the iterated item can match
			//       characters from more than one script. So give up unless repeating an
			//       explicit character.

			case OP_SCRIPT_RUN:
				if *(*Tuint32_t)(unsafe.Pointer(base_list)) != OP_CHAR && *(*Tuint32_t)(unsafe.Pointer(base_list)) != OP_CHARI {
					return DFALSE
				}
				break

			// Atomic sub-patterns and assertions can always auto-possessify their
			//       last iterator. However, if the group was entered as a result of checking
			//       a previous iterator, this is not possible.

			case OP_ASSERT:
				fallthrough
			case OP_ASSERT_NOT:
				fallthrough
			case OP_ASSERTBACK:
				fallthrough
			case OP_ASSERTBACK_NOT:
				fallthrough
			case OP_ONCE:
				return libc.BoolInt32(!(entered_a_group != 0))

			// Non-atomic assertions - don't possessify last iterator. This needs
			//       more thought.

			case OP_ASSERT_NA:
				fallthrough
			case OP_ASSERTBACK_NA:
				return DFALSE
			}

			// Skip over the bracket and inspect what comes next.

			code += TPCRE2_SPTR8(X_pcre2_OP_lengths_8[c])
			continue

		// Handle cases where the next item is a group.

		case OP_ONCE:
			fallthrough
		case OP_BRA:
			fallthrough
		case OP_CBRA:
			next_code = code + uintptr(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))))
			code += TPCRE2_SPTR8(X_pcre2_OP_lengths_8[c])

			// Check each branch. We have to recurse a level for all but the last
			//     branch.

			for int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(next_code))) == OP_ALT {
				if !(compare_opcodes(tls, code, utf, ucp, cb, base_list, base_end, rec_limit) != 0) {
					return DFALSE
				}
				code = next_code + uintptr(1) + uintptr(DLINK_SIZE)
				next_code += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(next_code + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(next_code + 2)))))
			}

			entered_a_group = DTRUE
			continue

		case OP_BRAZERO:
			fallthrough
		case OP_BRAMINZERO:

			next_code = code + uintptr(1)
			if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(next_code))) != OP_BRA && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(next_code))) != OP_CBRA && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(next_code))) != OP_ONCE {
				return DFALSE
			}

			for __ccgo1 := true; __ccgo1; __ccgo1 = int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(next_code))) == OP_ALT {
				next_code += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(next_code + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(next_code + 2)))))
			}

			// The bracket content will be checked by the OP_BRA/OP_CBRA case above.

			next_code += TPCRE2_SPTR8(1 + DLINK_SIZE)
			if !(compare_opcodes(tls, next_code, utf, ucp, cb, base_list, base_end,
				rec_limit) != 0) {
				return DFALSE
			}

			code += TPCRE2_SPTR8(X_pcre2_OP_lengths_8[c])
			continue

		// The next opcode does not need special handling; fall through and use it
		//     to see if the base can be possessified.

		default:
			break
		}

		// We now have the next appropriate opcode to compare with the base. Check
		//   for a supported opcode, and load its properties.

		code = get_chr_property_list(tls, code, utf, ucp, (*Tcompile_block_8)(unsafe.Pointer(cb)).Ffcc, bp)
		if code == uintptr(0) {
			return DFALSE
		} // Unsupported

		// If either opcode is a small character list, set pointers for comparing
		//   characters from that list with another list, or with a property.

		if *(*Tuint32_t)(unsafe.Pointer(base_list)) == OP_CHAR {
			chr_ptr = base_list + uintptr(2)*4
			list_ptr = bp /* &list[0] */
		} else if *(*Tuint32_t)(unsafe.Pointer(bp)) == OP_CHAR {
			chr_ptr = bp + uintptr(2)*4
			list_ptr = base_list
		} else if *(*Tuint32_t)(unsafe.Pointer(base_list)) == OP_CLASS || *(*Tuint32_t)(unsafe.Pointer(bp)) == OP_CLASS ||

			!(utf != 0) && (*(*Tuint32_t)(unsafe.Pointer(base_list)) == OP_NCLASS || *(*Tuint32_t)(unsafe.Pointer(bp)) == OP_NCLASS) {
			if *(*Tuint32_t)(unsafe.Pointer(base_list)) == OP_CLASS || !(utf != 0) && *(*Tuint32_t)(unsafe.Pointer(base_list)) == OP_NCLASS {
				set1 = base_end - uintptr(*(*Tuint32_t)(unsafe.Pointer(base_list + 2*4)))
				list_ptr = bp /* &list[0] */
			} else {
				set1 = code - uintptr(*(*Tuint32_t)(unsafe.Pointer(bp + 2*4)))
				list_ptr = base_list
			}

			invert_bits = DFALSE
			switch *(*Tuint32_t)(unsafe.Pointer(list_ptr)) {
			case OP_CLASS:
				fallthrough
			case OP_NCLASS:
				set2 = func() uintptr {
					if list_ptr == bp {
						return code
					}
					return base_end
				}() - uintptr(*(*Tuint32_t)(unsafe.Pointer(list_ptr + 2*4)))
				break
				fallthrough

			case OP_XCLASS:
				xclass_flags = func() uintptr {
					if list_ptr == bp {
						return code
					}
					return base_end
				}() - uintptr(*(*Tuint32_t)(unsafe.Pointer(list_ptr + 2*4))) + uintptr(DLINK_SIZE)
				if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(xclass_flags)))&DXCL_HASPROP != 0 {
					return DFALSE
				}
				if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(xclass_flags)))&DXCL_MAP == 0 {
					// No bits are set for characters < 256.
					if *(*Tuint32_t)(unsafe.Pointer(bp + 1*4)) == Tuint32_t(0) {
						return libc.Bool32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(xclass_flags)))&DXCL_NOT == 0)
					}
					// Might be an empty repeat.
					continue
				}
				set2 = xclass_flags + uintptr(1)
				break
				fallthrough

			case OP_NOT_DIGIT:
				invert_bits = DTRUE
				fallthrough
			// Fall through
			case OP_DIGIT:
				set2 = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fcbits + uintptr(Dcbit_digit)
				break
				fallthrough

			case OP_NOT_WHITESPACE:
				invert_bits = DTRUE
				fallthrough
			// Fall through
			case OP_WHITESPACE:
				set2 = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fcbits + uintptr(Dcbit_space)
				break
				fallthrough

			case OP_NOT_WORDCHAR:
				invert_bits = DTRUE
				fallthrough
			// Fall through
			case OP_WORDCHAR:
				set2 = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fcbits + uintptr(Dcbit_word)
				break
				fallthrough

			default:
				return DFALSE
			}

			// Because the bit sets are unaligned bytes, we need to perform byte
			//     comparison here.

			set_end = set1 + uintptr(32)
			if invert_bits != 0 {
				for __ccgo2 := true; __ccgo2; __ccgo2 = set1 < set_end {
					if int32(*(*Tuint8_t)(unsafe.Pointer(libc.PostIncUintptr(&set1, 1)))) & ^int32(*(*Tuint8_t)(unsafe.Pointer(libc.PostIncUintptr(&set2, 1)))) != 0 {
						return DFALSE
					}
				}
			} else {
				for __ccgo3 := true; __ccgo3; __ccgo3 = set1 < set_end {
					if int32(*(*Tuint8_t)(unsafe.Pointer(libc.PostIncUintptr(&set1, 1))))&int32(*(*Tuint8_t)(unsafe.Pointer(libc.PostIncUintptr(&set2, 1)))) != 0 {
						return DFALSE
					}
				}
			}

			if *(*Tuint32_t)(unsafe.Pointer(bp + 1*4)) == Tuint32_t(0) {
				return DTRUE
			}
			// Might be an empty repeat.
			continue
		} else {
			var leftop Tuint32_t
			var rightop Tuint32_t

			leftop = *(*Tuint32_t)(unsafe.Pointer(base_list))
			rightop = *(*Tuint32_t)(unsafe.Pointer(bp))

			accepted = DFALSE // Always set in non-unicode case.
			if leftop == OP_PROP || leftop == OP_NOTPROP {
				if rightop == OP_EOD {
					accepted = DTRUE
				} else if rightop == OP_PROP || rightop == OP_NOTPROP {
					var n int32
					var p uintptr
					var same TBOOL = libc.Bool32(leftop == rightop)
					var lisprop TBOOL = libc.Bool32(leftop == OP_PROP)
					var risprop TBOOL = libc.Bool32(rightop == OP_PROP)
					var bothprop TBOOL = libc.Bool32(lisprop != 0 && risprop != 0)

					// There's a table that specifies how each combination is to be
					//         processed:
					//           0   Always return FALSE (never auto-possessify)
					//           1   Character groups are distinct (possessify if both are OP_PROP)
					//           2   Check character categories in the same group (general or particular)
					//           3   Return TRUE if the two opcodes are not the same
					//           ... see comments below
					//

					n = int32(*(*Tuint8_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&propposstab)) + uintptr(*(*Tuint32_t)(unsafe.Pointer(base_list + 2*4)))*14 + uintptr(*(*Tuint32_t)(unsafe.Pointer(bp + 2*4))))))
					switch n {
					case 0:
						break
						fallthrough
					case 1:
						accepted = bothprop
						break
						fallthrough
					case 2:
						accepted = libc.Bool32(libc.Bool32(*(*Tuint32_t)(unsafe.Pointer(base_list + 3*4)) == *(*Tuint32_t)(unsafe.Pointer(bp + 3*4))) != same)
						break
						fallthrough
					case 3:
						accepted = libc.BoolInt32(!(same != 0))
						break
						fallthrough

					case 4: // Left general category, right particular category
						accepted = libc.Bool32(risprop != 0 && int32(*(*Tuint8_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&catposstab)) + uintptr(*(*Tuint32_t)(unsafe.Pointer(base_list + 3*4)))*30 + uintptr(*(*Tuint32_t)(unsafe.Pointer(bp + 3*4)))))) == same)
						break
						fallthrough

					case 5: // Right general category, left particular category
						accepted = libc.Bool32(lisprop != 0 && int32(*(*Tuint8_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&catposstab)) + uintptr(*(*Tuint32_t)(unsafe.Pointer(bp + 3*4)))*30 + uintptr(*(*Tuint32_t)(unsafe.Pointer(base_list + 3*4)))))) == same)
						break
						fallthrough

					// This code is logically tricky. Think hard before fiddling with it.
					//           The posspropstab table has four entries per row. Each row relates to
					//           one of PCRE's special properties such as ALNUM or SPACE or WORD.
					//           Only WORD actually needs all four entries, but using repeats for the
					//           others means they can all use the same code below.
					//
					//           The first two entries in each row are Unicode general categories, and
					//           apply always, because all the characters they include are part of the
					//           PCRE character set. The third and fourth entries are a general and a
					//           particular category, respectively, that include one or more relevant
					//           characters. One or the other is used, depending on whether the check
					//           is for a general or a particular category. However, in both cases the
					//           category contains more characters than the specials that are defined
					//           for the property being tested against. Therefore, it cannot be used
					//           in a NOTPROP case.
					//
					//           Example: the row for WORD contains ucp_L, ucp_N, ucp_P, ucp_Po.
					//           Underscore is covered by ucp_P or ucp_Po.

					case 6:
						fallthrough // Left alphanum vs right general category
					case 7:
						fallthrough // Left space vs right general category
					case 8: // Left word vs right general category
						p = uintptr(unsafe.Pointer(&posspropstab)) + uintptr(n-6)*4
						accepted = libc.Bool32(risprop != 0 && lisprop == libc.Bool32(*(*Tuint32_t)(unsafe.Pointer(bp + 3*4)) != Tuint32_t(*(*Tuint8_t)(unsafe.Pointer(p))) && *(*Tuint32_t)(unsafe.Pointer(bp + 3*4)) != Tuint32_t(*(*Tuint8_t)(unsafe.Pointer(p + 1))) && (*(*Tuint32_t)(unsafe.Pointer(bp + 3*4)) != Tuint32_t(*(*Tuint8_t)(unsafe.Pointer(p + 2))) || !(lisprop != 0))))
						break
						fallthrough

					case 9:
						fallthrough // Right alphanum vs left general category
					case 10:
						fallthrough // Right space vs left general category
					case 11: // Right word vs left general category
						p = uintptr(unsafe.Pointer(&posspropstab)) + uintptr(n-9)*4
						accepted = libc.Bool32(lisprop != 0 && risprop == libc.Bool32(*(*Tuint32_t)(unsafe.Pointer(base_list + 3*4)) != Tuint32_t(*(*Tuint8_t)(unsafe.Pointer(p))) && *(*Tuint32_t)(unsafe.Pointer(base_list + 3*4)) != Tuint32_t(*(*Tuint8_t)(unsafe.Pointer(p + 1))) && (*(*Tuint32_t)(unsafe.Pointer(base_list + 3*4)) != Tuint32_t(*(*Tuint8_t)(unsafe.Pointer(p + 2))) || !(risprop != 0))))
						break
						fallthrough

					case 12:
						fallthrough // Left alphanum vs right particular category
					case 13:
						fallthrough // Left space vs right particular category
					case 14: // Left word vs right particular category
						p = uintptr(unsafe.Pointer(&posspropstab)) + uintptr(n-12)*4
						accepted = libc.Bool32(risprop != 0 && lisprop == libc.Bool32(*(*Tuint8_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&catposstab)) + uintptr(*(*Tuint8_t)(unsafe.Pointer(p)))*30 + uintptr(*(*Tuint32_t)(unsafe.Pointer(bp + 3*4))))) != 0 && *(*Tuint8_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&catposstab)) + uintptr(*(*Tuint8_t)(unsafe.Pointer(p + 1)))*30 + uintptr(*(*Tuint32_t)(unsafe.Pointer(bp + 3*4))))) != 0 && (*(*Tuint32_t)(unsafe.Pointer(bp + 3*4)) != Tuint32_t(*(*Tuint8_t)(unsafe.Pointer(p + 3))) || !(lisprop != 0))))
						break
						fallthrough

					case 15:
						fallthrough // Right alphanum vs left particular category
					case 16:
						fallthrough // Right space vs left particular category
					case 17: // Right word vs left particular category
						p = uintptr(unsafe.Pointer(&posspropstab)) + uintptr(n-15)*4
						accepted = libc.Bool32(lisprop != 0 && risprop == libc.Bool32(*(*Tuint8_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&catposstab)) + uintptr(*(*Tuint8_t)(unsafe.Pointer(p)))*30 + uintptr(*(*Tuint32_t)(unsafe.Pointer(base_list + 3*4))))) != 0 && *(*Tuint8_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&catposstab)) + uintptr(*(*Tuint8_t)(unsafe.Pointer(p + 1)))*30 + uintptr(*(*Tuint32_t)(unsafe.Pointer(base_list + 3*4))))) != 0 && (*(*Tuint32_t)(unsafe.Pointer(base_list + 3*4)) != Tuint32_t(*(*Tuint8_t)(unsafe.Pointer(p + 3))) || !(risprop != 0))))
						break
					}
				}
			} else {

				accepted = libc.Bool32(leftop >= OP_NOT_DIGIT && leftop <= OP_EXTUNI && rightop >= OP_NOT_DIGIT && rightop <= OP_DOLLM && *(*Tuint8_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&autoposstab)) + uintptr(leftop-OP_NOT_DIGIT)*21 + uintptr(rightop-OP_NOT_DIGIT))) != 0)
			}

			if !(accepted != 0) {
				return DFALSE
			}

			if *(*Tuint32_t)(unsafe.Pointer(bp + 1*4)) == Tuint32_t(0) {
				return DTRUE
			}
			// Might be an empty repeat.
			continue
		}

		// Control reaches here only if one of the items is a small character list.
		//   All characters are checked against the other side.

		for __ccgo4 := true; __ccgo4; __ccgo4 = *(*Tuint32_t)(unsafe.Pointer(chr_ptr)) != DNOTACHAR {
			chr = *(*Tuint32_t)(unsafe.Pointer(chr_ptr))

			switch *(*Tuint32_t)(unsafe.Pointer(list_ptr)) {
			case OP_CHAR:
				ochr_ptr = list_ptr + uintptr(2)*4
				for __ccgo5 := true; __ccgo5; __ccgo5 = *(*Tuint32_t)(unsafe.Pointer(ochr_ptr)) != DNOTACHAR {
					if chr == *(*Tuint32_t)(unsafe.Pointer(ochr_ptr)) {
						return DFALSE
					}
					ochr_ptr += 4
				}
				break

			case OP_NOT:
				ochr_ptr = list_ptr + uintptr(2)*4
				for __ccgo6 := true; __ccgo6; __ccgo6 = *(*Tuint32_t)(unsafe.Pointer(ochr_ptr)) != DNOTACHAR {
					if chr == *(*Tuint32_t)(unsafe.Pointer(ochr_ptr)) {
						break
					}
					ochr_ptr += 4
				}
				if *(*Tuint32_t)(unsafe.Pointer(ochr_ptr)) == DNOTACHAR {
					return DFALSE
				} // Not found
				break

			// Note that OP_DIGIT etc. are generated only when PCRE2_UCP is *not*
			//       set. When it is set, \d etc. are converted into OP_(NOT_)PROP codes.

			case OP_DIGIT:
				if chr < Tuint32_t(256) && int32(*(*Tuint8_t)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fctypes + uintptr(chr))))&Dctype_digit != 0 {
					return DFALSE
				}
				break

			case OP_NOT_DIGIT:
				if chr > Tuint32_t(255) || int32(*(*Tuint8_t)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fctypes + uintptr(chr))))&Dctype_digit == 0 {
					return DFALSE
				}
				break

			case OP_WHITESPACE:
				if chr < Tuint32_t(256) && int32(*(*Tuint8_t)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fctypes + uintptr(chr))))&Dctype_space != 0 {
					return DFALSE
				}
				break

			case OP_NOT_WHITESPACE:
				if chr > Tuint32_t(255) || int32(*(*Tuint8_t)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fctypes + uintptr(chr))))&Dctype_space == 0 {
					return DFALSE
				}
				break

			case OP_WORDCHAR:
				if chr < Tuint32_t(255) && int32(*(*Tuint8_t)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fctypes + uintptr(chr))))&Dctype_word != 0 {
					return DFALSE
				}
				break

			case OP_NOT_WORDCHAR:
				if chr > Tuint32_t(255) || int32(*(*Tuint8_t)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fctypes + uintptr(chr))))&Dctype_word == 0 {
					return DFALSE
				}
				break

			case OP_HSPACE:
				switch chr {
				case Tuint32_t('\011'):
					fallthrough
				case Tuint32_t('\040'):
					fallthrough
				case Tuint32_t(uint8('\xa0')):
					fallthrough
				case Tuint32_t(0x1680):
					fallthrough /* OGHAM SPACE MARK */
				case Tuint32_t(0x180e):
					fallthrough /* MONGOLIAN VOWEL SEPARATOR */
				case Tuint32_t(0x2000):
					fallthrough /* EN QUAD */
				case Tuint32_t(0x2001):
					fallthrough /* EM QUAD */
				case Tuint32_t(0x2002):
					fallthrough /* EN SPACE */
				case Tuint32_t(0x2003):
					fallthrough /* EM SPACE */
				case Tuint32_t(0x2004):
					fallthrough /* THREE-PER-EM SPACE */
				case Tuint32_t(0x2005):
					fallthrough /* FOUR-PER-EM SPACE */
				case Tuint32_t(0x2006):
					fallthrough /* SIX-PER-EM SPACE */
				case Tuint32_t(0x2007):
					fallthrough /* FIGURE SPACE */
				case Tuint32_t(0x2008):
					fallthrough /* PUNCTUATION SPACE */
				case Tuint32_t(0x2009):
					fallthrough /* THIN SPACE */
				case Tuint32_t(0x200A):
					fallthrough /* HAIR SPACE */
				case Tuint32_t(0x202f):
					fallthrough /* NARROW NO-BREAK SPACE */
				case Tuint32_t(0x205f):
					fallthrough /* MEDIUM MATHEMATICAL SPACE */
				case Tuint32_t(0x3000):
					return DFALSE
				default:
					break
				}
				break

			case OP_NOT_HSPACE:
				switch chr {
				case Tuint32_t('\011'):
					fallthrough
				case Tuint32_t('\040'):
					fallthrough
				case Tuint32_t(uint8('\xa0')):
					fallthrough
				case Tuint32_t(0x1680):
					fallthrough /* OGHAM SPACE MARK */
				case Tuint32_t(0x180e):
					fallthrough /* MONGOLIAN VOWEL SEPARATOR */
				case Tuint32_t(0x2000):
					fallthrough /* EN QUAD */
				case Tuint32_t(0x2001):
					fallthrough /* EM QUAD */
				case Tuint32_t(0x2002):
					fallthrough /* EN SPACE */
				case Tuint32_t(0x2003):
					fallthrough /* EM SPACE */
				case Tuint32_t(0x2004):
					fallthrough /* THREE-PER-EM SPACE */
				case Tuint32_t(0x2005):
					fallthrough /* FOUR-PER-EM SPACE */
				case Tuint32_t(0x2006):
					fallthrough /* SIX-PER-EM SPACE */
				case Tuint32_t(0x2007):
					fallthrough /* FIGURE SPACE */
				case Tuint32_t(0x2008):
					fallthrough /* PUNCTUATION SPACE */
				case Tuint32_t(0x2009):
					fallthrough /* THIN SPACE */
				case Tuint32_t(0x200A):
					fallthrough /* HAIR SPACE */
				case Tuint32_t(0x202f):
					fallthrough /* NARROW NO-BREAK SPACE */
				case Tuint32_t(0x205f):
					fallthrough /* MEDIUM MATHEMATICAL SPACE */
				case Tuint32_t(0x3000):
					break
				default:
					return DFALSE
				}
				break

			case OP_ANYNL:
				fallthrough
			case OP_VSPACE:
				switch chr {
				case Tuint32_t('\012'):
					fallthrough
				case Tuint32_t('\013'):
					fallthrough
				case Tuint32_t('\014'):
					fallthrough
				case Tuint32_t('\015'):
					fallthrough
				case Tuint32_t(uint8('\x85')):
					fallthrough
				case Tuint32_t(0x2028):
					fallthrough /* LINE SEPARATOR */
				case Tuint32_t(0x2029):
					return DFALSE
				default:
					break
				}
				break

			case OP_NOT_VSPACE:
				switch chr {
				case Tuint32_t('\012'):
					fallthrough
				case Tuint32_t('\013'):
					fallthrough
				case Tuint32_t('\014'):
					fallthrough
				case Tuint32_t('\015'):
					fallthrough
				case Tuint32_t(uint8('\x85')):
					fallthrough
				case Tuint32_t(0x2028):
					fallthrough /* LINE SEPARATOR */
				case Tuint32_t(0x2029):
					break
				default:
					return DFALSE
				}
				break

			case OP_DOLL:
				fallthrough
			case OP_EODN:
				switch chr {
				case Tuint32_t('\015'):
					fallthrough
				case Tuint32_t('\012'):
					fallthrough
				case Tuint32_t('\013'):
					fallthrough
				case Tuint32_t('\014'):
					fallthrough
				case Tuint32_t(uint8('\x85')):
					fallthrough
				case Tuint32_t(0x2028):
					fallthrough
				case Tuint32_t(0x2029):
					return DFALSE
				}
				break

			case OP_EOD: // Can always possessify before \z
				break

			case OP_PROP:
				fallthrough
			case OP_NOTPROP:
				if !(check_char_prop(tls, chr, *(*Tuint32_t)(unsafe.Pointer(list_ptr + 2*4)), *(*Tuint32_t)(unsafe.Pointer(list_ptr + 3*4)),
					libc.Bool32(*(*Tuint32_t)(unsafe.Pointer(list_ptr)) == OP_NOTPROP)) != 0) {
					return DFALSE
				}
				break

			case OP_NCLASS:
				if chr > Tuint32_t(255) {
					return DFALSE
				}
				fallthrough
			// Fall through

			case OP_CLASS:
				if chr > Tuint32_t(255) {
					break
				}
				class_bitset = func() uintptr {
					if list_ptr == bp {
						return code
					}
					return base_end
				}() - uintptr(*(*Tuint32_t)(unsafe.Pointer(list_ptr + 2*4)))
				if uint32(*(*Tuint8_t)(unsafe.Pointer(class_bitset + uintptr(chr>>3))))&(uint32(1)<<(chr&Tuint32_t(7))) != uint32(0) {
					return DFALSE
				}
				break

			case OP_XCLASS:
				if X_pcre2_xclass_8(tls, chr, func() uintptr {
					if list_ptr == bp {
						return code
					}
					return base_end
				}()-uintptr(*(*Tuint32_t)(unsafe.Pointer(list_ptr + 2*4)))+uintptr(DLINK_SIZE), utf) != 0 {
					return DFALSE
				}
				break

			default:
				return DFALSE
			}

			chr_ptr += 4
		}

		// At least one character must be matched from this opcode.

		if *(*Tuint32_t)(unsafe.Pointer(bp + 1*4)) == Tuint32_t(0) {
			return DTRUE
		}
	}
	return TBOOL(0)

	// Control never reaches here. There used to be a fail-save return FALSE; here,
	// but some compilers complain about an unreachable statement.
}

// ************************************************
//
//    Scan compiled regex for auto-possession     *
//

// Replaces single character iterations with their possessive alternatives
// if appropriate. This function modifies the compiled opcode! Hitting a
// non-existent opcode may indicate a bug in PCRE2, but it can also be caused if a
// bad UTF string was compiled with PCRE2_NO_UTF_CHECK. The rec_limit catches
// overly complicated or large patterns. In these cases, the check just stops,
// leaving the remainder of the pattern unpossessified.
//
// Arguments:
//   code        points to start of the byte code
//   cb          compile data block
//
// Returns:      0 for success
//               -1 if a non-existant opcode is encountered

func X_pcre2_auto_possessify_8(tls *libc.TLS, code uintptr, cb uintptr) int32 { /* pcre2_auto_possess.c:1132:1: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var c TPCRE2_UCHAR8
	var end TPCRE2_SPTR8
	var repeat_opcode uintptr
	// var list [8]Tuint32_t at bp, 32

	*(*int32)(unsafe.Pointer(bp + 32 /* rec_limit */)) = 1000 // Was 10,000 but clang+ASAN uses a lot of stack.
	var utf TBOOL = libc.Bool32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fexternal_options&DPCRE2_UTF != Tuint32_t(0))
	var ucp TBOOL = libc.Bool32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fexternal_options&DPCRE2_UCP != Tuint32_t(0))

	for {
		c = *(*TPCRE2_UCHAR8)(unsafe.Pointer(code))

		if int32(c) >= OP_TABLE_LENGTH {
			return -1
		} // Something gone wrong

		if int32(c) >= OP_STAR && int32(c) <= OP_TYPEPOSUPTO {
			c = TPCRE2_UCHAR8(int32(c) - (int32(get_repeat_base(tls, c)) - OP_STAR))
			if int32(c) <= OP_MINUPTO {
				end = get_chr_property_list(tls, code, utf, ucp, (*Tcompile_block_8)(unsafe.Pointer(cb)).Ffcc, bp)
			} else {
				end = uintptr(0)
			}
			*(*Tuint32_t)(unsafe.Pointer(bp + 1*4)) = Tuint32_t(libc.Bool32(int32(c) == OP_STAR || int32(c) == OP_PLUS || int32(c) == OP_QUERY || int32(c) == OP_UPTO))

			if end != uintptr(0) && compare_opcodes(tls, end, utf, ucp, cb, bp, end,
				bp+32) != 0 {
				switch int32(c) {
				case OP_STAR:
					*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)) += TPCRE2_UCHAR8(OP_POSSTAR - OP_STAR)
					break
					fallthrough

				case OP_MINSTAR:
					*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)) += TPCRE2_UCHAR8(OP_POSSTAR - OP_MINSTAR)
					break
					fallthrough

				case OP_PLUS:
					*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)) += TPCRE2_UCHAR8(OP_POSPLUS - OP_PLUS)
					break
					fallthrough

				case OP_MINPLUS:
					*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)) += TPCRE2_UCHAR8(OP_POSPLUS - OP_MINPLUS)
					break
					fallthrough

				case OP_QUERY:
					*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)) += TPCRE2_UCHAR8(OP_POSQUERY - OP_QUERY)
					break
					fallthrough

				case OP_MINQUERY:
					*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)) += TPCRE2_UCHAR8(OP_POSQUERY - OP_MINQUERY)
					break
					fallthrough

				case OP_UPTO:
					*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)) += TPCRE2_UCHAR8(OP_POSUPTO - OP_UPTO)
					break
					fallthrough

				case OP_MINUPTO:
					*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)) += TPCRE2_UCHAR8(OP_POSUPTO - OP_MINUPTO)
					break
				}
			}
			c = *(*TPCRE2_UCHAR8)(unsafe.Pointer(code))
		} else if int32(c) == OP_CLASS || int32(c) == OP_NCLASS || int32(c) == OP_XCLASS {
			if int32(c) == OP_XCLASS {
				repeat_opcode = code + uintptr(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))))
			} else {
				repeat_opcode = code + uintptr(1) + uintptr(uint64(32)/uint64(unsafe.Sizeof(TPCRE2_UCHAR8(0))))
			}

			c = *(*TPCRE2_UCHAR8)(unsafe.Pointer(repeat_opcode))
			if int32(c) >= OP_CRSTAR && int32(c) <= OP_CRMINRANGE {
				// The return from get_chr_property_list() will never be NULL when
				// code (aka c) is one of the three class opcodes. However, gcc with
				//       -fanalyzer notes that a NULL return is possible, and grumbles. Hence we
				//       put in a check.

				end = get_chr_property_list(tls, code, utf, ucp, (*Tcompile_block_8)(unsafe.Pointer(cb)).Ffcc, bp)
				*(*Tuint32_t)(unsafe.Pointer(bp + 1*4)) = Tuint32_t(libc.Bool32(int32(c)&1 == 0))

				if end != uintptr(0) && compare_opcodes(tls, end, utf, ucp, cb, bp, end, bp+32) != 0 {
					switch int32(c) {
					case OP_CRSTAR:
						fallthrough
					case OP_CRMINSTAR:
						*(*TPCRE2_UCHAR8)(unsafe.Pointer(repeat_opcode)) = OP_CRPOSSTAR
						break
						fallthrough

					case OP_CRPLUS:
						fallthrough
					case OP_CRMINPLUS:
						*(*TPCRE2_UCHAR8)(unsafe.Pointer(repeat_opcode)) = OP_CRPOSPLUS
						break
						fallthrough

					case OP_CRQUERY:
						fallthrough
					case OP_CRMINQUERY:
						*(*TPCRE2_UCHAR8)(unsafe.Pointer(repeat_opcode)) = OP_CRPOSQUERY
						break
						fallthrough

					case OP_CRRANGE:
						fallthrough
					case OP_CRMINRANGE:
						*(*TPCRE2_UCHAR8)(unsafe.Pointer(repeat_opcode)) = OP_CRPOSRANGE
						break
					}
				}
			}
			c = *(*TPCRE2_UCHAR8)(unsafe.Pointer(code))
		}

		switch int32(c) {
		case OP_END:
			return 0

		case OP_TYPESTAR:
			fallthrough
		case OP_TYPEMINSTAR:
			fallthrough
		case OP_TYPEPLUS:
			fallthrough
		case OP_TYPEMINPLUS:
			fallthrough
		case OP_TYPEQUERY:
			fallthrough
		case OP_TYPEMINQUERY:
			fallthrough
		case OP_TYPEPOSSTAR:
			fallthrough
		case OP_TYPEPOSPLUS:
			fallthrough
		case OP_TYPEPOSQUERY:
			if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1))) == OP_PROP || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1))) == OP_NOTPROP {
				code += uintptr(2)
			}
			break

		case OP_TYPEUPTO:
			fallthrough
		case OP_TYPEMINUPTO:
			fallthrough
		case OP_TYPEEXACT:
			fallthrough
		case OP_TYPEPOSUPTO:
			if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3))) == OP_PROP || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3))) == OP_NOTPROP {
				code += uintptr(2)
			}
			break

		case OP_CALLOUT_STR:
			code += uintptr(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 5)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 6)))))
			break

		case OP_XCLASS:
			code += uintptr(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))))
			break

		case OP_MARK:
			fallthrough
		case OP_COMMIT_ARG:
			fallthrough
		case OP_PRUNE_ARG:
			fallthrough
		case OP_SKIP_ARG:
			fallthrough
		case OP_THEN_ARG:
			code += uintptr(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))
			break
		}

		// Add in the fixed length from the table

		code += uintptr(X_pcre2_OP_lengths_8[c])

		// In UTF-8 and UTF-16 modes, opcodes that are followed by a character may be
		//   followed by a multi-byte character. The length in the table is a minimum, so
		//   we have to arrange to skip the extra code units.

		if utf != 0 {
			switch int32(c) {
			case OP_CHAR:
				fallthrough
			case OP_CHARI:
				fallthrough
			case OP_NOT:
				fallthrough
			case OP_NOTI:
				fallthrough
			case OP_STAR:
				fallthrough
			case OP_MINSTAR:
				fallthrough
			case OP_PLUS:
				fallthrough
			case OP_MINPLUS:
				fallthrough
			case OP_QUERY:
				fallthrough
			case OP_MINQUERY:
				fallthrough
			case OP_UPTO:
				fallthrough
			case OP_MINUPTO:
				fallthrough
			case OP_EXACT:
				fallthrough
			case OP_POSSTAR:
				fallthrough
			case OP_POSPLUS:
				fallthrough
			case OP_POSQUERY:
				fallthrough
			case OP_POSUPTO:
				fallthrough
			case OP_STARI:
				fallthrough
			case OP_MINSTARI:
				fallthrough
			case OP_PLUSI:
				fallthrough
			case OP_MINPLUSI:
				fallthrough
			case OP_QUERYI:
				fallthrough
			case OP_MINQUERYI:
				fallthrough
			case OP_UPTOI:
				fallthrough
			case OP_MINUPTOI:
				fallthrough
			case OP_EXACTI:
				fallthrough
			case OP_POSSTARI:
				fallthrough
			case OP_POSPLUSI:
				fallthrough
			case OP_POSQUERYI:
				fallthrough
			case OP_POSUPTOI:
				fallthrough
			case OP_NOTSTAR:
				fallthrough
			case OP_NOTMINSTAR:
				fallthrough
			case OP_NOTPLUS:
				fallthrough
			case OP_NOTMINPLUS:
				fallthrough
			case OP_NOTQUERY:
				fallthrough
			case OP_NOTMINQUERY:
				fallthrough
			case OP_NOTUPTO:
				fallthrough
			case OP_NOTMINUPTO:
				fallthrough
			case OP_NOTEXACT:
				fallthrough
			case OP_NOTPOSSTAR:
				fallthrough
			case OP_NOTPOSPLUS:
				fallthrough
			case OP_NOTPOSQUERY:
				fallthrough
			case OP_NOTPOSUPTO:
				fallthrough
			case OP_NOTSTARI:
				fallthrough
			case OP_NOTMINSTARI:
				fallthrough
			case OP_NOTPLUSI:
				fallthrough
			case OP_NOTMINPLUSI:
				fallthrough
			case OP_NOTQUERYI:
				fallthrough
			case OP_NOTMINQUERYI:
				fallthrough
			case OP_NOTUPTOI:
				fallthrough
			case OP_NOTMINUPTOI:
				fallthrough
			case OP_NOTEXACTI:
				fallthrough
			case OP_NOTPOSSTARI:
				fallthrough
			case OP_NOTPOSPLUSI:
				fallthrough
			case OP_NOTPOSQUERYI:
				fallthrough
			case OP_NOTPOSUPTOI:
				if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + libc.UintptrFromInt32(-1)))) >= 0xc0 {
					code += uintptr(X_pcre2_utf8_table4[uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + libc.UintptrFromInt32(-1))))&0x3f])
				}
				break
			}
		}
	}
	return int32(0)
}

// End of pcre2_auto_possess.c

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

var X_pcre2_default_tables_8 = [1088]Tuint8_t{

	// This table is a lower casing table.

	Tuint8_t(0), Tuint8_t(1), Tuint8_t(2), Tuint8_t(3), Tuint8_t(4), Tuint8_t(5), Tuint8_t(6), Tuint8_t(7),
	Tuint8_t(8), Tuint8_t(9), Tuint8_t(10), Tuint8_t(11), Tuint8_t(12), Tuint8_t(13), Tuint8_t(14), Tuint8_t(15),
	Tuint8_t(16), Tuint8_t(17), Tuint8_t(18), Tuint8_t(19), Tuint8_t(20), Tuint8_t(21), Tuint8_t(22), Tuint8_t(23),
	Tuint8_t(24), Tuint8_t(25), Tuint8_t(26), Tuint8_t(27), Tuint8_t(28), Tuint8_t(29), Tuint8_t(30), Tuint8_t(31),
	Tuint8_t(32), Tuint8_t(33), Tuint8_t(34), Tuint8_t(35), Tuint8_t(36), Tuint8_t(37), Tuint8_t(38), Tuint8_t(39),
	Tuint8_t(40), Tuint8_t(41), Tuint8_t(42), Tuint8_t(43), Tuint8_t(44), Tuint8_t(45), Tuint8_t(46), Tuint8_t(47),
	Tuint8_t(48), Tuint8_t(49), Tuint8_t(50), Tuint8_t(51), Tuint8_t(52), Tuint8_t(53), Tuint8_t(54), Tuint8_t(55),
	Tuint8_t(56), Tuint8_t(57), Tuint8_t(58), Tuint8_t(59), Tuint8_t(60), Tuint8_t(61), Tuint8_t(62), Tuint8_t(63),
	Tuint8_t(64), Tuint8_t(97), Tuint8_t(98), Tuint8_t(99), Tuint8_t(100), Tuint8_t(101), Tuint8_t(102), Tuint8_t(103),
	Tuint8_t(104), Tuint8_t(105), Tuint8_t(106), Tuint8_t(107), Tuint8_t(108), Tuint8_t(109), Tuint8_t(110), Tuint8_t(111),
	Tuint8_t(112), Tuint8_t(113), Tuint8_t(114), Tuint8_t(115), Tuint8_t(116), Tuint8_t(117), Tuint8_t(118), Tuint8_t(119),
	Tuint8_t(120), Tuint8_t(121), Tuint8_t(122), Tuint8_t(91), Tuint8_t(92), Tuint8_t(93), Tuint8_t(94), Tuint8_t(95),
	Tuint8_t(96), Tuint8_t(97), Tuint8_t(98), Tuint8_t(99), Tuint8_t(100), Tuint8_t(101), Tuint8_t(102), Tuint8_t(103),
	Tuint8_t(104), Tuint8_t(105), Tuint8_t(106), Tuint8_t(107), Tuint8_t(108), Tuint8_t(109), Tuint8_t(110), Tuint8_t(111),
	Tuint8_t(112), Tuint8_t(113), Tuint8_t(114), Tuint8_t(115), Tuint8_t(116), Tuint8_t(117), Tuint8_t(118), Tuint8_t(119),
	Tuint8_t(120), Tuint8_t(121), Tuint8_t(122), Tuint8_t(123), Tuint8_t(124), Tuint8_t(125), Tuint8_t(126), Tuint8_t(127),
	Tuint8_t(128), Tuint8_t(129), Tuint8_t(130), Tuint8_t(131), Tuint8_t(132), Tuint8_t(133), Tuint8_t(134), Tuint8_t(135),
	Tuint8_t(136), Tuint8_t(137), Tuint8_t(138), Tuint8_t(139), Tuint8_t(140), Tuint8_t(141), Tuint8_t(142), Tuint8_t(143),
	Tuint8_t(144), Tuint8_t(145), Tuint8_t(146), Tuint8_t(147), Tuint8_t(148), Tuint8_t(149), Tuint8_t(150), Tuint8_t(151),
	Tuint8_t(152), Tuint8_t(153), Tuint8_t(154), Tuint8_t(155), Tuint8_t(156), Tuint8_t(157), Tuint8_t(158), Tuint8_t(159),
	Tuint8_t(160), Tuint8_t(161), Tuint8_t(162), Tuint8_t(163), Tuint8_t(164), Tuint8_t(165), Tuint8_t(166), Tuint8_t(167),
	Tuint8_t(168), Tuint8_t(169), Tuint8_t(170), Tuint8_t(171), Tuint8_t(172), Tuint8_t(173), Tuint8_t(174), Tuint8_t(175),
	Tuint8_t(176), Tuint8_t(177), Tuint8_t(178), Tuint8_t(179), Tuint8_t(180), Tuint8_t(181), Tuint8_t(182), Tuint8_t(183),
	Tuint8_t(184), Tuint8_t(185), Tuint8_t(186), Tuint8_t(187), Tuint8_t(188), Tuint8_t(189), Tuint8_t(190), Tuint8_t(191),
	Tuint8_t(192), Tuint8_t(193), Tuint8_t(194), Tuint8_t(195), Tuint8_t(196), Tuint8_t(197), Tuint8_t(198), Tuint8_t(199),
	Tuint8_t(200), Tuint8_t(201), Tuint8_t(202), Tuint8_t(203), Tuint8_t(204), Tuint8_t(205), Tuint8_t(206), Tuint8_t(207),
	Tuint8_t(208), Tuint8_t(209), Tuint8_t(210), Tuint8_t(211), Tuint8_t(212), Tuint8_t(213), Tuint8_t(214), Tuint8_t(215),
	Tuint8_t(216), Tuint8_t(217), Tuint8_t(218), Tuint8_t(219), Tuint8_t(220), Tuint8_t(221), Tuint8_t(222), Tuint8_t(223),
	Tuint8_t(224), Tuint8_t(225), Tuint8_t(226), Tuint8_t(227), Tuint8_t(228), Tuint8_t(229), Tuint8_t(230), Tuint8_t(231),
	Tuint8_t(232), Tuint8_t(233), Tuint8_t(234), Tuint8_t(235), Tuint8_t(236), Tuint8_t(237), Tuint8_t(238), Tuint8_t(239),
	Tuint8_t(240), Tuint8_t(241), Tuint8_t(242), Tuint8_t(243), Tuint8_t(244), Tuint8_t(245), Tuint8_t(246), Tuint8_t(247),
	Tuint8_t(248), Tuint8_t(249), Tuint8_t(250), Tuint8_t(251), Tuint8_t(252), Tuint8_t(253), Tuint8_t(254), Tuint8_t(255),

	// This table is a case flipping table.

	Tuint8_t(0), Tuint8_t(1), Tuint8_t(2), Tuint8_t(3), Tuint8_t(4), Tuint8_t(5), Tuint8_t(6), Tuint8_t(7),
	Tuint8_t(8), Tuint8_t(9), Tuint8_t(10), Tuint8_t(11), Tuint8_t(12), Tuint8_t(13), Tuint8_t(14), Tuint8_t(15),
	Tuint8_t(16), Tuint8_t(17), Tuint8_t(18), Tuint8_t(19), Tuint8_t(20), Tuint8_t(21), Tuint8_t(22), Tuint8_t(23),
	Tuint8_t(24), Tuint8_t(25), Tuint8_t(26), Tuint8_t(27), Tuint8_t(28), Tuint8_t(29), Tuint8_t(30), Tuint8_t(31),
	Tuint8_t(32), Tuint8_t(33), Tuint8_t(34), Tuint8_t(35), Tuint8_t(36), Tuint8_t(37), Tuint8_t(38), Tuint8_t(39),
	Tuint8_t(40), Tuint8_t(41), Tuint8_t(42), Tuint8_t(43), Tuint8_t(44), Tuint8_t(45), Tuint8_t(46), Tuint8_t(47),
	Tuint8_t(48), Tuint8_t(49), Tuint8_t(50), Tuint8_t(51), Tuint8_t(52), Tuint8_t(53), Tuint8_t(54), Tuint8_t(55),
	Tuint8_t(56), Tuint8_t(57), Tuint8_t(58), Tuint8_t(59), Tuint8_t(60), Tuint8_t(61), Tuint8_t(62), Tuint8_t(63),
	Tuint8_t(64), Tuint8_t(97), Tuint8_t(98), Tuint8_t(99), Tuint8_t(100), Tuint8_t(101), Tuint8_t(102), Tuint8_t(103),
	Tuint8_t(104), Tuint8_t(105), Tuint8_t(106), Tuint8_t(107), Tuint8_t(108), Tuint8_t(109), Tuint8_t(110), Tuint8_t(111),
	Tuint8_t(112), Tuint8_t(113), Tuint8_t(114), Tuint8_t(115), Tuint8_t(116), Tuint8_t(117), Tuint8_t(118), Tuint8_t(119),
	Tuint8_t(120), Tuint8_t(121), Tuint8_t(122), Tuint8_t(91), Tuint8_t(92), Tuint8_t(93), Tuint8_t(94), Tuint8_t(95),
	Tuint8_t(96), Tuint8_t(65), Tuint8_t(66), Tuint8_t(67), Tuint8_t(68), Tuint8_t(69), Tuint8_t(70), Tuint8_t(71),
	Tuint8_t(72), Tuint8_t(73), Tuint8_t(74), Tuint8_t(75), Tuint8_t(76), Tuint8_t(77), Tuint8_t(78), Tuint8_t(79),
	Tuint8_t(80), Tuint8_t(81), Tuint8_t(82), Tuint8_t(83), Tuint8_t(84), Tuint8_t(85), Tuint8_t(86), Tuint8_t(87),
	Tuint8_t(88), Tuint8_t(89), Tuint8_t(90), Tuint8_t(123), Tuint8_t(124), Tuint8_t(125), Tuint8_t(126), Tuint8_t(127),
	Tuint8_t(128), Tuint8_t(129), Tuint8_t(130), Tuint8_t(131), Tuint8_t(132), Tuint8_t(133), Tuint8_t(134), Tuint8_t(135),
	Tuint8_t(136), Tuint8_t(137), Tuint8_t(138), Tuint8_t(139), Tuint8_t(140), Tuint8_t(141), Tuint8_t(142), Tuint8_t(143),
	Tuint8_t(144), Tuint8_t(145), Tuint8_t(146), Tuint8_t(147), Tuint8_t(148), Tuint8_t(149), Tuint8_t(150), Tuint8_t(151),
	Tuint8_t(152), Tuint8_t(153), Tuint8_t(154), Tuint8_t(155), Tuint8_t(156), Tuint8_t(157), Tuint8_t(158), Tuint8_t(159),
	Tuint8_t(160), Tuint8_t(161), Tuint8_t(162), Tuint8_t(163), Tuint8_t(164), Tuint8_t(165), Tuint8_t(166), Tuint8_t(167),
	Tuint8_t(168), Tuint8_t(169), Tuint8_t(170), Tuint8_t(171), Tuint8_t(172), Tuint8_t(173), Tuint8_t(174), Tuint8_t(175),
	Tuint8_t(176), Tuint8_t(177), Tuint8_t(178), Tuint8_t(179), Tuint8_t(180), Tuint8_t(181), Tuint8_t(182), Tuint8_t(183),
	Tuint8_t(184), Tuint8_t(185), Tuint8_t(186), Tuint8_t(187), Tuint8_t(188), Tuint8_t(189), Tuint8_t(190), Tuint8_t(191),
	Tuint8_t(192), Tuint8_t(193), Tuint8_t(194), Tuint8_t(195), Tuint8_t(196), Tuint8_t(197), Tuint8_t(198), Tuint8_t(199),
	Tuint8_t(200), Tuint8_t(201), Tuint8_t(202), Tuint8_t(203), Tuint8_t(204), Tuint8_t(205), Tuint8_t(206), Tuint8_t(207),
	Tuint8_t(208), Tuint8_t(209), Tuint8_t(210), Tuint8_t(211), Tuint8_t(212), Tuint8_t(213), Tuint8_t(214), Tuint8_t(215),
	Tuint8_t(216), Tuint8_t(217), Tuint8_t(218), Tuint8_t(219), Tuint8_t(220), Tuint8_t(221), Tuint8_t(222), Tuint8_t(223),
	Tuint8_t(224), Tuint8_t(225), Tuint8_t(226), Tuint8_t(227), Tuint8_t(228), Tuint8_t(229), Tuint8_t(230), Tuint8_t(231),
	Tuint8_t(232), Tuint8_t(233), Tuint8_t(234), Tuint8_t(235), Tuint8_t(236), Tuint8_t(237), Tuint8_t(238), Tuint8_t(239),
	Tuint8_t(240), Tuint8_t(241), Tuint8_t(242), Tuint8_t(243), Tuint8_t(244), Tuint8_t(245), Tuint8_t(246), Tuint8_t(247),
	Tuint8_t(248), Tuint8_t(249), Tuint8_t(250), Tuint8_t(251), Tuint8_t(252), Tuint8_t(253), Tuint8_t(254), Tuint8_t(255),

	// This table contains bit maps for various character classes. Each map is 32
	// bytes long and the bits run from the least significant end of each byte. The
	// classes that have their own maps are: space, xdigit, digit, upper, lower, word,
	// graph, print, punct, and cntrl. Other classes are built from combinations.

	Tuint8_t(0x00), Tuint8_t(0x3e), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x01), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), // space
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00),
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00),
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00),

	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0xff), Tuint8_t(0x03), // xdigit
	Tuint8_t(0x7e), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x7e), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00),
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00),
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00),

	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0xff), Tuint8_t(0x03), // digit
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00),
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00),
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00),

	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), // upper
	Tuint8_t(0xfe), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0x07), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00),
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00),
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00),

	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), // lower
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0xfe), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0x07),
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00),
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00),

	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0xff), Tuint8_t(0x03), // word
	Tuint8_t(0xfe), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0x87), Tuint8_t(0xfe), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0x07),
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00),
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00),

	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0xfe), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), // graph
	Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0x7f),
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00),
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00),

	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), // print
	Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0x7f),
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00),
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00),

	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0xfe), Tuint8_t(0xff), Tuint8_t(0x00), Tuint8_t(0xfc), // punct
	Tuint8_t(0x01), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0xf8), Tuint8_t(0x01), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x78),
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00),
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00),

	Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), // cntrl
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x80),
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00),
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00),

	// This table identifies various classes of character by individual bits:
	//   0x01   white space character
	//   0x02   letter
	//   0x04   lower case letter
	//   0x08   decimal digit
	//   0x10   alphanumeric or '_'

	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), //   0-  7
	Tuint8_t(0x00), Tuint8_t(0x01), Tuint8_t(0x01), Tuint8_t(0x01), Tuint8_t(0x01), Tuint8_t(0x01), Tuint8_t(0x00), Tuint8_t(0x00), //   8- 15
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), //  16- 23
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), //  24- 31
	Tuint8_t(0x01), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), //    - '
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), //  ( - /
	Tuint8_t(0x18), Tuint8_t(0x18), Tuint8_t(0x18), Tuint8_t(0x18), Tuint8_t(0x18), Tuint8_t(0x18), Tuint8_t(0x18), Tuint8_t(0x18), //  0 - 7
	Tuint8_t(0x18), Tuint8_t(0x18), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), //  8 - ?
	Tuint8_t(0x00), Tuint8_t(0x12), Tuint8_t(0x12), Tuint8_t(0x12), Tuint8_t(0x12), Tuint8_t(0x12), Tuint8_t(0x12), Tuint8_t(0x12), //  @ - G
	Tuint8_t(0x12), Tuint8_t(0x12), Tuint8_t(0x12), Tuint8_t(0x12), Tuint8_t(0x12), Tuint8_t(0x12), Tuint8_t(0x12), Tuint8_t(0x12), //  H - O
	Tuint8_t(0x12), Tuint8_t(0x12), Tuint8_t(0x12), Tuint8_t(0x12), Tuint8_t(0x12), Tuint8_t(0x12), Tuint8_t(0x12), Tuint8_t(0x12), //  P - W
	Tuint8_t(0x12), Tuint8_t(0x12), Tuint8_t(0x12), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x10), //  X - _
	Tuint8_t(0x00), Tuint8_t(0x16), Tuint8_t(0x16), Tuint8_t(0x16), Tuint8_t(0x16), Tuint8_t(0x16), Tuint8_t(0x16), Tuint8_t(0x16), //  ` - g
	Tuint8_t(0x16), Tuint8_t(0x16), Tuint8_t(0x16), Tuint8_t(0x16), Tuint8_t(0x16), Tuint8_t(0x16), Tuint8_t(0x16), Tuint8_t(0x16), //  h - o
	Tuint8_t(0x16), Tuint8_t(0x16), Tuint8_t(0x16), Tuint8_t(0x16), Tuint8_t(0x16), Tuint8_t(0x16), Tuint8_t(0x16), Tuint8_t(0x16), //  p - w
	Tuint8_t(0x16), Tuint8_t(0x16), Tuint8_t(0x16), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), //  x -127
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), // 128-135
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), // 136-143
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), // 144-151
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), // 152-159
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), // 160-167
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), // 168-175
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), // 176-183
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), // 184-191
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), // 192-199
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), // 200-207
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), // 208-215
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), // 216-223
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), // 224-231
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), // 232-239
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), // 240-247
	Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00), Tuint8_t(0x00)} /* pcre2_chartables.c:34:15 */ // 248-255

// End of pcre2_chartables.c

// ************************************************
//
//      Code parameters and static tables         *
//

// COMPILE_WORK_SIZE specifies the size of stack workspace, which is used in
// different ways in the different pattern scans. The parsing and group-
// identifying pre-scan uses it to handle nesting, and needs it to be 16-bit
// aligned for this. Having defined the size in code units, we set up
// C16_WORK_SIZE as the number of elements in the 16-bit vector.
//
// During the first compiling phase, when determining how much memory is required,
// the regex is partly compiled into this space, but the compiled parts are
// discarded as soon as they can be, so that hopefully there will never be an
// overrun. The code does, however, check for an overrun, which can occur for
// pathological patterns. The size of the workspace depends on LINK_SIZE because
// the length of compiled items varies with this.
//
// In the real compile phase, this workspace is not currently used.

// A uint32_t vector is used for caching information about the size of
// capturing groups, to improve performance. A default is created on the stack of
// this size.

// The overrun tests check for a slightly smaller size so that they detect the
// overrun before it actually does run off the end of the data block.

// This value determines the size of the initial vector that is used for
// remembering named groups during the pre-compile. It is allocated on the stack,
// but if it is too small, it is expanded, in a similar way to the workspace. The
// value is the number of slots in the list.

// The pre-compiling pass over the pattern creates a parsed pattern in a vector
// of uint32_t. For short patterns this lives on the stack, with this size. Heap
// memory is used for longer patterns.

// Maximum length value to check against when making sure that the variable
// that holds the compiled pattern length does not overflow. We make it a bit less
// than INT_MAX to allow for adding in group terminating code units, so that we
// don't have to check them every time.

// Code values for parsed patterns, which are stored in a vector of 32-bit
// unsigned ints. Values less than META_END are literal data values. The coding
// for identifying the item is in the top 16-bits, leaving 16 bits for the
// additional data that some of them need. The META_CODE, META_DATA, and META_DIFF
// macros are used to manipulate parsed pattern elements.
//
// NOTE: When these definitions are changed, the table of extra lengths for each
// code (meta_extra_lengths, just below) must be updated to remain in step.

// These must be kept together to make it easy to check that an assertion
// is present where expected in a conditional group.

// These cannot be conditions

// These must be kept in this order, with consecutive values, and the _ARG
// versions of COMMIT, PRUNE, SKIP, and THEN immediately after their non-argument
// versions.

// These must be kept in groups of adjacent 3 values, and all together.

// This is a special "meta code" that is used only to distinguish (*asr: from
// (*sr: in the table of aphabetic assertions. It is never stored in the parsed
// pattern because (*asr: is turned into (*sr:(*atomic: at that stage. There is
// therefore no need for it to have a length entry, so use a high value.

// Table of extra lengths for each of the meta codes. Must be kept in step with
// the definitions above. For some items these values are a basic length to which
// a variable amount has to be added.

var meta_extra_lengths = [64]uint8{
	uint8(0), // META_END
	uint8(0), // META_ALT
	uint8(0), // META_ATOMIC
	uint8(0), // META_BACKREF - more if group is >= 10
	uint8(1 + DSIZEOFFSET),
	uint8(1), // META_BIGVALUE
	uint8(3), // META_CALLOUT_NUMBER
	uint8(3 + DSIZEOFFSET),
	uint8(0),           // META_CAPTURE
	uint8(0),           // META_CIRCUMFLEX
	uint8(0),           // META_CLASS
	uint8(0),           // META_CLASS_EMPTY
	uint8(0),           // META_CLASS_EMPTY_NOT
	uint8(0),           // META_CLASS_END
	uint8(0),           // META_CLASS_NOT
	uint8(0),           // META_COND_ASSERT
	uint8(DSIZEOFFSET), // META_COND_DEFINE
	uint8(1 + DSIZEOFFSET),
	uint8(1 + DSIZEOFFSET),
	uint8(1 + DSIZEOFFSET),
	uint8(1 + DSIZEOFFSET),
	uint8(3),           // META_COND_VERSION
	uint8(0),           // META_DOLLAR
	uint8(0),           // META_DOT
	uint8(0),           // META_ESCAPE - more for ESC_P, ESC_p, ESC_g, ESC_k
	uint8(0),           // META_KET
	uint8(0),           // META_NOCAPTURE
	uint8(1),           // META_OPTIONS
	uint8(1),           // META_POSIX
	uint8(1),           // META_POSIX_NEG
	uint8(0),           // META_RANGE_ESCAPED
	uint8(0),           // META_RANGE_LITERAL
	uint8(DSIZEOFFSET), // META_RECURSE
	uint8(1 + DSIZEOFFSET),
	uint8(0),           // META_SCRIPT_RUN
	uint8(0),           // META_LOOKAHEAD
	uint8(0),           // META_LOOKAHEADNOT
	uint8(DSIZEOFFSET), // META_LOOKBEHIND
	uint8(DSIZEOFFSET), // META_LOOKBEHINDNOT
	uint8(0),           // META_LOOKAHEAD_NA
	uint8(DSIZEOFFSET), // META_LOOKBEHIND_NA
	uint8(1),           // META_MARK - plus the string length
	uint8(0),           // META_ACCEPT
	uint8(0),           // META_FAIL
	uint8(0),           // META_COMMIT
	uint8(1),           // META_COMMIT_ARG - plus the string length
	uint8(0),           // META_PRUNE
	uint8(1),           // META_PRUNE_ARG - plus the string length
	uint8(0),           // META_SKIP
	uint8(1),           // META_SKIP_ARG - plus the string length
	uint8(0),           // META_THEN
	uint8(1),           // META_THEN_ARG - plus the string length
	uint8(0),           // META_ASTERISK
	uint8(0),           // META_ASTERISK_PLUS
	uint8(0),           // META_ASTERISK_QUERY
	uint8(0),           // META_PLUS
	uint8(0),           // META_PLUS_PLUS
	uint8(0),           // META_PLUS_QUERY
	uint8(0),           // META_QUERY
	uint8(0),           // META_QUERY_PLUS
	uint8(0),           // META_QUERY_QUERY
	uint8(2),           // META_MINMAX
	uint8(2),           // META_MINMAX_PLUS
	uint8(2),           // META_MINMAX_QUERY
} /* pcre2_compile.c:306:22 */

// Macro for setting individual bits in class bitmaps. It took some
// experimenting to figure out how to stop gcc 5.3.0 from warning with
// -Wconversion. This version gets a warning:
//
//   #define SETBIT(a,b) a[(b)/8] |= (uint8_t)(1u << ((b)&7))
//
// Let's hope the apparently less efficient version isn't actually so bad if the
// compiler is clever with identical subexpressions.

// Values and flags for the unsigned xxcuflags variables that accompany xxcu
// variables, which are concerned with first and required code units. A value
// greater than or equal to REQ_NONE means "no code unit set"; otherwise the
// matching xxcu variable is set, and the low valued bits are relevant.

// These flags are used in the groupinfo vector.

// This simple test for a decimal digit works for both ASCII/Unicode and EBCDIC
// and is fast (a good compiler can turn it into a subtraction and unsigned
// comparison).

// Table to identify hex digits. The tables in chartables are dependent on the
// locale, and may mark arbitrary characters as digits. We want to recognize only
// 0-9, a-z, and A-Z as hex digits, which is why we have a private table here. It
// costs 256 bytes, but it is a lot faster than doing character value tests (at
// least in some simple cases I timed), and in some applications one wants PCRE2
// to compile efficiently as well as match efficiently. The value in the table is
// the binary hex digit value, or 0xff for non-hex digits.

// This is the "normal" case, for ASCII systems, and EBCDIC systems running in
// UTF-8 mode.

var xdigitab = [256]Tuint8_t{
	Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), //   0-  7
	Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), //   8- 15
	Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), //  16- 23
	Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), //  24- 31
	Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), //    - '
	Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), //  ( - /
	Tuint8_t(0x00), Tuint8_t(0x01), Tuint8_t(0x02), Tuint8_t(0x03), Tuint8_t(0x04), Tuint8_t(0x05), Tuint8_t(0x06), Tuint8_t(0x07), //  0 - 7
	Tuint8_t(0x08), Tuint8_t(0x09), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), //  8 - ?
	Tuint8_t(0xff), Tuint8_t(0x0a), Tuint8_t(0x0b), Tuint8_t(0x0c), Tuint8_t(0x0d), Tuint8_t(0x0e), Tuint8_t(0x0f), Tuint8_t(0xff), //  @ - G
	Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), //  H - O
	Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), //  P - W
	Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), //  X - _
	Tuint8_t(0xff), Tuint8_t(0x0a), Tuint8_t(0x0b), Tuint8_t(0x0c), Tuint8_t(0x0d), Tuint8_t(0x0e), Tuint8_t(0x0f), Tuint8_t(0xff), //  ` - g
	Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), //  h - o
	Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), //  p - w
	Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), //  x -127
	Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), // 128-135
	Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), // 136-143
	Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), // 144-151
	Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), // 152-159
	Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), // 160-167
	Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), // 168-175
	Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), // 176-183
	Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), // 184-191
	Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), // 192-199
	Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), // 2ff-207
	Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), // 208-215
	Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), // 216-223
	Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), // 224-231
	Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), // 232-239
	Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), // 240-247
	Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff), Tuint8_t(0xff)} /* pcre2_compile.c:422:22 */ // 248-255

// Table for handling alphanumeric escaped characters. Positive returns are
// simple data values; negative values are for special things like \d and so on.
// Zero means further processing is needed (for things like \x), or the escape is
// invalid.

// This is the "normal" table for ASCII systems or for EBCDIC systems running
// in UTF-8 mode. It runs from '0' to 'z'.

var escapes = [75]int16{
	int16(0), int16(0),
	int16(0), int16(0),
	int16(0), int16(0),
	int16(0), int16(0),
	int16(0), int16(0),
	int16('\072'), int16('\073'),
	int16('\074'), int16('\075'),
	int16('\076'), int16('\077'),
	int16('\100'), int16(-ESC_A),
	int16(-ESC_B), int16(-ESC_C),
	int16(-ESC_D), int16(-ESC_E),
	int16(0), int16(-ESC_G),
	int16(-ESC_H), int16(0),
	int16(0), int16(-ESC_K),
	int16(0), int16(0),
	int16(-ESC_N), int16(0),
	int16(-ESC_P), int16(-ESC_Q),
	int16(-ESC_R), int16(-ESC_S),
	int16(0), int16(0),
	int16(-ESC_V), int16(-ESC_W),
	int16(-ESC_X), int16(0),
	int16(-ESC_Z), int16('\133'),
	int16('\134'), int16('\135'),
	int16('\136'), int16('\137'),
	int16('\140'), int16('\007'),
	int16(-ESC_b), int16(0),
	int16(-ESC_d), int16('\033'),
	int16('\014'), int16(0),
	int16(-ESC_h), int16(0),
	int16(0), int16(-ESC_k),
	int16(0), int16(0),
	int16('\012'), int16(0),
	int16(-ESC_p), int16(0),
	int16('\015'), int16(-ESC_s),
	int16('\011'), int16(0),
	int16(-ESC_v), int16(-ESC_w),
	int16(0), int16(0),
	int16(-ESC_z),
} /* pcre2_compile.c:511:24 */

// Table of special "verbs" like (*PRUNE). This is a short table, so it is
// searched linearly. Put all the names into a single string, in order to reduce
// the number of relocations when a shared library is dynamically linked. The
// string is built from string macros so that it works in UTF-8 mode on EBCDIC
// platforms.

type Sverbitem = struct {
	Flen     uint32
	Fmeta    Tuint32_t
	Fhas_arg int32
} /* pcre2_compile.c:602:9 */

// Table of special "verbs" like (*PRUNE). This is a short table, so it is
// searched linearly. Put all the names into a single string, in order to reduce
// the number of relocations when a shared library is dynamically linked. The
// string is built from string macros so that it works in UTF-8 mode on EBCDIC
// platforms.

type Tverbitem = Sverbitem /* pcre2_compile.c:606:3 */

var verbnames =
// Empty name is a shorthand for MARK

*(*[43]uint8)(unsafe.Pointer(ts)) /* pcre2_compile.c:608:19 */

var verbs = [9]Tverbitem{
	{Fmeta: DMETA_MARK, Fhas_arg: +1}, // > 0 => must have an argument
	{Flen: uint32(4), Fmeta: DMETA_MARK, Fhas_arg: +1},
	{Flen: uint32(6), Fmeta: DMETA_ACCEPT, Fhas_arg: -1}, // < 0 => Optional argument, convert to pre-MARK
	{Flen: uint32(1), Fmeta: DMETA_FAIL, Fhas_arg: -1},
	{Flen: uint32(4), Fmeta: DMETA_FAIL, Fhas_arg: -1},
	{Flen: uint32(6), Fmeta: DMETA_COMMIT},
	{Flen: uint32(5), Fmeta: DMETA_PRUNE}, // Optional argument; bump META code if found
	{Flen: uint32(4), Fmeta: DMETA_SKIP},
	{Flen: uint32(4), Fmeta: DMETA_THEN},
} /* pcre2_compile.c:619:23 */

var verbcount int32 = int32(uint64(unsafe.Sizeof(verbs)) / uint64(unsafe.Sizeof(Tverbitem{}))) /* pcre2_compile.c:631:18 */

// Verb opcodes, indexed by their META code offset from META_MARK.

var verbops = [11]Tuint32_t{
	OP_MARK, OP_ACCEPT, OP_FAIL, OP_COMMIT, OP_COMMIT_ARG, OP_PRUNE,
	OP_PRUNE_ARG, OP_SKIP, OP_SKIP_ARG, OP_THEN, OP_THEN_ARG} /* pcre2_compile.c:635:23 */

// Table of "alpha assertions" like (*pla:...), similar to the (*VERB) table.

type Salasitem = struct {
	Flen  uint32
	Fmeta Tuint32_t
} /* pcre2_compile.c:641:9 */

// Table of "alpha assertions" like (*pla:...), similar to the (*VERB) table.

type Talasitem = Salasitem /* pcre2_compile.c:644:3 */

var alasnames = *(*[210]uint8)(unsafe.Pointer(ts + 43)) /* pcre2_compile.c:646:19 */

var alasmeta = [17]Talasitem{
	{Flen: uint32(3), Fmeta: DMETA_LOOKAHEAD},
	{Flen: uint32(3), Fmeta: DMETA_LOOKBEHIND},
	{Flen: uint32(5), Fmeta: DMETA_LOOKAHEAD_NA},
	{Flen: uint32(5), Fmeta: DMETA_LOOKBEHIND_NA},
	{Flen: uint32(3), Fmeta: DMETA_LOOKAHEADNOT},
	{Flen: uint32(3), Fmeta: DMETA_LOOKBEHINDNOT},
	{Flen: uint32(18), Fmeta: DMETA_LOOKAHEAD},
	{Flen: uint32(19), Fmeta: DMETA_LOOKBEHIND},
	{Flen: uint32(29), Fmeta: DMETA_LOOKAHEAD_NA},
	{Flen: uint32(30), Fmeta: DMETA_LOOKBEHIND_NA},
	{Flen: uint32(18), Fmeta: DMETA_LOOKAHEADNOT},
	{Flen: uint32(19), Fmeta: DMETA_LOOKBEHINDNOT},
	{Flen: uint32(6), Fmeta: DMETA_ATOMIC},
	{Flen: uint32(2), Fmeta: DMETA_SCRIPT_RUN},         // sr = script run
	{Flen: uint32(3), Fmeta: DMETA_ATOMIC_SCRIPT_RUN},  // asr = atomic script run
	{Flen: uint32(10), Fmeta: DMETA_SCRIPT_RUN},        // script run
	{Flen: uint32(17), Fmeta: DMETA_ATOMIC_SCRIPT_RUN}, // atomic script run
} /* pcre2_compile.c:665:23 */

var alascount int32 = int32(uint64(unsafe.Sizeof(alasmeta)) / uint64(unsafe.Sizeof(Talasitem{}))) /* pcre2_compile.c:685:18 */

// Offsets from OP_STAR for case-independent and negative repeat opcodes.

var chartypeoffset = [4]Tuint32_t{
	Tuint32_t(OP_STAR - OP_STAR), Tuint32_t(OP_STARI - OP_STAR),
	Tuint32_t(OP_NOTSTAR - OP_STAR), Tuint32_t(OP_NOTSTARI - OP_STAR)} /* pcre2_compile.c:689:17 */

// Tables of names of POSIX character classes and their lengths. The names are
// now all in a single string, to reduce the number of relocations when a shared
// library is dynamically loaded. The list of lengths is terminated by a zero
// length entry. The first three must be alpha, lower, upper, as this is assumed
// for handling case independence. The indices for graph, print, and punct are
// needed, so identify them.

var posix_names = *(*[84]uint8)(unsafe.Pointer(ts + 253)) /* pcre2_compile.c:700:19 */

var posix_name_lengths = [15]Tuint8_t{
	Tuint8_t(5), Tuint8_t(5), Tuint8_t(5), Tuint8_t(5), Tuint8_t(5), Tuint8_t(5), Tuint8_t(5), Tuint8_t(5), Tuint8_t(5), Tuint8_t(5), Tuint8_t(5), Tuint8_t(5), Tuint8_t(4), Tuint8_t(6), Tuint8_t(0)} /* pcre2_compile.c:706:22 */

// Table of class bit maps for each POSIX class. Each class is formed from a
// base map, with an optional addition or removal of another map. Then, for some
// classes, there is some additional tweaking: for [:blank:] the vertical space
// characters are removed, and for [:alpha:] and [:alnum:] the underscore
// character is removed. The triples in the table consist of the base map offset,
// second map offset or -1 if no second map, and a non-negative value for map
// addition or a negative value for map subtraction (if there are two maps). The
// absolute value of the third field has these meanings: 0 => no tweaking, 1 =>
// remove vertical space characters, 2 => remove underscore.

var posix_class_maps = [42]int32{
	Dcbit_word, Dcbit_digit, -2, // alpha
	Dcbit_lower, -1, 0, // lower
	Dcbit_upper, -1, 0, // upper
	Dcbit_word, -1, 2, // alnum - word without underscore
	Dcbit_print, Dcbit_cntrl, 0, // ascii
	Dcbit_space, -1, 1, // blank - a GNU extension
	Dcbit_cntrl, -1, 0, // cntrl
	Dcbit_digit, -1, 0, // digit
	Dcbit_graph, -1, 0, // graph
	Dcbit_print, -1, 0, // print
	Dcbit_punct, -1, 0, // punct
	Dcbit_space, -1, 0, // space
	Dcbit_word, -1, 0, // word - a Perl extension
	Dcbit_xdigit, -1, 0, // xdigit
} /* pcre2_compile.c:723:18 */

// The POSIX class Unicode property substitutes that are used in UCP mode must
// be in the order of the POSIX class names, defined above.

var posix_substitutes = [28]int32{
	DPT_GC, ucp_L, // alpha
	DPT_PC, ucp_Ll, // lower
	DPT_PC, ucp_Lu, // upper
	DPT_ALNUM, 0, // alnum
	-1, 0, // ascii, treat as non-UCP
	-1, 1, // blank, treat as \h
	DPT_PC, ucp_Cc, // cntrl
	DPT_PC, ucp_Nd, // digit
	DPT_PXGRAPH, 0, // graph
	DPT_PXPRINT, 0, // print
	DPT_PXPUNCT, 0, // punct
	DPT_PXSPACE, 0, /* space */ // Xps is POSIX space, but from 8.34
	DPT_WORD, 0, /* word  */ // Perl and POSIX space are the same
	-1, 0, // xdigit, treat as non-UCP
} /* pcre2_compile.c:745:12 */ // Read integer value for depth limit

type Spso = struct {
	Fname   uintptr
	Flength Tuint16_t
	Ftype   Tuint16_t
	Fvalue  Tuint32_t
} /* pcre2_compile.c:822:9 */

// Read integer value for depth limit

type Tpso = Spso /* pcre2_compile.c:827:3 */

// NB: STRING_UTFn_RIGHTPAR contains the length as well

var pso_list = [21]Tpso{
	{Fname: uintptr(ts + 337), Flength: Tuint16_t(5), Fvalue: DPCRE2_UTF},
	{Fname: uintptr(ts + 343), Flength: Tuint16_t(4), Fvalue: DPCRE2_UTF},
	{Fname: uintptr(ts + 348), Flength: Tuint16_t(4), Fvalue: DPCRE2_UCP},
	{Fname: uintptr(ts + 353), Flength: Tuint16_t(9), Ftype: PSO_FLG, Fvalue: Tuint32_t(DPCRE2_NOTEMPTY_SET)},
	{Fname: uintptr(ts + 363), Flength: Tuint16_t(17), Ftype: PSO_FLG, Fvalue: Tuint32_t(DPCRE2_NE_ATST_SET)},
	{Fname: uintptr(ts + 381), Flength: Tuint16_t(16), Fvalue: DPCRE2_NO_AUTO_POSSESS},
	{Fname: uintptr(ts + 398), Flength: Tuint16_t(18), Fvalue: DPCRE2_NO_DOTSTAR_ANCHOR},
	{Fname: uintptr(ts + 417), Flength: Tuint16_t(7), Ftype: PSO_FLG, Fvalue: Tuint32_t(DPCRE2_NOJIT)},
	{Fname: uintptr(ts + 425), Flength: Tuint16_t(13), Fvalue: DPCRE2_NO_START_OPTIMIZE},
	{Fname: uintptr(ts + 439), Flength: Tuint16_t(11), Ftype: PSO_LIMH},
	{Fname: uintptr(ts + 451), Flength: Tuint16_t(12), Ftype: PSO_LIMM},
	{Fname: uintptr(ts + 464), Flength: Tuint16_t(12), Ftype: PSO_LIMD},
	{Fname: uintptr(ts + 477), Flength: Tuint16_t(16), Ftype: PSO_LIMD},
	{Fname: uintptr(ts + 494), Flength: Tuint16_t(3), Ftype: PSO_NL, Fvalue: Tuint32_t(DPCRE2_NEWLINE_CR)},
	{Fname: uintptr(ts + 498), Flength: Tuint16_t(3), Ftype: PSO_NL, Fvalue: Tuint32_t(DPCRE2_NEWLINE_LF)},
	{Fname: uintptr(ts + 502), Flength: Tuint16_t(5), Ftype: PSO_NL, Fvalue: Tuint32_t(DPCRE2_NEWLINE_CRLF)},
	{Fname: uintptr(ts + 508), Flength: Tuint16_t(4), Ftype: PSO_NL, Fvalue: Tuint32_t(DPCRE2_NEWLINE_ANY)},
	{Fname: uintptr(ts + 513), Flength: Tuint16_t(4), Ftype: PSO_NL, Fvalue: Tuint32_t(DPCRE2_NEWLINE_NUL)},
	{Fname: uintptr(ts + 518), Flength: Tuint16_t(8), Ftype: PSO_NL, Fvalue: Tuint32_t(DPCRE2_NEWLINE_ANYCRLF)},
	{Fname: uintptr(ts + 527), Flength: Tuint16_t(12), Ftype: PSO_BSR, Fvalue: Tuint32_t(DPCRE2_BSR_ANYCRLF)},
	{Fname: uintptr(ts + 540), Flength: Tuint16_t(12), Ftype: PSO_BSR, Fvalue: Tuint32_t(DPCRE2_BSR_UNICODE)},
} /* pcre2_compile.c:831:12 */

// This table is used when converting repeating opcodes into possessified
// versions as a result of an explicit possessive quantifier such as ++. A zero
// value means there is no possessified version - in those cases the item in
// question must be wrapped in ONCE brackets. The table is truncated at OP_CALLOUT
// because all relevant opcodes are less than that.

var opcode_possessify = [119]Tuint8_t{
	Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), // 0 - 15
	Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), // 16 - 31

	Tuint8_t(0),             // NOTI
	OP_POSSTAR, Tuint8_t(0), // STAR, MINSTAR
	OP_POSPLUS, Tuint8_t(0), // PLUS, MINPLUS
	OP_POSQUERY, Tuint8_t(0), // QUERY, MINQUERY
	OP_POSUPTO, Tuint8_t(0), // UPTO, MINUPTO
	Tuint8_t(0),                                        // EXACT
	Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), // POS{STAR,PLUS,QUERY,UPTO}

	OP_POSSTARI, Tuint8_t(0), // STARI, MINSTARI
	OP_POSPLUSI, Tuint8_t(0), // PLUSI, MINPLUSI
	OP_POSQUERYI, Tuint8_t(0), // QUERYI, MINQUERYI
	OP_POSUPTOI, Tuint8_t(0), // UPTOI, MINUPTOI
	Tuint8_t(0),                                        // EXACTI
	Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), // POS{STARI,PLUSI,QUERYI,UPTOI}

	OP_NOTPOSSTAR, Tuint8_t(0), // NOTSTAR, NOTMINSTAR
	OP_NOTPOSPLUS, Tuint8_t(0), // NOTPLUS, NOTMINPLUS
	OP_NOTPOSQUERY, Tuint8_t(0), // NOTQUERY, NOTMINQUERY
	OP_NOTPOSUPTO, Tuint8_t(0), // NOTUPTO, NOTMINUPTO
	Tuint8_t(0),                                        // NOTEXACT
	Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), // NOTPOS{STAR,PLUS,QUERY,UPTO}

	OP_NOTPOSSTARI, Tuint8_t(0), // NOTSTARI, NOTMINSTARI
	OP_NOTPOSPLUSI, Tuint8_t(0), // NOTPLUSI, NOTMINPLUSI
	OP_NOTPOSQUERYI, Tuint8_t(0), // NOTQUERYI, NOTMINQUERYI
	OP_NOTPOSUPTOI, Tuint8_t(0), // NOTUPTOI, NOTMINUPTOI
	Tuint8_t(0),                                        // NOTEXACTI
	Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), // NOTPOS{STARI,PLUSI,QUERYI,UPTOI}

	OP_TYPEPOSSTAR, Tuint8_t(0), // TYPESTAR, TYPEMINSTAR
	OP_TYPEPOSPLUS, Tuint8_t(0), // TYPEPLUS, TYPEMINPLUS
	OP_TYPEPOSQUERY, Tuint8_t(0), // TYPEQUERY, TYPEMINQUERY
	OP_TYPEPOSUPTO, Tuint8_t(0), // TYPEUPTO, TYPEMINUPTO
	Tuint8_t(0),                                        // TYPEEXACT
	Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), // TYPEPOS{STAR,PLUS,QUERY,UPTO}

	OP_CRPOSSTAR, Tuint8_t(0), // CRSTAR, CRMINSTAR
	OP_CRPOSPLUS, Tuint8_t(0), // CRPLUS, CRMINPLUS
	OP_CRPOSQUERY, Tuint8_t(0), // CRQUERY, CRMINQUERY
	OP_CRPOSRANGE, Tuint8_t(0), // CRRANGE, CRMINRANGE
	Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), // CRPOS{STAR,PLUS,QUERY,RANGE}

	Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), // CLASS, NCLASS, XCLASS
	Tuint8_t(0), Tuint8_t(0), // REF, REFI
	Tuint8_t(0), Tuint8_t(0), // DNREF, DNREFI
	Tuint8_t(0), Tuint8_t(0), // RECURSE, CALLOUT
} /* pcre2_compile.c:861:22 */

// ************************************************
//
//               Copy compiled code               *
//

// Compiled JIT code cannot be copied, so the new compiled block has no
// associated JIT data.

func Xpcre2_code_copy_8(tls *libc.TLS, code uintptr) uintptr { /* pcre2_compile.c:1193:27: */
	var ref_count uintptr
	var newcode uintptr

	if code == uintptr(0) {
		return uintptr(0)
	}
	newcode = (*struct {
		f func(*libc.TLS, Tsize_t, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_code_8)(unsafe.Pointer(code)).Fmemctl.Fmalloc})).f(tls, (*Tpcre2_code_8)(unsafe.Pointer(code)).Fblocksize, (*Tpcre2_code_8)(unsafe.Pointer(code)).Fmemctl.Fmemory_data)
	if newcode == uintptr(0) {
		return uintptr(0)
	}
	libc.Xmemcpy(tls, newcode, code, (*Tpcre2_code_8)(unsafe.Pointer(code)).Fblocksize)
	(*Tpcre2_code_8)(unsafe.Pointer(newcode)).Fexecutable_jit = uintptr(0)

	// If the code is one that has been deserialized, increment the reference count
	// in the decoded tables.

	if (*Tpcre2_code_8)(unsafe.Pointer(code)).Fflags&Tuint32_t(DPCRE2_DEREF_TABLES) != Tuint32_t(0) {
		ref_count = (*Tpcre2_code_8)(unsafe.Pointer(code)).Ftables + uintptr(Dcbits_offset+Dcbit_length+256)
		*(*Tsize_t)(unsafe.Pointer(ref_count))++
	}

	return newcode
}

// ************************************************
//
//     Copy compiled code and character tables    *
//

// Compiled JIT code cannot be copied, so the new compiled block has no
// associated JIT data. This version of code_copy also makes a separate copy of
// the character tables.

func Xpcre2_code_copy_with_tables_8(tls *libc.TLS, code uintptr) uintptr { /* pcre2_compile.c:1227:27: */
	var ref_count uintptr
	var newcode uintptr
	var newtables uintptr

	if code == uintptr(0) {
		return uintptr(0)
	}
	newcode = (*struct {
		f func(*libc.TLS, Tsize_t, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_code_8)(unsafe.Pointer(code)).Fmemctl.Fmalloc})).f(tls, (*Tpcre2_code_8)(unsafe.Pointer(code)).Fblocksize, (*Tpcre2_code_8)(unsafe.Pointer(code)).Fmemctl.Fmemory_data)
	if newcode == uintptr(0) {
		return uintptr(0)
	}
	libc.Xmemcpy(tls, newcode, code, (*Tpcre2_code_8)(unsafe.Pointer(code)).Fblocksize)
	(*Tpcre2_code_8)(unsafe.Pointer(newcode)).Fexecutable_jit = uintptr(0)

	newtables = (*struct {
		f func(*libc.TLS, Tsize_t, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_code_8)(unsafe.Pointer(code)).Fmemctl.Fmalloc})).f(tls, uint64(Dcbits_offset+Dcbit_length+256)+uint64(unsafe.Sizeof(Tsize_t(0))),
		(*Tpcre2_code_8)(unsafe.Pointer(code)).Fmemctl.Fmemory_data)
	if newtables == uintptr(0) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_code_8)(unsafe.Pointer(code)).Fmemctl.Ffree})).f(tls, newcode, (*Tpcre2_code_8)(unsafe.Pointer(code)).Fmemctl.Fmemory_data)
		return uintptr(0)
	}
	libc.Xmemcpy(tls, newtables, (*Tpcre2_code_8)(unsafe.Pointer(code)).Ftables, uint64(Dcbits_offset+Dcbit_length+256))
	ref_count = newtables + uintptr(Dcbits_offset+Dcbit_length+256)
	*(*Tsize_t)(unsafe.Pointer(ref_count)) = uint64(1)

	(*Tpcre2_code_8)(unsafe.Pointer(newcode)).Ftables = newtables
	*(*Tuint32_t)(unsafe.Pointer(newcode + 96)) |= Tuint32_t(DPCRE2_DEREF_TABLES)
	return newcode
}

// ************************************************
//
//               Free compiled code               *
//

func Xpcre2_code_free_8(tls *libc.TLS, code uintptr) { /* pcre2_compile.c:1263:1: */
	var ref_count uintptr

	if code != uintptr(0) {
		if (*Tpcre2_code_8)(unsafe.Pointer(code)).Fexecutable_jit != uintptr(0) {
			X_pcre2_jit_free_8(tls, (*Tpcre2_code_8)(unsafe.Pointer(code)).Fexecutable_jit, code)
		}

		if (*Tpcre2_code_8)(unsafe.Pointer(code)).Fflags&Tuint32_t(DPCRE2_DEREF_TABLES) != Tuint32_t(0) {
			// Decoded tables belong to the codes after deserialization, and they must
			//     be freed when there are no more references to them. The *ref_count should
			//     always be > 0.

			ref_count = (*Tpcre2_code_8)(unsafe.Pointer(code)).Ftables + uintptr(Dcbits_offset+Dcbit_length+256)
			if *(*Tsize_t)(unsafe.Pointer(ref_count)) > uint64(0) {
				*(*Tsize_t)(unsafe.Pointer(ref_count))--
				if *(*Tsize_t)(unsafe.Pointer(ref_count)) == uint64(0) {
					(*struct {
						f func(*libc.TLS, uintptr, uintptr)
					})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_code_8)(unsafe.Pointer(code)).Fmemctl.Ffree})).f(tls, (*Tpcre2_code_8)(unsafe.Pointer(code)).Ftables, (*Tpcre2_code_8)(unsafe.Pointer(code)).Fmemctl.Fmemory_data)
				}
			}
		}

		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_code_8)(unsafe.Pointer(code)).Fmemctl.Ffree})).f(tls, code, (*Tpcre2_code_8)(unsafe.Pointer(code)).Fmemctl.Fmemory_data)
	}
}

// ************************************************
//
//         Read a number, possibly signed         *
//

// This function is used to read numbers in the pattern. The initial pointer
// must be the sign or first digit of the number. When relative values (introduced
// by + or -) are allowed, they are relative group numbers, and the result must be
// greater than zero.
//
// Arguments:
//   ptrptr      points to the character pointer variable
//   ptrend      points to the end of the input string
//   allow_sign  if < 0, sign not allowed; if >= 0, sign is relative to this
//   max_value   the largest number allowed
//   max_error   the error to give for an over-large number
//   intptr      where to put the result
//   errcodeptr  where to put an error code
//
// Returns:      TRUE  - a number was read
//               FALSE - errorcode == 0 => no number was found
//                       errorcode != 0 => an error occurred

func read_number(tls *libc.TLS, ptrptr uintptr, ptrend TPCRE2_SPTR8, allow_sign Tint32_t, max_value Tuint32_t, max_error Tuint32_t, intptr uintptr, errorcodeptr uintptr) TBOOL { /* pcre2_compile.c:1317:1: */
	var sign int32
	var n Tuint32_t
	var ptr TPCRE2_SPTR8
	var yield TBOOL
	sign = 0
	n = Tuint32_t(0)
	ptr = *(*TPCRE2_SPTR8)(unsafe.Pointer(ptrptr))
	yield = DFALSE

	*(*int32)(unsafe.Pointer(errorcodeptr)) = 0

	if !(allow_sign >= 0 && ptr < ptrend) {
		goto __1
	}

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr))) == '\053') {
		goto __2
	}

	sign = +1
	max_value = max_value - Tuint32_t(allow_sign)
	ptr++
	goto __3
__2:
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr))) == '\055') {
		goto __4
	}

	sign = -1
	ptr++
__4:
	;
__3:
	;
__1:
	;

	if !(ptr >= ptrend || !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr))) >= '\060' && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr))) <= '\071')) {
		goto __5
	}
	return DFALSE
__5:
	;
__6:
	if !(ptr < ptrend && (int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr))) >= '\060' && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr))) <= '\071')) {
		goto __7
	}

	n = n*Tuint32_t(10) + Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&ptr, 1)))) - Tuint32_t('\060')
	if !(n > max_value) {
		goto __8
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = int32(max_error)
	goto EXIT
__8:
	;
	goto __6
__7:
	;

	if !(allow_sign >= 0 && sign != 0) {
		goto __9
	}

	if !(n == Tuint32_t(0)) {
		goto __10
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR26 // +0 and -0 are not allowed
	goto EXIT
__10:
	;

	if !(sign > 0) {
		goto __11
	}
	n = n + Tuint32_t(allow_sign)
	goto __12
__11:
	if !(int32(n) > allow_sign) {
		goto __13
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR15 // Non-existent subpattern
	goto EXIT
	goto __14
__13:
	n = Tuint32_t(allow_sign+1) - n
__14:
	;
__12:
	;
__9:
	;

	yield = DTRUE

EXIT:
	*(*int32)(unsafe.Pointer(intptr)) = int32(n)
	*(*TPCRE2_SPTR8)(unsafe.Pointer(ptrptr)) = ptr
	return yield
}

// ************************************************
//
//         Read repeat counts                     *
//

// Read an item of the form {n,m} and return the values if non-NULL pointers
// are supplied. Repeat counts must be less than 65536 (MAX_REPEAT_COUNT); a
// larger value is used for "unlimited". We have to use signed arguments for
// read_number() because it is capable of returning a signed value.
//
// Arguments:
//   ptrptr         points to pointer to character after'{'
//   ptrend         pointer to end of input
//   minp           if not NULL, pointer to int for min
//   maxp           if not NULL, pointer to int for max (-1 if no max)
//                  returned as -1 if no max
//   errorcodeptr   points to error code variable
//
// Returns:         FALSE if not a repeat quantifier, errorcode set zero
//                  FALSE on error, with errorcode set non-zero
//                  TRUE on success, with pointer updated to point after '}'

func read_repeat_counts(tls *libc.TLS, ptrptr uintptr, ptrend TPCRE2_SPTR8, minp uintptr, maxp uintptr, errorcodeptr uintptr) TBOOL { /* pcre2_compile.c:1403:1: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var p TPCRE2_SPTR8 at bp, 8

	var yield TBOOL
	var had_comma TBOOL
	// var min Tint32_t at bp+8, 4

	// var max Tint32_t at bp+12, 4

	var c Tuint32_t
	yield = DFALSE
	had_comma = DFALSE
	*(*Tint32_t)(unsafe.Pointer(bp + 8 /* min */)) = 0
	*(*Tint32_t)(unsafe.Pointer(bp + 12 /* max */)) = int32(DMAX_REPEAT_COUNT + uint32(1)) // This value is larger than MAX_REPEAT_COUNT

	// Check the syntax

	*(*int32)(unsafe.Pointer(errorcodeptr)) = 0
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp /* p */)) = *(*TPCRE2_SPTR8)(unsafe.Pointer(ptrptr))
__1:
	;

	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp)) >= ptrend) {
		goto __4
	}
	return DFALSE
__4:
	;
	c = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp /* p */)))))
	if !(c >= Tuint32_t('\060') && c <= Tuint32_t('\071')) {
		goto __5
	}
	goto __2
__5:
	;
	if !(c == Tuint32_t('\175')) {
		goto __6
	}
	goto __3
__6:
	;
	if !(c == Tuint32_t('\054')) {
		goto __7
	}

	if !(had_comma != 0) {
		goto __9
	}
	return DFALSE
__9:
	;
	had_comma = DTRUE
	goto __8
__7:
	return DFALSE
__8:
	;
	goto __2
__2:
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp /* p */))++
	goto __1
	goto __3
__3:
	;

	// The only error from read_number() is for a number that is too big.

	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp /* p */)) = *(*TPCRE2_SPTR8)(unsafe.Pointer(ptrptr))
	if !!(read_number(tls, bp, ptrend, -1, DMAX_REPEAT_COUNT, ERR5, bp+8, errorcodeptr) != 0) {
		goto __10
	}
	goto EXIT
__10:
	;

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp))))) == '\175') {
		goto __11
	}

	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp /* p */))++
	*(*Tint32_t)(unsafe.Pointer(bp + 12 /* max */)) = *(*Tint32_t)(unsafe.Pointer(bp + 8 /* min */))
	goto __12
__11:

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PreIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp)), 1)))) != '\175') {
		goto __13
	}

	if !!(read_number(tls, bp, ptrend, -1, DMAX_REPEAT_COUNT, ERR5, bp+12,
		errorcodeptr) != 0) {
		goto __14
	}
	goto EXIT
__14:
	;
	if !(*(*Tint32_t)(unsafe.Pointer(bp + 12)) < *(*Tint32_t)(unsafe.Pointer(bp + 8))) {
		goto __15
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR4
	goto EXIT
__15:
	;
__13:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp /* p */))++
__12:
	;

	yield = DTRUE
	if !(minp != uintptr(0)) {
		goto __16
	}
	*(*Tuint32_t)(unsafe.Pointer(minp)) = Tuint32_t(*(*Tint32_t)(unsafe.Pointer(bp + 8 /* min */)))
__16:
	;
	if !(maxp != uintptr(0)) {
		goto __17
	}
	*(*Tuint32_t)(unsafe.Pointer(maxp)) = Tuint32_t(*(*Tint32_t)(unsafe.Pointer(bp + 12 /* max */)))
__17:
	;

	// Update the pattern pointer

EXIT:
	*(*TPCRE2_SPTR8)(unsafe.Pointer(ptrptr)) = *(*TPCRE2_SPTR8)(unsafe.Pointer(bp /* p */))
	return yield
}

// ************************************************
//
//            Handle escapes                      *
//

// This function is called when a \ has been encountered. It either returns a
// positive value for a simple escape such as \d, or 0 for a data character, which
// is placed in chptr. A backreference to group n is returned as negative n. On
// entry, ptr is pointing at the character after \. On exit, it points after the
// final code unit of the escape sequence.
//
// This function is also called from pcre2_substitute() to handle escape sequences
// in replacement strings. In this case, the cb argument is NULL, and in the case
// of escapes that have further processing, only sequences that define a data
// character are recognised. The isclass argument is not relevant; the options
// argument is the final value of the compiled pattern's options.
//
// Arguments:
//   ptrptr         points to the input position pointer
//   ptrend         points to the end of the input
//   chptr          points to a returned data character
//   errorcodeptr   points to the errorcode variable (containing zero)
//   options        the current options bits
//   isclass        TRUE if inside a character class
//   cb             compile data block or NULL when called from pcre2_substitute()
//
// Returns:         zero => a data character
//                  positive => a special escape sequence
//                  negative => a numerical back reference
//                  on error, errorcodeptr is set non-zero

func X_pcre2_check_escape_8(tls *libc.TLS, ptrptr uintptr, ptrend TPCRE2_SPTR8, chptr uintptr, errorcodeptr uintptr, options Tuint32_t, extra_options Tuint32_t, isclass TBOOL, cb uintptr) int32 { /* pcre2_compile.c:1502:1: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var utf TBOOL
	// var ptr TPCRE2_SPTR8 at bp+24, 8

	var c Tuint32_t
	var cc Tuint32_t
	var escape int32
	var i int32
	// var p TPCRE2_SPTR8 at bp, 8

	var hptr TPCRE2_SPTR8
	var xc Tuint32_t
	// var p1 TPCRE2_SPTR8 at bp+8, 8

	var xc1 Tuint32_t
	// var s int32 at bp+16, 4

	var oldptr TPCRE2_SPTR8
	var overflow TBOOL
	var alt_bsux TBOOL
	utf = libc.Bool32(options&DPCRE2_UTF != Tuint32_t(0))
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24 /* ptr */)) = *(*TPCRE2_SPTR8)(unsafe.Pointer(ptrptr))
	escape = 0

	// If backslash is at the end of the string, it's an error.

	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)) >= ptrend) {
		goto __1
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR1
	return 0
__1:
	;

	c = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24 /* ptr */)), 1))))
	if !(utf != 0 && c >= 0xc0) {
		goto __2
	}
	if !(c&0x20 == Tuint32_t(0)) {
		goto __3
	}
	c = c&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)), 1))))&0x3f
	goto __4
__3:
	if !(c&0x10 == Tuint32_t(0)) {
		goto __5
	}
	c = c&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)))))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)) + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24 /* ptr */)) += uintptr(2)
	goto __6
__5:
	if !(c&0x08 == Tuint32_t(0)) {
		goto __7
	}
	c = c&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)))))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)) + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)) + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24 /* ptr */)) += uintptr(3)
	goto __8
__7:
	if !(c&0x04 == Tuint32_t(0)) {
		goto __9
	}
	c = c&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)))))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)) + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)) + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)) + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24 /* ptr */)) += uintptr(4)
	goto __10
__9:
	c = c&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)))))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)) + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)) + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)) + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)) + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24 /* ptr */)) += uintptr(5)
__10:
	;
__8:
	;
__6:
	;
__4:
	;
__2:
	;

	// Get character value, increment pointer
	*(*int32)(unsafe.Pointer(errorcodeptr)) = 0 // Be optimistic

	// Non-alphanumerics are literals, so we just leave the value in c. An initial
	// value test saves a memory lookup for code points outside the alphanumeric
	// range.

	if !(c < Tuint32_t('\060') || c > Tuint32_t('\172')) {
		goto __11
	}
	goto __12
__11:
	if !(libc.AssignInt32(&i, int32(escapes[c-Tuint32_t('\060')])) != 0) {
		goto __13
	}

	if !(i > 0) {
		goto __15
	}

	c = Tuint32_t(i)
	if !(c == Tuint32_t('\015') && extra_options&DPCRE2_EXTRA_ESCAPED_CR_IS_LF != Tuint32_t(0)) {
		goto __17
	}
	c = Tuint32_t('\012')
__17:
	;
	goto __16
__15: /* Negative table entry */

	escape = -i // Else return a special escape
	if !(cb != uintptr(0) && (escape == ESC_P || escape == ESC_p || escape == ESC_X)) {
		goto __18
	}
	*(*Tuint32_t)(unsafe.Pointer(cb + 208)) |= Tuint32_t(DPCRE2_HASBKPORX)
__18:
	; // Note \P, \p, or \X

	// Perl supports \N{name} for character names and \N{U+dddd} for numerical
	//     Unicode code points, as well as plain \N for "not newline". PCRE does not
	//     support \N{name}. However, it does support quantification such as \N{2,3},
	//     so if \N{ is not followed by U+dddd we check for a quantifier.

	if !(escape == ESC_N && *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)) < ptrend && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24))))) == '\173') {
		goto __19
	}

	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp /* p */)) = *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)) + uintptr(1)

	// \N{U+ can be handled by the \x{ code. However, this construction is
	//       not valid in EBCDIC environments because it specifies a Unicode
	//       character, not a codepoint in the local code. For example \N{U+0041}
	//       must be "A" in all environments. Also, in Perl, \N{U+ forces Unicode
	//       casing semantics for the entire pattern, so allow it only in UTF (i.e.
	//       Unicode) mode.

	if !((int64(ptrend)-int64(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp))))/1 > int64(1) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp))))) == '\125' && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp)) + 1))) == '\053') {
		goto __20
	}

	if !(utf != 0) {
		goto __22
	}

	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24 /* ptr */)) = *(*TPCRE2_SPTR8)(unsafe.Pointer(bp)) + uintptr(1)
	escape = 0 // Not a fancy escape after all
	goto COME_FROM_NU
	goto __23
__22:
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR93
__23:
	;
	goto __21
__20:

	if !(!(read_repeat_counts(tls, bp, ptrend, uintptr(0), uintptr(0), errorcodeptr) != 0) && *(*int32)(unsafe.Pointer(errorcodeptr)) == 0) {
		goto __24
	}
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR37
__24:
	;
__21:
	;
__19:
	;
__16:
	;
	goto __14
__13:
	alt_bsux =
		libc.Bool32(options&DPCRE2_ALT_BSUX|extra_options&DPCRE2_EXTRA_ALT_BSUX != Tuint32_t(0))

	// Filter calls from pcre2_substitute().

	if !(cb == uintptr(0)) {
		goto __25
	}

	if !(c != Tuint32_t('\143') && c != Tuint32_t('\157') && c != Tuint32_t('\170')) {
		goto __26
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR3
	return 0
__26:
	;
	alt_bsux = DFALSE // Do not modify \x handling
__25:
	;

	switch c {
	// A number of Perl escapes are not handled by PCRE. We give an explicit
	//     error.

	case Tuint32_t('\106'):
		goto __28
	case Tuint32_t('\154'):
		goto __29
	case Tuint32_t('\114'):
		goto __30

	// \u is unrecognized when neither PCRE2_ALT_BSUX nor PCRE2_EXTRA_ALT_BSUX
	//     is set. Otherwise, \u must be followed by exactly four hex digits or, if
	//     PCRE2_EXTRA_ALT_BSUX is set, by any number of hex digits in braces.
	//     Otherwise it is a lowercase u letter. This gives some compatibility with
	//     ECMAScript (aka JavaScript).

	case Tuint32_t('\165'):
		goto __31

	// \U is unrecognized unless PCRE2_ALT_BSUX or PCRE2_EXTRA_ALT_BSUX is set,
	//     in which case it is an upper case letter.

	case Tuint32_t('\125'):
		goto __32

	// In a character class, \g is just a literal "g". Outside a character
	//     class, \g must be followed by one of a number of specific things:
	//
	//     (1) A number, either plain or braced. If positive, it is an absolute
	//     backreference. If negative, it is a relative backreference. This is a Perl
	//     5.10 feature.
	//
	//     (2) Perl 5.10 also supports \g{name} as a reference to a named group. This
	//     is part of Perl's movement towards a unified syntax for back references. As
	//     this is synonymous with \k{name}, we fudge it up by pretending it really
	//     was \k{name}.
	//
	//     (3) For Oniguruma compatibility we also support \g followed by a name or a
	//     number either in angle brackets or in single quotes. However, these are
	//     (possibly recursive) subroutine calls, _not_ backreferences. We return
	//     the ESC_g code.
	//
	//     Summary: Return a negative number for a numerical back reference, ESC_k for
	//     a named back reference, and ESC_g for a named or numbered subroutine call.
	//

	case Tuint32_t('\147'):
		goto __33

	// The handling of escape sequences consisting of a string of digits
	//     starting with one that is not zero is not straightforward. Perl has changed
	//     over the years. Nowadays \g{} for backreferences and \o{} for octal are
	//     recommended to avoid the ambiguities in the old syntax.
	//
	//     Outside a character class, the digits are read as a decimal number. If the
	//     number is less than 10, or if there are that many previous extracting left
	//     brackets, it is a back reference. Otherwise, up to three octal digits are
	//     read to form an escaped character code. Thus \123 is likely to be octal 123
	//     (cf \0123, which is octal 012 followed by the literal 3).
	//
	//     Inside a character class, \ followed by a digit is always either a literal
	//     8 or 9 or an octal number.

	case Tuint32_t('\061'):
		goto __34
	case Tuint32_t('\062'):
		goto __35
	case Tuint32_t('\063'):
		goto __36
	case Tuint32_t('\064'):
		goto __37
	case Tuint32_t('\065'):
		goto __38
	case Tuint32_t('\066'):
		goto __39
	case Tuint32_t('\067'):
		goto __40
	case Tuint32_t('\070'):
		goto __41
	case Tuint32_t('\071'):
		goto __42

	// Fall through

	// \0 always starts an octal number, but we may drop through to here with a
	//     larger first octal digit. The original code used just to take the least
	//     significant 8 bits of octal numbers (I think this is what early Perls used
	//     to do). Nowadays we allow for larger numbers in UTF-8 mode and 16-bit mode,
	//     but no more than 3 octal digits.

	case Tuint32_t('\060'):
		goto __43

	// \o is a relatively new Perl feature, supporting a more general way of
	//     specifying character codes in octal. The only supported form is \o{ddd}.

	case Tuint32_t('\157'):
		goto __44

	// When PCRE2_ALT_BSUX or PCRE2_EXTRA_ALT_BSUX is set, \x must be followed
	//     by two hexadecimal digits. Otherwise it is a lowercase x letter.

	case Tuint32_t('\170'):
		goto __45

	// The handling of \c is different in ASCII and EBCDIC environments. In an
	//     ASCII (or Unicode) environment, an error is given if the character
	//     following \c is not a printable ASCII character. Otherwise, the following
	//     character is upper-cased if it is a letter, and after that the 0x40 bit is
	//     flipped. The result is the value of the escape.
	//
	//     In an EBCDIC environment the handling of \c is compatible with the
	//     specification in the perlebcdic document. The following character must be
	//     a letter or one of small number of special characters. These provide a
	//     means of defining the character values 0-31.
	//
	//     For testing the EBCDIC handling of \c in an ASCII environment, recognize
	//     the EBCDIC value of 'c' explicitly.

	case Tuint32_t('\143'):
		goto __46

	// Any other alphanumeric following \ is an error. Perl gives an error only
	//     if in warning mode, but PCRE doesn't have a warning mode.

	default:
		goto __47
	}
	goto __27

	// A number of Perl escapes are not handled by PCRE. We give an explicit
	//     error.

__28:
__29:
__30:
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR37
	goto __27

	// \u is unrecognized when neither PCRE2_ALT_BSUX nor PCRE2_EXTRA_ALT_BSUX
	//     is set. Otherwise, \u must be followed by exactly four hex digits or, if
	//     PCRE2_EXTRA_ALT_BSUX is set, by any number of hex digits in braces.
	//     Otherwise it is a lowercase u letter. This gives some compatibility with
	//     ECMAScript (aka JavaScript).

__31:
	if !!(alt_bsux != 0) {
		goto __48
	}
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR37
	goto __49
__48:

	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)) >= ptrend) {
		goto __50
	}
	goto __27
__50:
	;
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24))))) == '\173' && extra_options&DPCRE2_EXTRA_ALT_BSUX != Tuint32_t(0)) {
		goto __51
	}

	hptr = *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)) + uintptr(1)
	cc = Tuint32_t(0)

__53:
	if !(hptr < ptrend && libc.AssignUint32(&xc, Tuint32_t(xdigitab[*(*TPCRE2_UCHAR8)(unsafe.Pointer(hptr))])) != Tuint32_t(0xff)) {
		goto __54
	}

	if !(cc&0xf0000000 != Tuint32_t(0)) {
		goto __55
	} /* Test for 32-bit overflow */

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR77
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24 /* ptr */)) = hptr // Show where
	goto __54                                                  // *hptr != } will cause another break below
__55:
	;
	cc = cc<<4 | xc
	hptr++
	goto __53
__54:
	;

	if !(hptr == *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24))+uintptr(1) || hptr >= ptrend || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(hptr))) != '\175') {
		goto __56
	} // No } terminator
	goto __27
__56:
	; // Hex escape not recognized

	c = cc // Accept the code point
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24 /* ptr */)) = hptr + uintptr(1)
	goto __52
__51: /* Must be exactly 4 hex digits */

	if !((int64(ptrend)-int64(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24))))/1 < int64(4)) {
		goto __57
	}
	goto __27
__57:
	; // Less than 4 chars
	if !(libc.AssignUint32(&cc, Tuint32_t(xdigitab[*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24))))])) == Tuint32_t(0xff)) {
		goto __58
	}
	goto __27
__58:
	; // Not a hex digit
	if !(libc.AssignUint32(&xc, Tuint32_t(xdigitab[*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)) + 1))])) == Tuint32_t(0xff)) {
		goto __59
	}
	goto __27
__59:
	; // Not a hex digit
	cc = cc<<4 | xc
	if !(libc.AssignUint32(&xc, Tuint32_t(xdigitab[*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)) + 2))])) == Tuint32_t(0xff)) {
		goto __60
	}
	goto __27
__60:
	; // Not a hex digit
	cc = cc<<4 | xc
	if !(libc.AssignUint32(&xc, Tuint32_t(xdigitab[*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)) + 3))])) == Tuint32_t(0xff)) {
		goto __61
	}
	goto __27
__61:
	; // Not a hex digit
	c = cc<<4 | xc
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24 /* ptr */)) += uintptr(4)
__52:
	;

	if !(utf != 0) {
		goto __62
	}

	if !(c > 0x10ffff) {
		goto __64
	}
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR77
	goto __65
__64:
	if !(c >= Tuint32_t(0xd800) && c <= Tuint32_t(0xdfff) && extra_options&DPCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES == Tuint32_t(0)) {
		goto __66
	}
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR73
__66:
	;
__65:
	;
	goto __63
__62:
	if !(c > uint32(0xffffffff)>>(32-DPCRE2_CODE_UNIT_WIDTH)) {
		goto __67
	}
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR77
__67:
	;
__63:
	;
__49:
	;
	goto __27

	// \U is unrecognized unless PCRE2_ALT_BSUX or PCRE2_EXTRA_ALT_BSUX is set,
	//     in which case it is an upper case letter.

__32:
	if !!(alt_bsux != 0) {
		goto __68
	}
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR37
__68:
	;
	goto __27

	// In a character class, \g is just a literal "g". Outside a character
	//     class, \g must be followed by one of a number of specific things:
	//
	//     (1) A number, either plain or braced. If positive, it is an absolute
	//     backreference. If negative, it is a relative backreference. This is a Perl
	//     5.10 feature.
	//
	//     (2) Perl 5.10 also supports \g{name} as a reference to a named group. This
	//     is part of Perl's movement towards a unified syntax for back references. As
	//     this is synonymous with \k{name}, we fudge it up by pretending it really
	//     was \k{name}.
	//
	//     (3) For Oniguruma compatibility we also support \g followed by a name or a
	//     number either in angle brackets or in single quotes. However, these are
	//     (possibly recursive) subroutine calls, _not_ backreferences. We return
	//     the ESC_g code.
	//
	//     Summary: Return a negative number for a numerical back reference, ESC_k for
	//     a named back reference, and ESC_g for a named or numbered subroutine call.
	//

__33:
	if !(isclass != 0) {
		goto __69
	}
	goto __27
__69:
	;

	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)) >= ptrend) {
		goto __70
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR57
	goto __27
__70:
	;

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24))))) == '\074' || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24))))) == '\047') {
		goto __71
	}

	escape = ESC_g
	goto __27
__71:
	;

	// If there is a brace delimiter, try to read a numerical reference. If
	//     there isn't one, assume we have a name and treat it as \k.

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24))))) == '\173') {
		goto __72
	}

	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* p1 */)) = *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)) + uintptr(1)
	if !!(read_number(tls, bp+8, ptrend, int32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount), DMAX_GROUP_NUMBER, ERR61, bp+16,
		errorcodeptr) != 0) {
		goto __74
	}

	if !(*(*int32)(unsafe.Pointer(errorcodeptr)) == 0) {
		goto __75
	}
	escape = ESC_k
__75:
	; // No number found
	goto __27
__74:
	;
	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) >= ptrend || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) != '\175') {
		goto __76
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR57
	goto __27
__76:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24 /* ptr */)) = *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + uintptr(1)
	goto __73
__72:

	if !!(read_number(tls, bp+24, ptrend, int32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount), DMAX_GROUP_NUMBER, ERR61, bp+16,
		errorcodeptr) != 0) {
		goto __77
	}

	if !(*(*int32)(unsafe.Pointer(errorcodeptr)) == 0) {
		goto __78
	}
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR57
__78:
	; // No number found
	goto __27
__77:
	;
__73:
	;

	if !(*(*int32)(unsafe.Pointer(bp + 16)) <= 0) {
		goto __79
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR15
	goto __27
__79:
	;

	escape = -*(*int32)(unsafe.Pointer(bp + 16 /* s */))
	goto __27

	// The handling of escape sequences consisting of a string of digits
	//     starting with one that is not zero is not straightforward. Perl has changed
	//     over the years. Nowadays \g{} for backreferences and \o{} for octal are
	//     recommended to avoid the ambiguities in the old syntax.
	//
	//     Outside a character class, the digits are read as a decimal number. If the
	//     number is less than 10, or if there are that many previous extracting left
	//     brackets, it is a back reference. Otherwise, up to three octal digits are
	//     read to form an escaped character code. Thus \123 is likely to be octal 123
	//     (cf \0123, which is octal 012 followed by the literal 3).
	//
	//     Inside a character class, \ followed by a digit is always either a literal
	//     8 or 9 or an octal number.

__34:
__35:
__36:
__37:
__38:
__39:
__40:
__41:
__42:

	if !!(isclass != 0) {
		goto __80
	}

	oldptr = *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24 /* ptr */))
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24 /* ptr */))-- // Back to the digit

	// As we know we are at a digit, the only possible error from
	//       read_number() is a number that is too large to be a group number. In this
	//       case we fall through handle this as not a group reference. If we have
	//       read a small enough number, check for a back reference.
	//
	//       \1 to \9 are always back references. \8x and \9x are too; \1x to \7x
	//       are octal escapes if there are not that many previous captures.

	if !(read_number(tls, bp+24, ptrend, -1, uint32(0x7fffffff/10-1), uint32(0), bp+16, errorcodeptr) != 0 && (*(*int32)(unsafe.Pointer(bp + 16)) < 10 || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(oldptr + libc.UintptrFromInt32(-1)))) >= '\070' || *(*int32)(unsafe.Pointer(bp + 16)) <= int32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount))) {
		goto __81
	}

	if !(*(*int32)(unsafe.Pointer(bp + 16)) > int32(DMAX_GROUP_NUMBER)) {
		goto __82
	}
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR61
	goto __83
__82:
	escape = -*(*int32)(unsafe.Pointer(bp + 16 /* s */))
__83:
	; // Indicates a back reference
	goto __27
__81:
	;

	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24 /* ptr */)) = oldptr // Put the pointer back and fall through
__80:
	;

	// Handle a digit following \ when the number is not a back reference, or
	//     we are within a character class. If the first digit is 8 or 9, Perl used to
	//     generate a binary zero and then treat the digit as a following literal. At
	//     least by Perl 5.18 this changed so as not to insert the binary zero.

	if !(c >= Tuint32_t('\070')) {
		goto __84
	}
	goto __27
__84:
	;

	// Fall through

	// \0 always starts an octal number, but we may drop through to here with a
	//     larger first octal digit. The original code used just to take the least
	//     significant 8 bits of octal numbers (I think this is what early Perls used
	//     to do). Nowadays we allow for larger numbers in UTF-8 mode and 16-bit mode,
	//     but no more than 3 octal digits.

__43:
	c = c - Tuint32_t('\060')
__85:
	if !(libc.PostIncInt32(&i, 1) < 2 && *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)) < ptrend && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24))))) >= '\060' && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24))))) <= '\067') {
		goto __86
	}
	c = c*Tuint32_t(8) + Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)), 1)))) - Tuint32_t('\060')
	goto __85
__86:
	;
	if !(!(utf != 0) && c > Tuint32_t(0xff)) {
		goto __87
	}
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR51
__87:
	;
	goto __27

	// \o is a relatively new Perl feature, supporting a more general way of
	//     specifying character codes in octal. The only supported form is \o{ddd}.

__44:
	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)) >= ptrend || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)), 1)))) != '\173') {
		goto __88
	}

	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24 /* ptr */))--
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR55
	goto __89
__88:
	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)) >= ptrend || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24))))) == '\175') {
		goto __90
	}
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR78
	goto __91
__90:

	c = Tuint32_t(0)
	overflow = DFALSE
__92:
	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)) < ptrend && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24))))) >= '\060' && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24))))) <= '\067') {
		goto __93
	}

	cc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24 /* ptr */)), 1))))
	if !(c == Tuint32_t(0) && cc == Tuint32_t('\060')) {
		goto __94
	}
	goto __92
__94:
	; // Leading zeroes
	c = c<<3 + (cc - Tuint32_t('\060'))
	if !(c > func() uint32 {
		if utf != 0 {
			return 0x10ffff
		}
		return 0xff
	}()) {
		goto __95
	}
	overflow = DTRUE
	goto __93
__95:
	;
	goto __92
__93:
	;
	if !(overflow != 0) {
		goto __96
	}

__98:
	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)) < ptrend && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24))))) >= '\060' && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24))))) <= '\067') {
		goto __99
	}
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24 /* ptr */))++
	goto __98
__99:
	;
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR34
	goto __97
__96:
	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)) < ptrend && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)), 1)))) == '\175') {
		goto __100
	}

	if !(utf != 0 && c >= Tuint32_t(0xd800) && c <= Tuint32_t(0xdfff) && extra_options&DPCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES == Tuint32_t(0)) {
		goto __102
	}

	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24 /* ptr */))--
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR73
__102:
	;
	goto __101
__100:

	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24 /* ptr */))--
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR64
__101:
	;
__97:
	;
__91:
	;
__89:
	;
	goto __27

	// When PCRE2_ALT_BSUX or PCRE2_EXTRA_ALT_BSUX is set, \x must be followed
	//     by two hexadecimal digits. Otherwise it is a lowercase x letter.

__45:
	if !(alt_bsux != 0) {
		goto __103
	}

	if !((int64(ptrend)-int64(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24))))/1 < int64(2)) {
		goto __105
	}
	goto __27
__105:
	; // Less than 2 characters
	if !(libc.AssignUint32(&cc, Tuint32_t(xdigitab[*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24))))])) == Tuint32_t(0xff)) {
		goto __106
	}
	goto __27
__106:
	; // Not a hex digit
	if !(libc.AssignUint32(&xc1, Tuint32_t(xdigitab[*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)) + 1))])) == Tuint32_t(0xff)) {
		goto __107
	}
	goto __27
__107:
	; // Not a hex digit
	c = cc<<4 | xc1
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24 /* ptr */)) += uintptr(2)
	goto __104
__103:

	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)) < ptrend && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24))))) == '\173') {
		goto __108
	}

COME_FROM_NU:
	if !(libc.PreIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)), 1) >= ptrend || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24))))) == '\175') {
		goto __110
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR78
	goto __27
__110:
	;
	c = Tuint32_t(0)
	overflow = DFALSE

__111:
	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)) < ptrend && libc.AssignUint32(&cc, Tuint32_t(xdigitab[*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24))))])) != Tuint32_t(0xff)) {
		goto __112
	}

	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24 /* ptr */))++
	if !(c == Tuint32_t(0) && cc == Tuint32_t(0)) {
		goto __113
	}
	goto __111
__113:
	; // Leading zeroes
	c = c<<4 | cc
	if !(utf != 0 && c > 0x10ffff || !(utf != 0) && c > uint32(0xffffffff)>>(32-DPCRE2_CODE_UNIT_WIDTH)) {
		goto __114
	}

	overflow = DTRUE
	goto __112
__114:
	;
	goto __111
__112:
	;

	if !(overflow != 0) {
		goto __115
	}

__117:
	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)) < ptrend && int32(xdigitab[*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24))))]) != 0xff) {
		goto __118
	}
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24 /* ptr */))++
	goto __117
__118:
	;
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR34
	goto __116
__115:
	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)) < ptrend && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)), 1)))) == '\175') {
		goto __119
	}

	if !(utf != 0 && c >= Tuint32_t(0xd800) && c <= Tuint32_t(0xdfff) && extra_options&DPCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES == Tuint32_t(0)) {
		goto __121
	}

	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24 /* ptr */))--
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR73
__121:
	;
	goto __120
__119:

	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24 /* ptr */))--
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR67
__120:
	;
__116:
	;
	goto __109
__108:

	c = Tuint32_t(0)
	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)) >= ptrend || libc.AssignUint32(&cc, Tuint32_t(xdigitab[*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24))))])) == Tuint32_t(0xff)) {
		goto __122
	}
	goto __27
__122:
	; // Not a hex digit
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24 /* ptr */))++
	c = cc
	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)) >= ptrend || libc.AssignUint32(&cc, Tuint32_t(xdigitab[*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24))))])) == Tuint32_t(0xff)) {
		goto __123
	}
	goto __27
__123:
	; // Not a hex digit
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24 /* ptr */))++
	c = c<<4 | cc
__109:
	; // End of \xdd handling
__104:
	; // End of Perl-style \x handling
	goto __27

	// The handling of \c is different in ASCII and EBCDIC environments. In an
	//     ASCII (or Unicode) environment, an error is given if the character
	//     following \c is not a printable ASCII character. Otherwise, the following
	//     character is upper-cased if it is a letter, and after that the 0x40 bit is
	//     flipped. The result is the value of the escape.
	//
	//     In an EBCDIC environment the handling of \c is compatible with the
	//     specification in the perlebcdic document. The following character must be
	//     a letter or one of small number of special characters. These provide a
	//     means of defining the character values 0-31.
	//
	//     For testing the EBCDIC handling of \c in an ASCII environment, recognize
	//     the EBCDIC value of 'c' explicitly.

__46:
	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)) >= ptrend) {
		goto __124
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR2
	goto __27
__124:
	;
	c = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24 /* ptr */)))))
	if !(c >= Tuint32_t('\141') && c <= Tuint32_t('\172')) {
		goto __125
	}
	c = c - Tuint32_t(32)
__125:
	;

	// Handle \c in an ASCII/Unicode environment.

	if !(c < Tuint32_t(32) || c > Tuint32_t(126)) {
		goto __126
	} /* Excludes all non-printable ASCII */

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR68
	goto __27
__126:
	;
	c = c ^ Tuint32_t(0x40)

	// Handle \c in an EBCDIC environment. The special case \c? is converted to
	//     255 (0xff) or 95 (0x5f) if other characters suggest we are using the
	//     POSIX-BC encoding. (This is the way Perl indicates that it handles \c?.)
	//     The other valid sequences correspond to a list of specific characters.

	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24 /* ptr */))++
	goto __27

	// Any other alphanumeric following \ is an error. Perl gives an error only
	//     if in warning mode, but PCRE doesn't have a warning mode.

__47:
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR3
	*(*TPCRE2_SPTR8)(unsafe.Pointer(ptrptr)) = *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)) - uintptr(1) // Point to the character at fault
	return 0
__27:
	;
__14:
	;
__12:
	;

	// Set the pointer to the next character before returning.

	*(*TPCRE2_SPTR8)(unsafe.Pointer(ptrptr)) = *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24 /* ptr */))
	*(*Tuint32_t)(unsafe.Pointer(chptr)) = c
	return escape
}

// ************************************************
//
//               Handle \P and \p                 *
//

// This function is called after \P or \p has been encountered, provided that
// PCRE2 is compiled with support for UTF and Unicode properties. On entry, the
// contents of ptrptr are pointing after the P or p. On exit, it is left pointing
// after the final code unit of the escape sequence.
//
// Arguments:
//   ptrptr         the pattern position pointer
//   negptr         a boolean that is set TRUE for negation else FALSE
//   ptypeptr       an unsigned int that is set to the type value
//   pdataptr       an unsigned int that is set to the detailed property value
//   errorcodeptr   the error code variable
//   cb             the compile data
//
// Returns:         TRUE if the type value was found, or FALSE for an invalid type

func get_ucp(tls *libc.TLS, ptrptr uintptr, negptr uintptr, ptypeptr uintptr, pdataptr uintptr, errorcodeptr uintptr, cb uintptr) TBOOL { /* pcre2_compile.c:2087:1: */
	bp := tls.Alloc(58)
	defer tls.Free(58)

	var c TPCRE2_UCHAR8
	var i Tsize_t
	var bot Tsize_t
	var top Tsize_t
	var ptr TPCRE2_SPTR8
	// var name [50]TPCRE2_UCHAR8 at bp, 50

	var vptr uintptr
	var ptscript Tuint16_t
	var offset int32
	// var sname [8]TPCRE2_UCHAR8 at bp+50, 8

	var r int32
	ptr = *(*TPCRE2_SPTR8)(unsafe.Pointer(ptrptr))
	vptr = uintptr(0)
	ptscript = Tuint16_t(DPT_NOTSCRIPT)

	if !(ptr >= (*Tcompile_block_8)(unsafe.Pointer(cb)).Fend_pattern) {
		goto __1
	}
	goto ERROR_RETURN
__1:
	;
	c = *(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&ptr, 1)))
	*(*TBOOL)(unsafe.Pointer(negptr)) = DFALSE

	// \P or \p can be followed by a name in {}, optionally preceded by ^ for
	// negation.

	if !(int32(c) == '\173') {
		goto __2
	}

	if !(ptr >= (*Tcompile_block_8)(unsafe.Pointer(cb)).Fend_pattern) {
		goto __4
	}
	goto ERROR_RETURN
__4:
	;

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr))) == '\136') {
		goto __5
	}

	*(*TBOOL)(unsafe.Pointer(negptr)) = DTRUE
	ptr++
__5:
	;

	i = uint64(0)
__6:
	if !(i < uint64(int32(uint64(unsafe.Sizeof([50]TPCRE2_UCHAR8{}))/uint64(unsafe.Sizeof(TPCRE2_UCHAR8(0))))-1)) {
		goto __8
	}

	if !(ptr >= (*Tcompile_block_8)(unsafe.Pointer(cb)).Fend_pattern) {
		goto __9
	}
	goto ERROR_RETURN
__9:
	;
	c = *(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&ptr, 1)))
__10:
	if !(int32(c) == '_' || int32(c) == '-' || int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(c))*2)))&int32(_ISspace) != 0) {
		goto __11
	}

	if !(ptr >= (*Tcompile_block_8)(unsafe.Pointer(cb)).Fend_pattern) {
		goto __12
	}
	goto ERROR_RETURN
__12:
	;
	c = *(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&ptr, 1)))
	goto __10
__11:
	;
	if !(int32(c) == 0) {
		goto __13
	}
	goto ERROR_RETURN
__13:
	;
	if !(int32(c) == '\175') {
		goto __14
	}
	goto __8
__14:
	;
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(bp + uintptr(i))) = TPCRE2_UCHAR8(libc.Xtolower(tls, int32(c)))
	if !((int32(c) == ':' || int32(c) == '=') && vptr == uintptr(0)) {
		goto __15
	}
	vptr = bp + uintptr(i)
__15:
	;
	goto __7
__7:
	i++
	goto __6
	goto __8
__8:
	;

	if !(int32(c) != '\175') {
		goto __16
	}
	goto ERROR_RETURN
__16:
	;
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(bp + uintptr(i))) = TPCRE2_UCHAR8(0)
	goto __3
__2:
	if !(1 != 0 && int32(*(*Tuint8_t)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fctypes + uintptr(c))))&Dctype_letter != 0) {
		goto __17
	}

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(bp)) = TPCRE2_UCHAR8(libc.Xtolower(tls, int32(c)))
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(bp + 1)) = TPCRE2_UCHAR8(0)
	goto __18
__17:
	goto ERROR_RETURN
__18:
	;
__3:
	;

	*(*TPCRE2_SPTR8)(unsafe.Pointer(ptrptr)) = ptr

	// If the property contains ':' or '=' we have class name and value separately
	// specified. The following are supported:
	//
	//   . Bidi_Class (synonym bc), for which the property names are "bidi<name>".
	//   . Script (synonym sc) for which the property name is the script name
	//   . Script_Extensions (synonym scx), ditto
	//
	// As this is a small number, we currently just check the names directly. If this
	// grows, a sorted table and a switch will be neater.
	//
	// For both the script properties, set a PT_xxx value so that (1) they can be
	// distinguished and (2) invalid script names that happen to be the name of
	// another property can be diagnosed.

	if !(vptr != uintptr(0)) {
		goto __19
	}

	offset = 0

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(vptr)) = TPCRE2_UCHAR8(0) // Terminate property name
	if !(X_pcre2_strcmp_c8_8(tls, bp, ts+553) == 0 || X_pcre2_strcmp_c8_8(tls, bp, ts+563) == 0) {
		goto __20
	}

	offset = 4
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(bp + 50)) = TPCRE2_UCHAR8('\142')
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(bp + 50 + 1)) = TPCRE2_UCHAR8('\151') // There is no strcpy_c8 function
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(bp + 50 + 2)) = TPCRE2_UCHAR8('\144')
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(bp + 50 + 3)) = TPCRE2_UCHAR8('\151')
	goto __21
__20:
	if !(X_pcre2_strcmp_c8_8(tls, bp, ts+566) == 0 || X_pcre2_strcmp_c8_8(tls, bp, ts+573) == 0) {
		goto __22
	}
	ptscript = Tuint16_t(DPT_SC)
	goto __23
__22:
	if !(X_pcre2_strcmp_c8_8(tls, bp, ts+576) == 0 || X_pcre2_strcmp_c8_8(tls, bp, ts+593) == 0) {
		goto __24
	}
	ptscript = Tuint16_t(DPT_SCX)
	goto __25
__24:

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR47
	return DFALSE
__25:
	;
__23:
	;
__21:
	;

	// Adjust the string in name[] as needed

	libc.Xmemmove(tls, bp+uintptr(offset), vptr+uintptr(1), uint64((int64(bp+uintptr(i))-int64(vptr))/1)*uint64(unsafe.Sizeof(TPCRE2_UCHAR8(0))))
	if !(offset != 0) {
		goto __26
	}
	libc.Xmemmove(tls, bp, bp+50, uint64(offset)*uint64(unsafe.Sizeof(TPCRE2_UCHAR8(0))))
__26:
	;
__19:
	;

	// Search for a recognized property using binary chop.

	bot = uint64(0)
	top = X_pcre2_utt_size_8

__27:
	if !(bot < top) {
		goto __28
	}

	i = (bot + top) >> 1
	r = X_pcre2_strcmp_c8_8(tls, bp, uintptr(unsafe.Pointer(&X_pcre2_utt_names_8))+uintptr(X_pcre2_utt_8[i].Fname_offset))

	// When a matching property is found, some extra checking is needed when the
	//   \p{xx:yy} syntax is used and xx is either sc or scx.

	if !(r == 0) {
		goto __29
	}

	*(*Tuint16_t)(unsafe.Pointer(pdataptr)) = X_pcre2_utt_8[i].Fvalue
	if !(vptr == uintptr(0) || int32(ptscript) == DPT_NOTSCRIPT) {
		goto __30
	}

	*(*Tuint16_t)(unsafe.Pointer(ptypeptr)) = X_pcre2_utt_8[i].Ftype
	return DTRUE
__30:
	;

	switch int32(X_pcre2_utt_8[i].Ftype) {
	case DPT_SC:
		goto __32

	case DPT_SCX:
		goto __33
	}
	goto __31

__32:
	*(*Tuint16_t)(unsafe.Pointer(ptypeptr)) = Tuint16_t(DPT_SC)
	return DTRUE

__33:
	*(*Tuint16_t)(unsafe.Pointer(ptypeptr)) = ptscript
	return DTRUE
__31:
	;

	goto __28 // Non-script found
__29:
	;

	if !(r > 0) {
		goto __34
	}
	bot = i + uint64(1)
	goto __35
__34:
	top = i
__35:
	;
	goto __27
__28:
	;

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR47 // Unrecognized property
	return DFALSE

ERROR_RETURN: // Malformed \P or \p
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR46
	*(*TPCRE2_SPTR8)(unsafe.Pointer(ptrptr)) = ptr
	return DFALSE
}

// ************************************************
//
//           Check for POSIX class syntax         *
//

// This function is called when the sequence "[:" or "[." or "[=" is
// encountered in a character class. It checks whether this is followed by a
// sequence of characters terminated by a matching ":]" or ".]" or "=]". If we
// reach an unescaped ']' without the special preceding character, return FALSE.
//
// Originally, this function only recognized a sequence of letters between the
// terminators, but it seems that Perl recognizes any sequence of characters,
// though of course unknown POSIX names are subsequently rejected. Perl gives an
// "Unknown POSIX class" error for [:f\oo:] for example, where previously PCRE
// didn't consider this to be a POSIX class. Likewise for [:1234:].
//
// The problem in trying to be exactly like Perl is in the handling of escapes. We
// have to be sure that [abc[:x\]pqr] is *not* treated as containing a POSIX
// class, but [abc[:x\]pqr:]] is (so that an error can be generated). The code
// below handles the special cases \\ and \], but does not try to do any other
// escape processing. This makes it different from Perl for cases such as
// [:l\ower:] where Perl recognizes it as the POSIX class "lower" but PCRE does
// not recognize "l\ower". This is a lesser evil than not diagnosing bad classes
// when Perl does, I think.
//
// A user pointed out that PCRE was rejecting [:a[:digit:]] whereas Perl was not.
// It seems that the appearance of a nested POSIX class supersedes an apparent
// external class. For example, [:a[:digit:]b:] matches "a", "b", ":", or
// a digit. This is handled by returning FALSE if the start of a new group with
// the same terminator is encountered, since the next closing sequence must close
// the nested group, not the outer one.
//
// In Perl, unescaped square brackets may also appear as part of class names. For
// example, [:a[:abc]b:] gives unknown POSIX class "[:abc]b:]". However, for
// [:a[:abc]b][b:] it gives unknown POSIX class "[:abc]b][b:]", which does not
// seem right at all. PCRE does not allow closing square brackets in POSIX class
// names.
//
// Arguments:
//   ptr      pointer to the character after the initial [ (colon, dot, equals)
//   ptrend   pointer to the end of the pattern
//   endptr   where to return a pointer to the terminating ':', '.', or '='
//
// Returns:   TRUE or FALSE

func check_posix_syntax(tls *libc.TLS, ptr TPCRE2_SPTR8, ptrend TPCRE2_SPTR8, endptr uintptr) TBOOL { /* pcre2_compile.c:2293:1: */
	var terminator TPCRE2_UCHAR8                                                 // Don't combine these lines; the Solaris cc
	terminator = *(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&ptr, 1))) // compiler warns about "non-constant" initializer.

	for ; (int64(ptrend)-int64(ptr))/1 >= int64(2); ptr++ {
		if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr))) == '\134' && (int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 1))) == '\135' || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 1))) == '\134') {
			ptr++
		} else if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr))) == '\133' && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 1))) == int32(terminator) || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr))) == '\135' {
			return DFALSE
		} else if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr))) == int32(terminator) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 1))) == '\135' {
			*(*TPCRE2_SPTR8)(unsafe.Pointer(endptr)) = ptr
			return DTRUE
		}
	}

	return DFALSE
}

// ************************************************
//
//          Check POSIX class name                *
//

// This function is called to check the name given in a POSIX-style class entry
// such as [:alnum:].
//
// Arguments:
//   ptr        points to the first letter
//   len        the length of the name
//
// Returns:     a value representing the name, or -1 if unknown

func check_posix_name(tls *libc.TLS, ptr TPCRE2_SPTR8, len int32) int32 { /* pcre2_compile.c:2334:1: */
	var pn uintptr = uintptr(unsafe.Pointer(&posix_names))
	var yield int32 = 0
	for int32(posix_name_lengths[yield]) != 0 {
		if len == int32(posix_name_lengths[yield]) && X_pcre2_strncmp_c8_8(tls, ptr, pn, uint64(uint32(len))) == 0 {
			return yield
		}
		pn += uintptr(int32(posix_name_lengths[yield]) + 1)
		yield++
	}
	return -1
}

// ************************************************
//
//       Read a subpattern or VERB name           *
//

// This function is called from parse_regex() below whenever it needs to read
// the name of a subpattern or a (*VERB) or an (*alpha_assertion). The initial
// pointer must be to the character before the name. If that character is '*' we
// are reading a verb or alpha assertion name. The pointer is updated to point
// after the name, for a VERB or alpha assertion name, or after tha name's
// terminator for a subpattern name. Returning both the offset and the name
// pointer is redundant information, but some callers use one and some the other,
// so it is simplest just to return both.
//
// Arguments:
//   ptrptr      points to the character pointer variable
//   ptrend      points to the end of the input string
//   utf         true if the input is UTF-encoded
//   terminator  the terminator of a subpattern name must be this
//   offsetptr   where to put the offset from the start of the pattern
//   nameptr     where to put a pointer to the name in the input
//   namelenptr  where to put the length of the name
//   errcodeptr  where to put an error code
//   cb          pointer to the compile data block
//
// Returns:    TRUE if a name was read
//             FALSE otherwise, with error code set

func read_name(tls *libc.TLS, ptrptr uintptr, ptrend TPCRE2_SPTR8, utf TBOOL, terminator Tuint32_t, offsetptr uintptr, nameptr uintptr, namelenptr uintptr, errorcodeptr uintptr, cb uintptr) TBOOL { /* pcre2_compile.c:2379:1: */
	var ptr TPCRE2_SPTR8
	var is_group TBOOL
	var c Tuint32_t
	var type1 Tuint32_t
	ptr = *(*TPCRE2_SPTR8)(unsafe.Pointer(ptrptr))
	is_group = libc.Bool32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr))) != '\052')

	if !(libc.PreIncUintptr(&ptr, 1) >= ptrend) {
		goto __1
	} /* No characters in name */

	*(*int32)(unsafe.Pointer(errorcodeptr)) = func() int32 {
		if is_group != 0 {
			return ERR62
		}
		return ERR60
	}() // Verb not recognized or malformed
	goto FAILED
__1:
	;

	*(*TPCRE2_SPTR8)(unsafe.Pointer(nameptr)) = ptr
	*(*Tsize_t)(unsafe.Pointer(offsetptr)) = Tsize_t((int64(ptr) - int64((*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_pattern)) / 1)

	// In UTF mode, a group name may contain letters and decimal digits as defined
	// by Unicode properties, and underscores, but must not start with a digit.

	if !(utf != 0 && is_group != 0) {
		goto __2
	}

	c = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr)))
	if !(c >= 0xc0) {
		goto __4
	}
	if !(c&0x20 == Tuint32_t(0)) {
		goto __5
	}
	c = c&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 1)))&0x3f
	goto __6
__5:
	if !(c&0x10 == Tuint32_t(0)) {
		goto __7
	}
	c = c&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 2)))&0x3f
	goto __8
__7:
	if !(c&0x08 == Tuint32_t(0)) {
		goto __9
	}
	c = c&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 3)))&0x3f
	goto __10
__9:
	if !(c&0x04 == Tuint32_t(0)) {
		goto __11
	}
	c = c&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 4)))&0x3f
	goto __12
__11:
	c = c&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 5)))&0x3f
__12:
	;
__10:
	;
__8:
	;
__6:
	;
__4:
	;

	type1 = Tuint32_t((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12)).Fchartype)

	if !(type1 == ucp_Nd) {
		goto __13
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR44
	goto FAILED
__13:
	;

__14:

	if !(type1 != ucp_Nd && X_pcre2_ucp_gentype_8[type1] != ucp_L && c != Tuint32_t('\137')) {
		goto __17
	}
	goto __16
__17:
	;
	ptr++
__18:
	if !(ptr < ptrend && uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr)))&0xc0 == 0x80) {
		goto __19
	}
	ptr++
	goto __18
__19:
	;
	if !(ptr >= ptrend) {
		goto __20
	}
	goto __16
__20:
	;
	c = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr)))
	if !(c >= 0xc0) {
		goto __21
	}
	if !(c&0x20 == Tuint32_t(0)) {
		goto __22
	}
	c = c&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 1)))&0x3f
	goto __23
__22:
	if !(c&0x10 == Tuint32_t(0)) {
		goto __24
	}
	c = c&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 2)))&0x3f
	goto __25
__24:
	if !(c&0x08 == Tuint32_t(0)) {
		goto __26
	}
	c = c&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 3)))&0x3f
	goto __27
__26:
	if !(c&0x04 == Tuint32_t(0)) {
		goto __28
	}
	c = c&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 4)))&0x3f
	goto __29
__28:
	c = c&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 5)))&0x3f
__29:
	;
__27:
	;
__25:
	;
__23:
	;
__21:
	;

	type1 = Tuint32_t((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12)).Fchartype)
	goto __15
__15:
	goto __14
	goto __16
__16:
	;
	goto __3
__2:

	/* Handle non-group names and group names in non-UTF modes. A group name must
	   not start with a digit. If either of the others start with a digit it just
	   won't be recognized. */

	if !(is_group != 0 && (int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr))) >= '\060' && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr))) <= '\071')) {
		goto __30
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR44
	goto FAILED
__30:
	;

__31:
	if !(ptr < ptrend && 1 != 0 && int32(*(*Tuint8_t)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fctypes + uintptr(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr))))))&Dctype_word != 0) {
		goto __32
	}

	ptr++
	goto __31
__32:
	;
__3:
	;

	// Check name length

	if !(ptr > *(*TPCRE2_SPTR8)(unsafe.Pointer(nameptr))+uintptr(DMAX_NAME_SIZE)) {
		goto __33
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR48
	goto FAILED
__33:
	;
	*(*Tuint32_t)(unsafe.Pointer(namelenptr)) = Tuint32_t((int64(ptr) - int64(*(*TPCRE2_SPTR8)(unsafe.Pointer(nameptr)))) / 1)

	// Subpattern names must not be empty, and their terminator is checked here.
	// (What follows a verb or alpha assertion name is checked separately.)

	if !(is_group != 0) {
		goto __34
	}

	if !(ptr == *(*TPCRE2_SPTR8)(unsafe.Pointer(nameptr))) {
		goto __35
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR62 // Subpattern name expected
	goto FAILED
__35:
	;
	if !(ptr >= ptrend || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr))) != int32(TPCRE2_UCHAR8(terminator))) {
		goto __36
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR42
	goto FAILED
__36:
	;
	ptr++
__34:
	;

	*(*TPCRE2_SPTR8)(unsafe.Pointer(ptrptr)) = ptr
	return DTRUE

FAILED:
	*(*TPCRE2_SPTR8)(unsafe.Pointer(ptrptr)) = ptr
	return DFALSE
}

// ************************************************
//
//          Manage callouts at start of cycle     *
//

// At the start of a new item in parse_regex() we are able to record the
// details of the previous item in a prior callout, and also to set up an
// automatic callout if enabled. Avoid having two adjacent automatic callouts,
// which would otherwise happen for items such as \Q that contribute nothing to
// the parsed pattern.
//
// Arguments:
//   ptr              current pattern pointer
//   pcalloutptr      points to a pointer to previous callout, or NULL
//   auto_callout     TRUE if auto_callouts are enabled
//   parsed_pattern   the parsed pattern pointer
//   cb               compile block
//
// Returns: possibly updated parsed_pattern pointer.

func manage_callouts(tls *libc.TLS, ptr TPCRE2_SPTR8, pcalloutptr uintptr, auto_callout TBOOL, parsed_pattern uintptr, cb uintptr) uintptr { /* pcre2_compile.c:2503:17: */
	var previous_callout uintptr = *(*uintptr)(unsafe.Pointer(pcalloutptr))

	if previous_callout != uintptr(0) {
		*(*Tuint32_t)(unsafe.Pointer(previous_callout + 2*4)) = Tuint32_t(Tsize_t((int64(ptr)-int64((*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_pattern))/1) - Tsize_t(*(*Tuint32_t)(unsafe.Pointer(previous_callout + 1*4))))
	}

	if !(auto_callout != 0) {
		previous_callout = uintptr(0)
	} else {
		if previous_callout == uintptr(0) || previous_callout != parsed_pattern-uintptr(4)*4 || *(*Tuint32_t)(unsafe.Pointer(previous_callout + 3*4)) != Tuint32_t(255) {
			previous_callout = parsed_pattern // Set up new automatic callout
			parsed_pattern += 4 * uintptr(4)
			*(*Tuint32_t)(unsafe.Pointer(previous_callout)) = DMETA_CALLOUT_NUMBER
			*(*Tuint32_t)(unsafe.Pointer(previous_callout + 2*4)) = Tuint32_t(0)
			*(*Tuint32_t)(unsafe.Pointer(previous_callout + 3*4)) = Tuint32_t(255)
		}
		*(*Tuint32_t)(unsafe.Pointer(previous_callout + 1*4)) = Tuint32_t((int64(ptr) - int64((*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_pattern)) / 1)
	}

	*(*uintptr)(unsafe.Pointer(pcalloutptr)) = previous_callout
	return parsed_pattern
}

// ************************************************
//
//      Parse regex and identify named groups     *
//

// This function is called first of all. It scans the pattern and does two
// things: (1) It identifies capturing groups and makes a table of named capturing
// groups so that information about them is fully available to both the compiling
// scans. (2) It writes a parsed version of the pattern with comments omitted and
// escapes processed into the parsed_pattern vector.
//
// Arguments:
//   ptr             points to the start of the pattern
//   options         compiling dynamic options (may change during the scan)
//   has_lookbehind  points to a boolean, set TRUE if a lookbehind is found
//   cb              pointer to the compile data block
//
// Returns:   zero on success or a non-zero error code, with the
//              error offset placed in the cb field

// A structure and some flags for dealing with nested groups.

type Snest_save = struct {
	Fnest_depth  Tuint16_t
	Freset_group Tuint16_t
	Fmax_group   Tuint16_t
	Fflags       Tuint16_t
	Foptions     Tuint32_t
} /* pcre2_compile.c:2555:9 */

// ************************************************
//
//      Parse regex and identify named groups     *
//

// This function is called first of all. It scans the pattern and does two
// things: (1) It identifies capturing groups and makes a table of named capturing
// groups so that information about them is fully available to both the compiling
// scans. (2) It writes a parsed version of the pattern with comments omitted and
// escapes processed into the parsed_pattern vector.
//
// Arguments:
//   ptr             points to the start of the pattern
//   options         compiling dynamic options (may change during the scan)
//   has_lookbehind  points to a boolean, set TRUE if a lookbehind is found
//   cb              pointer to the compile data block
//
// Returns:   zero on success or a non-zero error code, with the
//              error offset placed in the cb field

// A structure and some flags for dealing with nested groups.

type Tnest_save = Snest_save /* pcre2_compile.c:2561:3 */

// Only in 32-bit mode can there be literals > META_END. A macro encapsulates
// the storing of literal values in the main parsed pattern, where they can always
// be quantified.

// Here's the actual function.

func parse_regex(tls *libc.TLS, ptr TPCRE2_SPTR8, options Tuint32_t, has_lookbehind uintptr, cb uintptr) int32 { /* pcre2_compile.c:2598:12: */
	bp := tls.Alloc(104)
	defer tls.Free(104)
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) = ptr

	// var c Tuint32_t at bp+16, 4

	var delimiter Tuint32_t
	// var namelen Tuint32_t at bp+72, 4

	var class_range_state Tuint32_t
	var verblengthptr uintptr // Value avoids compiler warning
	var verbstartptr uintptr
	// var previous_callout uintptr at bp, 8

	var parsed_pattern uintptr
	var parsed_pattern_end uintptr
	var meta_quantifier Tuint32_t
	var add_after_mark Tuint32_t
	var extra_options Tuint32_t
	var nest_depth Tuint16_t
	var after_manual_callout int32
	var expect_cond_assert int32
	// var errorcode int32 at bp+20, 4

	var escape int32
	// var i int32 at bp+48, 4

	var inescq TBOOL
	var inverbname TBOOL
	var utf TBOOL
	var auto_callout TBOOL
	var isdupname TBOOL
	var negate_class TBOOL
	var okquantifier TBOOL
	var thisptr TPCRE2_SPTR8
	// var name TPCRE2_SPTR8 at bp+64, 8

	var ptrend TPCRE2_SPTR8
	var verbnamestart TPCRE2_SPTR8 // Value avoids compiler warning
	var ng uintptr
	var top_nest uintptr
	var end_nests uintptr
	var verbnamelength Tsize_t
	var ok TBOOL
	// var negated TBOOL at bp+32, 4

	// var ptype Tuint16_t at bp+36, 2

	// var pdata Tuint16_t at bp+38, 2

	// var p TPCRE2_SPTR8 at bp+40, 8

	var p1 uintptr
	var ptype1 int32
	var pvalue int32
	var posix_negate TBOOL
	var posix_class int32
	// var negated1 TBOOL at bp+84, 4

	// var ptype2 Tuint16_t at bp+88, 2

	// var pdata1 Tuint16_t at bp+90, 2

	var char_is_literal TBOOL
	var meta Tuint32_t
	var vn uintptr
	var hyphenok TBOOL
	var oldoptions Tuint32_t
	var calloutlength Tsize_t
	var startptr TPCRE2_SPTR8
	var n int32
	var ge Tuint32_t
	// var major int32 at bp+100, 4

	var minor int32
	var was_r_ampersand TBOOL
	var newsize Tuint32_t
	var newspace uintptr
	var prev_expect_cond_assert int32
	// var min_repeat Tuint32_t at bp+76, 4

	// var max_repeat Tuint32_t at bp+80, 4

	// var set Tuint32_t at bp+92, 4

	// var unset Tuint32_t at bp+96, 4

	var optset uintptr
	var terminator Tuint32_t
	var prev_meta_quantifier Tuint32_t
	var prev_okquantifier TBOOL
	// var tempptr TPCRE2_SPTR8 at bp+24, 8

	// var offset Tsize_t at bp+56, 8
	verblengthptr = uintptr(0)
	verbstartptr = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp /* previous_callout */)) = uintptr(0)
	parsed_pattern = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fparsed_pattern
	parsed_pattern_end = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fparsed_pattern_end
	meta_quantifier = Tuint32_t(0)
	add_after_mark = Tuint32_t(0)
	extra_options = (*Tpcre2_real_compile_context_8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fcx)).Fextra_options
	nest_depth = Tuint16_t(0)
	after_manual_callout = 0
	expect_cond_assert = 0
	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = 0
	inescq = DFALSE
	inverbname = DFALSE
	utf = libc.Bool32(options&DPCRE2_UTF != Tuint32_t(0))
	auto_callout = libc.Bool32(options&DPCRE2_AUTO_CALLOUT != Tuint32_t(0))
	okquantifier = DFALSE
	ptrend = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fend_pattern
	verbnamestart = uintptr(0)

	// Insert leading items for word and line matching (features provided for the
	// benefit of pcre2grep).

	if !(extra_options&DPCRE2_EXTRA_MATCH_LINE != Tuint32_t(0)) {
		goto __1
	}

	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_CIRCUMFLEX
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_NOCAPTURE
	goto __2
__1:
	if !(extra_options&DPCRE2_EXTRA_MATCH_WORD != Tuint32_t(0)) {
		goto __3
	}

	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_ESCAPE + ESC_b
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_NOCAPTURE
__3:
	;
__2:
	;

	// If the pattern is actually a literal string, process it separately to avoid
	// cluttering up the main loop.

	if !(options&DPCRE2_LITERAL != Tuint32_t(0)) {
		goto __4
	}

__5:
	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) < ptrend) {
		goto __6
	}

	if !(parsed_pattern >= parsed_pattern_end) {
		goto __7
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR63 // Internal error (parsed pattern overflow)
	goto FAILED
__7:
	;
	thisptr = *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))
	*(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */)) = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)), 1))))
	if !(utf != 0 && *(*Tuint32_t)(unsafe.Pointer(bp + 16)) >= 0xc0) {
		goto __8
	}
	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x20 == Tuint32_t(0)) {
		goto __9
	}
	*(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)), 1))))&0x3f
	goto __10
__9:
	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x10 == Tuint32_t(0)) {
		goto __11
	}
	*(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)))))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(2)
	goto __12
__11:
	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x08 == Tuint32_t(0)) {
		goto __13
	}
	*(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)))))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(3)
	goto __14
__13:
	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x04 == Tuint32_t(0)) {
		goto __15
	}
	*(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)))))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(4)
	goto __16
__15:
	*(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)))))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(5)
__16:
	;
__14:
	;
__12:
	;
__10:
	;
__8:
	;

	if !(auto_callout != 0) {
		goto __17
	}
	parsed_pattern = manage_callouts(tls, thisptr, bp,
		auto_callout, parsed_pattern, cb)
__17:
	;
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = *(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */))
	okquantifier = DTRUE

	goto __5
__6:
	;
	goto PARSED_END
__4:
	;

	// Process a real regex which may contain meta-characters.

	top_nest = uintptr(0)
	end_nests = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_workspace + uintptr((*Tcompile_block_8)(unsafe.Pointer(cb)).Fworkspace_size)

	// The size of the nest_save structure might not be a factor of the size of the
	// workspace. Therefore we must round down end_nests so as to correctly avoid
	// creating a nest_save that spans the end of the workspace.

	end_nests = end_nests - uintptr((*Tcompile_block_8)(unsafe.Pointer(cb)).Fworkspace_size*Tsize_t(unsafe.Sizeof(TPCRE2_UCHAR8(0)))%Tsize_t(unsafe.Sizeof(Tnest_save{})))

	// PCRE2_EXTENDED_MORE implies PCRE2_EXTENDED

	if !(options&DPCRE2_EXTENDED_MORE != Tuint32_t(0)) {
		goto __18
	}
	options = options | DPCRE2_EXTENDED
__18:
	;

	// Now scan the pattern

__19:
	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) < ptrend) {
		goto __20
	}

	if !(parsed_pattern >= parsed_pattern_end) {
		goto __21
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR63 // Internal error (parsed pattern overflow)
	goto FAILED
__21:
	;

	if !(Tuint32_t(nest_depth) > (*Tpcre2_real_compile_context_8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fcx)).Fparens_nest_limit) {
		goto __22
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR19
	goto FAILED // Parentheses too deeply nested
__22:
	;

	// Get next input character, save its position for callout handling.

	thisptr = *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))
	*(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */)) = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)), 1))))
	if !(utf != 0 && *(*Tuint32_t)(unsafe.Pointer(bp + 16)) >= 0xc0) {
		goto __23
	}
	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x20 == Tuint32_t(0)) {
		goto __24
	}
	*(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)), 1))))&0x3f
	goto __25
__24:
	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x10 == Tuint32_t(0)) {
		goto __26
	}
	*(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)))))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(2)
	goto __27
__26:
	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x08 == Tuint32_t(0)) {
		goto __28
	}
	*(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)))))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(3)
	goto __29
__28:
	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x04 == Tuint32_t(0)) {
		goto __30
	}
	*(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)))))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(4)
	goto __31
__30:
	*(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)))))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(5)
__31:
	;
__29:
	;
__27:
	;
__25:
	;
__23:
	;

	// Copy quoted literals until \E, allowing for the possibility of automatic
	//   callouts, except when processing a (*VERB) "name".

	if !(inescq != 0) {
		goto __32
	}

	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 16)) == Tuint32_t('\134') && *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) < ptrend && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) == '\105') {
		goto __33
	}

	inescq = DFALSE
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))++ // Skip E
	goto __34
__33:

	if !(expect_cond_assert > 0) {
		goto __35
	} /* A literal is not allowed if we are */
	// expecting a conditional assertion,
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))-- // but an empty \Q\E sequence is OK.
	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR28
	goto FAILED
__35:
	;
	if !(inverbname != 0) {
		goto __36
	}
	// Don't use PARSED_LITERAL() because it
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = *(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */))
	goto __37
__36:

	if !(libc.PostDecInt32(&after_manual_callout, 1) <= 0) {
		goto __38
	}
	parsed_pattern = manage_callouts(tls, thisptr, bp,
		auto_callout, parsed_pattern, cb)
__38:
	;
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = *(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */))
	okquantifier = DTRUE

__37:
	;
	meta_quantifier = Tuint32_t(0)
__34:
	;
	goto __19 // Next character
__32:
	;

	// If we are processing the "name" part of a (*VERB:NAME) item, all
	//   characters up to the closing parenthesis are literals except when
	//   PCRE2_ALT_VERBNAMES is set. That causes backslash interpretation, but only \Q
	//   and \E and escaped characters are allowed (no character types such as \d). If
	//   PCRE2_EXTENDED is also set, we must ignore white space and # comments. Do
	//   this by not entering the special (*VERB:NAME) processing - they are then
	//   picked up below. Note that c is a character, not a code unit, so we must not
	//   use MAX_255 to test its size because MAX_255 tests code units and is assumed
	//   TRUE in 8-bit mode.

	if !(inverbname != 0 && (options&(DPCRE2_EXTENDED|DPCRE2_ALT_VERBNAMES) != DPCRE2_EXTENDED|DPCRE2_ALT_VERBNAMES || *(*Tuint32_t)(unsafe.Pointer(bp + 16)) > Tuint32_t(255) && *(*Tuint32_t)(unsafe.Pointer(bp + 16))|Tuint32_t(1) != Tuint32_t(0x200f) && *(*Tuint32_t)(unsafe.Pointer(bp + 16))|Tuint32_t(1) != Tuint32_t(0x2029) || *(*Tuint32_t)(unsafe.Pointer(bp + 16)) < Tuint32_t(256) && *(*Tuint32_t)(unsafe.Pointer(bp + 16)) != Tuint32_t('\043') && int32(*(*Tuint8_t)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fctypes + uintptr(*(*Tuint32_t)(unsafe.Pointer(bp + 16))))))&Dctype_space == 0 &&

		*(*Tuint32_t)(unsafe.Pointer(bp + 16)) != Tuint32_t(uint8('\x85')))) {
		goto __39
	}

	switch *(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */)) {
	default:
		goto __41

	case Tuint32_t('\051'):
		goto __42

	case Tuint32_t('\134'):
		goto __43
	}
	goto __40

__41: // Don't use PARSED_LITERAL() because it
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = *(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */))
	goto __40

__42:
	inverbname = DFALSE
	// This is the length in characters
	verbnamelength = Tsize_t((int64(parsed_pattern)-int64(verblengthptr))/4 - int64(1))
	// But the limit on the length is in code units
	if !((int64(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)))-int64(verbnamestart))/1-int64(1) > int64(int32(uint32(1)<<8-uint32(1)))) {
		goto __44
	}

	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))--
	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR76
	goto FAILED
__44:
	;
	*(*Tuint32_t)(unsafe.Pointer(verblengthptr)) = Tuint32_t(verbnamelength)

	// If this name was on a verb such as (*ACCEPT) which does not continue,
	//       a (*MARK) was generated for the name. We now add the original verb as the
	//       next item.

	if !(add_after_mark != Tuint32_t(0)) {
		goto __45
	}

	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = add_after_mark
	add_after_mark = Tuint32_t(0)
__45:
	;
	goto __40

__43:
	if !(options&DPCRE2_ALT_VERBNAMES != Tuint32_t(0)) {
		goto __46
	}

	escape = X_pcre2_check_escape_8(tls, bp+8, ptrend, bp+16, bp+20, options,
		(*Tpcre2_real_compile_context_8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fcx)).Fextra_options, DFALSE, cb)
	if !(*(*int32)(unsafe.Pointer(bp + 20)) != 0) {
		goto __48
	}
	goto FAILED
__48:
	;
	goto __47
__46:
	escape = 0
__47:
	; // Treat all as literal

	switch escape {
	case 0:
		goto __50

	case ESC_Q:
		goto __51

	case ESC_E:
		goto __52

	default:
		goto __53
	}
	goto __49

__50: // Don't use PARSED_LITERAL() because it
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = *(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */))
	goto __49

__51:
	inescq = DTRUE
	goto __49

__52: // Ignore
	goto __49

__53:
	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR40 // Invalid in verb name
	goto FAILED
__49:
	;
__40:
	;
	goto __19 // Next character in pattern
__39:
	;

	// Not a verb name character. At this point we must process everything that
	//   must not change the quantification state. This is mainly comments, but we
	//   handle \Q and \E here as well, so that an item such as A\Q\E+ is treated as
	//   A+, as in Perl. An isolated \E is ignored.

	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 16)) == Tuint32_t('\134') && *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) < ptrend) {
		goto __54
	}

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) == '\121' || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) == '\105') {
		goto __55
	}

	inescq = libc.Bool32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) == '\121')
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))++
	goto __19
__55:
	;
__54:
	;

	// Skip over whitespace and # comments in extended mode. Note that c is a
	//   character, not a code unit, so we must not use MAX_255 to test its size
	//   because MAX_255 tests code units and is assumed TRUE in 8-bit mode. The
	//   whitespace characters are those designated as "Pattern White Space" by
	//   Unicode, which are the isspace() characters plus CHAR_NEL (newline), which is
	//   U+0085 in Unicode, plus U+200E, U+200F, U+2028, and U+2029. These are a
	//   subset of space characters that match \h and \v.

	if !(options&DPCRE2_EXTENDED != Tuint32_t(0)) {
		goto __56
	}

	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 16)) < Tuint32_t(256) && int32(*(*Tuint8_t)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fctypes + uintptr(*(*Tuint32_t)(unsafe.Pointer(bp + 16))))))&Dctype_space != 0) {
		goto __57
	}
	goto __19
__57:
	;
	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 16)) == Tuint32_t(uint8('\x85')) || *(*Tuint32_t)(unsafe.Pointer(bp + 16))|Tuint32_t(1) == Tuint32_t(0x200f) || *(*Tuint32_t)(unsafe.Pointer(bp + 16))|Tuint32_t(1) == Tuint32_t(0x2029)) {
		goto __58
	}
	goto __19
__58:
	;
	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 16)) == Tuint32_t('\043')) {
		goto __59
	}

__60:
	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) < ptrend) {
		goto __61
	}

	if !(func() int32 {
		if (*Tcompile_block_8)(unsafe.Pointer(cb)).Fnltype != Tuint32_t(DNLTYPE_FIXED) {
			return libc.Bool32(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) < (*Tcompile_block_8)(unsafe.Pointer(cb)).Fend_pattern && X_pcre2_is_newline_8(tls, *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)), (*Tcompile_block_8)(unsafe.Pointer(cb)).Fnltype, (*Tcompile_block_8)(unsafe.Pointer(cb)).Fend_pattern, cb+260, utf) != 0)
		}
		return libc.Bool32(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) <= (*Tcompile_block_8)(unsafe.Pointer(cb)).Fend_pattern-uintptr((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnllen) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cb + 272))) && ((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnllen == Tuint32_t(1) || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + uintptr(1)))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cb + 272 + 1)))))
	}() != 0) {
		goto __62
	} /* For non-fixed-length newline cases, */
	// IS_NEWLINE sets cb->nllen.
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)) += TPCRE2_SPTR8((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnllen)
	goto __61
__62:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))++
	if !(utf != 0) {
		goto __63
	}
__64:
	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) < ptrend && uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)))))&0xc0 == 0x80) {
		goto __65
	}
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))++
	goto __64
__65:
	;
__63:
	;
	goto __60
__61:
	;
	goto __19 // Next character in pattern
__59:
	;
__56:
	;

	// Skip over bracketed comments

	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 16)) == Tuint32_t('\050') && (int64(ptrend)-int64(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))/1 >= int64(2) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) == '\077' && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 1))) == '\043') {
		goto __66
	}

__67:
	if !(libc.PreIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)), 1) < ptrend && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) != '\051') {
		goto __68
	}
	goto __67
__68:
	;
	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) >= ptrend) {
		goto __69
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR18 // A special error for missing ) in a comment
	goto FAILED                                                // to make it easier to debug.
__69:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))++
	goto __19 // Next character in pattern
__66:
	;

	// If the next item is not a quantifier, fill in length of any previous
	//   callout and create an auto callout if required.

	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 16)) != Tuint32_t('\052') && *(*Tuint32_t)(unsafe.Pointer(bp + 16)) != Tuint32_t('\053') && *(*Tuint32_t)(unsafe.Pointer(bp + 16)) != Tuint32_t('\077') && (*(*Tuint32_t)(unsafe.Pointer(bp + 16)) != Tuint32_t('\173') || func() bool {
		*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)) = *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))
		return !(read_repeat_counts(tls, bp+24, ptrend, uintptr(0), uintptr(0), bp+20) != 0)
	}())) {
		goto __70
	}

	if !(libc.PostDecInt32(&after_manual_callout, 1) <= 0) {
		goto __71
	}
	parsed_pattern = manage_callouts(tls, thisptr, bp, auto_callout,
		parsed_pattern, cb)
__71:
	;
__70:
	;

	// If expect_cond_assert is 2, we have just passed (?( and are expecting an
	//   assertion, possibly preceded by a callout. If the value is 1, we have just
	//   had the callout and expect an assertion. There must be at least 3 more
	//   characters in all cases. When expect_cond_assert is 2, we know that the
	//   current character is an opening parenthesis, as otherwise we wouldn't be
	//   here. However, when it is 1, we need to check, and it's easiest just to check
	//   always. Note that expect_cond_assert may be negative, since all callouts just
	//   decrement it.

	if !(expect_cond_assert > 0) {
		goto __72
	}

	ok = libc.Bool32(*(*Tuint32_t)(unsafe.Pointer(bp + 16)) == Tuint32_t('\050') && (int64(ptrend)-int64(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))/1 >= int64(3) && (int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) == '\077' || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) == '\052'))
	if !(ok != 0) {
		goto __73
	}

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) == '\052') {
		goto __74
	} /* New alpha assertion format, possibly */

	ok = libc.Bool32(1 != 0 && int32(*(*Tuint8_t)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fctypes + uintptr(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 1))))))&Dctype_lcletter != 0)
	goto __75
__74:
	switch int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)) + 1))) {
	case '\103':
		goto __77

	case '\075':
		goto __78
	case '\041':
		goto __79

	case '\074':
		goto __80

	default:
		goto __81
	}
	goto __76 /* Traditional symbolic format */

__77:
	ok = libc.Bool32(expect_cond_assert == 2)
	goto __76

__78:
__79:
	goto __76

__80:
	ok = libc.Bool32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 2))) == '\075' || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 2))) == '\041')
	goto __76

__81:
	ok = DFALSE
__76:
	;
__75:
	;
__73:
	;

	if !!(ok != 0) {
		goto __82
	}

	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))-- // Adjust error offset
	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR28
	goto FAILED
__82:
	;
__72:
	;

	// Remember whether we are expecting a conditional assertion, and set the
	//   default for this item.

	prev_expect_cond_assert = expect_cond_assert
	expect_cond_assert = 0

	// Remember quantification status for the previous significant item, then set
	//   default for this item.

	prev_okquantifier = okquantifier
	prev_meta_quantifier = meta_quantifier
	okquantifier = DFALSE
	meta_quantifier = Tuint32_t(0)

	// If the previous significant item was a quantifier, adjust the parsed code
	//   if there is a following modifier. The base meta value is always followed by
	//   the PLUS and QUERY values, in that order. We do this here rather than after
	//   reading a quantifier so that intervening comments and /x whitespace can be
	//   ignored without having to replicate code.

	if !(prev_meta_quantifier != Tuint32_t(0) && (*(*Tuint32_t)(unsafe.Pointer(bp + 16)) == Tuint32_t('\077') || *(*Tuint32_t)(unsafe.Pointer(bp + 16)) == Tuint32_t('\053'))) {
		goto __83
	}

	*(*Tuint32_t)(unsafe.Pointer(parsed_pattern + uintptr(func() int32 {
		if prev_meta_quantifier == DMETA_MINMAX {
			return -3
		}
		return -1
	}())*4)) = prev_meta_quantifier + func() uint32 {
		if *(*Tuint32_t)(unsafe.Pointer(bp + 16)) == Tuint32_t('\077') {
			return 0x00020000
		}
		return 0x00010000
	}()
	goto __19 // Next character in pattern
__83:
	;

	// Process the next item in the main part of a pattern.

	switch *(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */)) {
	default:
		goto __85

	// ---- Escape sequence ----

	case Tuint32_t('\134'):
		goto __86 // End escape sequence processing

	// ---- Single-character special items ----

	case Tuint32_t('\136'):
		goto __87

	case Tuint32_t('\044'):
		goto __88

	case Tuint32_t('\056'):
		goto __89

	// ---- Single-character quantifiers ----

	case Tuint32_t('\052'):
		goto __90

	case Tuint32_t('\053'):
		goto __91

	case Tuint32_t('\077'):
		goto __92

	// ---- Potential {n,m} quantifier ----

	case Tuint32_t('\173'):
		goto __93

	// ---- Character class ----

	case Tuint32_t('\133'):
		goto __94 // End of character class

	// ---- Opening parenthesis ----

	case Tuint32_t('\050'):
		goto __95 // End of ( handling

	// ---- Branch terminators ----

	// Alternation: reset the capture count if we are in a (?| group.

	case Tuint32_t('\174'):
		goto __96

	// End of group; reset the capture count to the maximum if we are in a (?|
	//     group and/or reset the options that are tracked during parsing. Disallow
	//     quantifier for a condition that is an assertion.

	case Tuint32_t('\051'):
		goto __97
	}
	goto __84

__85: // Non-special character
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = *(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */))
	okquantifier = DTRUE

	goto __84

	// ---- Escape sequence ----

__86:
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24 /* tempptr */)) = *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))
	escape = X_pcre2_check_escape_8(tls, bp+8, ptrend, bp+16, bp+20, options,
		(*Tpcre2_real_compile_context_8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fcx)).Fextra_options, DFALSE, cb)
	if !(*(*int32)(unsafe.Pointer(bp + 20)) != 0) {
		goto __98
	}

ESCAPE_FAILED:
	if !(extra_options&DPCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL == Tuint32_t(0)) {
		goto __99
	}
	goto FAILED
__99:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)) = *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24 /* tempptr */))
	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) >= ptrend) {
		goto __100
	}
	*(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */)) = Tuint32_t('\134')
	goto __101
__100:

	*(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */)) = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)), 1))))
	if !(utf != 0 && *(*Tuint32_t)(unsafe.Pointer(bp + 16)) >= 0xc0) {
		goto __102
	}
	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x20 == Tuint32_t(0)) {
		goto __103
	}
	*(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)), 1))))&0x3f
	goto __104
__103:
	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x10 == Tuint32_t(0)) {
		goto __105
	}
	*(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)))))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(2)
	goto __106
__105:
	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x08 == Tuint32_t(0)) {
		goto __107
	}
	*(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)))))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(3)
	goto __108
__107:
	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x04 == Tuint32_t(0)) {
		goto __109
	}
	*(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)))))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(4)
	goto __110
__109:
	*(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)))))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(5)
__110:
	;
__108:
	;
__106:
	;
__104:
	;
__102:
	;

	// Get character value, increment pointer
__101:
	;
	escape = 0 // Treat as literal character
__98:
	;

	// The escape was a data escape or literal character.

	if !(escape == 0) {
		goto __111
	}

	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = *(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */))
	okquantifier = DTRUE

	goto __112
__111:
	if !(escape < 0) {
		goto __113
	}

	*(*Tsize_t)(unsafe.Pointer(bp + 56 /* offset */)) = Tsize_t((int64(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)))-int64((*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_pattern))/1 - int64(1))
	escape = -escape
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_BACKREF | Tuint32_t(escape)
	if !(escape < 10) {
		goto __115
	}

	if !(*(*Tsize_t)(unsafe.Pointer(cb + 88 + uintptr(escape)*8)) == libc.CplUint64(uint64(0))) {
		goto __117
	}
	*(*Tsize_t)(unsafe.Pointer(cb + 88 + uintptr(escape)*8)) = *(*Tsize_t)(unsafe.Pointer(bp + 56 /* offset */))
__117:
	;
	goto __116
__115:

	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = Tuint32_t(*(*Tsize_t)(unsafe.Pointer(bp + 56)) >> 32)
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = Tuint32_t(*(*Tsize_t)(unsafe.Pointer(bp + 56)) & uint64(0xffffffff))

__116:
	;
	okquantifier = DTRUE
	goto __114
__113:
	switch escape {
	case ESC_C:
		goto __119

	case ESC_X:
		goto __120
	case ESC_H:
		goto __121
	case ESC_h:
		goto __122
	case ESC_N:
		goto __123
	case ESC_R:
		goto __124
	case ESC_V:
		goto __125
	case ESC_v:
		goto __126

	default:
		goto __127

	// Escapes that change in UCP mode. Note that PCRE2_UCP will never be set
	//       without Unicode support because it is checked when pcre2_compile() is
	//       called.

	case ESC_d:
		goto __128
	case ESC_D:
		goto __129
	case ESC_s:
		goto __130
	case ESC_S:
		goto __131
	case ESC_w:
		goto __132
	case ESC_W:
		goto __133

	// Unicode property matching

	case ESC_P:
		goto __134
	case ESC_p:
		goto __135 // End \P and \p

	// When \g is used with quotes or angle brackets as delimiters, it is a
	//       numerical or named subroutine call, and control comes here. When used
	//       with brace delimiters it is a numberical back reference and does not come
	//       here because check_escape() returns it directly as a reference. \k is
	//       always a named back reference.

	case ESC_g:
		goto __136
	case ESC_k:
		goto __137
	}
	goto __118

__119:
	if !(options&DPCRE2_NEVER_BACKSLASH_C != Tuint32_t(0)) {
		goto __138
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR83
	goto ESCAPE_FAILED
__138:
	;
	okquantifier = DTRUE
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_ESCAPE + uint32(escape)
	goto __118

__120:
__121:
__122:
__123:
__124:
__125:
__126:
	okquantifier = DTRUE
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_ESCAPE + uint32(escape)
	goto __118

__127: // \A, \B, \b, \G, \K, \Z, \z cannot be quantified.
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_ESCAPE + uint32(escape)
	goto __118

	// Escapes that change in UCP mode. Note that PCRE2_UCP will never be set
	//       without Unicode support because it is checked when pcre2_compile() is
	//       called.

__128:
__129:
__130:
__131:
__132:
__133:
	okquantifier = DTRUE
	if !(options&DPCRE2_UCP == Tuint32_t(0)) {
		goto __139
	}

	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_ESCAPE + uint32(escape)
	goto __140
__139:

	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_ESCAPE + func() uint32 {
		if escape == ESC_d || escape == ESC_s || escape == ESC_w {
			return ESC_p
		}
		return ESC_P
	}()
	switch escape {
	case ESC_d:
		goto __142
	case ESC_D:
		goto __143

	case ESC_s:
		goto __144
	case ESC_S:
		goto __145

	case ESC_w:
		goto __146
	case ESC_W:
		goto __147
	}
	goto __141

__142:
__143:
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = Tuint32_t(int32(DPT_PC)<<16 | ucp_Nd)
	goto __141

__144:
__145:
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = Tuint32_t(int32(DPT_SPACE) << 16)
	goto __141

__146:
__147:
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = Tuint32_t(int32(DPT_WORD) << 16)
	goto __141
__141:
	;
__140:
	;
	goto __118

	// Unicode property matching

__134:
__135:

	*(*Tuint16_t)(unsafe.Pointer(bp + 36 /* ptype */)) = Tuint16_t(0)
	*(*Tuint16_t)(unsafe.Pointer(bp + 38 /* pdata */)) = Tuint16_t(0)
	if !!(get_ucp(tls, bp+8, bp+32, bp+36, bp+38, bp+20, cb) != 0) {
		goto __148
	}
	goto ESCAPE_FAILED
__148:
	;
	if !(*(*TBOOL)(unsafe.Pointer(bp + 32)) != 0) {
		goto __149
	}
	if escape == ESC_P {
		escape = ESC_p
	} else {
		escape = ESC_P
	}
__149:
	;
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_ESCAPE + uint32(escape)
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = Tuint32_t(int32(*(*Tuint16_t)(unsafe.Pointer(bp + 36)))<<16 | int32(*(*Tuint16_t)(unsafe.Pointer(bp + 38))))
	okquantifier = DTRUE

	goto __118 // End \P and \p

	// When \g is used with quotes or angle brackets as delimiters, it is a
	//       numerical or named subroutine call, and control comes here. When used
	//       with brace delimiters it is a numberical back reference and does not come
	//       here because check_escape() returns it directly as a reference. \k is
	//       always a named back reference.

__136:
__137:
	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) >= ptrend || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) != '\173' && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) != '\074' && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) != '\047') {
		goto __150
	}

	if escape == ESC_g {
		*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR57
	} else {
		*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR69
	}
	goto ESCAPE_FAILED
__150:
	;
	if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) == '\074' {
		terminator = uint32('\076')
	} else {
		if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) == '\047' {
			terminator = uint32('\047')
		} else {
			terminator = uint32('\175')
		}
	}

	// For a non-braced \g, check for a numerical recursion.

	if !(escape == ESC_g && terminator != Tuint32_t('\175')) {
		goto __151
	}

	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 40 /* p */)) = *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + uintptr(1)

	if !(read_number(tls, bp+40, ptrend, int32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount), DMAX_GROUP_NUMBER, ERR61, bp+48,
		bp+20) != 0) {
		goto __152
	}

	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 40)) >= ptrend || Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 40))))) != terminator) {
		goto __153
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR57
	goto ESCAPE_FAILED
__153:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)) = *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 40 /* p */))
	goto SET_RECURSION
__152:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 20)) != 0) {
		goto __154
	}
	goto ESCAPE_FAILED
__154:
	;
__151:
	;

	// Not a numerical recursion

	if !!(read_name(tls, bp+8, ptrend, utf, terminator, bp+56, bp+64, bp+72,
		bp+20, cb) != 0) {
		goto __155
	}
	goto ESCAPE_FAILED
__155:
	;

	// \k and \g when used with braces are back references, whereas \g used
	//       with quotes or angle brackets is a recursion

	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = func() uint32 {
		if escape == ESC_k || terminator == Tuint32_t('\175') {
			return DMETA_BACKREF_BYNAME
		}
		return DMETA_RECURSE_BYNAME
	}()
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = *(*Tuint32_t)(unsafe.Pointer(bp + 72 /* namelen */))

	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = Tuint32_t(*(*Tsize_t)(unsafe.Pointer(bp + 56)) >> 32)
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = Tuint32_t(*(*Tsize_t)(unsafe.Pointer(bp + 56)) & uint64(0xffffffff))

	okquantifier = DTRUE
	goto __118 // End special escape processing
__118:
	;
__114:
	;
__112:
	;
	goto __84 // End escape sequence processing

	// ---- Single-character special items ----

__87:
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_CIRCUMFLEX
	goto __84

__88:
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_DOLLAR
	goto __84

__89:
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_DOT
	okquantifier = DTRUE
	goto __84

	// ---- Single-character quantifiers ----

__90:
	meta_quantifier = DMETA_ASTERISK
	goto CHECK_QUANTIFIER

__91:
	meta_quantifier = DMETA_PLUS
	goto CHECK_QUANTIFIER

__92:
	meta_quantifier = DMETA_QUERY
	goto CHECK_QUANTIFIER

	// ---- Potential {n,m} quantifier ----

__93:
	if !!(read_repeat_counts(tls, bp+8, ptrend, bp+76, bp+80,
		bp+20) != 0) {
		goto __156
	}

	if !(*(*int32)(unsafe.Pointer(bp + 20)) != 0) {
		goto __157
	}
	goto FAILED
__157:
	; // Error in quantifier.
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = *(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */))
	okquantifier = DTRUE
	// Not a quantifier
	goto __84 // No more quantifier processing
__156:
	;
	meta_quantifier = DMETA_MINMAX
	// Fall through

	// ---- Quantifier post-processing ----

	// Check that a quantifier is allowed after the previous item.

CHECK_QUANTIFIER:
	if !!(prev_okquantifier != 0) {
		goto __158
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR9
	goto FAILED_BACK
__158:
	;

	// Most (*VERB)s are not allowed to be quantified, but an ungreedy
	//     quantifier can be useful for (*ACCEPT) - meaning "succeed on backtrack", a
	//     sort of negated (*COMMIT). We therefore allow (*ACCEPT) to be quantified by
	//     wrapping it in non-capturing brackets, but we have to allow for a preceding
	//     (*MARK) for when (*ACCEPT) has an argument.

	if !(*(*Tuint32_t)(unsafe.Pointer(parsed_pattern + libc.UintptrFromInt32(-1)*4)) == DMETA_ACCEPT) {
		goto __159
	}

	p1 = parsed_pattern - uintptr(1)*4
__160:
	if !(p1 >= verbstartptr) {
		goto __162
	}
	*(*Tuint32_t)(unsafe.Pointer(p1 + 1*4)) = *(*Tuint32_t)(unsafe.Pointer(p1))
	goto __161
__161:
	p1 -= 4
	goto __160
	goto __162
__162:
	;
	*(*Tuint32_t)(unsafe.Pointer(verbstartptr)) = DMETA_NOCAPTURE
	*(*Tuint32_t)(unsafe.Pointer(parsed_pattern + 1*4)) = DMETA_KET
	parsed_pattern += 4 * uintptr(2)
__159:
	;

	// Now we can put the quantifier into the parsed pattern vector. At this
	//     stage, we have only the basic quantifier. The check for a following + or ?
	//     modifier happens at the top of the loop, after any intervening comments
	//     have been removed.

	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = meta_quantifier
	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 16)) == Tuint32_t('\173')) {
		goto __163
	}

	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = *(*Tuint32_t)(unsafe.Pointer(bp + 76 /* min_repeat */))
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = *(*Tuint32_t)(unsafe.Pointer(bp + 80 /* max_repeat */))
__163:
	;
	goto __84

	// ---- Character class ----

__94:
	okquantifier = DTRUE

	// In another (POSIX) regex library, the ugly syntax [[:<:]] and [[:>:]] is
	//     used for "start of word" and "end of word". As these are otherwise illegal
	//     sequences, we don't break anything by recognizing them. They are replaced
	//     by \b(?=\w) and \b(?<=\w) respectively. Sequences like [a[:<:]] are
	//     erroneous and are handled by the normal code below.

	if !((int64(ptrend)-int64(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))/1 >= int64(6) && (X_pcre2_strncmp_c8_8(tls, *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)), ts+597, uint64(6)) == 0 || X_pcre2_strncmp_c8_8(tls, *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)), ts+604, uint64(6)) == 0)) {
		goto __164
	}

	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_ESCAPE + ESC_b

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 2))) == '\074') {
		goto __165
	}

	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_LOOKAHEAD
	goto __166
__165:

	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_LOOKBEHIND
	*(*TBOOL)(unsafe.Pointer(has_lookbehind)) = DTRUE

	/* The offset is used only for the "non-fixed length" error; this won't
	   occur here, so just store zero. */

	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = uint32(Tsize_t(uint64(0)) >> 32)
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = uint32(uint64(0) & uint64(0xffffffff))

__166:
	;

	if !(options&DPCRE2_UCP == Tuint32_t(0)) {
		goto __167
	}
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_ESCAPE + ESC_w
	goto __168
__167:

	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_ESCAPE + ESC_p
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = Tuint32_t(int32(DPT_WORD) << 16)
__168:
	;
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_KET
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(6)
	goto __84
__164:
	;

	// PCRE supports POSIX class stuff inside a class. Perl gives an error if
	//     they are encountered at the top level, so we'll do that too.

	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) < ptrend && (int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) == '\072' || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) == '\056' || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) == '\075') && check_posix_syntax(tls, *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)), ptrend, bp+24) != 0) {
		goto __169
	}

	if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostDecUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)), 1)))) == '\072' {
		*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR12
	} else {
		*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR13
	}
	goto FAILED
__169:
	;

	// Process a regular character class. If the first character is '^', set
	//     the negation flag. If the first few characters (either before or after ^)
	//     are \Q\E or \E or space or tab in extended-more mode, we skip them too.
	//     This makes for compatibility with Perl.

	negate_class = DFALSE
__170:
	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) < ptrend) {
		goto __171
	}

	*(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */)) = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)), 1))))
	if !(utf != 0 && *(*Tuint32_t)(unsafe.Pointer(bp + 16)) >= 0xc0) {
		goto __172
	}
	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x20 == Tuint32_t(0)) {
		goto __173
	}
	*(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)), 1))))&0x3f
	goto __174
__173:
	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x10 == Tuint32_t(0)) {
		goto __175
	}
	*(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)))))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(2)
	goto __176
__175:
	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x08 == Tuint32_t(0)) {
		goto __177
	}
	*(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)))))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(3)
	goto __178
__177:
	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x04 == Tuint32_t(0)) {
		goto __179
	}
	*(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)))))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(4)
	goto __180
__179:
	*(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)))))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(5)
__180:
	;
__178:
	;
__176:
	;
__174:
	;
__172:
	;

	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 16)) == Tuint32_t('\134')) {
		goto __181
	}

	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) < ptrend && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) == '\105') {
		goto __183
	}
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))++
	goto __184
__183:
	if !((int64(ptrend)-int64(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))/1 >= int64(3) && X_pcre2_strncmp_c8_8(tls, *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)), ts+611, uint64(3)) == 0) {
		goto __185
	}
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(3)
	goto __186
__185:
	goto __171
__186:
	;
__184:
	;
	goto __182
__181:
	if !(options&DPCRE2_EXTENDED_MORE != Tuint32_t(0) && (*(*Tuint32_t)(unsafe.Pointer(bp + 16)) == Tuint32_t('\040') || *(*Tuint32_t)(unsafe.Pointer(bp + 16)) == Tuint32_t('\011'))) {
		goto __187
	} // Note: just these two
	goto __170
	goto __188
__187:
	if !(!(negate_class != 0) && *(*Tuint32_t)(unsafe.Pointer(bp + 16)) == Tuint32_t('\136')) {
		goto __189
	}
	negate_class = DTRUE
	goto __190
__189:
	goto __171
__190:
	;
__188:
	;
__182:
	;
	goto __170
__171:
	;

	// Now the real contents of the class; c has the first "real" character.
	//     Empty classes are permitted only if the option is set.

	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 16)) == Tuint32_t('\135') && (*Tcompile_block_8)(unsafe.Pointer(cb)).Fexternal_options&DPCRE2_ALLOW_EMPTY_CLASS != Tuint32_t(0)) {
		goto __191
	}

	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = func() uint32 {
		if negate_class != 0 {
			return DMETA_CLASS_EMPTY_NOT
		}
		return DMETA_CLASS_EMPTY
	}()
	goto __84 // End of class processing
__191:
	;

	// Process a non-empty class.

	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = func() uint32 {
		if negate_class != 0 {
			return DMETA_CLASS_NOT
		}
		return DMETA_CLASS
	}()
	class_range_state = RANGE_NO

	// In an EBCDIC environment, Perl treats alphabetic ranges specially
	//     because there are holes in the encoding, and simply using the range A-Z
	//     (for example) would include the characters in the holes. This applies only
	//     to ranges where both values are literal; [\xC1-\xE9] is different to [A-Z]
	//     in this respect. In order to accommodate this, we keep track of whether
	//     character values are literal or not, and a state variable for handling
	//     ranges.

	// Loop for the contents of the class

__192:
	char_is_literal = DTRUE

	// Inside \Q...\E everything is literal except \E

	if !(inescq != 0) {
		goto __195
	}

	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 16)) == Tuint32_t('\134') && *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) < ptrend && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) == '\105') {
		goto __196
	}

	inescq = DFALSE                                      // Reset literal state
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))++ // Skip the 'E'
	goto CLASS_CONTINUE
__196:
	;
	goto CLASS_LITERAL
__195:
	;

	// Skip over space and tab (only) in extended-more mode.

	if !(options&DPCRE2_EXTENDED_MORE != Tuint32_t(0) && (*(*Tuint32_t)(unsafe.Pointer(bp + 16)) == Tuint32_t('\040') || *(*Tuint32_t)(unsafe.Pointer(bp + 16)) == Tuint32_t('\011'))) {
		goto __197
	}
	goto CLASS_CONTINUE
__197:
	;

	// Handle POSIX class names. Perl allows a negation extension of the
	//       form [:^name:]. A square bracket that doesn't match the syntax is
	//       treated as a literal. We also recognize the POSIX constructions
	//       [.ch.] and [=ch=] ("collating elements") and fault them, as Perl
	//       5.6 and 5.8 do.

	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 16)) == Tuint32_t('\133') && (int64(ptrend)-int64(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))/1 >= int64(3) && (int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) == '\072' || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) == '\056' || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) == '\075') && check_posix_syntax(tls, *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)), ptrend, bp+24) != 0) {
		goto __198
	}

	posix_negate = DFALSE

	// Perl treats a hyphen before a POSIX class as a literal, not the
	//         start of a range. However, it gives a warning in its warning mode. PCRE
	//         does not have a warning mode, so we give an error, because this is
	//         likely an error on the user's part.

	if !(class_range_state == Tuint32_t(1)) {
		goto __200
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR50
	goto FAILED
__200:
	;

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) != '\072') {
		goto __201
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR13
	goto FAILED_BACK
__201:
	;

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PreIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)), 1)))) == '\136') {
		goto __202
	}

	posix_negate = DTRUE
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))++
__202:
	;

	posix_class = check_posix_name(tls, *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)), int32((int64(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)))-int64(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))/1))
	if !(posix_class < 0) {
		goto __203
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR30
	goto FAILED
__203:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)) = *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24)) + uintptr(2)

	// Perl treats a hyphen after a POSIX class as a literal, not the
	//         start of a range. However, it gives a warning in its warning mode
	//         unless the hyphen is the last character in the class. PCRE does not
	//         have a warning mode, so we give an error, because this is likely an
	//         error on the user's part.

	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) < ptrend-uintptr(1) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) == '\055' && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 1))) != '\135') {
		goto __204
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR50
	goto FAILED
__204:
	;

	// Set "a hyphen is not the start of a range" for the -] case, and also
	//         in case the POSIX class is followed by \E or \Q\E (possibly repeated -
	//         fuzzers do that kind of thing) and *then* a hyphen. This causes that
	//         hyphen to be treated as a literal. I don't think it's worth setting up
	//         special apparatus to do otherwise.

	class_range_state = RANGE_NO

	// When PCRE2_UCP is set, some of the POSIX classes are converted to
	//         use Unicode properties \p or \P or, in one case, \h or \H. The
	//         substitutes table has two values per class, containing the type and
	//         value of a \p or \P item. The special cases are specified with a
	//         negative type: a non-zero value causes \h or \H to be used, and a zero
	//         value falls through to behave like a non-UCP POSIX class.

	if !(options&DPCRE2_UCP != Tuint32_t(0)) {
		goto __205
	}

	ptype1 = posix_substitutes[2*posix_class]
	pvalue = posix_substitutes[2*posix_class+1]
	if !(ptype1 >= 0) {
		goto __206
	}

	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_ESCAPE + func() uint32 {
		if posix_negate != 0 {
			return ESC_P
		}
		return ESC_p
	}()
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = Tuint32_t(ptype1<<16 | pvalue)
	goto CLASS_CONTINUE
__206:
	;

	if !(pvalue != 0) {
		goto __207
	}

	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_ESCAPE + func() uint32 {
		if posix_negate != 0 {
			return ESC_H
		}
		return ESC_h
	}()
	goto CLASS_CONTINUE
__207:
	;

	// Fall through
__205:
	;

	// Non-UCP POSIX class

	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = func() uint32 {
		if posix_negate != 0 {
			return DMETA_POSIX_NEG
		}
		return DMETA_POSIX
	}()
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = Tuint32_t(posix_class)
	goto __199
__198:
	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 16)) == Tuint32_t('\055') && class_range_state >= RANGE_OK_ESCAPED) {
		goto __208
	}

	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = func() uint32 {
		if class_range_state == RANGE_OK_LITERAL {
			return DMETA_RANGE_LITERAL
		}
		return DMETA_RANGE_ESCAPED
	}()
	class_range_state = Tuint32_t(1) /* RANGE_STARTED */
	goto __209
__208:
	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 16)) != Tuint32_t('\134')) {
		goto __210
	}

CLASS_LITERAL:
	if !(class_range_state == Tuint32_t(1)) {
		goto __212
	}

	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 16)) == *(*Tuint32_t)(unsafe.Pointer(parsed_pattern + libc.UintptrFromInt32(-2)*4))) {
		goto __214
	} // Optimize one-char range
	parsed_pattern -= 4
	goto __215
__214:
	if !(*(*Tuint32_t)(unsafe.Pointer(parsed_pattern + libc.UintptrFromInt32(-2)*4)) > *(*Tuint32_t)(unsafe.Pointer(bp + 16))) {
		goto __216
	} /* Check range is in order */

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR8
	goto FAILED_BACK
	goto __217
__216:

	if !(!(char_is_literal != 0) && *(*Tuint32_t)(unsafe.Pointer(parsed_pattern + libc.UintptrFromInt32(-1)*4)) == DMETA_RANGE_LITERAL) {
		goto __218
	}
	*(*Tuint32_t)(unsafe.Pointer(parsed_pattern + libc.UintptrFromInt32(-1)*4)) = DMETA_RANGE_ESCAPED
__218:
	;
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = *(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */))
	okquantifier = DTRUE

__217:
	;
__215:
	;
	class_range_state = RANGE_NO
	goto __213
__212: /* Potential start of range */

	if char_is_literal != 0 {
		class_range_state = RANGE_OK_LITERAL
	} else {
		class_range_state = RANGE_OK_ESCAPED
	}
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = *(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */))
	okquantifier = DTRUE

__213:
	;
	goto __211
__210:

	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24 /* tempptr */)) = *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))
	escape = X_pcre2_check_escape_8(tls, bp+8, ptrend, bp+16, bp+20, options,
		(*Tpcre2_real_compile_context_8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fcx)).Fextra_options, DTRUE, cb)

	if !(*(*int32)(unsafe.Pointer(bp + 20)) != 0) {
		goto __219
	}

	if !(extra_options&DPCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL == Tuint32_t(0)) {
		goto __220
	}
	goto FAILED
__220:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)) = *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 24 /* tempptr */))
	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) >= ptrend) {
		goto __221
	}
	*(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */)) = Tuint32_t('\134')
	goto __222
__221:

	*(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */)) = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)), 1))))
	if !(utf != 0 && *(*Tuint32_t)(unsafe.Pointer(bp + 16)) >= 0xc0) {
		goto __223
	}
	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x20 == Tuint32_t(0)) {
		goto __224
	}
	*(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)), 1))))&0x3f
	goto __225
__224:
	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x10 == Tuint32_t(0)) {
		goto __226
	}
	*(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)))))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(2)
	goto __227
__226:
	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x08 == Tuint32_t(0)) {
		goto __228
	}
	*(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)))))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(3)
	goto __229
__228:
	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x04 == Tuint32_t(0)) {
		goto __230
	}
	*(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)))))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(4)
	goto __231
__230:
	*(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)))))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(5)
__231:
	;
__229:
	;
__227:
	;
__225:
	;
__223:
	;

	// Get character value, increment pointer
__222:
	;
	escape = 0 // Treat as literal character
__219:
	;

	switch escape {
	case 0:
		goto __233

	case ESC_b:
		goto __234

	case ESC_Q:
		goto __235

	case ESC_E:
		goto __236

	case ESC_B:
		goto __237 // Always an error in a class
	case ESC_R:
		goto __238
	case ESC_X:
		goto __239
	}
	goto __232

__233: // Escaped character code point is in c
	char_is_literal = DFALSE
	goto CLASS_LITERAL

__234:
	*(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */)) = Tuint32_t('\010') // \b is backspace in a class
	char_is_literal = DFALSE
	goto CLASS_LITERAL

__235:
	inescq = DTRUE // Enter literal mode
	goto CLASS_CONTINUE

__236: // Ignore orphan \E
	goto CLASS_CONTINUE

__237: // Always an error in a class
__238:
__239:
	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR7
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))--
	goto FAILED
__232:
	;

	// The second part of a range can be a single-character escape
	//         sequence (detected above), but not any of the other escapes. Perl
	//         treats a hyphen as a literal in such circumstances. However, in Perl's
	//         warning mode, a warning is given, so PCRE now faults it, as it is
	//         almost certainly a mistake on the user's part.

	if !(class_range_state == Tuint32_t(1)) {
		goto __240
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR50
	goto FAILED // Not CLASS_ESCAPE_FAILED; always an error
__240:
	;

	// Of the remaining escapes, only those that define characters are
	//         allowed in a class. None may start a range.

	class_range_state = RANGE_NO
	switch escape {
	case ESC_N:
		goto __242

	case ESC_H:
		goto __243
	case ESC_h:
		goto __244
	case ESC_V:
		goto __245
	case ESC_v:
		goto __246

	// These escapes are converted to Unicode property tests when
	//           PCRE2_UCP is set.

	case ESC_d:
		goto __247
	case ESC_D:
		goto __248
	case ESC_s:
		goto __249
	case ESC_S:
		goto __250
	case ESC_w:
		goto __251
	case ESC_W:
		goto __252

	// Explicit Unicode property matching

	case ESC_P:
		goto __253
	case ESC_p:
		goto __254 // End \P and \p

	default:
		goto __255
	}
	goto __241

__242:
	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR71
	goto FAILED

__243:
__244:
__245:
__246:
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_ESCAPE + uint32(escape)
	goto __241

	// These escapes are converted to Unicode property tests when
	//           PCRE2_UCP is set.

__247:
__248:
__249:
__250:
__251:
__252:
	if !(options&DPCRE2_UCP == Tuint32_t(0)) {
		goto __256
	}

	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_ESCAPE + uint32(escape)
	goto __257
__256:

	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_ESCAPE + func() uint32 {
		if escape == ESC_d || escape == ESC_s || escape == ESC_w {
			return ESC_p
		}
		return ESC_P
	}()
	switch escape {
	case ESC_d:
		goto __259
	case ESC_D:
		goto __260

	case ESC_s:
		goto __261
	case ESC_S:
		goto __262

	case ESC_w:
		goto __263
	case ESC_W:
		goto __264
	}
	goto __258

__259:
__260:
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = Tuint32_t(int32(DPT_PC)<<16 | ucp_Nd)
	goto __258

__261:
__262:
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = Tuint32_t(int32(DPT_SPACE) << 16)
	goto __258

__263:
__264:
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = Tuint32_t(int32(DPT_WORD) << 16)
	goto __258
__258:
	;
__257:
	;
	goto __241

	// Explicit Unicode property matching

__253:
__254:

	*(*Tuint16_t)(unsafe.Pointer(bp + 88 /* ptype2 */)) = Tuint16_t(0)
	*(*Tuint16_t)(unsafe.Pointer(bp + 90 /* pdata1 */)) = Tuint16_t(0)
	if !!(get_ucp(tls, bp+8, bp+84, bp+88, bp+90, bp+20, cb) != 0) {
		goto __265
	}
	goto FAILED
__265:
	;
	if !(*(*TBOOL)(unsafe.Pointer(bp + 84)) != 0) {
		goto __266
	}
	if escape == ESC_P {
		escape = ESC_p
	} else {
		escape = ESC_P
	}
__266:
	;
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_ESCAPE + uint32(escape)
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = Tuint32_t(int32(*(*Tuint16_t)(unsafe.Pointer(bp + 88)))<<16 | int32(*(*Tuint16_t)(unsafe.Pointer(bp + 90))))

	goto __241 // End \P and \p

__255: // All others are not allowed in a class
	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR7
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))--
	goto FAILED
__241:
	;

	// Perl gives a warning unless a following hyphen is the last character
	//         in the class. PCRE throws an error.

	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) < ptrend-uintptr(1) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) == '\055' && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 1))) != '\135') {
		goto __267
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR50
	goto FAILED
__267:
	;
__211:
	;
__209:
	;
__199:
	;

	// Proceed to next thing in the class.

CLASS_CONTINUE:
	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) >= ptrend) {
		goto __268
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR6 // Missing terminating ']'
	goto FAILED
__268:
	;
	*(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */)) = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)), 1))))
	if !(utf != 0 && *(*Tuint32_t)(unsafe.Pointer(bp + 16)) >= 0xc0) {
		goto __269
	}
	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x20 == Tuint32_t(0)) {
		goto __270
	}
	*(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)), 1))))&0x3f
	goto __271
__270:
	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x10 == Tuint32_t(0)) {
		goto __272
	}
	*(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)))))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(2)
	goto __273
__272:
	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x08 == Tuint32_t(0)) {
		goto __274
	}
	*(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)))))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(3)
	goto __275
__274:
	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x04 == Tuint32_t(0)) {
		goto __276
	}
	*(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)))))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(4)
	goto __277
__276:
	*(*Tuint32_t)(unsafe.Pointer(bp + 16 /* c */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 16))&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)))))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(5)
__277:
	;
__275:
	;
__273:
	;
__271:
	;
__269:
	;

	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 16)) == Tuint32_t('\135') && !(inescq != 0)) {
		goto __278
	}
	goto __194
__278:
	;
	goto __193
__193:
	goto __192
	goto __194
__194:
	; // End of class-processing loop

	// -] at the end of a class is a literal '-'

	if !(class_range_state == Tuint32_t(1)) {
		goto __279
	}

	*(*Tuint32_t)(unsafe.Pointer(parsed_pattern + libc.UintptrFromInt32(-1)*4)) = Tuint32_t('\055')
	class_range_state = RANGE_NO
__279:
	;

	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_CLASS_END
	goto __84 // End of character class

	// ---- Opening parenthesis ----

__95:
	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) >= ptrend) {
		goto __280
	}
	goto UNCLOSED_PARENTHESIS
__280:
	;

	// If ( is not followed by ? it is either a capture or a special verb or an
	//     alpha assertion or a positive non-atomic lookahead.

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) != '\077') {
		goto __281
	}

	// Handle capturing brackets (or non-capturing if auto-capture is turned
	//       off).

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) != '\052') {
		goto __282
	}

	nest_depth++
	if !(options&DPCRE2_NO_AUTO_CAPTURE == Tuint32_t(0)) {
		goto __284
	}

	if !((*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount >= DMAX_GROUP_NUMBER) {
		goto __286
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR97
	goto FAILED
__286:
	;
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount++
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_CAPTURE | (*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount
	goto __285
__284:
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_NOCAPTURE
__285:
	;
	goto __283
__282:
	if !((int64(ptrend)-int64(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))/1 <= int64(1) || libc.AssignPtrUint32(bp+16, Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 1)))) == Tuint32_t('\051')) {
		goto __287
	}
	goto __84
	goto __288
__287:
	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 16)) <= 255 && int32(*(*Tuint8_t)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fctypes + uintptr(*(*Tuint32_t)(unsafe.Pointer(bp + 16))))))&Dctype_lcletter != 0) {
		goto __289
	}

	vn = uintptr(unsafe.Pointer(&alasnames))
	if !!(read_name(tls, bp+8, ptrend, utf, uint32(0), bp+56, bp+64, bp+72,
		bp+20, cb) != 0) {
		goto __291
	}
	goto FAILED
__291:
	;
	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) >= ptrend || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) != '\072') {
		goto __292
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR95 // Malformed
	goto FAILED
__292:
	;

	// Scan the table of alpha assertion names

	*(*int32)(unsafe.Pointer(bp + 48 /* i */)) = 0
__293:
	if !(*(*int32)(unsafe.Pointer(bp + 48)) < alascount) {
		goto __295
	}

	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 72)) == alasmeta[*(*int32)(unsafe.Pointer(bp + 48))].Flen && X_pcre2_strncmp_c8_8(tls, *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 64)), vn, uint64(*(*Tuint32_t)(unsafe.Pointer(bp + 72)))) == 0) {
		goto __296
	}
	goto __295
__296:
	;
	vn += uintptr(alasmeta[*(*int32)(unsafe.Pointer(bp + 48))].Flen + uint32(1))
	goto __294
__294:
	*(*int32)(unsafe.Pointer(bp + 48 /* i */))++
	goto __293
	goto __295
__295:
	;

	if !(*(*int32)(unsafe.Pointer(bp + 48)) >= alascount) {
		goto __297
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR95 // Alpha assertion not recognized
	goto FAILED
__297:
	;

	// Check for expecting an assertion condition. If so, only atomic
	//         lookaround assertions are valid.

	meta = alasmeta[*(*int32)(unsafe.Pointer(bp + 48 /* i */))].Fmeta
	if !(prev_expect_cond_assert > 0 && (meta < DMETA_LOOKAHEAD || meta > DMETA_LOOKBEHINDNOT)) {
		goto __298
	}

	if meta == DMETA_LOOKAHEAD_NA || meta == DMETA_LOOKBEHIND_NA {
		*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR98
	} else {
		*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR28
	} // (Atomic) assertion expected
	goto FAILED
__298:
	;

	// The lookaround alphabetic synonyms can mostly be handled by jumping
	//         to the code that handles the traditional symbolic forms.

	switch meta {
	default:
		goto __300 // the meta values come from a table above.

	case DMETA_ATOMIC:
		goto __301

	case DMETA_LOOKAHEAD:
		goto __302

	case DMETA_LOOKAHEAD_NA:
		goto __303

	case DMETA_LOOKAHEADNOT:
		goto __304

	case DMETA_LOOKBEHIND:
		goto __305
	case DMETA_LOOKBEHINDNOT:
		goto __306
	case DMETA_LOOKBEHIND_NA:
		goto __307

	// The script run facilities are handled here. Unicode support is
	//           required (give an error if not, as this is a security issue). Always
	//           record a META_SCRIPT_RUN item. Then, for the atomic version, insert
	//           META_ATOMIC and remember that we need two META_KETs at the end.

	case DMETA_SCRIPT_RUN:
		goto __308
	case DMETA_ATOMIC_SCRIPT_RUN:
		goto __309
	}
	goto __299

__300:
	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR89 // Unknown code; should never occur because
	goto FAILED                                                // the meta values come from a table above.

__301:
	goto ATOMIC_GROUP

__302:
	goto POSITIVE_LOOK_AHEAD

__303:
	goto POSITIVE_NONATOMIC_LOOK_AHEAD

__304:
	goto NEGATIVE_LOOK_AHEAD

__305:
__306:
__307:
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = meta
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))--
	goto POST_LOOKBEHIND

	// The script run facilities are handled here. Unicode support is
	//           required (give an error if not, as this is a security issue). Always
	//           record a META_SCRIPT_RUN item. Then, for the atomic version, insert
	//           META_ATOMIC and remember that we need two META_KETs at the end.

__308:
__309:
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_SCRIPT_RUN
	nest_depth++
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))++
	if !(meta == DMETA_ATOMIC_SCRIPT_RUN) {
		goto __310
	}

	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_ATOMIC
	if !(top_nest == uintptr(0)) {
		goto __311
	}
	top_nest = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_workspace
	goto __312
__311:
	if !(libc.PreIncUintptr(&top_nest, 12) >= end_nests) {
		goto __313
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR84
	goto FAILED
__313:
	;
__312:
	;
	(*Tnest_save)(unsafe.Pointer(top_nest)).Fnest_depth = nest_depth
	(*Tnest_save)(unsafe.Pointer(top_nest)).Fflags = uint16(DNSF_ATOMICSR)
	(*Tnest_save)(unsafe.Pointer(top_nest)).Foptions = options & (DPCRE2_CASELESS | DPCRE2_DOTALL | DPCRE2_DUPNAMES | DPCRE2_EXTENDED | DPCRE2_EXTENDED_MORE | DPCRE2_MULTILINE | DPCRE2_NO_AUTO_CAPTURE | DPCRE2_UNGREEDY)
__310:
	;
	goto __299
__299:
	;
	goto __290
__289:

	vn = uintptr(unsafe.Pointer(&verbnames))
	if !!(read_name(tls, bp+8, ptrend, utf, uint32(0), bp+56, bp+64, bp+72,
		bp+20, cb) != 0) {
		goto __314
	}
	goto FAILED
__314:
	;
	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) >= ptrend || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) != '\072' && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) != '\051') {
		goto __315
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR60 // Malformed
	goto FAILED
__315:
	;

	// Scan the table of verb names

	*(*int32)(unsafe.Pointer(bp + 48 /* i */)) = 0
__316:
	if !(*(*int32)(unsafe.Pointer(bp + 48)) < verbcount) {
		goto __318
	}

	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 72)) == verbs[*(*int32)(unsafe.Pointer(bp + 48))].Flen && X_pcre2_strncmp_c8_8(tls, *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 64)), vn, uint64(*(*Tuint32_t)(unsafe.Pointer(bp + 72)))) == 0) {
		goto __319
	}
	goto __318
__319:
	;
	vn += uintptr(verbs[*(*int32)(unsafe.Pointer(bp + 48))].Flen + uint32(1))
	goto __317
__317:
	*(*int32)(unsafe.Pointer(bp + 48 /* i */))++
	goto __316
	goto __318
__318:
	;

	if !(*(*int32)(unsafe.Pointer(bp + 48)) >= verbcount) {
		goto __320
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR60 // Verb not recognized
	goto FAILED
__320:
	;

	// An empty argument is treated as no argument.

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) == '\072' && *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))+uintptr(1) < ptrend && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 1))) == '\051') {
		goto __321
	}
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))++
__321:
	; // Advance to the closing parens

	// Check for mandatory non-empty argument; this is (*MARK)

	if !(verbs[*(*int32)(unsafe.Pointer(bp + 48))].Fhas_arg > 0 && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) != '\072') {
		goto __322
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR66
	goto FAILED
__322:
	;

	// Remember where this verb, possibly with a preceding (*MARK), starts,
	//         for handling quantified (*ACCEPT).

	verbstartptr = parsed_pattern
	okquantifier = libc.Bool32(verbs[*(*int32)(unsafe.Pointer(bp + 48))].Fmeta == DMETA_ACCEPT)

	// It appears that Perl allows any characters whatsoever, other than a
	//         closing parenthesis, to appear in arguments ("names"), so we no longer
	//         insist on letters, digits, and underscores. Perl does not, however, do
	//         any interpretation within arguments, and has no means of including a
	//         closing parenthesis. PCRE supports escape processing but only when it
	//         is requested by an option. We set inverbname TRUE here, and let the
	//         main loop take care of this so that escape and \x processing is done by
	//         the main code above.

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)), 1)))) == '\072') {
		goto __323
	} /* Skip past : or ) */

	// Some optional arguments can be treated as a preceding (*MARK)

	if !(verbs[*(*int32)(unsafe.Pointer(bp + 48))].Fhas_arg < 0) {
		goto __325
	}

	add_after_mark = verbs[*(*int32)(unsafe.Pointer(bp + 48 /* i */))].Fmeta
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_MARK
	goto __326
__325:

	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = verbs[*(*int32)(unsafe.Pointer(bp + 48))].Fmeta + func() uint32 {
		if verbs[*(*int32)(unsafe.Pointer(bp + 48))].Fmeta != DMETA_MARK {
			return 0x00010000
		}
		return uint32(0)
	}()
__326:
	;

	// Set up for reading the name in the main loop.

	verblengthptr = libc.PostIncUintptr(&parsed_pattern, 4)
	verbnamestart = *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))
	inverbname = DTRUE
	goto __324
__323: /* No verb "name" argument */

	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = verbs[*(*int32)(unsafe.Pointer(bp + 48 /* i */))].Fmeta
__324:
	;
__290:
	;
__288:
	;
__283:
	;         // End of (*VERB) handling
	goto __84 // Done with this parenthesis
__281:
	; // End of groups that don't start with (?

	// ---- Items starting (? ----

	// The type of item is determined by what follows (?. Handle (?| and option
	//     changes under "default" because both need a new block on the nest stack.
	//     Comments starting with (?# are handled above. Note that there is some
	//     ambiguity about the sequence (?- because if a digit follows it's a relative
	//     recursion or subroutine call whereas otherwise it's an option unsetting.

	if !(libc.PreIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)), 1) >= ptrend) {
		goto __327
	}
	goto UNCLOSED_PARENTHESIS
__327:
	;

	switch int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))))) {
	default:
		goto __329 // End default case after (?

	// ---- Python syntax support ----

	case '\120':
		goto __330 // End of (?P processing

	// ---- Recursion/subroutine calls by number ----

	case '\122':
		goto __331

	// An item starting (?- followed by a digit comes here via the "default"
	//       case because (?- followed by a non-digit is an options setting.

	case '\053':
		goto __332
	// Fall through

	case '\060':
		goto __333
	case '\061':
		goto __334
	case '\062':
		goto __335
	case '\063':
		goto __336
	case '\064':
		goto __337
	case '\065':
		goto __338
	case '\066':
		goto __339
	case '\067':
		goto __340
	case '\070':
		goto __341
	case '\071':
		goto __342 // End of recursive call by number handling

	// ---- Recursion/subroutine calls by name ----

	case '\046':
		goto __343

	// ---- Callout with numerical or string argument ----

	case '\103':
		goto __344 // End callout

	// ---- Conditional group ----

	// A condition can be an assertion, a number (referring to a numbered
	//       group's having been set), a name (referring to a named group), or 'R',
	//       referring to overall recursion. R<digits> and R&name are also permitted
	//       for recursion state tests. Numbers may be preceded by + or - to specify a
	//       relative group number.
	//
	//       There are several syntaxes for testing a named group: (?(name)) is used
	//       by Python; Perl 5.10 onwards uses (?(<name>) or (?('name')).
	//
	//       There are two unfortunate ambiguities. 'R' can be the recursive thing or
	//       the name 'R' (and similarly for 'R' followed by digits). 'DEFINE' can be
	//       the Perl DEFINE feature or the Python named test. We look for a name
	//       first; if not found, we try the other case.
	//
	//       For compatibility with auto-callouts, we allow a callout to be specified
	//       before a condition that is an assertion.

	case '\050':
		goto __345 // End of condition processing

	// ---- Atomic group ----

	case '\076':
		goto __346

	// ---- Lookahead assertions ----

	case '\075':
		goto __347

	case '\052':
		goto __348

	case '\041':
		goto __349

	// ---- Lookbehind assertions ----

	// (?< followed by = or ! or * is a lookbehind assertion. Otherwise (?<
	//       is the start of the name of a capturing group.

	case '\074':
		goto __350

	// ---- Define a named group ----

	// A named group may be defined as (?'name') or (?<name>). In the latter
	//       case we jump to DEFINE_NAME from the disambiguation of (?< above with the
	//       terminator set to '>'.

	case '\047':
		goto __351
	}
	goto __328

__329:
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) == '\055' && (int64(ptrend)-int64(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))/1 > int64(1) && (int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 1))) >= '\060' && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 1))) <= '\071')) {
		goto __352
	}
	goto RECURSION_BYNUMBER
__352:
	; // The + case is handled by CHAR_PLUS

	// We now have either (?| or a (possibly empty) option setting,
	//       optionally followed by a non-capturing group.

	nest_depth++
	if !(top_nest == uintptr(0)) {
		goto __353
	}
	top_nest = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_workspace
	goto __354
__353:
	if !(libc.PreIncUintptr(&top_nest, 12) >= end_nests) {
		goto __355
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR84
	goto FAILED
__355:
	;
__354:
	;
	(*Tnest_save)(unsafe.Pointer(top_nest)).Fnest_depth = nest_depth
	(*Tnest_save)(unsafe.Pointer(top_nest)).Fflags = Tuint16_t(0)
	(*Tnest_save)(unsafe.Pointer(top_nest)).Foptions = options & (DPCRE2_CASELESS | DPCRE2_DOTALL | DPCRE2_DUPNAMES | DPCRE2_EXTENDED | DPCRE2_EXTENDED_MORE | DPCRE2_MULTILINE | DPCRE2_NO_AUTO_CAPTURE | DPCRE2_UNGREEDY)

	// Start of non-capturing group that resets the capture count for each
	//       branch.

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) == '\174') {
		goto __356
	}

	(*Tnest_save)(unsafe.Pointer(top_nest)).Freset_group = Tuint16_t((*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount)
	(*Tnest_save)(unsafe.Pointer(top_nest)).Fmax_group = Tuint16_t((*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount)
	*(*Tuint16_t)(unsafe.Pointer(top_nest + 6)) |= uint16(DNSF_RESET)
	*(*Tuint32_t)(unsafe.Pointer(cb + 208)) |= Tuint32_t(DPCRE2_DUPCAPUSED)
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_NOCAPTURE
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))++
	goto __357
__356:

	hyphenok = DTRUE
	oldoptions = options

	(*Tnest_save)(unsafe.Pointer(top_nest)).Freset_group = Tuint16_t(0)
	(*Tnest_save)(unsafe.Pointer(top_nest)).Fmax_group = Tuint16_t(0)
	*(*Tuint32_t)(unsafe.Pointer(bp + 92 /* set */)) = libc.AssignPtrUint32(bp+96 /* unset */, Tuint32_t(0))
	optset = bp + 92 /* &set */

	// ^ at the start unsets imnsx and disables the subsequent use of -

	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) < ptrend && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) == '\136') {
		goto __358
	}

	options = options & libc.CplUint32(DPCRE2_CASELESS|DPCRE2_MULTILINE|DPCRE2_NO_AUTO_CAPTURE|DPCRE2_DOTALL|DPCRE2_EXTENDED|DPCRE2_EXTENDED_MORE)
	hyphenok = DFALSE
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))++
__358:
	;

__359:
	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) < ptrend && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) != '\051' && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) != '\072') {
		goto __360
	}

	switch int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)), 1)))) {
	case '\055':
		goto __362

	case '\112':
		goto __363

	case '\151':
		goto __364
	case '\155':
		goto __365
	case '\156':
		goto __366
	case '\163':
		goto __367
	case '\125':
		goto __368

	// If x appears twice it sets the extended extended option.

	case '\170':
		goto __369

	default:
		goto __370
	}
	goto __361

__362:
	if !!(hyphenok != 0) {
		goto __371
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR94
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))-- // Correct the offset
	goto FAILED
__371:
	;
	optset = bp + 96 /* &unset */
	hyphenok = DFALSE
	goto __361

__363: // Record that it changed in the external options
	*(*Tuint32_t)(unsafe.Pointer(optset)) |= DPCRE2_DUPNAMES
	*(*Tuint32_t)(unsafe.Pointer(cb + 208)) |= Tuint32_t(DPCRE2_JCHANGED)
	goto __361

__364:
	*(*Tuint32_t)(unsafe.Pointer(optset)) |= DPCRE2_CASELESS
	goto __361
__365:
	*(*Tuint32_t)(unsafe.Pointer(optset)) |= DPCRE2_MULTILINE
	goto __361
__366:
	*(*Tuint32_t)(unsafe.Pointer(optset)) |= DPCRE2_NO_AUTO_CAPTURE
	goto __361
__367:
	*(*Tuint32_t)(unsafe.Pointer(optset)) |= DPCRE2_DOTALL
	goto __361
__368:
	*(*Tuint32_t)(unsafe.Pointer(optset)) |= DPCRE2_UNGREEDY
	goto __361

	// If x appears twice it sets the extended extended option.

__369:
	*(*Tuint32_t)(unsafe.Pointer(optset)) |= DPCRE2_EXTENDED
	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) < ptrend && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) == '\170') {
		goto __372
	}

	*(*Tuint32_t)(unsafe.Pointer(optset)) |= DPCRE2_EXTENDED_MORE
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))++
__372:
	;
	goto __361

__370:
	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR11
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))-- // Correct the offset
	goto FAILED
__361:
	;
	goto __359
__360:
	;

	// If we are setting extended without extended-more, ensure that any
	//         existing extended-more gets unset. Also, unsetting extended must also
	//         unset extended-more.

	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 92))&(DPCRE2_EXTENDED|DPCRE2_EXTENDED_MORE) == DPCRE2_EXTENDED || *(*Tuint32_t)(unsafe.Pointer(bp + 96))&DPCRE2_EXTENDED != Tuint32_t(0)) {
		goto __373
	}
	*(*Tuint32_t)(unsafe.Pointer(bp + 96 /* unset */)) |= DPCRE2_EXTENDED_MORE
__373:
	;

	options = (options | *(*Tuint32_t)(unsafe.Pointer(bp + 92))) & ^*(*Tuint32_t)(unsafe.Pointer(bp + 96))

	// If the options ended with ')' this is not the start of a nested
	//         group with option changes, so the options change at this level.
	//         In this case, if the previous level set up a nest block, discard the
	//         one we have just created. Otherwise adjust it for the previous level.
	//         If the options ended with ':' we are starting a non-capturing group,
	//         possibly with an options setting.

	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) >= ptrend) {
		goto __374
	}
	goto UNCLOSED_PARENTHESIS
__374:
	;
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)), 1)))) == '\051') {
		goto __375
	}

	nest_depth-- // This is not a nested group after all.
	if !(top_nest > (*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_workspace && int32((*Tnest_save)(unsafe.Pointer(top_nest-uintptr(1)*12)).Fnest_depth) == int32(nest_depth)) {
		goto __377
	}
	top_nest -= 12
	goto __378
__377:
	(*Tnest_save)(unsafe.Pointer(top_nest)).Fnest_depth = nest_depth
__378:
	;
	goto __376
__375:
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_NOCAPTURE
__376:
	;

	// If nothing changed, no need to record.

	if !(options != oldoptions) {
		goto __379
	}

	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_OPTIONS
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = options
__379:
	;
__357:
	;          // End options processing
	goto __328 // End default case after (?

	// ---- Python syntax support ----

__330:
	if !(libc.PreIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)), 1) >= ptrend) {
		goto __380
	}
	goto UNCLOSED_PARENTHESIS
__380:
	;

	// (?P<name> is the same as (?<name>, which defines a named group.

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) == '\074') {
		goto __381
	}

	terminator = Tuint32_t('\076')
	goto DEFINE_NAME
__381:
	;

	// (?P>name) is the same as (?&name), which is a recursion or subroutine
	//       call.

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) == '\076') {
		goto __382
	}
	goto RECURSE_BY_NAME
__382:
	;

	// (?P=name) is the same as \k<name>, a back reference by name. Anything
	//       else after (?P is an error.

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) != '\075') {
		goto __383
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR41
	goto FAILED
__383:
	;
	if !!(read_name(tls, bp+8, ptrend, utf, uint32('\051'), bp+56, bp+64,
		bp+72, bp+20, cb) != 0) {
		goto __384
	}
	goto FAILED
__384:
	;
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_BACKREF_BYNAME
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = *(*Tuint32_t)(unsafe.Pointer(bp + 72 /* namelen */))
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = Tuint32_t(*(*Tsize_t)(unsafe.Pointer(bp + 56)) >> 32)
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = Tuint32_t(*(*Tsize_t)(unsafe.Pointer(bp + 56)) & uint64(0xffffffff))

	okquantifier = DTRUE
	goto __328 // End of (?P processing

	// ---- Recursion/subroutine calls by number ----

__331:
	*(*int32)(unsafe.Pointer(bp + 48 /* i */)) = 0 // (?R) == (?R0)
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))++
	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) >= ptrend || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) != '\051') {
		goto __385
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR58
	goto FAILED
__385:
	;
	goto SET_RECURSION

	// An item starting (?- followed by a digit comes here via the "default"
	//       case because (?- followed by a non-digit is an options setting.

__332:
	if !((int64(ptrend)-int64(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))/1 < int64(2) || !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 1))) >= '\060' && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 1))) <= '\071')) {
		goto __386
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR29 // Missing number
	goto FAILED
__386:
	;
	// Fall through

__333:
__334:
__335:
__336:
__337:
__338:
__339:
__340:
__341:
__342:
RECURSION_BYNUMBER:
	if !!(read_number(tls, bp+8, ptrend,
		func() int32 {
			if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) >= '\060' && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) <= '\071' {
				return -1
			}
			return int32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount)
		}(),
		DMAX_GROUP_NUMBER, ERR61,
		bp+48, bp+20) != 0) {
		goto __387
	}
	goto FAILED
__387:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 48)) < 0) {
		goto __388
	} /* NB (?0) is permitted */

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR15 // Unknown group
	goto FAILED_BACK
__388:
	;
	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) >= ptrend || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) != '\051') {
		goto __389
	}
	goto UNCLOSED_PARENTHESIS
__389:
	;

SET_RECURSION:
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_RECURSE | Tuint32_t(*(*int32)(unsafe.Pointer(bp + 48)))
	*(*Tsize_t)(unsafe.Pointer(bp + 56 /* offset */)) = Tsize_t((int64(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))) - int64((*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_pattern)) / 1)
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))++
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = Tuint32_t(*(*Tsize_t)(unsafe.Pointer(bp + 56)) >> 32)
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = Tuint32_t(*(*Tsize_t)(unsafe.Pointer(bp + 56)) & uint64(0xffffffff))

	okquantifier = DTRUE
	goto __328 // End of recursive call by number handling

	// ---- Recursion/subroutine calls by name ----

__343:
RECURSE_BY_NAME:
	if !!(read_name(tls, bp+8, ptrend, utf, uint32('\051'), bp+56, bp+64,
		bp+72, bp+20, cb) != 0) {
		goto __390
	}
	goto FAILED
__390:
	;
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_RECURSE_BYNAME
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = *(*Tuint32_t)(unsafe.Pointer(bp + 72 /* namelen */))
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = Tuint32_t(*(*Tsize_t)(unsafe.Pointer(bp + 56)) >> 32)
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = Tuint32_t(*(*Tsize_t)(unsafe.Pointer(bp + 56)) & uint64(0xffffffff))

	okquantifier = DTRUE
	goto __328

	// ---- Callout with numerical or string argument ----

__344:
	if !(libc.PreIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)), 1) >= ptrend) {
		goto __391
	}
	goto UNCLOSED_PARENTHESIS
__391:
	;

	// If the previous item was a condition starting (?(? an assertion,
	//       optionally preceded by a callout, is expected. This is checked later on,
	//       during actual compilation. However we need to identify this kind of
	//       assertion in this pass because it must not be qualified. The value of
	//       expect_cond_assert is set to 2 after (?(? is processed. We decrement it
	//       for a callout - still leaving a positive value that identifies the
	//       assertion. Multiple callouts or any other items will make it zero or
	//       less, which doesn't matter because they will cause an error later.

	expect_cond_assert = prev_expect_cond_assert - 1

	// If previous_callout is not NULL, it means this follows a previous
	//       callout. If it was a manual callout, do nothing; this means its "length
	//       of next pattern item" field will remain zero. If it was an automatic
	//       callout, abolish it.

	if !(*(*uintptr)(unsafe.Pointer(bp)) != uintptr(0) && options&DPCRE2_AUTO_CALLOUT != Tuint32_t(0) && *(*uintptr)(unsafe.Pointer(bp)) == parsed_pattern-uintptr(4)*4 && *(*Tuint32_t)(unsafe.Pointer(parsed_pattern + libc.UintptrFromInt32(-1)*4)) == Tuint32_t(255)) {
		goto __392
	}
	parsed_pattern = *(*uintptr)(unsafe.Pointer(bp /* previous_callout */))
__392:
	;

	// Save for updating next pattern item length, and skip one item before
	//       completing.

	*(*uintptr)(unsafe.Pointer(bp /* previous_callout */)) = parsed_pattern
	after_manual_callout = 1

	// Handle a string argument; specific delimiter is required.

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) != '\051' && !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) >= '\060' && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) <= '\071')) {
		goto __393
	}

	startptr = *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))

	delimiter = Tuint32_t(0)
	*(*int32)(unsafe.Pointer(bp + 48 /* i */)) = 0
__395:
	if !(X_pcre2_callout_start_delims_8[*(*int32)(unsafe.Pointer(bp + 48))] != Tuint32_t(0)) {
		goto __397
	}

	if !(Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) == X_pcre2_callout_start_delims_8[*(*int32)(unsafe.Pointer(bp + 48))]) {
		goto __398
	}

	delimiter = X_pcre2_callout_end_delims_8[*(*int32)(unsafe.Pointer(bp + 48 /* i */))]
	goto __397
__398:
	;
	goto __396
__396:
	*(*int32)(unsafe.Pointer(bp + 48 /* i */))++
	goto __395
	goto __397
__397:
	;
	if !(delimiter == Tuint32_t(0)) {
		goto __399
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR82
	goto FAILED
__399:
	;

	*(*Tuint32_t)(unsafe.Pointer(parsed_pattern)) = DMETA_CALLOUT_STRING
	parsed_pattern += 4 * uintptr(3) // Skip pattern info

__400:

	if !(libc.PreIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)), 1) >= ptrend) {
		goto __403
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR81
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)) = startptr // To give a more useful message
	goto FAILED
__403:
	;
	if !(Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) == delimiter && (libc.PreIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)), 1) >= ptrend || Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) != delimiter)) {
		goto __404
	}
	goto __402
__404:
	;
	goto __401
__401:
	goto __400
	goto __402
__402:
	;

	calloutlength = Tsize_t((int64(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))) - int64(startptr)) / 1)
	if !(calloutlength > uint64(4294967295)) {
		goto __405
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR72
	goto FAILED
__405:
	;
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = Tuint32_t(calloutlength)
	*(*Tsize_t)(unsafe.Pointer(bp + 56 /* offset */)) = Tsize_t((int64(startptr) - int64((*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_pattern)) / 1)
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = Tuint32_t(*(*Tsize_t)(unsafe.Pointer(bp + 56)) >> 32)
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = Tuint32_t(*(*Tsize_t)(unsafe.Pointer(bp + 56)) & uint64(0xffffffff))

	goto __394
__393:

	n = 0
	*(*Tuint32_t)(unsafe.Pointer(parsed_pattern)) = DMETA_CALLOUT_NUMBER // Numerical callout
	parsed_pattern += 4 * uintptr(3)                                     // Skip pattern info
__406:
	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) < ptrend && (int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) >= '\060' && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) <= '\071')) {
		goto __407
	}

	n = n*10 + int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)), 1)))) - '\060'
	if !(n > 255) {
		goto __408
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR38
	goto FAILED
__408:
	;
	goto __406
__407:
	;
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = Tuint32_t(n)
__394:
	;

	// Both formats must have a closing parenthesis

	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) >= ptrend || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) != '\051') {
		goto __409
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR39
	goto FAILED
__409:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))++

	// Remember the offset to the next item in the pattern, and set a default
	//       length. This should get updated after the next item is read.

	*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* previous_callout */)) + 1*4)) = Tuint32_t((int64(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))) - int64((*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_pattern)) / 1)
	*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* previous_callout */)) + 2*4)) = Tuint32_t(0)
	goto __328 // End callout

	// ---- Conditional group ----

	// A condition can be an assertion, a number (referring to a numbered
	//       group's having been set), a name (referring to a named group), or 'R',
	//       referring to overall recursion. R<digits> and R&name are also permitted
	//       for recursion state tests. Numbers may be preceded by + or - to specify a
	//       relative group number.
	//
	//       There are several syntaxes for testing a named group: (?(name)) is used
	//       by Python; Perl 5.10 onwards uses (?(<name>) or (?('name')).
	//
	//       There are two unfortunate ambiguities. 'R' can be the recursive thing or
	//       the name 'R' (and similarly for 'R' followed by digits). 'DEFINE' can be
	//       the Perl DEFINE feature or the Python named test. We look for a name
	//       first; if not found, we try the other case.
	//
	//       For compatibility with auto-callouts, we allow a callout to be specified
	//       before a condition that is an assertion.

__345:
	if !(libc.PreIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)), 1) >= ptrend) {
		goto __410
	}
	goto UNCLOSED_PARENTHESIS
__410:
	;
	nest_depth++

	// If the next character is ? or * there must be an assertion next
	//       (optionally preceded by a callout). We do not check this here, but
	//       instead we set expect_cond_assert to 2. If this is still greater than
	//       zero (callouts decrement it) when the next assertion is read, it will be
	//       marked as a condition that must not be repeated. A value greater than
	//       zero also causes checking that an assertion (possibly with callout)
	//       follows.

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) == '\077' || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) == '\052') {
		goto __411
	}

	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_COND_ASSERT
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))-- // Pull pointer back to the opening parenthesis.
	expect_cond_assert = 2
	goto __328 // End of conditional
__411:
	;

	// Handle (?([+-]number)...

	if !(read_number(tls, bp+8, ptrend, int32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount), DMAX_GROUP_NUMBER, ERR61, bp+48,
		bp+20) != 0) {
		goto __412
	}

	if !(*(*int32)(unsafe.Pointer(bp + 48)) <= 0) {
		goto __414
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR15
	goto FAILED
__414:
	;
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_COND_NUMBER
	*(*Tsize_t)(unsafe.Pointer(bp + 56 /* offset */)) = Tsize_t((int64(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)))-int64((*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_pattern))/1 - int64(2))
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = Tuint32_t(*(*Tsize_t)(unsafe.Pointer(bp + 56)) >> 32)
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = Tuint32_t(*(*Tsize_t)(unsafe.Pointer(bp + 56)) & uint64(0xffffffff))

	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = Tuint32_t(*(*int32)(unsafe.Pointer(bp + 48 /* i */)))
	goto __413
__412:
	if !(*(*int32)(unsafe.Pointer(bp + 20)) != 0) {
		goto __415
	}
	goto FAILED
	goto __416
__415:
	if !((int64(ptrend)-int64(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))/1 >= int64(10) && X_pcre2_strncmp_c8_8(tls, *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)), ts+615, uint64(7)) == 0 && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 7))) != '\051') {
		goto __417
	}

	ge = Tuint32_t(0)
	*(*int32)(unsafe.Pointer(bp + 100 /* major */)) = 0
	minor = 0

	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(7)
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) == '\076') {
		goto __419
	}

	ge = Tuint32_t(1)
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))++
__419:
	;

	// NOTE: cannot write IS_DIGIT(*(++ptr)) here because IS_DIGIT
	//         references its argument twice.

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) != '\075' || func() bool {
		*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))++
		return !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) >= '\060' && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) <= '\071')
	}()) {
		goto __420
	}
	goto BAD_VERSION_CONDITION
__420:
	;

	if !!(read_number(tls, bp+8, ptrend, -1, uint32(1000), ERR79, bp+100, bp+20) != 0) {
		goto __421
	}
	goto FAILED
__421:
	;

	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) >= ptrend) {
		goto __422
	}
	goto BAD_VERSION_CONDITION
__422:
	;
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) == '\056') {
		goto __423
	}

	if !(libc.PreIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)), 1) >= ptrend || !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) >= '\060' && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) <= '\071')) {
		goto __424
	}
	goto BAD_VERSION_CONDITION
__424:
	;
	minor = (int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)), 1)))) - '\060') * 10
	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) >= ptrend) {
		goto __425
	}
	goto BAD_VERSION_CONDITION
__425:
	;
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) >= '\060' && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) <= '\071') {
		goto __426
	}
	minor = minor + (int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)), 1)))) - '\060')
__426:
	;
	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) >= ptrend || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) != '\051') {
		goto __427
	}
	goto BAD_VERSION_CONDITION
__427:
	;
__423:
	;

	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_COND_VERSION
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = ge
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = Tuint32_t(*(*int32)(unsafe.Pointer(bp + 100 /* major */)))
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = Tuint32_t(minor)
	goto __418
__417:

	was_r_ampersand = DFALSE

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) == '\122' && (int64(ptrend)-int64(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))/1 > int64(1) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 1))) == '\046') {
		goto __428
	}

	terminator = Tuint32_t('\051')
	was_r_ampersand = DTRUE
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))++
	goto __429
__428:
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) == '\074') {
		goto __430
	}
	terminator = Tuint32_t('\076')
	goto __431
__430:
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) == '\047') {
		goto __432
	}
	terminator = Tuint32_t('\047')
	goto __433
__432:

	terminator = Tuint32_t('\051')
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))-- // Point to char before name
__433:
	;
__431:
	;
__429:
	;
	if !!(read_name(tls, bp+8, ptrend, utf, terminator, bp+56, bp+64, bp+72,
		bp+20, cb) != 0) {
		goto __434
	}
	goto FAILED
__434:
	;

	// Handle (?(R&name)

	if !(was_r_ampersand != 0) {
		goto __435
	}

	*(*Tuint32_t)(unsafe.Pointer(parsed_pattern)) = DMETA_COND_RNAME
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))-- // Back to closing parens
	goto __436
__435:
	if !(terminator == Tuint32_t('\051')) {
		goto __437
	}

	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 72)) == Tuint32_t(6) && X_pcre2_strncmp_c8_8(tls, *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 64)), ts+623, uint64(6)) == 0) {
		goto __439
	}
	*(*Tuint32_t)(unsafe.Pointer(parsed_pattern)) = DMETA_COND_DEFINE
	goto __440
__439:

	*(*int32)(unsafe.Pointer(bp + 48 /* i */)) = 1
__441:
	if !(*(*int32)(unsafe.Pointer(bp + 48)) < int32(*(*Tuint32_t)(unsafe.Pointer(bp + 72)))) {
		goto __443
	}
	if !!(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 64)) + uintptr(*(*int32)(unsafe.Pointer(bp + 48)))))) >= '\060' && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 64)) + uintptr(*(*int32)(unsafe.Pointer(bp + 48)))))) <= '\071') {
		goto __444
	}
	goto __443
__444:
	;
	goto __442
__442:
	*(*int32)(unsafe.Pointer(bp + 48 /* i */))++
	goto __441
	goto __443
__443:
	;
	*(*Tuint32_t)(unsafe.Pointer(parsed_pattern)) = func() uint32 {
		if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 64))))) == '\122' && *(*int32)(unsafe.Pointer(bp + 48)) >= int32(*(*Tuint32_t)(unsafe.Pointer(bp + 72))) {
			return DMETA_COND_RNUMBER
		}
		return DMETA_COND_NAME
	}()
__440:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))-- // Back to closing parens
	goto __438
__437:
	*(*Tuint32_t)(unsafe.Pointer(parsed_pattern)) = DMETA_COND_NAME
__438:
	;
__436:
	;

	// All these cases except DEFINE end with the name length and offset;
	//         DEFINE just has an offset (for the "too many branches" error).

	if !(*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) != DMETA_COND_DEFINE) {
		goto __445
	}
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = *(*Tuint32_t)(unsafe.Pointer(bp + 72 /* namelen */))
__445:
	;
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = Tuint32_t(*(*Tsize_t)(unsafe.Pointer(bp + 56)) >> 32)
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = Tuint32_t(*(*Tsize_t)(unsafe.Pointer(bp + 56)) & uint64(0xffffffff))

__418:
	;
__416:
	;
__413:
	; // End cases that read a name

	// Check the closing parenthesis of the condition

	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) >= ptrend || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))) != '\051') {
		goto __446
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR24
	goto FAILED
__446:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))++
	goto __328 // End of condition processing

	// ---- Atomic group ----

__346:
ATOMIC_GROUP: // Come from (*atomic:
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_ATOMIC
	nest_depth++
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))++
	goto __328

	// ---- Lookahead assertions ----

__347:
POSITIVE_LOOK_AHEAD: // Come from (*pla:
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_LOOKAHEAD
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))++
	goto POST_ASSERTION

__348:
POSITIVE_NONATOMIC_LOOK_AHEAD: // Come from (?*
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_LOOKAHEAD_NA
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))++
	goto POST_ASSERTION

__349:
NEGATIVE_LOOK_AHEAD: // Come from (*nla:
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_LOOKAHEADNOT
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))++
	goto POST_ASSERTION

	// ---- Lookbehind assertions ----

	// (?< followed by = or ! or * is a lookbehind assertion. Otherwise (?<
	//       is the start of the name of a capturing group.

__350:
	if !((int64(ptrend)-int64(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))))/1 <= int64(1) || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 1))) != '\075' && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 1))) != '\041' && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 1))) != '\052') {
		goto __447
	}

	terminator = Tuint32_t('\076')
	goto DEFINE_NAME
__447:
	;
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = func() uint32 {
		if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 1))) == '\075' {
			return DMETA_LOOKBEHIND
		}
		return func() uint32 {
			if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) + 1))) == '\041' {
				return DMETA_LOOKBEHINDNOT
			}
			return DMETA_LOOKBEHIND_NA
		}()
	}()

POST_LOOKBEHIND: // Come from (*plb: (*naplb: and (*nlb:
	*(*TBOOL)(unsafe.Pointer(has_lookbehind)) = DTRUE
	*(*Tsize_t)(unsafe.Pointer(bp + 56 /* offset */)) = Tsize_t((int64(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)))-int64((*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_pattern))/1 - int64(2))
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = Tuint32_t(*(*Tsize_t)(unsafe.Pointer(bp + 56)) >> 32)
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = Tuint32_t(*(*Tsize_t)(unsafe.Pointer(bp + 56)) & uint64(0xffffffff))

	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(2)
	// Fall through

	// If the previous item was a condition starting (?(? an assertion,
	//       optionally preceded by a callout, is expected. This is checked later on,
	//       during actual compilation. However we need to identify this kind of
	//       assertion in this pass because it must not be qualified. The value of
	//       expect_cond_assert is set to 2 after (?(? is processed. We decrement it
	//       for a callout - still leaving a positive value that identifies the
	//       assertion. Multiple callouts or any other items will make it zero or
	//       less, which doesn't matter because they will cause an error later.

POST_ASSERTION:
	nest_depth++
	if !(prev_expect_cond_assert > 0) {
		goto __448
	}

	if !(top_nest == uintptr(0)) {
		goto __449
	}
	top_nest = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_workspace
	goto __450
__449:
	if !(libc.PreIncUintptr(&top_nest, 12) >= end_nests) {
		goto __451
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR84
	goto FAILED
__451:
	;
__450:
	;
	(*Tnest_save)(unsafe.Pointer(top_nest)).Fnest_depth = nest_depth
	(*Tnest_save)(unsafe.Pointer(top_nest)).Fflags = uint16(DNSF_CONDASSERT)
	(*Tnest_save)(unsafe.Pointer(top_nest)).Foptions = options & (DPCRE2_CASELESS | DPCRE2_DOTALL | DPCRE2_DUPNAMES | DPCRE2_EXTENDED | DPCRE2_EXTENDED_MORE | DPCRE2_MULTILINE | DPCRE2_NO_AUTO_CAPTURE | DPCRE2_UNGREEDY)
__448:
	;
	goto __328

	// ---- Define a named group ----

	// A named group may be defined as (?'name') or (?<name>). In the latter
	//       case we jump to DEFINE_NAME from the disambiguation of (?< above with the
	//       terminator set to '>'.

__351:
	terminator = Tuint32_t('\047') // Terminator

DEFINE_NAME:
	if !!(read_name(tls, bp+8, ptrend, utf, terminator, bp+56, bp+64, bp+72,
		bp+20, cb) != 0) {
		goto __452
	}
	goto FAILED
__452:
	;

	// We have a name for this capturing group. It is also assigned a number,
	//       which is its primary means of identification.

	if !((*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount >= DMAX_GROUP_NUMBER) {
		goto __453
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR97
	goto FAILED
__453:
	;
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount++
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_CAPTURE | (*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount
	nest_depth++

	// Check not too many names

	if !(int32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnames_found) >= DMAX_NAME_COUNT) {
		goto __454
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR49
	goto FAILED
__454:
	;

	// Adjust the entry size to accommodate the longest name found.

	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 72))+Tuint32_t(DIMM2_SIZE)+Tuint32_t(1) > Tuint32_t((*Tcompile_block_8)(unsafe.Pointer(cb)).Fname_entry_size)) {
		goto __455
	}
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Fname_entry_size = Tuint16_t(*(*Tuint32_t)(unsafe.Pointer(bp + 72)) + Tuint32_t(DIMM2_SIZE) + Tuint32_t(1))
__455:
	;

	// Scan the list to check for duplicates. For duplicate names, if the
	//       number is the same, break the loop, which causes the name to be
	//       discarded; otherwise, if DUPNAMES is not set, give an error.
	//       If it is set, allow the name with a different number, but continue
	//       scanning in case this is a duplicate with the same number. For
	//       non-duplicate names, give an error if the number is duplicated.

	isdupname = DFALSE
	ng = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fnamed_groups
	*(*int32)(unsafe.Pointer(bp + 48 /* i */)) = 0
__456:
	if !(*(*int32)(unsafe.Pointer(bp + 48)) < int32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnames_found)) {
		goto __458
	}

	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 72)) == Tuint32_t((*Tnamed_group_8)(unsafe.Pointer(ng)).Flength) && X_pcre2_strncmp_8(tls, *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 64)), (*Tnamed_group_8)(unsafe.Pointer(ng)).Fname, Tsize_t(*(*Tuint32_t)(unsafe.Pointer(bp + 72)))) == 0) {
		goto __459
	}

	if !((*Tnamed_group_8)(unsafe.Pointer(ng)).Fnumber == (*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount) {
		goto __461
	}
	goto __458
__461:
	;
	if !(options&DPCRE2_DUPNAMES == Tuint32_t(0)) {
		goto __462
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR43
	goto FAILED
__462:
	;
	isdupname = TBOOL(libc.AssignPtrUint16(ng+14, Tuint16_t(DTRUE))) // Mark as a duplicate
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Fdupnames = DTRUE        // Duplicate names exist
	goto __460
__459:
	if !((*Tnamed_group_8)(unsafe.Pointer(ng)).Fnumber == (*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount) {
		goto __463
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR65
	goto FAILED
__463:
	;
__460:
	;
	goto __457
__457:
	*(*int32)(unsafe.Pointer(bp + 48 /* i */))++
	ng += 16
	goto __456
	goto __458
__458:
	;

	if !(*(*int32)(unsafe.Pointer(bp + 48)) < int32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnames_found)) {
		goto __464
	}
	goto __328
__464:
	; // Ignore duplicate with same number

	// Increase the list size if necessary

	if !(Tuint32_t((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnames_found) >= (*Tcompile_block_8)(unsafe.Pointer(cb)).Fnamed_group_list_size) {
		goto __465
	}

	newsize = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fnamed_group_list_size * Tuint32_t(2)
	newspace =
		(*struct {
			f func(*libc.TLS, Tsize_t, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_real_compile_context_8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fcx)).Fmemctl.Fmalloc})).f(tls, uint64(newsize)*uint64(unsafe.Sizeof(Tnamed_group_8{})),
			(*Tpcre2_real_compile_context_8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fcx)).Fmemctl.Fmemory_data)
	if !(newspace == uintptr(0)) {
		goto __466
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR21
	goto FAILED
__466:
	;

	libc.Xmemcpy(tls, newspace, (*Tcompile_block_8)(unsafe.Pointer(cb)).Fnamed_groups,
		uint64((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnamed_group_list_size)*uint64(unsafe.Sizeof(Tnamed_group_8{})))
	if !((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnamed_group_list_size > Tuint32_t(DNAMED_GROUP_LIST_SIZE)) {
		goto __467
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_real_compile_context_8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fcx)).Fmemctl.Ffree})).f(tls, (*Tcompile_block_8)(unsafe.Pointer(cb)).Fnamed_groups,
		(*Tpcre2_real_compile_context_8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fcx)).Fmemctl.Fmemory_data)
__467:
	;
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Fnamed_groups = newspace
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Fnamed_group_list_size = newsize
__465:
	;

	// Add this name to the list

	(*Tnamed_group_8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnamed_groups + uintptr((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnames_found)*16)).Fname = *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 64 /* name */))
	(*Tnamed_group_8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnamed_groups + uintptr((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnames_found)*16)).Flength = Tuint16_t(*(*Tuint32_t)(unsafe.Pointer(bp + 72 /* namelen */)))
	(*Tnamed_group_8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnamed_groups + uintptr((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnames_found)*16)).Fnumber = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount
	(*Tnamed_group_8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnamed_groups + uintptr((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnames_found)*16)).Fisdup = Tuint16_t(isdupname)
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Fnames_found++
	goto __328
__328:
	;         // End of (? switch
	goto __84 // End of ( handling

	// ---- Branch terminators ----

	// Alternation: reset the capture count if we are in a (?| group.

__96:
	if !(top_nest != uintptr(0) && int32((*Tnest_save)(unsafe.Pointer(top_nest)).Fnest_depth) == int32(nest_depth) && uint32((*Tnest_save)(unsafe.Pointer(top_nest)).Fflags)&DNSF_RESET != uint32(0)) {
		goto __468
	}

	if !((*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount > Tuint32_t((*Tnest_save)(unsafe.Pointer(top_nest)).Fmax_group)) {
		goto __469
	}
	(*Tnest_save)(unsafe.Pointer(top_nest)).Fmax_group = Tuint16_t((*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount)
__469:
	;
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount = Tuint32_t((*Tnest_save)(unsafe.Pointer(top_nest)).Freset_group)
__468:
	;
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_ALT
	goto __84

	// End of group; reset the capture count to the maximum if we are in a (?|
	//     group and/or reset the options that are tracked during parsing. Disallow
	//     quantifier for a condition that is an assertion.

__97:
	okquantifier = DTRUE
	if !(top_nest != uintptr(0) && int32((*Tnest_save)(unsafe.Pointer(top_nest)).Fnest_depth) == int32(nest_depth)) {
		goto __470
	}

	options = options&libc.CplUint32(DPCRE2_CASELESS|DPCRE2_DOTALL|DPCRE2_DUPNAMES|DPCRE2_EXTENDED|DPCRE2_EXTENDED_MORE|DPCRE2_MULTILINE|DPCRE2_NO_AUTO_CAPTURE|DPCRE2_UNGREEDY) | (*Tnest_save)(unsafe.Pointer(top_nest)).Foptions
	if !(uint32((*Tnest_save)(unsafe.Pointer(top_nest)).Fflags)&DNSF_RESET != uint32(0) && Tuint32_t((*Tnest_save)(unsafe.Pointer(top_nest)).Fmax_group) > (*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount) {
		goto __471
	}
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount = Tuint32_t((*Tnest_save)(unsafe.Pointer(top_nest)).Fmax_group)
__471:
	;
	if !(uint32((*Tnest_save)(unsafe.Pointer(top_nest)).Fflags)&DNSF_CONDASSERT != uint32(0)) {
		goto __472
	}
	okquantifier = DFALSE
__472:
	;

	if !(uint32((*Tnest_save)(unsafe.Pointer(top_nest)).Fflags)&DNSF_ATOMICSR != uint32(0)) {
		goto __473
	}

	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_KET
__473:
	;

	if !(top_nest == (*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_workspace) {
		goto __474
	}
	top_nest = uintptr(0)
	goto __475
__474:
	top_nest -= 12
__475:
	;
__470:
	;
	if !(int32(nest_depth) == 0) {
		goto __476
	} /* Unmatched closing parenthesis */

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR22
	goto FAILED_BACK
__476:
	;
	nest_depth--
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_KET
	goto __84
__84:
	; // End of switch on pattern character
	goto __19
__20:
	; // End of main character scan loop

	// End of pattern reached. Check for missing ) at the end of a verb name.

	if !(inverbname != 0 && *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8)) >= ptrend) {
		goto __477
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR60
	goto FAILED
__477:
	;

	// Manage callout for the final item

PARSED_END:
	parsed_pattern = manage_callouts(tls, *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */)), bp, auto_callout,
		parsed_pattern, cb)

	// Insert trailing items for word and line matching (features provided for the
	// benefit of pcre2grep).

	if !(extra_options&DPCRE2_EXTRA_MATCH_LINE != Tuint32_t(0)) {
		goto __478
	}

	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_KET
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_DOLLAR
	goto __479
__478:
	if !(extra_options&DPCRE2_EXTRA_MATCH_WORD != Tuint32_t(0)) {
		goto __480
	}

	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_KET
	*(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_ESCAPE + ESC_b
__480:
	;
__479:
	;

	// Terminate the parsed pattern, then return success if all groups are closed.
	// Otherwise we have unclosed parentheses.

	if !(parsed_pattern >= parsed_pattern_end) {
		goto __481
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR63 // Internal error (parsed pattern overflow)
	goto FAILED
__481:
	;

	*(*Tuint32_t)(unsafe.Pointer(parsed_pattern)) = DMETA_END
	if !(int32(nest_depth) == 0) {
		goto __482
	}
	return 0
__482:
	;

UNCLOSED_PARENTHESIS:
	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR14

	// Come here for all failures.

FAILED:
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Ferroroffset = Tsize_t((int64(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8))) - int64((*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_pattern)) / 1)
	return *(*int32)(unsafe.Pointer(bp + 20 /* errorcode */))

	// Some errors need to indicate the previous character.

FAILED_BACK:
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* ptr */))--
	goto FAILED

	// This failure happens several times.

BAD_VERSION_CONDITION:
	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR79
	goto FAILED
	return int32(0)
}

// ************************************************
//
//       Find first significant opcode            *
//

// This is called by several functions that scan a compiled expression looking
// for a fixed first character, or an anchoring opcode etc. It skips over things
// that do not influence this. For some calls, it makes sense to skip negative
// forward and all backward assertions, and also the \b assertion; for others it
// does not.
//
// Arguments:
//   code         pointer to the start of the group
//   skipassert   TRUE if certain assertions are to be skipped
//
// Returns:       pointer to the first significant opcode

func first_significant_code(tls *libc.TLS, code TPCRE2_SPTR8, skipassert TBOOL) uintptr { /* pcre2_compile.c:4845:25: */
	for {
		switch int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code))) {
		case OP_ASSERT_NOT:
			fallthrough
		case OP_ASSERTBACK:
			fallthrough
		case OP_ASSERTBACK_NOT:
			fallthrough
		case OP_ASSERTBACK_NA:
			if !(skipassert != 0) {
				return code
			}
			for __ccgo := true; __ccgo; __ccgo = int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code))) == OP_ALT {
				code += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))))
			}
			code += TPCRE2_SPTR8(X_pcre2_OP_lengths_8[*(*TPCRE2_UCHAR8)(unsafe.Pointer(code))])
			break

		case OP_WORD_BOUNDARY:
			fallthrough
		case OP_NOT_WORD_BOUNDARY:
			if !(skipassert != 0) {
				return code
			}
			fallthrough
		// Fall through

		case OP_CALLOUT:
			fallthrough
		case OP_CREF:
			fallthrough
		case OP_DNCREF:
			fallthrough
		case OP_RREF:
			fallthrough
		case OP_DNRREF:
			fallthrough
		case OP_FALSE:
			fallthrough
		case OP_TRUE:
			code += TPCRE2_SPTR8(X_pcre2_OP_lengths_8[*(*TPCRE2_UCHAR8)(unsafe.Pointer(code))])
			break

		case OP_CALLOUT_STR:
			code += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 5)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 6)))))
			break

		case OP_SKIPZERO:
			code += TPCRE2_SPTR8(uint32(2) + uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3)))) + uint32(DLINK_SIZE))
			break

		case OP_COND:
			fallthrough
		case OP_SCOND:
			if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3))) != OP_FALSE || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + uintptr(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))))))) != OP_KET { // More than one branch
				return code
			}
			code += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))) + uint32(1) + uint32(DLINK_SIZE))
			break

		case OP_MARK:
			fallthrough
		case OP_COMMIT_ARG:
			fallthrough
		case OP_PRUNE_ARG:
			fallthrough
		case OP_SKIP_ARG:
			fallthrough
		case OP_THEN_ARG:
			code += TPCRE2_SPTR8(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1))) + int32(X_pcre2_OP_lengths_8[*(*TPCRE2_UCHAR8)(unsafe.Pointer(code))]))
			break

		default:
			return code
		}
	}
	return uintptr(0)
	// Control never reaches here
}

// ************************************************
//
//           Get othercase range                  *
//

// This function is passed the start and end of a class range in UCP mode. It
// searches up the characters, looking for ranges of characters in the "other"
// case. Each call returns the next one, updating the start address. A character
// with multiple other cases is returned on its own with a special return value.
//
// Arguments:
//   cptr        points to starting character value; updated
//   d           end value
//   ocptr       where to put start of othercase range
//   odptr       where to put end of othercase range
//
// Yield:        -1 when no more
//                0 when a range is returned
//               >0 the CASESET offset for char with multiple other cases
//                 in this case, ocptr contains the original

func get_othercase_range(tls *libc.TLS, cptr uintptr, d Tuint32_t, ocptr uintptr, odptr uintptr) int32 { /* pcre2_compile.c:4932:1: */
	var c Tuint32_t
	var othercase Tuint32_t
	var next Tuint32_t
	var co uint32

	// Find the first character that has an other case. If it has multiple other
	// cases, return its case offset value.

	for c = *(*Tuint32_t)(unsafe.Pointer(cptr)); c <= d; c++ {
		if libc.AssignUint32(&co, uint32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12)).Fcaseset)) != uint32(0) {
			*(*Tuint32_t)(unsafe.Pointer(ocptr)) = libc.PostIncUint32(&c, 1) // Character that has the set
			*(*Tuint32_t)(unsafe.Pointer(cptr)) = c                          // Rest of input range
			return int32(co)
		}
		if libc.AssignUint32(&othercase, Tuint32_t(int32(c)+(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12)).Fother_case)) != c {
			break
		}
	}

	if c > d {
		return -1
	} // Reached end of range

	// Found a character that has a single other case. Search for the end of the
	// range, which is either the end of the input range, or a character that has zero
	// or more than one other cases.

	*(*Tuint32_t)(unsafe.Pointer(ocptr)) = othercase
	next = othercase + Tuint32_t(1)

	for c++; c <= d; c++ {
		if libc.AssignUint32(&co, uint32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12)).Fcaseset)) != uint32(0) || Tuint32_t(int32(c)+(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12)).Fother_case) != next {
			break
		}
		next++
	}

	*(*Tuint32_t)(unsafe.Pointer(odptr)) = next - Tuint32_t(1) // End of othercase range
	*(*Tuint32_t)(unsafe.Pointer(cptr)) = c                    // Rest of input range
	return 0
}

// ************************************************
//
// Add a character or range to a class (internal) *
//

// This function packages up the logic of adding a character or range of
// characters to a class. The character values in the arguments will be within the
// valid values for the current mode (8-bit, 16-bit, UTF, etc). This function is
// called only from within the "add to class" group of functions, some of which
// are recursive and mutually recursive. The external entry point is
// add_to_class().
//
// Arguments:
//   classbits     the bit map for characters < 256
//   uchardptr     points to the pointer for extra data
//   options       the options word
//   cb            compile data
//   start         start of range character
//   end           end of range character
//
// Returns:        the number of < 256 characters added
//                 the pointer to extra data is updated

func add_to_class_internal(tls *libc.TLS, classbits uintptr, uchardptr uintptr, options Tuint32_t, cb uintptr, start Tuint32_t, end Tuint32_t) uint32 { /* pcre2_compile.c:4999:1: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	// var c Tuint32_t at bp, 4

	var classbits_end Tuint32_t = func() uint32 {
		if end <= Tuint32_t(0xff) {
			return end
		}
		return uint32(0xff)
	}()
	var n8 uint32 = uint32(0)

	// If caseless matching is required, scan the range and process alternate
	// cases. In Unicode, there are 8-bit characters that have alternate cases that
	// are greater than 255 and vice-versa. Sometimes we can just extend the original
	// range.

	if options&DPCRE2_CASELESS != Tuint32_t(0) {
		if options&(DPCRE2_UTF|DPCRE2_UCP) != Tuint32_t(0) {
			var rc int32
			// var oc Tuint32_t at bp+4, 4

			// var od Tuint32_t at bp+8, 4

			options = options & libc.CplUint32(DPCRE2_CASELESS) // Remove for recursive calls
			*(*Tuint32_t)(unsafe.Pointer(bp /* c */)) = start

			for libc.AssignInt32(&rc, get_othercase_range(tls, bp, end, bp+4, bp+8)) >= 0 {
				// Handle a single character that has more than one other case.

				if rc > 0 {
					n8 = n8 + add_list_to_class_internal(tls, classbits, uchardptr, options, cb,
						uintptr(unsafe.Pointer(&X_pcre2_ucd_caseless_sets_8))+uintptr(rc)*4, *(*Tuint32_t)(unsafe.Pointer(bp + 4)))
				} else if *(*Tuint32_t)(unsafe.Pointer(bp + 4)) >= (*Tcompile_block_8)(unsafe.Pointer(cb)).Fclass_range_start && *(*Tuint32_t)(unsafe.Pointer(bp + 8)) <= (*Tcompile_block_8)(unsafe.Pointer(cb)).Fclass_range_end {
					continue
				} else if *(*Tuint32_t)(unsafe.Pointer(bp + 4)) < start && *(*Tuint32_t)(unsafe.Pointer(bp + 8)) >= start-Tuint32_t(1) {
					start = *(*Tuint32_t)(unsafe.Pointer(bp + 4 /* oc */))
				} else if *(*Tuint32_t)(unsafe.Pointer(bp + 8)) > end && *(*Tuint32_t)(unsafe.Pointer(bp + 4)) <= end+Tuint32_t(1) {
					end = *(*Tuint32_t)(unsafe.Pointer(bp + 8 /* od */)) // Extend upwards
					if end > classbits_end {
						classbits_end = func() uint32 {
							if end <= Tuint32_t(0xff) {
								return end
							}
							return uint32(0xff)
						}()
					}
				} else {
					n8 = n8 + add_to_class_internal(tls, classbits, uchardptr, options, cb, *(*Tuint32_t)(unsafe.Pointer(bp + 4)), *(*Tuint32_t)(unsafe.Pointer(bp + 8)))
				}
			}
		} else {

			// Not UTF mode

			for *(*Tuint32_t)(unsafe.Pointer(bp /* c */)) = start; *(*Tuint32_t)(unsafe.Pointer(bp /* c */)) <= classbits_end; *(*Tuint32_t)(unsafe.Pointer(bp /* c */))++ {
				*(*Tuint8_t)(unsafe.Pointer(classbits + uintptr(int32(*(*Tuint8_t)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Ffcc + uintptr(*(*Tuint32_t)(unsafe.Pointer(bp))))))/8))) = Tuint8_t(uint32(*(*Tuint8_t)(unsafe.Pointer(classbits + uintptr(int32(*(*Tuint8_t)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Ffcc + uintptr(*(*Tuint32_t)(unsafe.Pointer(bp))))))/8)))) | uint32(1)<<(int32(*(*Tuint8_t)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Ffcc + uintptr(*(*Tuint32_t)(unsafe.Pointer(bp))))))&7))
				n8++
			}
		}
	}

	// Now handle the originally supplied range. Adjust the final value according
	// to the bit length - this means that the same lists of (e.g.) horizontal spaces
	// can be used in all cases.

	if options&DPCRE2_UTF == Tuint32_t(0) && end > uint32(0xffffffff)>>(32-DPCRE2_CODE_UNIT_WIDTH) {
		end = uint32(0xffffffff) >> (32 - DPCRE2_CODE_UNIT_WIDTH)
	}

	if start > (*Tcompile_block_8)(unsafe.Pointer(cb)).Fclass_range_start && end < (*Tcompile_block_8)(unsafe.Pointer(cb)).Fclass_range_end {
		return n8
	}

	// Use the bitmap for characters < 256. Otherwise use extra data.

	for *(*Tuint32_t)(unsafe.Pointer(bp /* c */)) = start; *(*Tuint32_t)(unsafe.Pointer(bp /* c */)) <= classbits_end; *(*Tuint32_t)(unsafe.Pointer(bp /* c */))++ {
		// Regardless of start, c will always be <= 255.
		*(*Tuint8_t)(unsafe.Pointer(classbits + uintptr(*(*Tuint32_t)(unsafe.Pointer(bp))/Tuint32_t(8)))) = Tuint8_t(uint32(*(*Tuint8_t)(unsafe.Pointer(classbits + uintptr(*(*Tuint32_t)(unsafe.Pointer(bp))/Tuint32_t(8))))) | uint32(1)<<(*(*Tuint32_t)(unsafe.Pointer(bp))&Tuint32_t(7)))
		n8++
	}

	if start <= Tuint32_t(0xff) {
		start = Tuint32_t(0xff + 1)
	}

	if end >= start {
		var uchardata uintptr = *(*uintptr)(unsafe.Pointer(uchardptr))

		if options&DPCRE2_UTF != Tuint32_t(0) {
			if start < end {
				*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&uchardata, 1))) = TPCRE2_UCHAR8(DXCL_RANGE)
				uchardata += uintptr(X_pcre2_ord2utf_8(tls, start, uchardata))
				uchardata += uintptr(X_pcre2_ord2utf_8(tls, end, uchardata))
			} else if start == end {
				*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&uchardata, 1))) = TPCRE2_UCHAR8(DXCL_SINGLE)
				uchardata += uintptr(X_pcre2_ord2utf_8(tls, start, uchardata))
			}
		} else {
		}
		*(*uintptr)(unsafe.Pointer(uchardptr)) = uchardata // Updata extra data pointer
	}

	return n8 // Number of 8-bit characters
}

// ************************************************
//
// Add a list of characters to a class (internal) *
//

// This function is used for adding a list of case-equivalent characters to a
// class when in UTF mode. This function is called only from within
// add_to_class_internal(), with which it is mutually recursive.
//
// Arguments:
//   classbits     the bit map for characters < 256
//   uchardptr     points to the pointer for extra data
//   options       the options word
//   cb            contains pointers to tables etc.
//   p             points to row of 32-bit values, terminated by NOTACHAR
//   except        character to omit; this is used when adding lists of
//                   case-equivalent characters to avoid including the one we
//                   already know about
//
// Returns:        the number of < 256 characters added
//                 the pointer to extra data is updated

func add_list_to_class_internal(tls *libc.TLS, classbits uintptr, uchardptr uintptr, options Tuint32_t, cb uintptr, p uintptr, except uint32) uint32 { /* pcre2_compile.c:5154:1: */
	var n8 uint32 = uint32(0)
	for *(*Tuint32_t)(unsafe.Pointer(p)) < DNOTACHAR {
		var n uint32 = uint32(0)
		if *(*Tuint32_t)(unsafe.Pointer(p)) != except {
			for *(*Tuint32_t)(unsafe.Pointer(p + uintptr(n+uint32(1))*4)) == *(*Tuint32_t)(unsafe.Pointer(p))+n+Tuint32_t(1) {
				n++
			}
			n8 = n8 + add_to_class_internal(tls, classbits, uchardptr, options, cb, *(*Tuint32_t)(unsafe.Pointer(p)), *(*Tuint32_t)(unsafe.Pointer(p + uintptr(n)*4)))
		}
		p += 4 * uintptr(n+uint32(1))
	}
	return n8
}

// ************************************************
//
//   External entry point for add range to class  *
//

// This function sets the overall range so that the internal functions can try
// to avoid duplication when handling case-independence.
//
// Arguments:
//   classbits     the bit map for characters < 256
//   uchardptr     points to the pointer for extra data
//   options       the options word
//   cb            compile data
//   start         start of range character
//   end           end of range character
//
// Returns:        the number of < 256 characters added
//                 the pointer to extra data is updated

func add_to_class(tls *libc.TLS, classbits uintptr, uchardptr uintptr, options Tuint32_t, cb uintptr, start Tuint32_t, end Tuint32_t) uint32 { /* pcre2_compile.c:5194:1: */
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Fclass_range_start = start
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Fclass_range_end = end
	return add_to_class_internal(tls, classbits, uchardptr, options, cb, start, end)
}

// ************************************************
//
//   External entry point for add list to class   *
//

// This function is used for adding a list of horizontal or vertical whitespace
// characters to a class. The list must be in order so that ranges of characters
// can be detected and handled appropriately. This function sets the overall range
// so that the internal functions can try to avoid duplication when handling
// case-independence.
//
// Arguments:
//   classbits     the bit map for characters < 256
//   uchardptr     points to the pointer for extra data
//   options       the options word
//   cb            contains pointers to tables etc.
//   p             points to row of 32-bit values, terminated by NOTACHAR
//   except        character to omit; this is used when adding lists of
//                   case-equivalent characters to avoid including the one we
//                   already know about
//
// Returns:        the number of < 256 characters added
//                 the pointer to extra data is updated

func add_list_to_class(tls *libc.TLS, classbits uintptr, uchardptr uintptr, options Tuint32_t, cb uintptr, p uintptr, except uint32) uint32 { /* pcre2_compile.c:5228:1: */
	var n8 uint32 = uint32(0)
	for *(*Tuint32_t)(unsafe.Pointer(p)) < DNOTACHAR {
		var n uint32 = uint32(0)
		if *(*Tuint32_t)(unsafe.Pointer(p)) != except {
			for *(*Tuint32_t)(unsafe.Pointer(p + uintptr(n+uint32(1))*4)) == *(*Tuint32_t)(unsafe.Pointer(p))+n+Tuint32_t(1) {
				n++
			}
			(*Tcompile_block_8)(unsafe.Pointer(cb)).Fclass_range_start = *(*Tuint32_t)(unsafe.Pointer(p))
			(*Tcompile_block_8)(unsafe.Pointer(cb)).Fclass_range_end = *(*Tuint32_t)(unsafe.Pointer(p + uintptr(n)*4))
			n8 = n8 + add_to_class_internal(tls, classbits, uchardptr, options, cb, *(*Tuint32_t)(unsafe.Pointer(p)), *(*Tuint32_t)(unsafe.Pointer(p + uintptr(n)*4)))
		}
		p += 4 * uintptr(n+uint32(1))
	}
	return n8
}

// ************************************************
//
//    Add characters not in a list to a class     *
//

// This function is used for adding the complement of a list of horizontal or
// vertical whitespace to a class. The list must be in order.
//
// Arguments:
//   classbits     the bit map for characters < 256
//   uchardptr     points to the pointer for extra data
//   options       the options word
//   cb            contains pointers to tables etc.
//   p             points to row of 32-bit values, terminated by NOTACHAR
//
// Returns:        the number of < 256 characters added
//                 the pointer to extra data is updated

func add_not_list_to_class(tls *libc.TLS, classbits uintptr, uchardptr uintptr, options Tuint32_t, cb uintptr, p uintptr) uint32 { /* pcre2_compile.c:5268:1: */
	var utf TBOOL = libc.Bool32(options&DPCRE2_UTF != Tuint32_t(0))
	var n8 uint32 = uint32(0)
	if *(*Tuint32_t)(unsafe.Pointer(p)) > Tuint32_t(0) {
		n8 = n8 + add_to_class(tls, classbits, uchardptr, options, cb, uint32(0), *(*Tuint32_t)(unsafe.Pointer(p))-Tuint32_t(1))
	}
	for *(*Tuint32_t)(unsafe.Pointer(p)) < DNOTACHAR {
		for *(*Tuint32_t)(unsafe.Pointer(p + 1*4)) == *(*Tuint32_t)(unsafe.Pointer(p))+Tuint32_t(1) {
			p += 4
		}
		n8 = n8 + add_to_class(tls, classbits, uchardptr, options, cb, *(*Tuint32_t)(unsafe.Pointer(p))+Tuint32_t(1),
			func() uint32 {
				if *(*Tuint32_t)(unsafe.Pointer(p + 1*4)) == DNOTACHAR {
					return func() uint32 {
						if utf != 0 {
							return 0x10ffff
						}
						return 0xffffffff
					}()
				}
				return *(*Tuint32_t)(unsafe.Pointer(p + 1*4)) - Tuint32_t(1)
			}())
		p += 4
	}
	return n8
}

// ************************************************
//
//    Find details of duplicate group names       *
//

// This is called from compile_branch() when it needs to know the index and
// count of duplicates in the names table when processing named backreferences,
// either directly, or as conditions.
//
// Arguments:
//   name          points to the name
//   length        the length of the name
//   indexptr      where to put the index
//   countptr      where to put the count of duplicates
//   errorcodeptr  where to put an error code
//   cb            the compile block
//
// Returns:        TRUE if OK, FALSE if not, error code set

func find_dupname_details(tls *libc.TLS, name TPCRE2_SPTR8, length Tuint32_t, indexptr uintptr, countptr uintptr, errorcodeptr uintptr, cb uintptr) TBOOL { /* pcre2_compile.c:5307:1: */
	var i Tuint32_t
	var groupnumber Tuint32_t
	var count int32
	var slot uintptr = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fname_table

	// Find the first entry in the table

	for i = Tuint32_t(0); i < Tuint32_t((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnames_found); i++ {
		if X_pcre2_strncmp_8(tls, name, slot+uintptr(DIMM2_SIZE), uint64(length)) == 0 && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(slot + uintptr(Tuint32_t(DIMM2_SIZE)+length)))) == 0 {
			break
		}
		slot += uintptr((*Tcompile_block_8)(unsafe.Pointer(cb)).Fname_entry_size)
	}

	// This should not occur, because this function is called only when we know we
	// have duplicate names. Give an internal error.

	if i >= Tuint32_t((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnames_found) {
		*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR53
		(*Tcompile_block_8)(unsafe.Pointer(cb)).Ferroroffset = Tsize_t((int64(name) - int64((*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_pattern)) / 1)
		return DFALSE
	}

	// Record the index and then see how many duplicates there are, updating the
	// backref map and maximum back reference as we do.

	*(*int32)(unsafe.Pointer(indexptr)) = int32(i)
	count = 0

	for {
		count++
		groupnumber = uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(slot)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(slot + 1))))
		*(*Tuint32_t)(unsafe.Pointer(cb + 252)) |= func() uint32 {
			if groupnumber < Tuint32_t(32) {
				return uint32(1) << groupnumber
			}
			return uint32(1)
		}()
		if groupnumber > (*Tcompile_block_8)(unsafe.Pointer(cb)).Ftop_backref {
			(*Tcompile_block_8)(unsafe.Pointer(cb)).Ftop_backref = groupnumber
		}
		if libc.PreIncUint32(&i, 1) >= Tuint32_t((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnames_found) {
			break
		}
		slot += uintptr((*Tcompile_block_8)(unsafe.Pointer(cb)).Fname_entry_size)
		if X_pcre2_strncmp_8(tls, name, slot+uintptr(DIMM2_SIZE), uint64(length)) != 0 || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(slot + uintptr(DIMM2_SIZE) + uintptr(length)))) != 0 {
			break
		}
	}

	*(*int32)(unsafe.Pointer(countptr)) = count
	return DTRUE
}

// ************************************************
//
//           Compile one branch                   *
//

// Scan the parsed pattern, compiling it into the a vector of PCRE2_UCHAR. If
// the options are changed during the branch, the pointer is used to change the
// external options bits. This function is used during the pre-compile phase when
// we are trying to find out the amount of memory needed, as well as during the
// real compile phase. The value of lengthptr distinguishes the two phases.
//
// Arguments:
//   optionsptr        pointer to the option bits
//   codeptr           points to the pointer to the current code point
//   pptrptr           points to the current parsed pattern pointer
//   errorcodeptr      points to error code variable
//   firstcuptr        place to put the first required code unit
//   firstcuflagsptr   place to put the first code unit flags
//   reqcuptr          place to put the last required code unit
//   reqcuflagsptr     place to put the last required code unit flags
//   bcptr             points to current branch chain
//   cb                contains pointers to tables etc.
//   lengthptr         NULL during the real compile phase
//                     points to length accumulator during pre-compile phase
//
// Returns:            0 There's been an error, *errorcodeptr is non-zero
//                    +1 Success, this branch must match at least one character
//                    -1 Success, this branch may match an empty string

func compile_branch(tls *libc.TLS, optionsptr uintptr, codeptr uintptr, pptrptr uintptr, errorcodeptr uintptr, firstcuptr uintptr, firstcuflagsptr uintptr, reqcuptr uintptr, reqcuflagsptr uintptr, bcptr uintptr, cb uintptr, lengthptr uintptr) int32 { /* pcre2_compile.c:5387:1: */
	bp := tls.Alloc(136)
	defer tls.Free(136)

	var bravalue int32
	var okreturn int32
	var group_return int32
	var repeat_min Tuint32_t
	var repeat_max Tuint32_t // To please picky compilers
	var greedy_default Tuint32_t
	var greedy_non_default Tuint32_t
	var repeat_type Tuint32_t
	var op_type Tuint32_t
	var options Tuint32_t // May change dynamically
	var firstcu Tuint32_t
	var reqcu Tuint32_t
	var zeroreqcu Tuint32_t
	var zerofirstcu Tuint32_t
	var escape Tuint32_t
	// var pptr uintptr at bp+96, 8

	var meta Tuint32_t
	var meta_arg Tuint32_t
	var firstcuflags Tuint32_t
	var reqcuflags Tuint32_t
	var zeroreqcuflags Tuint32_t
	var zerofirstcuflags Tuint32_t
	var req_caseopt Tuint32_t
	var reqvary Tuint32_t
	var tempreqvary Tuint32_t
	var offset Tsize_t
	// var length_prevgroup Tsize_t at bp+120, 8

	var code uintptr
	var last_code uintptr
	var orig_code uintptr
	// var tempcode uintptr at bp+88, 8

	var previous uintptr
	var op_previous TPCRE2_UCHAR8
	var groupsetfirstcu TBOOL
	var had_accept TBOOL
	var matched_char TBOOL
	var previous_matched_char TBOOL
	var reset_caseful TBOOL
	var cbits uintptr
	// var classbits [32]Tuint8_t at bp, 32

	// We can fish out the UTF setting once and for all into a BOOL, but we must
	// not do this for other options (e.g. PCRE2_EXTENDED) because they may change
	// dynamically as we process the pattern.

	var utf TBOOL
	var ucp TBOOL

	// Helper variables for OP_XCLASS opcode (for characters > 255). We define
	// class_uchardata always so that it can be passed to add_to_class() always,
	// though it will not be used in non-UTF 8-bit cases. This avoids having to supply
	// alternative calls for the different cases.

	// var class_uchardata uintptr at bp+64, 8

	var xclass TBOOL
	var class_uchardata_base uintptr
	var d Tuint32_t
	var c Tuint32_t
	var d1 Tuint32_t
	var c1 Tuint32_t
	var i int32
	var i1 int32
	var local_negate TBOOL
	var posix_class int32
	var taboffset int32
	var tabopt int32
	// var pbits [32]Tuint8_t at bp+32, 32

	var i2 int32
	var i3 int32
	var ptype Tuint32_t
	var pdata Tuint32_t
	var i4 int32
	var i5 int32
	var i6 int32
	var i7 int32
	var i8 int32
	var i9 int32
	var c2 Tuint32_t
	var d2 Tuint32_t
	var i10 int32
	var i11 int32
	// var count int32 at bp+84, 4

	// var index int32 at bp+80, 4

	var i12 uint32
	var name TPCRE2_SPTR8
	var ng uintptr
	var length Tuint32_t
	var tc uintptr
	var condcount int32
	// var count1 int32 at bp+132, 4

	// var index1 int32 at bp+128, 4

	var name1 TPCRE2_SPTR8
	var is_dupname TBOOL
	var ng1 uintptr
	var length1 Tuint32_t
	var i13 uint32
	var pp TPCRE2_SPTR8
	var delimiter Tuint32_t
	var length2 Tuint32_t
	var callout_string uintptr
	var lastchar uintptr
	var delta Tsize_t
	var replicate int32
	var i14 int32
	var linkoffset int32
	var delta1 Tsize_t
	var i15 Tuint32_t
	var delta2 Tsize_t
	var linkoffset1 int32
	var oldlinkoffset int32
	var linkoffset2 int32
	var bra uintptr
	var i16 Tuint32_t
	var nlen int32
	var ketcode uintptr
	var bracode uintptr
	var len int32
	var bralink uintptr
	var brazeroptr uintptr
	var prop_type int32
	var prop_value int32
	var oldcode uintptr
	var repcode uint32
	var len1 int32
	var ptype1 Tuint32_t
	var pdata1 Tuint32_t
	var caseset Tuint32_t
	var i17 int32
	var xclass_has_prop TBOOL
	var negate_class TBOOL
	var should_flip_negation TBOOL
	var match_all_or_no_wide_chars TBOOL
	var possessive_quantifier TBOOL
	var note_group_empty TBOOL
	var class_has_8bitchar int32
	var mclength Tuint32_t
	var skipunits Tuint32_t
	// var subreqcu Tuint32_t at bp+112, 4

	// var subfirstcu Tuint32_t at bp+104, 4

	var groupnumber Tuint32_t
	var verbarglen Tuint32_t
	var verbculen Tuint32_t
	// var subreqcuflags Tuint32_t at bp+116, 4

	// var subfirstcuflags Tuint32_t at bp+108, 4

	var oc uintptr
	// var mcbuffer [8]TPCRE2_UCHAR8 at bp+72, 8
	bravalue = 0
	okreturn = -1
	group_return = 0
	repeat_min = Tuint32_t(0)
	repeat_max = Tuint32_t(0)
	options = *(*Tuint32_t)(unsafe.Pointer(optionsptr))
	*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) = *(*uintptr)(unsafe.Pointer(pptrptr))
	offset = uint64(0)
	*(*Tsize_t)(unsafe.Pointer(bp + 120 /* length_prevgroup */)) = uint64(0)
	code = *(*uintptr)(unsafe.Pointer(codeptr))
	last_code = code
	orig_code = code
	previous = uintptr(0)
	groupsetfirstcu = DFALSE
	had_accept = DFALSE
	matched_char = DFALSE
	previous_matched_char = DFALSE
	reset_caseful = DFALSE
	cbits = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fcbits
	utf = libc.Bool32(options&DPCRE2_UTF != Tuint32_t(0))
	ucp = libc.Bool32(options&DPCRE2_UCP != Tuint32_t(0))

	// Set up the default and non-default settings for greediness

	greedy_default = Tuint32_t(libc.Bool32(options&DPCRE2_UNGREEDY != Tuint32_t(0)))
	greedy_non_default = greedy_default ^ Tuint32_t(1)

	// Initialize no first unit, no required unit. REQ_UNSET means "no char
	// matching encountered yet". It gets changed to REQ_NONE if we hit something that
	// matches a non-fixed first unit; reqcu just remains unset if we never find one.
	//
	// When we hit a repeat whose minimum is zero, we may have to adjust these values
	// to take the zero repeat into account. This is implemented by setting them to
	// zerofirstcu and zeroreqcu when such a repeat is encountered. The individual
	// item types that can be repeated set these backoff variables appropriately.

	firstcu = libc.AssignUint32(&reqcu, libc.AssignUint32(&zerofirstcu, libc.AssignUint32(&zeroreqcu, Tuint32_t(0))))
	firstcuflags = libc.AssignUint32(&reqcuflags, libc.AssignUint32(&zerofirstcuflags, libc.AssignUint32(&zeroreqcuflags, DREQ_UNSET)))

	// The variable req_caseopt contains either the REQ_CASELESS bit or zero,
	// according to the current setting of the caseless flag. The REQ_CASELESS value
	// leaves the lower 28 bit empty. It is added into the firstcu or reqcu variables
	// to record the case status of the value. This is used only for ASCII characters.

	if options&DPCRE2_CASELESS != Tuint32_t(0) {
		req_caseopt = DREQ_CASELESS
	} else {
		req_caseopt = uint32(0)
	}

	// Switch on next META item until the end of the branch

__1:
	;

	// Get next META item in the pattern and its potential argument.

	meta = *(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)))) & 0xffff0000
	meta_arg = *(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)))) & 0x0000ffff

	// If we are in the pre-compile phase, accumulate the length used for the
	//   previous cycle of this loop, unless the next item is a quantifier.

	if !(lengthptr != uintptr(0)) {
		goto __4
	}

	if !(code > (*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_workspace+uintptr((*Tcompile_block_8)(unsafe.Pointer(cb)).Fworkspace_size)-uintptr(100)) {
		goto __5
	} /* Check for overrun */

	*(*int32)(unsafe.Pointer(errorcodeptr)) = func() int32 {
		if code >= (*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_workspace+uintptr((*Tcompile_block_8)(unsafe.Pointer(cb)).Fworkspace_size) {
			return ERR52
		}
		return ERR86
	}()
	return 0
__5:
	;

	// There is at least one situation where code goes backwards: this is the
	//     case of a zero quantifier after a class (e.g. [ab]{0}). When the quantifier
	//     is processed, the whole class is eliminated. However, it is created first,
	//     so we have to allow memory for it. Therefore, don't ever reduce the length
	//     at this point.

	if !(code < last_code) {
		goto __6
	}
	code = last_code
__6:
	;

	// If the next thing is not a quantifier, we add the length of the previous
	//     item into the total, and reset the code pointer to the start of the
	//     workspace. Otherwise leave the previous item available to be quantified.

	if !(meta < DMETA_ASTERISK || meta > DMETA_MINMAX_QUERY) {
		goto __7
	}

	if !(uint64(0x7fffffff-20)-*(*Tsize_t)(unsafe.Pointer(lengthptr)) < Tsize_t((int64(code)-int64(orig_code))/1)) {
		goto __8
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR20 // Integer overflow
	return 0
__8:
	;
	*(*Tsize_t)(unsafe.Pointer(lengthptr)) += Tsize_t((int64(code) - int64(orig_code)) / 1)
	if !(*(*Tsize_t)(unsafe.Pointer(lengthptr)) > uint64(int32(1)<<16)) {
		goto __9
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR20 // Pattern is too large
	return 0
__9:
	;
	code = orig_code
__7:
	;

	// Remember where this code item starts so we can catch the "backwards"
	//     case above next time round.

	last_code = code
__4:
	;

	// Process the next parsed pattern item. If it is not a quantifier, remember
	//   where it starts so that it can be quantified when a quantifier follows.
	//   Checking for the legality of quantifiers happens in parse_regex(), except for
	//   a quantifier after an assertion that is a condition.

	if !(meta < DMETA_ASTERISK || meta > DMETA_MINMAX_QUERY) {
		goto __10
	}

	previous = code
	if !(matched_char != 0 && !(had_accept != 0)) {
		goto __11
	}
	okreturn = 1
__11:
	;
__10:
	;

	previous_matched_char = matched_char
	matched_char = DFALSE
	note_group_empty = DFALSE
	skipunits = Tuint32_t(0) // Default value for most subgroups

	switch meta {
	// ===================================================================
	// The branch terminates at pattern end or | or )

	case DMETA_END:
		goto __13
	case DMETA_ALT:
		goto __14
	case DMETA_KET:
		goto __15

	// ===================================================================
	// Handle single-character metacharacters. In multiline mode, ^ disables
	//     the setting of any following char as a first character.

	case DMETA_CIRCUMFLEX:
		goto __16

	case DMETA_DOLLAR:
		goto __17

	// There can never be a first char if '.' is first, whatever happens about
	//     repeats. The value of reqcu doesn't change either.

	case DMETA_DOT:
		goto __18

	// ===================================================================
	// Empty character classes are allowed if PCRE2_ALLOW_EMPTY_CLASS is set.
	//     Otherwise, an initial ']' is taken as a data character. When empty classes
	//     are allowed, [] must always fail, so generate OP_FAIL, whereas [^] must
	//     match any character, so generate OP_ALLANY.

	case DMETA_CLASS_EMPTY:
		goto __19
	case DMETA_CLASS_EMPTY_NOT:
		goto __20

	// ===================================================================
	// Non-empty character class. If the included characters are all < 256, we
	//     build a 32-byte bitmap of the permitted characters, except in the special
	//     case where there is only one such character. For negated classes, we build
	//     the map as usual, then invert it at the end. However, we use a different
	//     opcode so that data characters > 255 can be handled correctly.
	//
	//     If the class contains characters outside the 0-255 range, a different
	//     opcode is compiled. It may optionally have a bit map for characters < 256,
	//     but those above are are explicitly listed afterwards. A flag code unit
	//     tells whether the bitmap is present, and whether this is a negated class or
	//     not.

	case DMETA_CLASS_NOT:
		goto __21
	case DMETA_CLASS:
		goto __22 // End of class processing

	// ===================================================================
	// Deal with (*VERB)s.

	// Check for open captures before ACCEPT and close those that are within
	//     the same assertion level, also converting ACCEPT to ASSERT_ACCEPT in an
	//     assertion. In the first pass, just accumulate the length required;
	//     otherwise hitting (*ACCEPT) inside many nested parentheses can cause
	//     workspace overflow. Do not set firstcu after *ACCEPT.

	case DMETA_ACCEPT:
		goto __23

	case DMETA_PRUNE:
		goto __24
	case DMETA_SKIP:
		goto __25
	// Fall through
	case DMETA_COMMIT:
		goto __26
	case DMETA_FAIL:
		goto __27

	case DMETA_THEN:
		goto __28

	// Handle verbs with arguments. Arguments can be very long, especially in
	//     16- and 32-bit modes, and can overflow the workspace in the first pass.
	//     However, the argument length is constrained to be small enough to fit in
	//     one code unit. This check happens in parse_regex(). In the first pass,
	//     instead of putting the argument into memory, we just update the length
	//     counter and set up an empty argument.

	case DMETA_THEN_ARG:
		goto __29

	case DMETA_PRUNE_ARG:
		goto __30
	case DMETA_SKIP_ARG:
		goto __31
	// Fall through
	case DMETA_MARK:
		goto __32
	case DMETA_COMMIT_ARG:
		goto __33

	// ===================================================================
	// Handle options change. The new setting must be passed back for use in
	//     subsequent branches. Reset the greedy defaults and the case value for
	//     firstcu and reqcu.

	case DMETA_OPTIONS:
		goto __34

	// ===================================================================
	// Handle conditional subpatterns. The case of (?(Rdigits) is ambiguous
	//     because it could be a numerical check on recursion, or a name check on a
	//     group's being set. The pre-pass sets up META_COND_RNUMBER as a name so that
	//     we can handle it either way. We first try for a name; if not found, process
	//     the number.

	case DMETA_COND_RNUMBER:
		goto __35 // (?(Rdigits)
	case DMETA_COND_NAME:
		goto __36 // (?(name) or (?'name') or ?(<name>)
	case DMETA_COND_RNAME:
		goto __37

	// The DEFINE condition is always false. Its internal groups may never
	//     be called, so matched_char must remain false, hence the jump to
	//     GROUP_PROCESS rather than GROUP_PROCESS_NOTE_EMPTY.

	case DMETA_COND_DEFINE:
		goto __38

	// Conditional test of a group's being set.

	case DMETA_COND_NUMBER:
		goto __39

	// Test for the PCRE2 version.

	case DMETA_COND_VERSION:
		goto __40

	// The condition is an assertion, possibly preceded by a callout.

	case DMETA_COND_ASSERT:
		goto __41

	// ===================================================================
	// Handle all kinds of nested bracketed groups. The non-capturing,
	//     non-conditional cases are here; others come to GROUP_PROCESS via goto.

	case DMETA_LOOKAHEAD:
		goto __42

	case DMETA_LOOKAHEAD_NA:
		goto __43

	// Optimize (?!) to (*FAIL) unless it is quantified - which is a weird
	//     thing to do, but Perl allows all assertions to be quantified, and when
	//     they contain capturing parentheses there may be a potential use for
	//     this feature. Not that that applies to a quantified (?!) but we allow
	//     it for uniformity.

	case DMETA_LOOKAHEADNOT:
		goto __44

	case DMETA_LOOKBEHIND:
		goto __45

	case DMETA_LOOKBEHINDNOT:
		goto __46

	case DMETA_LOOKBEHIND_NA:
		goto __47

	case DMETA_ATOMIC:
		goto __48

	case DMETA_SCRIPT_RUN:
		goto __49

	case DMETA_NOCAPTURE:
		goto __50 // End of nested group handling

	// ===================================================================
	// Handle named backreferences and recursions.

	case DMETA_BACKREF_BYNAME:
		goto __51
	case DMETA_RECURSE_BYNAME:
		goto __52

	// ===================================================================
	// Handle a numerical callout.

	case DMETA_CALLOUT_NUMBER:
		goto __53

	// ===================================================================
	// Handle a callout with a string argument. In the pre-pass we just compute
	//     the length without generating anything. The length in pptr[3] includes both
	//     delimiters; in the actual compile only the first one is copied, but a
	//     terminating zero is added. Any doubled delimiters within the string make
	//     this an overestimate, but it is not worth bothering about.

	case DMETA_CALLOUT_STRING:
		goto __54

	// ===================================================================
	// Handle repetition. The different types are all sorted out in the parsing
	//     pass.

	case DMETA_MINMAX_PLUS:
		goto __55
	case DMETA_MINMAX_QUERY:
		goto __56
	case DMETA_MINMAX:
		goto __57

	case DMETA_ASTERISK:
		goto __58
	case DMETA_ASTERISK_PLUS:
		goto __59
	case DMETA_ASTERISK_QUERY:
		goto __60

	case DMETA_PLUS:
		goto __61
	case DMETA_PLUS_PLUS:
		goto __62
	case DMETA_PLUS_QUERY:
		goto __63

	case DMETA_QUERY:
		goto __64
	case DMETA_QUERY_PLUS:
		goto __65
	case DMETA_QUERY_QUERY:
		goto __66

	// ===================================================================
	// Handle a 32-bit data character with a value greater than META_END.

	case DMETA_BIGVALUE:
		goto __67

	// ===============================================================
	// Handle a back reference by number, which is the meta argument. The
	//     pattern offsets for back references to group numbers less than 10 are held
	//     in a special vector, to avoid using more than two parsed pattern elements
	//     in 64-bit environments. We only need the offset to the first occurrence,
	//     because if that doesn't fail, subsequent ones will also be OK.

	case DMETA_BACKREF:
		goto __68

	// ===============================================================
	// Handle recursion by inserting the number of the called group (which is
	//     the meta argument) after OP_RECURSE. At the end of compiling the pattern is
	//     scanned and these numbers are replaced by offsets within the pattern. It is
	//     done like this to avoid problems with forward references and adjusting
	//     offsets when groups are duplicated and moved (as discovered in previous
	//     implementations). Note that a recursion does not have a set first
	//     character.

	case DMETA_RECURSE:
		goto __69

	// ===============================================================
	// Handle capturing parentheses; the number is the meta argument.

	case DMETA_CAPTURE:
		goto __70

	// ===============================================================
	// Handle escape sequence items. For ones like \d, the ESC_values are
	//     arranged to be the same as the corresponding OP_values in the default case
	//     when PCRE2_UCP is not set (which is the only case in which they will appear
	//     here).
	//
	//     Note: \Q and \E are never seen here, as they were dealt with in
	//     parse_pattern(). Neither are numerical back references or recursions, which
	//     were turned into META_BACKREF or META_RECURSE items, respectively. \k and
	//     \g, when followed by names, are turned into META_BACKREF_BYNAME or
	//     META_RECURSE_BYNAME.

	case DMETA_ESCAPE:
		goto __71 // End META_ESCAPE

	// ===================================================================
	// Handle an unrecognized meta value. A parsed pattern value less than
	//     META_END is a literal. Otherwise we have a problem.

	default:
		goto __72
	}
	goto __12

	// ===================================================================
	// The branch terminates at pattern end or | or )

__13:
__14:
__15:
	*(*Tuint32_t)(unsafe.Pointer(firstcuptr)) = firstcu
	*(*Tuint32_t)(unsafe.Pointer(firstcuflagsptr)) = firstcuflags
	*(*Tuint32_t)(unsafe.Pointer(reqcuptr)) = reqcu
	*(*Tuint32_t)(unsafe.Pointer(reqcuflagsptr)) = reqcuflags
	*(*uintptr)(unsafe.Pointer(codeptr)) = code
	*(*uintptr)(unsafe.Pointer(pptrptr)) = *(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */))
	return okreturn

	// ===================================================================
	// Handle single-character metacharacters. In multiline mode, ^ disables
	//     the setting of any following char as a first character.

__16:
	if !(options&DPCRE2_MULTILINE != Tuint32_t(0)) {
		goto __73
	}

	if !(firstcuflags == DREQ_UNSET) {
		goto __75
	}
	zerofirstcuflags = libc.AssignUint32(&firstcuflags, DREQ_NONE)
__75:
	;
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = OP_CIRCM
	goto __74
__73:
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = OP_CIRC
__74:
	;
	goto __12

__17:
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = func() uint8 {
		if options&DPCRE2_MULTILINE != Tuint32_t(0) {
			return OP_DOLLM
		}
		return OP_DOLL
	}()
	goto __12

	// There can never be a first char if '.' is first, whatever happens about
	//     repeats. The value of reqcu doesn't change either.

__18:
	matched_char = DTRUE
	if !(firstcuflags == DREQ_UNSET) {
		goto __76
	}
	firstcuflags = DREQ_NONE
__76:
	;
	zerofirstcu = firstcu
	zerofirstcuflags = firstcuflags
	zeroreqcu = reqcu
	zeroreqcuflags = reqcuflags
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = func() uint8 {
		if options&DPCRE2_DOTALL != Tuint32_t(0) {
			return OP_ALLANY
		}
		return OP_ANY
	}()
	goto __12

	// ===================================================================
	// Empty character classes are allowed if PCRE2_ALLOW_EMPTY_CLASS is set.
	//     Otherwise, an initial ']' is taken as a data character. When empty classes
	//     are allowed, [] must always fail, so generate OP_FAIL, whereas [^] must
	//     match any character, so generate OP_ALLANY.

__19:
__20:
	matched_char = DTRUE
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = func() uint8 {
		if meta == DMETA_CLASS_EMPTY_NOT {
			return OP_ALLANY
		}
		return OP_FAIL
	}()
	if !(firstcuflags == DREQ_UNSET) {
		goto __77
	}
	firstcuflags = DREQ_NONE
__77:
	;
	zerofirstcu = firstcu
	zerofirstcuflags = firstcuflags
	goto __12

	// ===================================================================
	// Non-empty character class. If the included characters are all < 256, we
	//     build a 32-byte bitmap of the permitted characters, except in the special
	//     case where there is only one such character. For negated classes, we build
	//     the map as usual, then invert it at the end. However, we use a different
	//     opcode so that data characters > 255 can be handled correctly.
	//
	//     If the class contains characters outside the 0-255 range, a different
	//     opcode is compiled. It may optionally have a bit map for characters < 256,
	//     but those above are are explicitly listed afterwards. A flag code unit
	//     tells whether the bitmap is present, and whether this is a negated class or
	//     not.

__21:
__22:
	matched_char = DTRUE
	negate_class = libc.Bool32(meta == DMETA_CLASS_NOT)

	// We can optimize the case of a single character in a class by generating
	//     OP_CHAR or OP_CHARI if it's positive, or OP_NOT or OP_NOTI if it's
	//     negative. In the negative case there can be no first char if this item is
	//     first, whatever repeat count may follow. In the case of reqcu, save the
	//     previous value for reinstating.

	// NOTE: at present this optimization is not effective if the only
	//     character in a class in 32-bit, non-UCP mode has its top bit set.

	if !(*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 1*4)) < DMETA_END && *(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 2*4)) == DMETA_CLASS_END) {
		goto __78
	}

	c = *(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) + 1*4))

	*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) += 4 * uintptr(2) // Move on to class end
	if !(meta == DMETA_CLASS) {
		goto __79
	} /* A positive one-char class can be */
	// handled as a normal literal character.
	meta = c // Set up the character
	goto NORMAL_CHAR_SET
__79:
	;

	// Handle a negative one-character class

	zeroreqcu = reqcu
	zeroreqcuflags = reqcuflags
	if !(firstcuflags == DREQ_UNSET) {
		goto __80
	}
	firstcuflags = DREQ_NONE
__80:
	;
	zerofirstcu = firstcu
	zerofirstcuflags = firstcuflags

	// For caseless UTF or UCP mode, check whether this character has more
	//       than one other case. If so, generate a special OP_NOTPROP item instead of
	//       OP_NOTI.

	if !((utf != 0 || ucp != 0) && options&DPCRE2_CASELESS != Tuint32_t(0) && libc.AssignUint32(&d, Tuint32_t((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12)).Fcaseset)) != Tuint32_t(0)) {
		goto __81
	}

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = OP_NOTPROP
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = TPCRE2_UCHAR8(DPT_CLIST)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = TPCRE2_UCHAR8(d)
	goto __12 // We are finished with this class
__81:
	;
	// Char has only one other case, or UCP not available

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = func() uint8 {
		if options&DPCRE2_CASELESS != Tuint32_t(0) {
			return OP_NOTI
		}
		return OP_NOT
	}()
	code += func() uintptr {
		if utf != 0 && c > Tuint32_t(DMAX_UTF_SINGLE_CU) {
			return uintptr(X_pcre2_ord2utf_8(tls, c, code))
		}
		return uintptr(func() int32 { *(*TPCRE2_UCHAR8)(unsafe.Pointer(code)) = TPCRE2_UCHAR8(c); return 1 }())
	}()
	goto __12 // We are finished with this class
__78:
	; // End of 1-char optimization

	// Handle character classes that contain more than just one literal
	//     character. If there are exactly two characters in a positive class, see if
	//     they are case partners. This can be optimized to generate a caseless single
	//     character match (which also sets first/required code units if relevant).

	if !(meta == DMETA_CLASS && *(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 1*4)) < DMETA_END && *(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 2*4)) < DMETA_END && *(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 3*4)) == DMETA_CLASS_END) {
		goto __82
	}

	c1 = *(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) + 1*4))

	if !(int32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c1)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c1)%DUCD_BLOCK_SIZE])*12)).Fcaseset) == 0) {
		goto __83
	}

	if !((utf != 0 || ucp != 0) && c1 > Tuint32_t(127)) {
		goto __84
	}
	d1 = Tuint32_t(int32(c1) + (*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c1)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c1)%DUCD_BLOCK_SIZE])*12)).Fother_case)
	goto __85
__84:

	d1 = Tuint32_t(*(*Tuint8_t)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Ffcc + uintptr(c1))))
__85:
	;

	if !(c1 != d1 && *(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 2*4)) == d1) {
		goto __86
	}

	*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) += 4 * uintptr(3) // Move on to class end
	meta = c1
	if !(options&DPCRE2_CASELESS == Tuint32_t(0)) {
		goto __87
	}

	reset_caseful = DTRUE
	options = options | DPCRE2_CASELESS
	req_caseopt = DREQ_CASELESS
__87:
	;
	goto CLASS_CASELESS_CHAR
__86:
	;
__83:
	;
__82:
	;

	// If a non-extended class contains a negative special such as \S, we need
	//     to flip the negation flag at the end, so that support for characters > 255
	//     works correctly (they are all included in the class). An extended class may
	//     need to insert specific matching or non-matching code for wide characters.
	//

	should_flip_negation = libc.AssignInt32(&match_all_or_no_wide_chars, DFALSE)

	// Extended class (xclass) will be used when characters > 255
	//     might match.

	xclass = DFALSE
	*(*uintptr)(unsafe.Pointer(bp + 64 /* class_uchardata */)) = code + uintptr(DLINK_SIZE) + uintptr(2) // For XCLASS items
	class_uchardata_base = *(*uintptr)(unsafe.Pointer(bp + 64 /* class_uchardata */))                    // Save the start

	// For optimization purposes, we track some properties of the class:
	//     class_has_8bitchar will be non-zero if the class contains at least one
	//     character with a code point less than 256; xclass_has_prop will be TRUE if
	//     Unicode property checks are present in the class.

	class_has_8bitchar = 0
	xclass_has_prop = DFALSE

	// Initialize the 256-bit (32-byte) bit map to all zeros. We build the map
	//     in a temporary bit of memory, in case the class contains fewer than two
	//     8-bit characters because in that case the compiled code doesn't use the bit
	//     map.

	libc.Xmemset(tls, bp, 0, uint64(32)*uint64(unsafe.Sizeof(Tuint8_t(0))))

	// Process items until META_CLASS_END is reached.

__88:
	if !(libc.AssignUint32(&meta, *(*Tuint32_t)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 96)), 4)))) != DMETA_CLASS_END) {
		goto __89
	}

	// Handle POSIX classes such as [:alpha:] etc.

	if !(meta == DMETA_POSIX || meta == DMETA_POSIX_NEG) {
		goto __90
	}

	local_negate = libc.Bool32(meta == DMETA_POSIX_NEG)
	posix_class = int32(*(*Tuint32_t)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 96)), 4))))

	should_flip_negation = local_negate // Note negative special

	// If matching is caseless, upper and lower are converted to alpha.
	//         This relies on the fact that the class table starts with alpha,
	//         lower, upper as the first 3 entries.

	if !(options&DPCRE2_CASELESS != Tuint32_t(0) && posix_class <= 2) {
		goto __91
	}
	posix_class = 0
__91:
	;

	// When PCRE2_UCP is set, some of the POSIX classes are converted to
	//         different escape sequences that use Unicode properties \p or \P.
	//         Others that are not available via \p or \P have to generate
	//         XCL_PROP/XCL_NOTPROP directly, which is done here.

	if !(options&DPCRE2_UCP != Tuint32_t(0)) {
		goto __92
	}
	switch posix_class {
	case DPC_GRAPH:
		goto __94
	case DPC_PRINT:
		goto __95
	case DPC_PUNCT:
		goto __96

	// For the other POSIX classes (ascii, xdigit) we are going to
	//           fall through to the non-UCP case and build a bit map for
	//           characters with code points less than 256. However, if we are in
	//           a negated POSIX class, characters with code points greater than
	//           255 must either all match or all not match, depending on whether
	//           the whole class is not or is negated. For example, for
	//           [[:^ascii:]... they must all match, whereas for [^[:^xdigit:]...
	//           they must not.
	//
	//           In the special case where there are no xclass items, this is
	//           automatically handled by the use of OP_CLASS or OP_NCLASS, but an
	//           explicit range is needed for OP_XCLASS. Setting a flag here
	//           causes the range to be generated later when it is known that
	//           OP_XCLASS is required. In the 8-bit library this is relevant only in
	//           utf mode, since no wide characters can exist otherwise.

	default:
		goto __97
	}
	goto __93

__94:
__95:
__96:
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 64 /* class_uchardata */)), 1))) = func() uint8 {
		if local_negate != 0 {
			return uint8(DXCL_NOTPROP)
		}
		return uint8(DXCL_PROP)
	}()
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 64 /* class_uchardata */)), 1))) = func() uint8 {
		if posix_class == DPC_GRAPH {
			return uint8(DPT_PXGRAPH)
		}
		return func() uint8 {
			if posix_class == DPC_PRINT {
				return uint8(DPT_PXPRINT)
			}
			return uint8(DPT_PXPUNCT)
		}()
	}()
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 64 /* class_uchardata */)), 1))) = TPCRE2_UCHAR8(0)
	xclass_has_prop = DTRUE
	goto CONTINUE_CLASS

	// For the other POSIX classes (ascii, xdigit) we are going to
	//           fall through to the non-UCP case and build a bit map for
	//           characters with code points less than 256. However, if we are in
	//           a negated POSIX class, characters with code points greater than
	//           255 must either all match or all not match, depending on whether
	//           the whole class is not or is negated. For example, for
	//           [[:^ascii:]... they must all match, whereas for [^[:^xdigit:]...
	//           they must not.
	//
	//           In the special case where there are no xclass items, this is
	//           automatically handled by the use of OP_CLASS or OP_NCLASS, but an
	//           explicit range is needed for OP_XCLASS. Setting a flag here
	//           causes the range to be generated later when it is known that
	//           OP_XCLASS is required. In the 8-bit library this is relevant only in
	//           utf mode, since no wide characters can exist otherwise.

__97:
	if !(utf != 0) {
		goto __98
	}
	match_all_or_no_wide_chars = match_all_or_no_wide_chars | local_negate
__98:
	;
	goto __93
__93:
	;
__92:
	;

	// In the non-UCP case, or when UCP makes no difference, we build the
	//         bit map for the POSIX class in a chunk of local store because we may
	//         be adding and subtracting from it, and we don't want to subtract bits
	//         that may be in the main map already. At the end we or the result into
	//         the bit map that is being built.

	posix_class = posix_class * 3

	// Copy in the first table (always present)

	libc.Xmemcpy(tls, bp+32, cbits+uintptr(posix_class_maps[posix_class]),
		uint64(32)*uint64(unsafe.Sizeof(Tuint8_t(0))))

	// If there is a second table, add or remove it as required.

	taboffset = posix_class_maps[posix_class+1]
	tabopt = posix_class_maps[posix_class+2]

	if !(taboffset >= 0) {
		goto __99
	}

	if !(tabopt >= 0) {
		goto __100
	}
	{
		i = 0
	__102:
		if !(i < 32) {
			goto __104
		}
		*(*Tuint8_t)(unsafe.Pointer(bp + 32 + uintptr(i))) |= Tuint8_t(int32(*(*Tuint8_t)(unsafe.Pointer(cbits + uintptr(i+taboffset)))))
		goto __103
	__103:
		i++
		goto __102
		goto __104
	__104:
	}
	goto __101
__100:
	{
		i1 = 0
	__105:
		if !(i1 < 32) {
			goto __107
		}
		*(*Tuint8_t)(unsafe.Pointer(bp + 32 + uintptr(i1))) &= Tuint8_t(^int32(*(*Tuint8_t)(unsafe.Pointer(cbits + uintptr(i1+taboffset)))))
		goto __106
	__106:
		i1++
		goto __105
		goto __107
	__107:
	}
__101:
	;
__99:
	;

	// Now see if we need to remove any special characters. An option
	//         value of 1 removes vertical space and 2 removes underscore.

	if !(tabopt < 0) {
		goto __108
	}
	tabopt = -tabopt
__108:
	;
	if !(tabopt == 1) {
		goto __109
	}
	*(*Tuint8_t)(unsafe.Pointer(bp + 32 + 1)) &= libc.Uint8FromInt32(libc.CplInt32(0x3c))
	goto __110
__109:
	if !(tabopt == 2) {
		goto __111
	}
	*(*Tuint8_t)(unsafe.Pointer(bp + 32 + 11)) &= Tuint8_t(0x7f)
__111:
	;
__110:
	;

	// Add the POSIX table or its complement into the main table that is
	//         being built and we are done.

	if !(local_negate != 0) {
		goto __112
	}
	{
		i2 = 0
	__114:
		if !(i2 < 32) {
			goto __116
		}
		*(*Tuint8_t)(unsafe.Pointer(bp + uintptr(i2))) |= Tuint8_t(int32(Tuint8_t(^int32(*(*Tuint8_t)(unsafe.Pointer(bp + 32 + uintptr(i2)))))))
		goto __115
	__115:
		i2++
		goto __114
		goto __116
	__116:
	}
	goto __113
__112:
	{
		i3 = 0
	__117:
		if !(i3 < 32) {
			goto __119
		}
		*(*Tuint8_t)(unsafe.Pointer(bp + uintptr(i3))) |= Tuint8_t(int32(*(*Tuint8_t)(unsafe.Pointer(bp + 32 + uintptr(i3)))))
		goto __118
	__118:
		i3++
		goto __117
		goto __119
	__119:
	}
__113:
	;

	// Every class contains at least one < 256 character.

	class_has_8bitchar = 1
	goto CONTINUE_CLASS // End of POSIX handling
__90:
	;

	// Other than POSIX classes, the only items we should encounter are
	//       \d-type escapes and literal characters (possibly as ranges).

	if !(meta == DMETA_BIGVALUE) {
		goto __120
	}

	meta = *(*Tuint32_t)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 96)), 4)))
	goto CLASS_LITERAL
__120:
	;

	// Any other non-literal must be an escape

	if !(meta >= DMETA_END) {
		goto __121
	}

	if !(meta&0xffff0000 != DMETA_ESCAPE) {
		goto __123
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR89 // Internal error - unrecognized.
	return 0
__123:
	;
	escape = meta & 0x0000ffff

	// Every class contains at least one < 256 character.

	class_has_8bitchar++

	switch escape {
	case ESC_d:
		goto __125

	case ESC_D:
		goto __126

	case ESC_w:
		goto __127

	case ESC_W:
		goto __128

	// Perl 5.004 onwards omitted VT from \s, but restored it at Perl
	//           5.18. Before PCRE 8.34, we had to preserve the VT bit if it was
	//           previously set by something earlier in the character class.
	//           Luckily, the value of CHAR_VT is 0x0b in both ASCII and EBCDIC, so
	//           we could just adjust the appropriate bit. From PCRE 8.34 we no
	//           longer treat \s and \S specially.

	case ESC_s:
		goto __129

	case ESC_S:
		goto __130

	// When adding the horizontal or vertical space lists to a class, or
	//           their complements, disable PCRE2_CASELESS, because it justs wastes
	//           time, and in the "not-x" UTF cases can create unwanted duplicates in
	//           the XCLASS list (provoked by characters that have more than one other
	//           case and by both cases being in the same "not-x" sublist).

	case ESC_h:
		goto __131

	case ESC_H:
		goto __132

	case ESC_v:
		goto __133

	case ESC_V:
		goto __134

	// If Unicode is not supported, \P and \p are not allowed and are
	//           faulted at parse time, so will never appear here.

	case ESC_p:
		goto __135
	case ESC_P:
		goto __136
	}
	goto __124

__125:
	{
		i4 = 0
	__137:
		if !(i4 < 32) {
			goto __139
		}
		*(*Tuint8_t)(unsafe.Pointer(bp + uintptr(i4))) |= Tuint8_t(int32(*(*Tuint8_t)(unsafe.Pointer(cbits + uintptr(i4+Dcbit_digit)))))
		goto __138
	__138:
		i4++
		goto __137
		goto __139
	__139:
	}
	goto __124

__126:
	should_flip_negation = DTRUE
	{
		i5 = 0
	__140:
		if !(i5 < 32) {
			goto __142
		}
		*(*Tuint8_t)(unsafe.Pointer(bp + uintptr(i5))) |= Tuint8_t(int32(Tuint8_t(^int32(*(*Tuint8_t)(unsafe.Pointer(cbits + uintptr(i5+Dcbit_digit)))))))
		goto __141
	__141:
		i5++
		goto __140
		goto __142
	__142:
	}
	goto __124

__127:
	{
		i6 = 0
	__143:
		if !(i6 < 32) {
			goto __145
		}
		*(*Tuint8_t)(unsafe.Pointer(bp + uintptr(i6))) |= Tuint8_t(int32(*(*Tuint8_t)(unsafe.Pointer(cbits + uintptr(i6+Dcbit_word)))))
		goto __144
	__144:
		i6++
		goto __143
		goto __145
	__145:
	}
	goto __124

__128:
	should_flip_negation = DTRUE
	{
		i7 = 0
	__146:
		if !(i7 < 32) {
			goto __148
		}
		*(*Tuint8_t)(unsafe.Pointer(bp + uintptr(i7))) |= Tuint8_t(int32(Tuint8_t(^int32(*(*Tuint8_t)(unsafe.Pointer(cbits + uintptr(i7+Dcbit_word)))))))
		goto __147
	__147:
		i7++
		goto __146
		goto __148
	__148:
	}
	goto __124

	// Perl 5.004 onwards omitted VT from \s, but restored it at Perl
	//           5.18. Before PCRE 8.34, we had to preserve the VT bit if it was
	//           previously set by something earlier in the character class.
	//           Luckily, the value of CHAR_VT is 0x0b in both ASCII and EBCDIC, so
	//           we could just adjust the appropriate bit. From PCRE 8.34 we no
	//           longer treat \s and \S specially.

__129:
	{
		i8 = 0
	__149:
		if !(i8 < 32) {
			goto __151
		}
		*(*Tuint8_t)(unsafe.Pointer(bp + uintptr(i8))) |= Tuint8_t(int32(*(*Tuint8_t)(unsafe.Pointer(cbits + uintptr(i8+Dcbit_space)))))
		goto __150
	__150:
		i8++
		goto __149
		goto __151
	__151:
	}
	goto __124

__130:
	should_flip_negation = DTRUE
	{
		i9 = 0
	__152:
		if !(i9 < 32) {
			goto __154
		}
		*(*Tuint8_t)(unsafe.Pointer(bp + uintptr(i9))) |= Tuint8_t(int32(Tuint8_t(^int32(*(*Tuint8_t)(unsafe.Pointer(cbits + uintptr(i9+Dcbit_space)))))))
		goto __153
	__153:
		i9++
		goto __152
		goto __154
	__154:
	}
	goto __124

	// When adding the horizontal or vertical space lists to a class, or
	//           their complements, disable PCRE2_CASELESS, because it justs wastes
	//           time, and in the "not-x" UTF cases can create unwanted duplicates in
	//           the XCLASS list (provoked by characters that have more than one other
	//           case and by both cases being in the same "not-x" sublist).

__131:
	add_list_to_class(tls, bp, bp+64,
		options&libc.CplUint32(DPCRE2_CASELESS), cb, uintptr(unsafe.Pointer(&X_pcre2_hspace_list_8)), DNOTACHAR)
	goto __124

__132:
	add_not_list_to_class(tls, bp, bp+64,
		options&libc.CplUint32(DPCRE2_CASELESS), cb, uintptr(unsafe.Pointer(&X_pcre2_hspace_list_8)))
	goto __124

__133:
	add_list_to_class(tls, bp, bp+64,
		options&libc.CplUint32(DPCRE2_CASELESS), cb, uintptr(unsafe.Pointer(&X_pcre2_vspace_list_8)), DNOTACHAR)
	goto __124

__134:
	add_not_list_to_class(tls, bp, bp+64,
		options&libc.CplUint32(DPCRE2_CASELESS), cb, uintptr(unsafe.Pointer(&X_pcre2_vspace_list_8)))
	goto __124

	// If Unicode is not supported, \P and \p are not allowed and are
	//           faulted at parse time, so will never appear here.

__135:
__136:

	ptype = *(*Tuint32_t)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 96)), 4))) >> 16
	pdata = *(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)))) & Tuint32_t(0xffff)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 64 /* class_uchardata */)), 1))) = func() uint8 {
		if escape == ESC_p {
			return uint8(DXCL_PROP)
		}
		return uint8(DXCL_NOTPROP)
	}()
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 64 /* class_uchardata */)), 1))) = TPCRE2_UCHAR8(ptype)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 64 /* class_uchardata */)), 1))) = TPCRE2_UCHAR8(pdata)
	xclass_has_prop = DTRUE
	class_has_8bitchar-- // Undo!

	goto __124
__124:
	;

	goto CONTINUE_CLASS
	goto __122
__121:

CLASS_LITERAL:
	c2 = libc.AssignUint32(&d2, meta)

	// Remember if \r or \n were explicitly used

	if !(c2 == Tuint32_t('\015') || c2 == Tuint32_t('\012')) {
		goto __155
	}
	*(*Tuint32_t)(unsafe.Pointer(cb + 208)) |= Tuint32_t(DPCRE2_HASCRORLF)
__155:
	;

	// Process a character range

	if !(*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 1*4)) == DMETA_RANGE_LITERAL || *(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 1*4)) == DMETA_RANGE_ESCAPED) {
		goto __156
	}

	*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) += 4 * uintptr(2)
	d2 = *(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */))))
	if !(d2 == DMETA_BIGVALUE) {
		goto __157
	}
	d2 = *(*Tuint32_t)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 96)), 4)))
__157:
	;

	// Remember an explicit \r or \n, and add the range to the class.

	if !(d2 == Tuint32_t('\015') || d2 == Tuint32_t('\012')) {
		goto __158
	}
	*(*Tuint32_t)(unsafe.Pointer(cb + 208)) |= Tuint32_t(DPCRE2_HASCRORLF)
__158:
	;

	// In an EBCDIC environment, Perl treats alphabetic ranges specially
	//           because there are holes in the encoding, and simply using the range
	//           A-Z (for example) would include the characters in the holes. This
	//           applies only to literal ranges; [\xC1-\xE9] is different to [A-Z].

	// Not an EBCDIC special range

	class_has_8bitchar = int32(uint32(class_has_8bitchar) + add_to_class(tls, bp, bp+64, options, cb, c2, d2))
	goto CONTINUE_CLASS // Go get the next char in the class
__156:
	; // End of range handling

	// Handle a single character.

	class_has_8bitchar = int32(uint32(class_has_8bitchar) + add_to_class(tls, bp, bp+64, options, cb, meta, meta))
__122:
	;

	// Continue to the next item in the class.

CONTINUE_CLASS:

	// If any wide characters or Unicode properties have been encountered,
	//       set xclass = TRUE. Then, in the pre-compile phase, accumulate the length
	//       of the extra data and reset the pointer. This is so that very large
	//       classes that contain a zillion wide characters or Unicode property tests
	//       do not overwrite the workspace (which is on the stack).

	if !(*(*uintptr)(unsafe.Pointer(bp + 64)) > class_uchardata_base) {
		goto __159
	}

	xclass = DTRUE
	if !(lengthptr != uintptr(0)) {
		goto __160
	}

	*(*Tsize_t)(unsafe.Pointer(lengthptr)) += Tsize_t((int64(*(*uintptr)(unsafe.Pointer(bp + 64))) - int64(class_uchardata_base)) / 1)
	*(*uintptr)(unsafe.Pointer(bp + 64 /* class_uchardata */)) = class_uchardata_base
__160:
	;
__159:
	;

	goto __88 // Needed to avoid error when not supporting wide chars
	goto __88
__89:
	; // End of main class-processing loop

	// If this class is the first thing in the branch, there can be no first
	//     char setting, whatever the repeat count. Any reqcu setting must remain
	//     unchanged after any kind of repeat.

	if !(firstcuflags == DREQ_UNSET) {
		goto __161
	}
	firstcuflags = DREQ_NONE
__161:
	;
	zerofirstcu = firstcu
	zerofirstcuflags = firstcuflags
	zeroreqcu = reqcu
	zeroreqcuflags = reqcuflags

	// If there are characters with values > 255, or Unicode property settings
	//     (\p or \P), we have to compile an extended class, with its own opcode,
	//     unless there were no property settings and there was a negated special such
	//     as \S in the class, and PCRE2_UCP is not set, because in that case all
	//     characters > 255 are in or not in the class, so any that were explicitly
	//     given as well can be ignored.
	//
	//     In the UCP case, if certain negated POSIX classes ([:^ascii:] or
	//     [^:xdigit:]) were present in a class, we either have to match or not match
	//     all wide characters (depending on whether the whole class is or is not
	//     negated). This requirement is indicated by match_all_or_no_wide_chars being
	//     true. We do this by including an explicit range, which works in both cases.
	//     This applies only in UTF and 16-bit and 32-bit non-UTF modes, since there
	//     cannot be any wide characters in 8-bit non-UTF mode.
	//
	//     When there *are* properties in a positive UTF-8 or any 16-bit or 32_bit
	//     class where \S etc is present without PCRE2_UCP, causing an extended class
	//     to be compiled, we make sure that all characters > 255 are included by
	//     forcing match_all_or_no_wide_chars to be true.
	//
	//     If, when generating an xclass, there are no characters < 256, we can omit
	//     the bitmap in the actual compiled code.

	if !(xclass != 0 && (options&DPCRE2_UCP != Tuint32_t(0) || xclass_has_prop != 0 || !(should_flip_negation != 0))) {
		goto __162
	}

	if !(match_all_or_no_wide_chars != 0 || utf != 0 && should_flip_negation != 0 && !(negate_class != 0) && options&DPCRE2_UCP == Tuint32_t(0)) {
		goto __163
	}

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 64 /* class_uchardata */)), 1))) = TPCRE2_UCHAR8(DXCL_RANGE)
	if !(utf != 0) {
		goto __164
	} /* Will always be utf in the 8-bit library */

	*(*uintptr)(unsafe.Pointer(bp + 64 /* class_uchardata */)) += uintptr(X_pcre2_ord2utf_8(tls, uint32(0x100), *(*uintptr)(unsafe.Pointer(bp + 64 /* class_uchardata */))))
	*(*uintptr)(unsafe.Pointer(bp + 64 /* class_uchardata */)) += uintptr(X_pcre2_ord2utf_8(tls, uint32(DMAX_UTF_CODE_POINT), *(*uintptr)(unsafe.Pointer(bp + 64 /* class_uchardata */))))
	goto __165
__164: /* Can only happen for the 16-bit & 32-bit libraries */

	;
__165:
	;
__163:
	;
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 64 /* class_uchardata */)), 1))) = TPCRE2_UCHAR8(DXCL_END) // Marks the end of extra data
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = OP_XCLASS
	code += uintptr(DLINK_SIZE)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)) = func() uint8 {
		if negate_class != 0 {
			return uint8(DXCL_NOT)
		}
		return uint8(0)
	}()
	if !(xclass_has_prop != 0) {
		goto __166
	}
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)) |= TPCRE2_UCHAR8(DXCL_HASPROP)
__166:
	;

	// If the map is required, move up the extra data to make room for it;
	//       otherwise just move the code pointer to the end of the extra data.

	if !(class_has_8bitchar > 0) {
		goto __167
	}

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) |= TPCRE2_UCHAR8(DXCL_MAP)
	libc.Xmemmove(tls, code+uintptr(uint64(32)/uint64(unsafe.Sizeof(TPCRE2_UCHAR8(0)))), code,
		uint64((int64(*(*uintptr)(unsafe.Pointer(bp + 64)))-int64(code))/1*int64(DPCRE2_CODE_UNIT_WIDTH/8)))
	if !(negate_class != 0 && !(xclass_has_prop != 0)) {
		goto __169
	}

	// Using 255 ^ instead of ~ avoids clang sanitize warning.
	{
		i10 = 0
	__170:
		if !(i10 < 32) {
			goto __172
		}
		*(*Tuint8_t)(unsafe.Pointer(bp + uintptr(i10))) = Tuint8_t(255 ^ int32(*(*Tuint8_t)(unsafe.Pointer(bp + uintptr(i10)))))
		goto __171
	__171:
		i10++
		goto __170
		goto __172
	__172:
	}
__169:
	;
	libc.Xmemcpy(tls, code, bp, uint64(32))
	code = *(*uintptr)(unsafe.Pointer(bp + 64)) + uintptr(uint64(32)/uint64(unsafe.Sizeof(TPCRE2_UCHAR8(0))))
	goto __168
__167:
	code = *(*uintptr)(unsafe.Pointer(bp + 64 /* class_uchardata */))
__168:
	;

	// Now fill in the complete length of the item

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(previous + 1)) = TPCRE2_UCHAR8(int32((int64(code)-int64(previous))/1) >> 8)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(previous + 2)) = TPCRE2_UCHAR8(int32((int64(code)-int64(previous))/1) & 255)
	goto __12 // End of class handling
__162:
	;

	// If there are no characters > 255, or they are all to be included or
	//     excluded, set the opcode to OP_CLASS or OP_NCLASS, depending on whether the
	//     whole class was negated and whether there were negative specials such as \S
	//     (non-UCP) in the class. Then copy the 32-byte map into the code vector,
	//     negating it if necessary.

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = func() uint8 {
		if negate_class == should_flip_negation {
			return OP_CLASS
		}
		return OP_NCLASS
	}()
	if !(lengthptr == uintptr(0)) {
		goto __173
	} /* Save time in the pre-compile phase */

	if !(negate_class != 0) {
		goto __174
	}

	// Using 255 ^ instead of ~ avoids clang sanitize warning.
	{
		i11 = 0
	__175:
		if !(i11 < 32) {
			goto __177
		}
		*(*Tuint8_t)(unsafe.Pointer(bp + uintptr(i11))) = Tuint8_t(255 ^ int32(*(*Tuint8_t)(unsafe.Pointer(bp + uintptr(i11)))))
		goto __176
	__176:
		i11++
		goto __175
		goto __177
	__177:
	}
__174:
	;
	libc.Xmemcpy(tls, code, bp, uint64(32))
__173:
	;
	code += uintptr(uint64(32) / uint64(unsafe.Sizeof(TPCRE2_UCHAR8(0))))
	goto __12 // End of class processing

	// ===================================================================
	// Deal with (*VERB)s.

	// Check for open captures before ACCEPT and close those that are within
	//     the same assertion level, also converting ACCEPT to ASSERT_ACCEPT in an
	//     assertion. In the first pass, just accumulate the length required;
	//     otherwise hitting (*ACCEPT) inside many nested parentheses can cause
	//     workspace overflow. Do not set firstcu after *ACCEPT.

__23:
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Fhad_accept = libc.AssignInt32(&had_accept, DTRUE)
	oc = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fopen_caps
__178:
	if !(oc != uintptr(0) && int32((*Topen_capitem)(unsafe.Pointer(oc)).Fassert_depth) >= int32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fassert_depth)) {
		goto __180
	}

	if !(lengthptr != uintptr(0)) {
		goto __181
	}

	*(*Tsize_t)(unsafe.Pointer(lengthptr)) += uint64(1*(DPCRE2_CODE_UNIT_WIDTH/8) + DIMM2_SIZE)
	goto __182
__181:

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = OP_CLOSE
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)) = TPCRE2_UCHAR8(int32((*Topen_capitem)(unsafe.Pointer(oc)).Fnumber) >> 8)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)) = TPCRE2_UCHAR8(int32((*Topen_capitem)(unsafe.Pointer(oc)).Fnumber) & 255)
	code += uintptr(DIMM2_SIZE)
__182:
	;
	goto __179
__179:
	oc = (*Topen_capitem)(unsafe.Pointer(oc)).Fnext
	goto __178
	goto __180
__180:
	;
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = func() uint8 {
		if int32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fassert_depth) > 0 {
			return OP_ASSERT_ACCEPT
		}
		return OP_ACCEPT
	}()
	if !(firstcuflags == DREQ_UNSET) {
		goto __183
	}
	firstcuflags = DREQ_NONE
__183:
	;
	goto __12

__24:
__25:
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Fhad_pruneorskip = DTRUE
	// Fall through
__26:
__27:
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = TPCRE2_UCHAR8(verbops[(meta-DMETA_MARK)>>16])
	goto __12

__28:
	*(*Tuint32_t)(unsafe.Pointer(cb + 208)) |= Tuint32_t(DPCRE2_HASTHEN)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = OP_THEN
	goto __12

	// Handle verbs with arguments. Arguments can be very long, especially in
	//     16- and 32-bit modes, and can overflow the workspace in the first pass.
	//     However, the argument length is constrained to be small enough to fit in
	//     one code unit. This check happens in parse_regex(). In the first pass,
	//     instead of putting the argument into memory, we just update the length
	//     counter and set up an empty argument.

__29:
	*(*Tuint32_t)(unsafe.Pointer(cb + 208)) |= Tuint32_t(DPCRE2_HASTHEN)
	goto VERB_ARG

__30:
__31:
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Fhad_pruneorskip = DTRUE
	// Fall through
__32:
__33:
VERB_ARG:
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = TPCRE2_UCHAR8(verbops[(meta-DMETA_MARK)>>16])
	// The length is in characters.
	verbarglen = *(*Tuint32_t)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 96)), 4)))
	verbculen = Tuint32_t(0)
	*(*uintptr)(unsafe.Pointer(bp + 88 /* tempcode */)) = libc.PostIncUintptr(&code, 1)
	{
		i17 = 0
	__184:
		if !(i17 < int32(verbarglen)) {
			goto __186
		}

		meta = *(*Tuint32_t)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 96)), 4)))
		if !(utf != 0) {
			goto __187
		}
		mclength = X_pcre2_ord2utf_8(tls, meta, bp+72)
		goto __188
	__187:

		mclength = Tuint32_t(1)
		*(*TPCRE2_UCHAR8)(unsafe.Pointer(bp + 72)) = TPCRE2_UCHAR8(meta)
	__188:
		;
		if !(lengthptr != uintptr(0)) {
			goto __189
		}
		*(*Tsize_t)(unsafe.Pointer(lengthptr)) += Tsize_t(mclength)
		goto __190
	__189:

		libc.Xmemcpy(tls, code, bp+72, uint64(mclength*Tuint32_t(DPCRE2_CODE_UNIT_WIDTH/8)))
		code += uintptr(mclength)
		verbculen = verbculen + mclength
	__190:
		;
		goto __185
	__185:
		i17++
		goto __184
		goto __186
	__186:
	}

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 88 /* tempcode */)))) = TPCRE2_UCHAR8(verbculen) // Fill in the code unit length
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = TPCRE2_UCHAR8(0)                               // Terminating zero
	goto __12

	// ===================================================================
	// Handle options change. The new setting must be passed back for use in
	//     subsequent branches. Reset the greedy defaults and the case value for
	//     firstcu and reqcu.

__34:
	*(*Tuint32_t)(unsafe.Pointer(optionsptr)) = libc.AssignUint32(&options, *(*Tuint32_t)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 96)), 4))))
	greedy_default = Tuint32_t(libc.Bool32(options&DPCRE2_UNGREEDY != Tuint32_t(0)))
	greedy_non_default = greedy_default ^ Tuint32_t(1)
	if options&DPCRE2_CASELESS != Tuint32_t(0) {
		req_caseopt = DREQ_CASELESS
	} else {
		req_caseopt = uint32(0)
	}
	goto __12

	// ===================================================================
	// Handle conditional subpatterns. The case of (?(Rdigits) is ambiguous
	//     because it could be a numerical check on recursion, or a name check on a
	//     group's being set. The pre-pass sets up META_COND_RNUMBER as a name so that
	//     we can handle it either way. We first try for a name; if not found, process
	//     the number.

__35: // (?(Rdigits)
__36: // (?(name) or (?'name') or ?(<name>)
__37: // (?(R&name) - test for recursion
	bravalue = OP_COND

	ng = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fnamed_groups
	length = *(*Tuint32_t)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 96)), 4)))

	offset = Tsize_t(*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 1*4)))<<32 | Tsize_t(*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 2*4)))
	*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) += 4 * uintptr(2)

	name = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_pattern + uintptr(offset)

	// In the first pass, the names generated in the pre-pass are available,
	//       but the main name table has not yet been created. Scan the list of names
	//       generated in the pre-pass in order to get a number and whether or not
	//       this name is duplicated. If it is not duplicated, we can handle it as a
	//       numerical group.

	i12 = uint32(0)
__191:
	if !(i12 < uint32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnames_found)) {
		goto __193
	}

	if !(length == Tuint32_t((*Tnamed_group_8)(unsafe.Pointer(ng)).Flength) && X_pcre2_strncmp_8(tls, name, (*Tnamed_group_8)(unsafe.Pointer(ng)).Fname, uint64(length)) == 0) {
		goto __194
	}

	if !!(int32((*Tnamed_group_8)(unsafe.Pointer(ng)).Fisdup) != 0) {
		goto __195
	}

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3)) = func() uint8 {
		if meta == DMETA_COND_RNAME {
			return OP_RREF
		}
		return OP_CREF
	}()
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 4)) = TPCRE2_UCHAR8((*Tnamed_group_8)(unsafe.Pointer(ng)).Fnumber >> 8)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 5)) = TPCRE2_UCHAR8((*Tnamed_group_8)(unsafe.Pointer(ng)).Fnumber & Tuint32_t(255))
	if !((*Tnamed_group_8)(unsafe.Pointer(ng)).Fnumber > (*Tcompile_block_8)(unsafe.Pointer(cb)).Ftop_backref) {
		goto __196
	}
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Ftop_backref = (*Tnamed_group_8)(unsafe.Pointer(ng)).Fnumber
__196:
	;
	skipunits = Tuint32_t(1 + DIMM2_SIZE)
	goto GROUP_PROCESS_NOTE_EMPTY
__195:
	;
	goto __193 // Found a duplicated name
__194:
	;
	goto __192
__192:
	i12++
	ng += 16
	goto __191
	goto __193
__193:
	;

	// If the name was not found we have a bad reference, unless we are
	//       dealing with R<digits>, which is treated as a recursion test by number.
	//

	if !(i12 >= uint32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnames_found)) {
		goto __197
	}

	groupnumber = Tuint32_t(0)
	if !(meta == DMETA_COND_RNUMBER) {
		goto __198
	}

	i12 = uint32(1)
__199:
	if !(i12 < length) {
		goto __201
	}

	groupnumber = groupnumber*Tuint32_t(10) + Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(name + uintptr(i12)))) - Tuint32_t('\060')
	if !(groupnumber > DMAX_GROUP_NUMBER) {
		goto __202
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR61
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Ferroroffset = offset + Tsize_t(i12)
	return 0
__202:
	;
	goto __200
__200:
	i12++
	goto __199
	goto __201
__201:
	;
__198:
	;

	if !(meta != DMETA_COND_RNUMBER || groupnumber > (*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount) {
		goto __203
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR15
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Ferroroffset = offset
	return 0
__203:
	;

	// (?Rdigits) treated as a recursion reference by number. A value of
	//         zero (which is the result of both (?R) and (?R0)) means "any", and is
	//         translated into RREF_ANY (which is 0xffff).

	if !(groupnumber == Tuint32_t(0)) {
		goto __204
	}
	groupnumber = Tuint32_t(DRREF_ANY)
__204:
	;
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3)) = OP_RREF
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 4)) = TPCRE2_UCHAR8(groupnumber >> 8)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 5)) = TPCRE2_UCHAR8(groupnumber & Tuint32_t(255))
	skipunits = Tuint32_t(1 + DIMM2_SIZE)
	goto GROUP_PROCESS_NOTE_EMPTY
__197:
	;

	// A duplicated name was found. Note that if an R<digits> name is found
	//       (META_COND_RNUMBER), it is a reference test, not a recursion test.

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3)) = func() uint8 {
		if meta == DMETA_COND_RNAME {
			return OP_RREF
		}
		return OP_CREF
	}()

	// We have a duplicated name. In the compile pass we have to search the
	//       main table in order to get the index and count values.

	*(*int32)(unsafe.Pointer(bp + 84 /* count */)) = 0 // Values for first pass (avoids compiler warning)
	*(*int32)(unsafe.Pointer(bp + 80 /* index */)) = 0
	if !(lengthptr == uintptr(0) && !(find_dupname_details(tls, name, length, bp+80,
		bp+84, errorcodeptr, cb) != 0)) {
		goto __205
	}
	return 0
__205:
	;

	// Add one to the opcode to change CREF/RREF into DNCREF/DNRREF and
	//       insert appropriate data values.

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3))++
	skipunits = Tuint32_t(1 + 2*DIMM2_SIZE)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 4)) = TPCRE2_UCHAR8(*(*int32)(unsafe.Pointer(bp + 80)) >> 8)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 5)) = TPCRE2_UCHAR8(*(*int32)(unsafe.Pointer(bp + 80)) & 255)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 6)) = TPCRE2_UCHAR8(*(*int32)(unsafe.Pointer(bp + 84)) >> 8)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 7)) = TPCRE2_UCHAR8(*(*int32)(unsafe.Pointer(bp + 84)) & 255)

	goto GROUP_PROCESS_NOTE_EMPTY

	// The DEFINE condition is always false. Its internal groups may never
	//     be called, so matched_char must remain false, hence the jump to
	//     GROUP_PROCESS rather than GROUP_PROCESS_NOTE_EMPTY.

__38:
	bravalue = OP_COND
	offset = Tsize_t(*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 1*4)))<<32 | Tsize_t(*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 2*4)))
	*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) += 4 * uintptr(2)

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3)) = OP_DEFINE
	skipunits = Tuint32_t(1)
	goto GROUP_PROCESS

	// Conditional test of a group's being set.

__39:
	bravalue = OP_COND
	offset = Tsize_t(*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 1*4)))<<32 | Tsize_t(*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 2*4)))
	*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) += 4 * uintptr(2)

	groupnumber = *(*Tuint32_t)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 96)), 4)))
	if !(groupnumber > (*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount) {
		goto __206
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR15
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Ferroroffset = offset
	return 0
__206:
	;
	if !(groupnumber > (*Tcompile_block_8)(unsafe.Pointer(cb)).Ftop_backref) {
		goto __207
	}
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Ftop_backref = groupnumber
__207:
	;
	offset = offset - uint64(2) // Point at initial ( for too many branches error
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3)) = OP_CREF
	skipunits = Tuint32_t(1 + DIMM2_SIZE)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 4)) = TPCRE2_UCHAR8(groupnumber >> 8)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 5)) = TPCRE2_UCHAR8(groupnumber & Tuint32_t(255))
	goto GROUP_PROCESS_NOTE_EMPTY

	// Test for the PCRE2 version.

__40:
	bravalue = OP_COND
	if !(*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 1*4)) > Tuint32_t(0)) {
		goto __208
	}
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3)) = func() uint8 {
		if Tuint32_t(DPCRE2_MAJOR) > *(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 2*4)) || Tuint32_t(DPCRE2_MAJOR) == *(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 2*4)) && Tuint32_t(DPCRE2_MINOR) >= *(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 3*4)) {
			return OP_TRUE
		}
		return OP_FALSE
	}()
	goto __209
__208:
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3)) = func() uint8 {
		if Tuint32_t(DPCRE2_MAJOR) == *(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 2*4)) && Tuint32_t(DPCRE2_MINOR) == *(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 3*4)) {
			return OP_TRUE
		}
		return OP_FALSE
	}()
__209:
	;
	skipunits = Tuint32_t(1)
	*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) += 4 * uintptr(3)
	goto GROUP_PROCESS_NOTE_EMPTY

	// The condition is an assertion, possibly preceded by a callout.

__41:
	bravalue = OP_COND
	goto GROUP_PROCESS_NOTE_EMPTY

	// ===================================================================
	// Handle all kinds of nested bracketed groups. The non-capturing,
	//     non-conditional cases are here; others come to GROUP_PROCESS via goto.

__42:
	bravalue = OP_ASSERT
	*(*Tuint16_t)(unsafe.Pointer(cb + 182)) += Tuint16_t(1)
	goto GROUP_PROCESS

__43:
	bravalue = OP_ASSERT_NA
	*(*Tuint16_t)(unsafe.Pointer(cb + 182)) += Tuint16_t(1)
	goto GROUP_PROCESS

	// Optimize (?!) to (*FAIL) unless it is quantified - which is a weird
	//     thing to do, but Perl allows all assertions to be quantified, and when
	//     they contain capturing parentheses there may be a potential use for
	//     this feature. Not that that applies to a quantified (?!) but we allow
	//     it for uniformity.

__44:
	if !(*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 1*4)) == DMETA_KET && (*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 2*4)) < DMETA_ASTERISK || *(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 2*4)) > DMETA_MINMAX_QUERY)) {
		goto __210
	}

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = OP_FAIL
	*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) += 4
	goto __211
__210:

	bravalue = OP_ASSERT_NOT
	*(*Tuint16_t)(unsafe.Pointer(cb + 182)) += Tuint16_t(1)
	goto GROUP_PROCESS
__211:
	;
	goto __12

__45:
	bravalue = OP_ASSERTBACK
	*(*Tuint16_t)(unsafe.Pointer(cb + 182)) += Tuint16_t(1)
	goto GROUP_PROCESS

__46:
	bravalue = OP_ASSERTBACK_NOT
	*(*Tuint16_t)(unsafe.Pointer(cb + 182)) += Tuint16_t(1)
	goto GROUP_PROCESS

__47:
	bravalue = OP_ASSERTBACK_NA
	*(*Tuint16_t)(unsafe.Pointer(cb + 182)) += Tuint16_t(1)
	goto GROUP_PROCESS

__48:
	bravalue = OP_ONCE
	goto GROUP_PROCESS_NOTE_EMPTY

__49:
	bravalue = OP_SCRIPT_RUN
	goto GROUP_PROCESS_NOTE_EMPTY

__50:
	bravalue = OP_BRA
	// Fall through

	// Process nested bracketed regex. The nesting depth is maintained for the
	//     benefit of the stackguard function. The test for too deep nesting is now
	//     done in parse_regex(). Assertion and DEFINE groups come to GROUP_PROCESS;
	//     others come to GROUP_PROCESS_NOTE_EMPTY, to indicate that we need to take
	//     note of whether or not they may match an empty string.

GROUP_PROCESS_NOTE_EMPTY:
	note_group_empty = DTRUE

GROUP_PROCESS:
	*(*Tuint16_t)(unsafe.Pointer(cb + 180)) += Tuint16_t(1)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)) = TPCRE2_UCHAR8(bravalue)
	*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) += 4
	*(*uintptr)(unsafe.Pointer(bp + 88 /* tempcode */)) = code
	tempreqvary = (*Tcompile_block_8)(unsafe.Pointer(cb)).Freq_varyopt       // Save value before group
	*(*Tsize_t)(unsafe.Pointer(bp + 120 /* length_prevgroup */)) = uint64(0) // Initialize for pre-compile phase

	if !(libc.AssignInt32(&group_return, compile_regex(tls,
		options,
		bp+88,
		bp+96,
		errorcodeptr,
		skipunits,
		bp+104,
		bp+108,
		bp+112,
		bp+116,
		bcptr,
		cb,
		func() uintptr {
			if lengthptr == uintptr(0) {
				return uintptr(0)
			}
			return bp + 120
		}())) == 0) {
		goto __212
	}
	return 0
__212:
	; // Error

	*(*Tuint16_t)(unsafe.Pointer(cb + 180)) -= Tuint16_t(1)

	// If that was a non-conditional significant group (not an assertion, not a
	//     DEFINE) that matches at least one character, then the current item matches
	//     a character. Conditionals are handled below.

	if !(note_group_empty != 0 && bravalue != OP_COND && group_return > 0) {
		goto __213
	}
	matched_char = DTRUE
__213:
	;

	// If we've just compiled an assertion, pop the assert depth.

	if !(bravalue >= OP_ASSERT && bravalue <= OP_ASSERTBACK_NA) {
		goto __214
	}
	*(*Tuint16_t)(unsafe.Pointer(cb + 182)) -= Tuint16_t(1)
__214:
	;

	// At the end of compiling, code is still pointing to the start of the
	//     group, while tempcode has been updated to point past the end of the group.
	//     The parsed pattern pointer (pptr) is on the closing META_KET.
	//
	//     If this is a conditional bracket, check that there are no more than
	//     two branches in the group, or just one if it's a DEFINE group. We do this
	//     in the real compile phase, not in the pre-pass, where the whole group may
	//     not be available.

	if !(bravalue == OP_COND && lengthptr == uintptr(0)) {
		goto __215
	}

	tc = code
	condcount = 0

__216:
	condcount++
	tc += uintptr(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(tc + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(tc + 2)))))
	goto __217
__217:
	if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(tc))) != OP_KET {
		goto __216
	}
	goto __218
__218:
	;

	// A DEFINE group is never obeyed inline (the "condition" is always
	//       false). It must have only one branch. Having checked this, change the
	//       opcode to OP_FALSE.

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3))) == OP_DEFINE) {
		goto __219
	}

	if !(condcount > 1) {
		goto __221
	}

	(*Tcompile_block_8)(unsafe.Pointer(cb)).Ferroroffset = offset
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR54
	return 0
__221:
	;
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3)) = OP_FALSE
	bravalue = OP_DEFINE // A flag to suppress char handling below
	goto __220
__219:

	if !(condcount > 2) {
		goto __222
	}

	(*Tcompile_block_8)(unsafe.Pointer(cb)).Ferroroffset = offset
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR27
	return 0
__222:
	;
	if !(condcount == 1) {
		goto __223
	}
	*(*Tuint32_t)(unsafe.Pointer(bp + 108 /* subfirstcuflags */)) = libc.AssignPtrUint32(bp+116 /* subreqcuflags */, DREQ_NONE)
	goto __224
__223:
	if !(group_return > 0) {
		goto __225
	}
	matched_char = DTRUE
__225:
	;
__224:
	;
__220:
	;
__215:
	;

	// In the pre-compile phase, update the length by the length of the group,
	//     less the brackets at either end. Then reduce the compiled code to just a
	//     set of non-capturing brackets so that it doesn't use much memory if it is
	//     duplicated by a quantifier.

	if !(lengthptr != uintptr(0)) {
		goto __226
	}

	if !(uint64(0x7fffffff-20)-*(*Tsize_t)(unsafe.Pointer(lengthptr)) < *(*Tsize_t)(unsafe.Pointer(bp + 120))-uint64(2)-uint64(2*DLINK_SIZE)) {
		goto __227
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR20
	return 0
__227:
	;
	*(*Tsize_t)(unsafe.Pointer(lengthptr)) += *(*Tsize_t)(unsafe.Pointer(bp + 120)) - uint64(2) - uint64(2*DLINK_SIZE)
	code++ // This already contains bravalue
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)) = TPCRE2_UCHAR8(int32(1+DLINK_SIZE) >> 8)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)) = TPCRE2_UCHAR8((1 + DLINK_SIZE) & 255)
	code += uintptr(DLINK_SIZE)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = OP_KET
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)) = TPCRE2_UCHAR8(int32(1+DLINK_SIZE) >> 8)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)) = TPCRE2_UCHAR8((1 + DLINK_SIZE) & 255)
	code += uintptr(DLINK_SIZE)
	goto __12 // No need to waste time with special character handling
__226:
	;

	// Otherwise update the main code pointer to the end of the group.

	code = *(*uintptr)(unsafe.Pointer(bp + 88 /* tempcode */))

	// For a DEFINE group, required and first character settings are not
	//     relevant.

	if !(bravalue == OP_DEFINE) {
		goto __228
	}
	goto __12
__228:
	;

	// Handle updating of the required and first code units for other types of
	//     group. Update for normal brackets of all kinds, and conditions with two
	//     branches (see code above). If the bracket is followed by a quantifier with
	//     zero repeat, we have to back off. Hence the definition of zeroreqcu and
	//     zerofirstcu outside the main loop so that they can be accessed for the back
	//     off.

	zeroreqcu = reqcu
	zeroreqcuflags = reqcuflags
	zerofirstcu = firstcu
	zerofirstcuflags = firstcuflags
	groupsetfirstcu = DFALSE

	if !(bravalue >= OP_ONCE) {
		goto __229
	} /* Not an assertion */

	// If we have not yet set a firstcu in this branch, take it from the
	//       subpattern, remembering that it was set here so that a repeat of more
	//       than one can replicate it as reqcu if necessary. If the subpattern has
	//       no firstcu, set "none" for the whole branch. In both cases, a zero
	//       repeat forces firstcu to "none".

	if !(firstcuflags == DREQ_UNSET && *(*Tuint32_t)(unsafe.Pointer(bp + 108)) != DREQ_UNSET) {
		goto __231
	}

	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 108)) < DREQ_NONE) {
		goto __233
	}

	firstcu = *(*Tuint32_t)(unsafe.Pointer(bp + 104 /* subfirstcu */))
	firstcuflags = *(*Tuint32_t)(unsafe.Pointer(bp + 108 /* subfirstcuflags */))
	groupsetfirstcu = DTRUE
	goto __234
__233:
	firstcuflags = DREQ_NONE
__234:
	;
	zerofirstcuflags = DREQ_NONE
	goto __232
__231:
	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 108)) < DREQ_NONE && *(*Tuint32_t)(unsafe.Pointer(bp + 116)) >= DREQ_NONE) {
		goto __235
	}

	*(*Tuint32_t)(unsafe.Pointer(bp + 112 /* subreqcu */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 104 /* subfirstcu */))
	*(*Tuint32_t)(unsafe.Pointer(bp + 116 /* subreqcuflags */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 108)) | tempreqvary
__235:
	;
__232:
	;

	// If the subpattern set a required code unit (or set a first code unit
	//       that isn't really the first code unit - see above), set it.

	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 116)) < DREQ_NONE) {
		goto __236
	}

	reqcu = *(*Tuint32_t)(unsafe.Pointer(bp + 112 /* subreqcu */))
	reqcuflags = *(*Tuint32_t)(unsafe.Pointer(bp + 116 /* subreqcuflags */))
__236:
	;
	goto __230
__229:
	if !((bravalue == OP_ASSERT || bravalue == OP_ASSERT_NA) && *(*Tuint32_t)(unsafe.Pointer(bp + 116)) < DREQ_NONE && *(*Tuint32_t)(unsafe.Pointer(bp + 108)) < DREQ_NONE) {
		goto __237
	}

	reqcu = *(*Tuint32_t)(unsafe.Pointer(bp + 112 /* subreqcu */))
	reqcuflags = *(*Tuint32_t)(unsafe.Pointer(bp + 116 /* subreqcuflags */))
__237:
	;
__230:
	;

	goto __12 // End of nested group handling

	// ===================================================================
	// Handle named backreferences and recursions.

__51:
__52:

	is_dupname = DFALSE
	ng1 = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fnamed_groups
	length1 = *(*Tuint32_t)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 96)), 4)))

	offset = Tsize_t(*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 1*4)))<<32 | Tsize_t(*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 2*4)))
	*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) += 4 * uintptr(2)

	name1 = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_pattern + uintptr(offset)

	// In the first pass, the names generated in the pre-pass are available,
	//       but the main name table has not yet been created. Scan the list of names
	//       generated in the pre-pass in order to get a number and whether or not
	//       this name is duplicated.

	groupnumber = Tuint32_t(0)
	{
		i13 = uint32(0)
	__238:
		if !(i13 < uint32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnames_found)) {
			goto __240
		}

		if !(length1 == Tuint32_t((*Tnamed_group_8)(unsafe.Pointer(ng1)).Flength) && X_pcre2_strncmp_8(tls, name1, (*Tnamed_group_8)(unsafe.Pointer(ng1)).Fname, uint64(length1)) == 0) {
			goto __241
		}

		is_dupname = TBOOL((*Tnamed_group_8)(unsafe.Pointer(ng1)).Fisdup)
		groupnumber = (*Tnamed_group_8)(unsafe.Pointer(ng1)).Fnumber

		// For a recursion, that's all that is needed. We can now go to
		//           the code that handles numerical recursion, applying it to the first
		//           group with the given name.

		if !(meta == DMETA_RECURSE_BYNAME) {
			goto __242
		}

		meta_arg = groupnumber
		goto HANDLE_NUMERICAL_RECURSION
	__242:
		;

		// For a back reference, update the back reference map and the
		//           maximum back reference.

		*(*Tuint32_t)(unsafe.Pointer(cb + 252)) |= func() uint32 {
			if groupnumber < Tuint32_t(32) {
				return uint32(1) << groupnumber
			}
			return uint32(1)
		}()
		if !(groupnumber > (*Tcompile_block_8)(unsafe.Pointer(cb)).Ftop_backref) {
			goto __243
		}
		(*Tcompile_block_8)(unsafe.Pointer(cb)).Ftop_backref = groupnumber
	__243:
		;
	__241:
		;
		goto __239
	__239:
		i13++
		ng1 += 16
		goto __238
		goto __240
	__240:
	}

	// If the name was not found we have a bad reference.

	if !(groupnumber == Tuint32_t(0)) {
		goto __244
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR15
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Ferroroffset = offset
	return 0
__244:
	;

	// If a back reference name is not duplicated, we can handle it as
	//       a numerical reference.

	if !!(is_dupname != 0) {
		goto __245
	}

	meta_arg = groupnumber
	goto HANDLE_SINGLE_REFERENCE
__245:
	;

	// If a back reference name is duplicated, we generate a different
	//       opcode to a numerical back reference. In the second pass we must
	//       search for the index and count in the final name table.

	*(*int32)(unsafe.Pointer(bp + 132 /* count1 */)) = 0 // Values for first pass (avoids compiler warning)
	*(*int32)(unsafe.Pointer(bp + 128 /* index1 */)) = 0
	if !(lengthptr == uintptr(0) && !(find_dupname_details(tls, name1, length1, bp+128,
		bp+132, errorcodeptr, cb) != 0)) {
		goto __246
	}
	return 0
__246:
	;

	if !(firstcuflags == DREQ_UNSET) {
		goto __247
	}
	firstcuflags = DREQ_NONE
__247:
	;
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = func() uint8 {
		if options&DPCRE2_CASELESS != Tuint32_t(0) {
			return OP_DNREFI
		}
		return OP_DNREF
	}()
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)) = TPCRE2_UCHAR8(*(*int32)(unsafe.Pointer(bp + 128)) >> 8)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)) = TPCRE2_UCHAR8(*(*int32)(unsafe.Pointer(bp + 128)) & 255)
	code += uintptr(DIMM2_SIZE)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)) = TPCRE2_UCHAR8(*(*int32)(unsafe.Pointer(bp + 132)) >> 8)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)) = TPCRE2_UCHAR8(*(*int32)(unsafe.Pointer(bp + 132)) & 255)
	code += uintptr(DIMM2_SIZE)

	goto __12

	// ===================================================================
	// Handle a numerical callout.

__53:
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)) = OP_CALLOUT
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)) = TPCRE2_UCHAR8(*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 1*4)) >> 8)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)) = TPCRE2_UCHAR8(*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 1*4)) & Tuint32_t(255)) // Offset to next pattern item
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3)) = TPCRE2_UCHAR8(*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 2*4)) >> 8)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 4)) = TPCRE2_UCHAR8(*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 2*4)) & Tuint32_t(255)) // Length of next pattern item
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 5)) = TPCRE2_UCHAR8(*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) + 3*4)))
	*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) += 4 * uintptr(3)
	code += uintptr(X_pcre2_OP_lengths_8[OP_CALLOUT])
	goto __12

	// ===================================================================
	// Handle a callout with a string argument. In the pre-pass we just compute
	//     the length without generating anything. The length in pptr[3] includes both
	//     delimiters; in the actual compile only the first one is copied, but a
	//     terminating zero is added. Any doubled delimiters within the string make
	//     this an overestimate, but it is not worth bothering about.

__54:
	if !(lengthptr != uintptr(0)) {
		goto __248
	}

	*(*Tsize_t)(unsafe.Pointer(lengthptr)) += Tsize_t(*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 3*4)) + Tuint32_t(1+4*DLINK_SIZE))
	*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) += 4 * uintptr(3)
	*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) += 4 * uintptr(2)
	goto __249
__248:

	length2 = *(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) + 3*4))
	callout_string = code + uintptr(1+4*DLINK_SIZE)

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)) = OP_CALLOUT_STR
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)) = TPCRE2_UCHAR8(*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 1*4)) >> 8)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)) = TPCRE2_UCHAR8(*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 1*4)) & Tuint32_t(255)) // Offset to next pattern item
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3)) = TPCRE2_UCHAR8(*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 2*4)) >> 8)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 4)) = TPCRE2_UCHAR8(*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 2*4)) & Tuint32_t(255)) // Length of next pattern item

	*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) += 4 * uintptr(3)
	offset = Tsize_t(*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 1*4)))<<32 | Tsize_t(*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 2*4)))
	*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) += 4 * uintptr(2)
	// Offset to string in pattern
	pp = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_pattern + uintptr(offset)
	delimiter = Tuint32_t(libc.AssignPtrUint8(libc.PostIncUintptr(&callout_string, 1), *(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&pp, 1)))))
	if !(delimiter == Tuint32_t('\173')) {
		goto __250
	}
	delimiter = Tuint32_t('\175')
__250:
	;
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 7)) = TPCRE2_UCHAR8(int32(offset+uint64(1)) >> 8)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 8)) = TPCRE2_UCHAR8(int32(offset+uint64(1)) & 255) // One after delimiter

	// The syntax of the pattern was checked in the parsing scan. The length
	//       includes both delimiters, but we have passed the opening one just above,
	//       so we reduce length before testing it. The test is for > 1 because we do
	//       not want to copy the final delimiter. This also ensures that pp[1] is
	//       accessible.

__251:
	if !(libc.PreDecUint32(&length2, 1) > Tuint32_t(1)) {
		goto __252
	}

	if !(Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pp))) == delimiter && Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pp + 1))) == delimiter) {
		goto __253
	}

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&callout_string, 1))) = TPCRE2_UCHAR8(delimiter)
	pp += uintptr(2)
	length2--
	goto __254
__253:
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&callout_string, 1))) = *(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&pp, 1)))
__254:
	;
	goto __251
__252:
	;
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&callout_string, 1))) = TPCRE2_UCHAR8(0)

	// Set the length of the entire item, the advance to its end.

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 5)) = TPCRE2_UCHAR8(int32((int64(callout_string)-int64(code))/1) >> 8)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 6)) = TPCRE2_UCHAR8(int32((int64(callout_string)-int64(code))/1) & 255)
	code = callout_string
__249:
	;
	goto __12

	// ===================================================================
	// Handle repetition. The different types are all sorted out in the parsing
	//     pass.

__55:
__56:
__57:
	repeat_min = *(*Tuint32_t)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 96)), 4)))
	repeat_max = *(*Tuint32_t)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 96)), 4)))
	goto REPEAT

__58:
__59:
__60:
	repeat_min = Tuint32_t(0)
	repeat_max = DMAX_REPEAT_COUNT + uint32(1)
	goto REPEAT

__61:
__62:
__63:
	repeat_min = Tuint32_t(1)
	repeat_max = DMAX_REPEAT_COUNT + uint32(1)
	goto REPEAT

__64:
__65:
__66:
	repeat_min = Tuint32_t(0)
	repeat_max = Tuint32_t(1)

REPEAT:
	if !(previous_matched_char != 0 && repeat_min > Tuint32_t(0)) {
		goto __255
	}
	matched_char = DTRUE
__255:
	;

	// Remember whether this is a variable length repeat, and default to
	//     single-char opcodes.

	if repeat_min == repeat_max {
		reqvary = uint32(0)
	} else {
		reqvary = DREQ_VARY
	}
	op_type = Tuint32_t(0)

	// Adjust first and required code units for a zero repeat.

	if !(repeat_min == Tuint32_t(0)) {
		goto __256
	}

	firstcu = zerofirstcu
	firstcuflags = zerofirstcuflags
	reqcu = zeroreqcu
	reqcuflags = zeroreqcuflags
__256:
	;

	// Note the greediness and possessiveness.

	switch meta {
	case DMETA_MINMAX_PLUS:
		goto __258
	case DMETA_ASTERISK_PLUS:
		goto __259
	case DMETA_PLUS_PLUS:
		goto __260
	case DMETA_QUERY_PLUS:
		goto __261

	case DMETA_MINMAX_QUERY:
		goto __262
	case DMETA_ASTERISK_QUERY:
		goto __263
	case DMETA_PLUS_QUERY:
		goto __264
	case DMETA_QUERY_QUERY:
		goto __265

	default:
		goto __266
	}
	goto __257

__258:
__259:
__260:
__261:
	repeat_type = Tuint32_t(0) // Force greedy
	possessive_quantifier = DTRUE
	goto __257

__262:
__263:
__264:
__265:
	repeat_type = greedy_non_default
	possessive_quantifier = DFALSE
	goto __257

__266:
	repeat_type = greedy_default
	possessive_quantifier = DFALSE
	goto __257
__257:
	;

	// Save start of previous item, in case we have to move it up in order to
	//     insert something before it, and remember what it was.

	*(*uintptr)(unsafe.Pointer(bp + 88 /* tempcode */)) = previous
	op_previous = *(*TPCRE2_UCHAR8)(unsafe.Pointer(previous))

	// Now handle repetition for the different types of item. If the repeat
	//     minimum and the repeat maximum are both 1, we can ignore the quantifier for
	//     non-parenthesized items, as they have only one alternative. For anything in
	//     parentheses, we must not ignore if {1} is possessive.

	switch int32(op_previous) {
	// If previous was a character or negated character match, abolish the
	//       item and generate a repeat item instead. If a char item has a minimum of
	//       more than one, ensure that it is set in reqcu - it might not be if a
	//       sequence such as x{3} is the first thing in a branch because the x will
	//       have gone into firstcu instead.

	case OP_CHAR:
		goto __268
	case OP_CHARI:
		goto __269
	case OP_NOT:
		goto __270
	case OP_NOTI:
		goto __271 // Code shared with single character types

	// If previous was a character class or a back reference, we put the
	//       repeat stuff after it, but just skip the item if the repeat was {0,0}.

	case OP_XCLASS:
		goto __272
	case OP_CLASS:
		goto __273
	case OP_NCLASS:
		goto __274
	case OP_REF:
		goto __275
	case OP_REFI:
		goto __276
	case OP_DNREF:
		goto __277
	case OP_DNREFI:
		goto __278

	// If previous is OP_FAIL, it was generated by an empty class []
	//       (PCRE2_ALLOW_EMPTY_CLASS is set). The other ways in which OP_FAIL can be
	//       generated, that is by (*FAIL) or (?!), disallow a quantifier at parse
	//       time. We can just ignore this repeat.

	case OP_FAIL:
		goto __279

	// Prior to 10.30, repeated recursions were wrapped in OP_ONCE brackets
	//       because pcre2_match() could not handle backtracking into recursively
	//       called groups. Now that this backtracking is available, we no longer need
	//       to do this. However, we still need to replicate recursions as we do for
	//       groups so as to have independent backtracking points. We can replicate
	//       for the minimum number of repeats directly. For optional repeats we now
	//       wrap the recursion in OP_BRA brackets and make use of the bracket
	//       repetition.

	case OP_RECURSE:
		goto __280 // Set "may match empty string"

	// Now treat as a repeated OP_BRA.
	// Fall through

	// If previous was a bracket group, we may have to replicate it in
	//       certain cases. Note that at this point we can encounter only the "basic"
	//       bracket opcodes such as BRA and CBRA, as this is the place where they get
	//       converted into the more special varieties such as BRAPOS and SBRA.
	//       Originally, PCRE did not allow repetition of assertions, but now it does,
	//       for Perl compatibility.

	case OP_ASSERT:
		goto __281
	case OP_ASSERT_NOT:
		goto __282
	case OP_ASSERT_NA:
		goto __283
	case OP_ASSERTBACK:
		goto __284
	case OP_ASSERTBACK_NOT:
		goto __285
	case OP_ASSERTBACK_NA:
		goto __286
	case OP_ONCE:
		goto __287
	case OP_SCRIPT_RUN:
		goto __288
	case OP_BRA:
		goto __289
	case OP_CBRA:
		goto __290
	case OP_COND:
		goto __291

	// If previous was a character type match (\d or similar), abolish it and
	//       create a suitable repeat item. The code is shared with single-character
	//       repeats by setting op_type to add a suitable offset into repeat_type.
	//       Note the the Unicode property types will be present only when
	//       SUPPORT_UNICODE is defined, but we don't wrap the little bits of code
	//       here because it just makes it horribly messy.

	default:
		goto __292
	}
	goto __267

	// If previous was a character or negated character match, abolish the
	//       item and generate a repeat item instead. If a char item has a minimum of
	//       more than one, ensure that it is set in reqcu - it might not be if a
	//       sequence such as x{3} is the first thing in a branch because the x will
	//       have gone into firstcu instead.

__268:
__269:
__270:
__271:
	if !(repeat_max == Tuint32_t(1) && repeat_min == Tuint32_t(1)) {
		goto __293
	}
	goto END_REPEAT
__293:
	;
	op_type = chartypeoffset[int32(op_previous)-OP_CHAR]

	// Deal with UTF characters that take up more than one code unit.

	if !(utf != 0 && uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + libc.UintptrFromInt32(-1))))&0xc0 == 0x80) {
		goto __294
	}

	lastchar = code - uintptr(1)
__296:
	if !(uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(lastchar)))&0xc0 == 0x80) {
		goto __297
	}
	lastchar--
	goto __296
__297:
	;
	mclength = Tuint32_t((int64(code) - int64(lastchar)) / 1)                                // Length of UTF character
	libc.Xmemcpy(tls, bp+72, lastchar, uint64(mclength*Tuint32_t(DPCRE2_CODE_UNIT_WIDTH/8))) // Save the char
	goto __295
__294:

	/* Handle the case of a single code unit - either with no UTF support, or
	   with UTF disabled, or for a single-code-unit UTF character. In the latter
	   case, for a repeated positive match, get the caseless flag for the
	   required code unit from the previous character, because a class like [Aa]
	   sets a caseless A but by now the req_caseopt flag has been reset. */

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(bp + 72)) = *(*TPCRE2_UCHAR8)(unsafe.Pointer(code + libc.UintptrFromInt32(-1)))
	mclength = Tuint32_t(1)
	if !(int32(op_previous) <= OP_CHARI && repeat_min > Tuint32_t(1)) {
		goto __298
	}

	reqcu = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bp + 72)))
	reqcuflags = (*Tcompile_block_8)(unsafe.Pointer(cb)).Freq_varyopt
	if !(int32(op_previous) == OP_CHARI) {
		goto __299
	}
	reqcuflags = reqcuflags | DREQ_CASELESS
__299:
	;
__298:
	;
__295:
	;
	goto OUTPUT_SINGLE_REPEAT // Code shared with single character types

	// If previous was a character class or a back reference, we put the
	//       repeat stuff after it, but just skip the item if the repeat was {0,0}.

__272:
__273:
__274:
__275:
__276:
__277:
__278:

	if !(repeat_max == Tuint32_t(0)) {
		goto __300
	}

	code = previous
	goto END_REPEAT
__300:
	;
	if !(repeat_max == Tuint32_t(1) && repeat_min == Tuint32_t(1)) {
		goto __301
	}
	goto END_REPEAT
__301:
	;

	if !(repeat_min == Tuint32_t(0) && repeat_max == DMAX_REPEAT_COUNT+uint32(1)) {
		goto __302
	}
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = TPCRE2_UCHAR8(OP_CRSTAR + repeat_type)
	goto __303
__302:
	if !(repeat_min == Tuint32_t(1) && repeat_max == DMAX_REPEAT_COUNT+uint32(1)) {
		goto __304
	}
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = TPCRE2_UCHAR8(OP_CRPLUS + repeat_type)
	goto __305
__304:
	if !(repeat_min == Tuint32_t(0) && repeat_max == Tuint32_t(1)) {
		goto __306
	}
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = TPCRE2_UCHAR8(OP_CRQUERY + repeat_type)
	goto __307
__306:

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = TPCRE2_UCHAR8(OP_CRRANGE + repeat_type)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)) = TPCRE2_UCHAR8(repeat_min >> 8)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)) = TPCRE2_UCHAR8(repeat_min & Tuint32_t(255))
	code += uintptr(DIMM2_SIZE)
	if !(repeat_max == DMAX_REPEAT_COUNT+uint32(1)) {
		goto __308
	}
	repeat_max = Tuint32_t(0)
__308:
	; // 2-byte encoding for max
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)) = TPCRE2_UCHAR8(repeat_max >> 8)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)) = TPCRE2_UCHAR8(repeat_max & Tuint32_t(255))
	code += uintptr(DIMM2_SIZE)
__307:
	;
__305:
	;
__303:
	;
	goto __267

	// If previous is OP_FAIL, it was generated by an empty class []
	//       (PCRE2_ALLOW_EMPTY_CLASS is set). The other ways in which OP_FAIL can be
	//       generated, that is by (*FAIL) or (?!), disallow a quantifier at parse
	//       time. We can just ignore this repeat.

__279:
	goto END_REPEAT

	// Prior to 10.30, repeated recursions were wrapped in OP_ONCE brackets
	//       because pcre2_match() could not handle backtracking into recursively
	//       called groups. Now that this backtracking is available, we no longer need
	//       to do this. However, we still need to replicate recursions as we do for
	//       groups so as to have independent backtracking points. We can replicate
	//       for the minimum number of repeats directly. For optional repeats we now
	//       wrap the recursion in OP_BRA brackets and make use of the bracket
	//       repetition.

__280:
	if !(repeat_max == Tuint32_t(1) && repeat_min == Tuint32_t(1) && !(possessive_quantifier != 0)) {
		goto __309
	}
	goto END_REPEAT
__309:
	;

	// Generate unwrapped repeats for a non-zero minimum, except when the
	//       minimum is 1 and the maximum unlimited, because that can be handled with
	//       OP_BRA terminated by OP_KETRMAX/MIN. When the maximum is equal to the
	//       minimum, we just need to generate the appropriate additional copies.
	//       Otherwise we need to generate one more, to simulate the situation when
	//       the minimum is zero.

	if !(repeat_min > Tuint32_t(0) && (repeat_min != Tuint32_t(1) || repeat_max != DMAX_REPEAT_COUNT+uint32(1))) {
		goto __310
	}

	replicate = int32(repeat_min)
	if !(repeat_min == repeat_max) {
		goto __311
	}
	replicate--
__311:
	;

	// In the pre-compile phase, we don't actually do the replication. We
	//         just adjust the length as if we had. Do some paranoid checks for
	//         potential integer overflow. The INT64_OR_DOUBLE type is a 64-bit
	//         integer type when available, otherwise double.

	if !(lengthptr != uintptr(0)) {
		goto __312
	}

	delta = Tsize_t(replicate * (1 + DLINK_SIZE))
	if !(Tint64_t(replicate)*int64(1+DLINK_SIZE) > int64(0x7fffffff) || uint64(0x7fffffff-20)-*(*Tsize_t)(unsafe.Pointer(lengthptr)) < delta) {
		goto __314
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR20
	return 0
__314:
	;
	*(*Tsize_t)(unsafe.Pointer(lengthptr)) += delta
	goto __313
__312:
	{
		i14 = 0
	__315:
		if !(i14 < replicate) {
			goto __317
		}

		libc.Xmemcpy(tls, code, previous, uint64((1+DLINK_SIZE)*(DPCRE2_CODE_UNIT_WIDTH/8)))
		previous = code
		code += uintptr(1 + DLINK_SIZE)
		goto __316
	__316:
		i14++
		goto __315
		goto __317
	__317:
	}
__313:
	;

	// If the number of repeats is fixed, we are done. Otherwise, adjust
	//         the counts and fall through.

	if !(repeat_min == repeat_max) {
		goto __318
	}
	goto __267
__318:
	;
	if !(repeat_max != DMAX_REPEAT_COUNT+uint32(1)) {
		goto __319
	}
	repeat_max = repeat_max - repeat_min
__319:
	;
	repeat_min = Tuint32_t(0)
__310:
	;

	// Wrap the recursion call in OP_BRA brackets.

	libc.Xmemmove(tls, previous+uintptr(1)+uintptr(DLINK_SIZE), previous, uint64((1+DLINK_SIZE)*(DPCRE2_CODE_UNIT_WIDTH/8)))
	op_previous = libc.AssignPtrUint8(previous, OP_BRA)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(previous + 1)) = TPCRE2_UCHAR8(int32(2+2*DLINK_SIZE) >> 8)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(previous + 2)) = TPCRE2_UCHAR8((2 + 2*DLINK_SIZE) & 255)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(previous + 6)) = OP_KET
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(previous + 7)) = TPCRE2_UCHAR8(int32(2+2*DLINK_SIZE) >> 8)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(previous + 8)) = TPCRE2_UCHAR8((2 + 2*DLINK_SIZE) & 255)
	code += uintptr(2 + 2*DLINK_SIZE)
	*(*Tsize_t)(unsafe.Pointer(bp + 120 /* length_prevgroup */)) = uint64(3 + 3*DLINK_SIZE)
	group_return = -1 // Set "may match empty string"

	// Now treat as a repeated OP_BRA.
	// Fall through

	// If previous was a bracket group, we may have to replicate it in
	//       certain cases. Note that at this point we can encounter only the "basic"
	//       bracket opcodes such as BRA and CBRA, as this is the place where they get
	//       converted into the more special varieties such as BRAPOS and SBRA.
	//       Originally, PCRE did not allow repetition of assertions, but now it does,
	//       for Perl compatibility.

__281:
__282:
__283:
__284:
__285:
__286:
__287:
__288:
__289:
__290:
__291:

	len = int32((int64(code) - int64(previous)) / 1)
	bralink = uintptr(0)
	brazeroptr = uintptr(0)

	if !(repeat_max == Tuint32_t(1) && repeat_min == Tuint32_t(1) && !(possessive_quantifier != 0)) {
		goto __320
	}
	goto END_REPEAT
__320:
	;

	// Repeating a DEFINE group (or any group where the condition is always
	//         FALSE and there is only one branch) is pointless, but Perl allows the
	//         syntax, so we just ignore the repeat.

	if !(int32(op_previous) == OP_COND && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(previous + 3))) == OP_FALSE && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(previous + uintptr(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(previous + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(previous + 2)))))))) != OP_ALT) {
		goto __321
	}
	goto END_REPEAT
__321:
	;

	// Perl allows all assertions to be quantified, and when they contain
	//         capturing parentheses and/or are optional there are potential uses for
	//         this feature. PCRE2 used to force the maximum quantifier to 1 on the
	//         invalid grounds that further repetition was never useful. This was
	//         always a bit pointless, since an assertion could be wrapped with a
	//         repeated group to achieve the effect. General repetition is now
	//         permitted, but if the maximum is unlimited it is set to one more than
	//         the minimum.

	if !(int32(op_previous) < OP_ONCE) {
		goto __322
	} /* Assertion */

	if !(repeat_max == DMAX_REPEAT_COUNT+uint32(1)) {
		goto __323
	}
	repeat_max = repeat_min + Tuint32_t(1)
__323:
	;
__322:
	;

	// The case of a zero minimum is special because of the need to stick
	//         OP_BRAZERO in front of it, and because the group appears once in the
	//         data, whereas in other cases it appears the minimum number of times. For
	//         this reason, it is simplest to treat this case separately, as otherwise
	//         the code gets far too messy. There are several special subcases when the
	//         minimum is zero.

	if !(repeat_min == Tuint32_t(0)) {
		goto __324
	}

	// If the maximum is also zero, we used to just omit the group from
	//           the output altogether, like this:
	//
	//           ** if (repeat_max == 0)
	//           **   {
	//           **   code = previous;
	//           **   goto END_REPEAT;
	//           **   }
	//
	//           However, that fails when a group or a subgroup within it is
	//           referenced as a subroutine from elsewhere in the pattern, so now we
	//           stick in OP_SKIPZERO in front of it so that it is skipped on
	//           execution. As we don't have a list of which groups are referenced, we
	//           cannot do this selectively.
	//
	//           If the maximum is 1 or unlimited, we just have to stick in the
	//           BRAZERO and do no more at this point.

	if !(repeat_max <= Tuint32_t(1) || repeat_max == DMAX_REPEAT_COUNT+uint32(1)) {
		goto __326
	}

	libc.Xmemmove(tls, previous+uintptr(1), previous, uint64(len*(DPCRE2_CODE_UNIT_WIDTH/8)))
	code++
	if !(repeat_max == Tuint32_t(0)) {
		goto __328
	}

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&previous, 1))) = OP_SKIPZERO
	goto END_REPEAT
__328:
	;
	brazeroptr = previous // Save for possessive optimizing
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&previous, 1))) = TPCRE2_UCHAR8(OP_BRAZERO + repeat_type)
	goto __327
__326:

	libc.Xmemmove(tls, previous+uintptr(2)+uintptr(DLINK_SIZE), previous, uint64(len*(DPCRE2_CODE_UNIT_WIDTH/8)))
	code += uintptr(2 + DLINK_SIZE)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&previous, 1))) = TPCRE2_UCHAR8(OP_BRAZERO + repeat_type)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&previous, 1))) = OP_BRA

	// We chain together the bracket link offset fields that have to be
	//             filled in later when the ends of the brackets are reached.

	if bralink == uintptr(0) {
		linkoffset = 0
	} else {
		linkoffset = int32((int64(previous) - int64(bralink)) / 1)
	}
	bralink = previous
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(previous)) = TPCRE2_UCHAR8(linkoffset >> 8)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(previous + 1)) = TPCRE2_UCHAR8(linkoffset & 255)
	previous += uintptr(DLINK_SIZE)
__327:
	;

	if !(repeat_max != DMAX_REPEAT_COUNT+uint32(1)) {
		goto __329
	}
	repeat_max--
__329:
	;
	goto __325
__324:

	if !(repeat_min > Tuint32_t(1)) {
		goto __330
	}

	// In the pre-compile phase, we don't actually do the replication.
	//             We just adjust the length as if we had. Do some paranoid checks for
	//             potential integer overflow. The INT64_OR_DOUBLE type is a 64-bit
	//             integer type when available, otherwise double.

	if !(lengthptr != uintptr(0)) {
		goto __331
	}

	delta1 = Tsize_t(repeat_min-Tuint32_t(1)) * *(*Tsize_t)(unsafe.Pointer(bp + 120))
	if !(Tint64_t(repeat_min-Tuint32_t(1))*Tint64_t(*(*Tsize_t)(unsafe.Pointer(bp + 120))) > int64(0x7fffffff) || uint64(0x7fffffff-20)-*(*Tsize_t)(unsafe.Pointer(lengthptr)) < delta1) {
		goto __333
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR20
	return 0
__333:
	;
	*(*Tsize_t)(unsafe.Pointer(lengthptr)) += delta1
	goto __332
__331:

	if !(groupsetfirstcu != 0 && reqcuflags >= DREQ_NONE) {
		goto __334
	}

	reqcu = firstcu
	reqcuflags = firstcuflags
__334:
	;
	{
		i15 = Tuint32_t(1)
	__335:
		if !(i15 < repeat_min) {
			goto __337
		}

		libc.Xmemcpy(tls, code, previous, uint64(len*(DPCRE2_CODE_UNIT_WIDTH/8)))
		code += uintptr(len)
		goto __336
	__336:
		i15++
		goto __335
		goto __337
	__337:
	}
__332:
	;
__330:
	;

	if !(repeat_max != DMAX_REPEAT_COUNT+uint32(1)) {
		goto __338
	}
	repeat_max = repeat_max - repeat_min
__338:
	;
__325:
	;

	// This code is common to both the zero and non-zero minimum cases. If
	//         the maximum is limited, it replicates the group in a nested fashion,
	//         remembering the bracket starts on a stack. In the case of a zero
	//         minimum, the first one was set up above. In all cases the repeat_max
	//         now specifies the number of additional copies needed. Again, we must
	//         remember to replicate entries on the forward reference list.

	if !(repeat_max != DMAX_REPEAT_COUNT+uint32(1)) {
		goto __339
	}

	// In the pre-compile phase, we don't actually do the replication. We
	//           just adjust the length as if we had. For each repetition we must add
	//           1 to the length for BRAZERO and for all but the last repetition we
	//           must add 2 + 2*LINKSIZE to allow for the nesting that occurs. Do some
	//           paranoid checks to avoid integer overflow. The INT64_OR_DOUBLE type
	//           is a 64-bit integer type when available, otherwise double.

	if !(lengthptr != uintptr(0) && repeat_max > Tuint32_t(0)) {
		goto __341
	}

	delta2 = Tsize_t(repeat_max)*(*(*Tsize_t)(unsafe.Pointer(bp + 120))+uint64(1)+uint64(2)+uint64(2*DLINK_SIZE)) - uint64(2) - uint64(2*DLINK_SIZE) // Last one doesn't nest
	if !(Tint64_t(repeat_max)*Tint64_t(*(*Tsize_t)(unsafe.Pointer(bp + 120))+uint64(1)+uint64(2)+uint64(2*DLINK_SIZE)) >
		int64(0x7fffffff) || uint64(0x7fffffff-20)-*(*Tsize_t)(unsafe.Pointer(lengthptr)) < delta2) {
		goto __343
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR20
	return 0
__343:
	;
	*(*Tsize_t)(unsafe.Pointer(lengthptr)) += delta2
	goto __342
__341:
	{
		i16 = repeat_max
	__344:
		if !(i16 >= Tuint32_t(1)) {
			goto __346
		}

		*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = TPCRE2_UCHAR8(OP_BRAZERO + repeat_type)

		// All but the final copy start a new nesting, maintaining the
		//             chain of brackets outstanding.

		if !(i16 != Tuint32_t(1)) {
			goto __347
		}

		*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = OP_BRA
		if bralink == uintptr(0) {
			linkoffset1 = 0
		} else {
			linkoffset1 = int32((int64(code) - int64(bralink)) / 1)
		}
		bralink = code
		*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)) = TPCRE2_UCHAR8(linkoffset1 >> 8)
		*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)) = TPCRE2_UCHAR8(linkoffset1 & 255)
		code += uintptr(DLINK_SIZE)
	__347:
		;

		libc.Xmemcpy(tls, code, previous, uint64(len*(DPCRE2_CODE_UNIT_WIDTH/8)))
		code += uintptr(len)
		goto __345
	__345:
		i16--
		goto __344
		goto __346
	__346:
	}
__342:
	;

	// Now chain through the pending brackets, and fill in their length
	//           fields (which are holding the chain links pro tem).

__348:
	if !(bralink != uintptr(0)) {
		goto __349
	}

	linkoffset2 = int32((int64(code)-int64(bralink))/1 + int64(1))
	bra = code - uintptr(linkoffset2)
	oldlinkoffset = int32(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bra + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bra + 2)))))
	if oldlinkoffset == 0 {
		bralink = uintptr(0)
	} else {
		bralink = bralink - uintptr(oldlinkoffset)
	}
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = OP_KET
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)) = TPCRE2_UCHAR8(linkoffset2 >> 8)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)) = TPCRE2_UCHAR8(linkoffset2 & 255)
	code += uintptr(DLINK_SIZE)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(bra + 1)) = TPCRE2_UCHAR8(linkoffset2 >> 8)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(bra + 2)) = TPCRE2_UCHAR8(linkoffset2 & 255)
	goto __348
__349:
	;
	goto __340
__339:

	ketcode = code - uintptr(1) - uintptr(DLINK_SIZE)
	bracode = ketcode - uintptr(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ketcode + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ketcode + 2)))))

	// Convert possessive ONCE brackets to non-capturing

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bracode))) == OP_ONCE && possessive_quantifier != 0) {
		goto __350
	}
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(bracode)) = OP_BRA
__350:
	;

	// For non-possessive ONCE and for SCRIPT_RUN brackets, all we need
	//           to do is to set the KET.

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bracode))) == OP_ONCE || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bracode))) == OP_SCRIPT_RUN) {
		goto __351
	}
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(ketcode)) = TPCRE2_UCHAR8(OP_KETRMAX + repeat_type)
	goto __352
__351:

	// In the compile phase, adjust the opcode if the group can match
	//             an empty string. For a conditional group with only one branch, the
	//             value of group_return will not show "could be empty", so we must
	//             check that separately.

	if !(lengthptr == uintptr(0)) {
		goto __353
	}

	if !(group_return < 0) {
		goto __354
	}
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(bracode)) += TPCRE2_UCHAR8(OP_SBRA - OP_BRA)
__354:
	;
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bracode))) == OP_COND && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bracode + uintptr(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bracode + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bracode + 2)))))))) != OP_ALT) {
		goto __355
	}
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(bracode)) = OP_SCOND
__355:
	;
__353:
	;

	// Handle possessive quantifiers.

	if !(possessive_quantifier != 0) {
		goto __356
	}

	// For COND brackets, we wrap the whole thing in a possessively
	//               repeated non-capturing bracket, because we have not invented POS
	//               versions of the COND opcodes.

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bracode))) == OP_COND || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bracode))) == OP_SCOND) {
		goto __358
	}

	nlen = int32((int64(code) - int64(bracode)) / 1)
	libc.Xmemmove(tls, bracode+uintptr(1)+uintptr(DLINK_SIZE), bracode, uint64(nlen*(DPCRE2_CODE_UNIT_WIDTH/8)))
	code += uintptr(1 + DLINK_SIZE)
	nlen = nlen + (1 + DLINK_SIZE)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(bracode)) = func() uint8 {
		if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bracode))) == OP_COND {
			return OP_BRAPOS
		}
		return OP_SBRAPOS
	}()
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = OP_KETRPOS
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)) = TPCRE2_UCHAR8(nlen >> 8)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)) = TPCRE2_UCHAR8(nlen & 255)
	code += uintptr(DLINK_SIZE)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(bracode + 1)) = TPCRE2_UCHAR8(nlen >> 8)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(bracode + 2)) = TPCRE2_UCHAR8(nlen & 255)
	goto __359
__358:

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(bracode)) += TPCRE2_UCHAR8(1) // Switch to xxxPOS opcodes
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(ketcode)) = OP_KETRPOS
__359:
	;

	// If the minimum is zero, mark it as possessive, then unset the
	//               possessive flag when the minimum is 0 or 1.

	if !(brazeroptr != uintptr(0)) {
		goto __360
	}
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(brazeroptr)) = OP_BRAPOSZERO
__360:
	;
	if !(repeat_min < Tuint32_t(2)) {
		goto __361
	}
	possessive_quantifier = DFALSE
__361:
	;
	goto __357
__356:
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(ketcode)) = TPCRE2_UCHAR8(OP_KETRMAX + repeat_type)
__357:
	;
__352:
	;
__340:
	;

	goto __267

	// If previous was a character type match (\d or similar), abolish it and
	//       create a suitable repeat item. The code is shared with single-character
	//       repeats by setting op_type to add a suitable offset into repeat_type.
	//       Note the the Unicode property types will be present only when
	//       SUPPORT_UNICODE is defined, but we don't wrap the little bits of code
	//       here because it just makes it horribly messy.

__292:
	if !(int32(op_previous) >= OP_EODN) {
		goto __362
	} /* Not a character type - internal error */

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR10
	return 0
	goto __363
__362:

	if !(repeat_max == Tuint32_t(1) && repeat_min == Tuint32_t(1)) {
		goto __364
	}
	goto END_REPEAT
__364:
	;

	op_type = Tuint32_t(OP_TYPESTAR - OP_STAR) // Use type opcodes
	mclength = Tuint32_t(0)                    // Not a character

	if !(int32(op_previous) == OP_PROP || int32(op_previous) == OP_NOTPROP) {
		goto __365
	}

	prop_type = int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(previous + 1)))
	prop_value = int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(previous + 2)))
	goto __366
__365:

	// Come here from just above with a character in mcbuffer/mclength.
OUTPUT_SINGLE_REPEAT:
	prop_type = libc.AssignInt32(&prop_value, -1)
__366:
	;

	// At this point, if prop_type == prop_value == -1 we either have a
	//         character in mcbuffer when mclength is greater than zero, or we have
	//         mclength zero, in which case there is a non-property character type in
	//         op_previous. If prop_type/value are not negative, we have a property
	//         character type in op_previous.

	oldcode = code  // Save where we were
	code = previous // Usually overwrite previous item

	// If the maximum is zero then the minimum must also be zero; Perl allows
	//         this case, so we do too - by simply omitting the item altogether.

	if !(repeat_max == Tuint32_t(0)) {
		goto __367
	}
	goto END_REPEAT
__367:
	;

	// Combine the op_type with the repeat_type

	repeat_type = repeat_type + op_type

	// A minimum of zero is handled either as the special case * or ?, or as
	//         an UPTO, with the maximum given.

	if !(repeat_min == Tuint32_t(0)) {
		goto __368
	}

	if !(repeat_max == DMAX_REPEAT_COUNT+uint32(1)) {
		goto __370
	}
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = TPCRE2_UCHAR8(OP_STAR + repeat_type)
	goto __371
__370:
	if !(repeat_max == Tuint32_t(1)) {
		goto __372
	}
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = TPCRE2_UCHAR8(OP_QUERY + repeat_type)
	goto __373
__372:

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = TPCRE2_UCHAR8(OP_UPTO + repeat_type)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)) = TPCRE2_UCHAR8(repeat_max >> 8)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)) = TPCRE2_UCHAR8(repeat_max & Tuint32_t(255))
	code += uintptr(DIMM2_SIZE)
__373:
	;
__371:
	;
	goto __369
__368:
	if !(repeat_min == Tuint32_t(1)) {
		goto __374
	}

	if !(repeat_max == DMAX_REPEAT_COUNT+uint32(1)) {
		goto __376
	}
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = TPCRE2_UCHAR8(OP_PLUS + repeat_type)
	goto __377
__376:

	code = oldcode // Leave previous item in place
	if !(repeat_max == Tuint32_t(1)) {
		goto __378
	}
	goto END_REPEAT
__378:
	;
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = TPCRE2_UCHAR8(OP_UPTO + repeat_type)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)) = TPCRE2_UCHAR8((repeat_max - Tuint32_t(1)) >> 8)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)) = TPCRE2_UCHAR8((repeat_max - Tuint32_t(1)) & Tuint32_t(255))
	code += uintptr(DIMM2_SIZE)
__377:
	;
	goto __375
__374:

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = TPCRE2_UCHAR8(OP_EXACT + op_type) // NB EXACT doesn't have repeat_type
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)) = TPCRE2_UCHAR8(repeat_min >> 8)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)) = TPCRE2_UCHAR8(repeat_min & Tuint32_t(255))
	code += uintptr(DIMM2_SIZE)

	// Unless repeat_max equals repeat_min, fill in the data for EXACT,
	//           and then generate the second opcode. For a repeated Unicode property
	//           match, there are two extra values that define the required property,
	//           and mclength is set zero to indicate this.

	if !(repeat_max != repeat_min) {
		goto __379
	}

	if !(mclength > Tuint32_t(0)) {
		goto __380
	}

	libc.Xmemcpy(tls, code, bp+72, uint64(mclength*Tuint32_t(DPCRE2_CODE_UNIT_WIDTH/8)))
	code += uintptr(mclength)
	goto __381
__380:

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = op_previous
	if !(prop_type >= 0) {
		goto __382
	}

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = TPCRE2_UCHAR8(prop_type)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = TPCRE2_UCHAR8(prop_value)
__382:
	;
__381:
	;

	// Now set up the following opcode

	if !(repeat_max == DMAX_REPEAT_COUNT+uint32(1)) {
		goto __383
	}
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = TPCRE2_UCHAR8(OP_STAR + repeat_type)
	goto __384
__383:

	repeat_max = repeat_max - repeat_min
	if !(repeat_max == Tuint32_t(1)) {
		goto __385
	}

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = TPCRE2_UCHAR8(OP_QUERY + repeat_type)
	goto __386
__385:

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = TPCRE2_UCHAR8(OP_UPTO + repeat_type)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)) = TPCRE2_UCHAR8(repeat_max >> 8)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)) = TPCRE2_UCHAR8(repeat_max & Tuint32_t(255))
	code += uintptr(DIMM2_SIZE)
__386:
	;
__384:
	;
__379:
	;
__375:
	;
__369:
	;

	// Fill in the character or character type for the final opcode.

	if !(mclength > Tuint32_t(0)) {
		goto __387
	}

	libc.Xmemcpy(tls, code, bp+72, uint64(mclength*Tuint32_t(DPCRE2_CODE_UNIT_WIDTH/8)))
	code += uintptr(mclength)
	goto __388
__387:

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = op_previous
	if !(prop_type >= 0) {
		goto __389
	}

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = TPCRE2_UCHAR8(prop_type)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = TPCRE2_UCHAR8(prop_value)
__389:
	;
__388:
	;
__363:
	;
	goto __267
__267:
	; // End of switch on different op_previous values

	// If the character following a repeat is '+', possessive_quantifier is
	//     TRUE. For some opcodes, there are special alternative opcodes for this
	//     case. For anything else, we wrap the entire repeated item inside OP_ONCE
	//     brackets. Logically, the '+' notation is just syntactic sugar, taken from
	//     Sun's Java package, but the special opcodes can optimize it.
	//
	//     Some (but not all) possessively repeated subpatterns have already been
	//     completely handled in the code just above. For them, possessive_quantifier
	//     is always FALSE at this stage. Note that the repeated item starts at
	//     tempcode, not at previous, which might be the first part of a string whose
	//     (former) last char we repeated.

	if !(possessive_quantifier != 0) {
		goto __390
	}

	// Possessifying an EXACT quantifier has no effect, so we can ignore it.
	//       However, QUERY, STAR, or UPTO may follow (for quantifiers such as {5,6},
	//       {5,}, or {5,10}). We skip over an EXACT item; if the length of what
	//       remains is greater than zero, there's a further opcode that can be
	//       handled. If not, do nothing, leaving the EXACT alone.

	switch int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 88 /* tempcode */))))) {
	case OP_TYPEEXACT:
		goto __392

	// CHAR opcodes are used for exacts whose count is 1.

	case OP_CHAR:
		goto __393
	case OP_CHARI:
		goto __394
	case OP_NOT:
		goto __395
	case OP_NOTI:
		goto __396
	case OP_EXACT:
		goto __397
	case OP_EXACTI:
		goto __398
	case OP_NOTEXACT:
		goto __399
	case OP_NOTEXACTI:
		goto __400

	// For the class opcodes, the repeat operator appears at the end;
	//         adjust tempcode to point to it.

	case OP_CLASS:
		goto __401
	case OP_NCLASS:
		goto __402

	case OP_XCLASS:
		goto __403
	}
	goto __391

__392:
	*(*uintptr)(unsafe.Pointer(bp + 88 /* tempcode */)) += uintptr(int32(X_pcre2_OP_lengths_8[*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 88))))]) + func() int32 {
		if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 88)) + 3))) == OP_PROP ||
			int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 88)) + 3))) == OP_NOTPROP {
			return 2
		}
		return 0
	}())
	goto __391

	// CHAR opcodes are used for exacts whose count is 1.

__393:
__394:
__395:
__396:
__397:
__398:
__399:
__400:
	*(*uintptr)(unsafe.Pointer(bp + 88 /* tempcode */)) += uintptr(X_pcre2_OP_lengths_8[*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 88 /* tempcode */))))])
	if !(utf != 0 && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 88)) + libc.UintptrFromInt32(-1)))) >= 0xc0) {
		goto __404
	}
	*(*uintptr)(unsafe.Pointer(bp + 88 /* tempcode */)) += uintptr(X_pcre2_utf8_table4[uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 88)) + libc.UintptrFromInt32(-1))))&0x3f])
__404:
	;
	goto __391

	// For the class opcodes, the repeat operator appears at the end;
	//         adjust tempcode to point to it.

__401:
__402:
	*(*uintptr)(unsafe.Pointer(bp + 88 /* tempcode */)) += uintptr(uint64(1) + uint64(32)/uint64(unsafe.Sizeof(TPCRE2_UCHAR8(0))))
	goto __391

__403:
	*(*uintptr)(unsafe.Pointer(bp + 88 /* tempcode */)) += uintptr(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 88)) + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 88)) + 2)))))
	goto __391
__391:
	;

	// If tempcode is equal to code (which points to the end of the repeated
	//       item), it means we have skipped an EXACT item but there is no following
	//       QUERY, STAR, or UPTO; the value of len will be 0, and we do nothing. In
	//       all other cases, tempcode will be pointing to the repeat opcode, and will
	//       be less than code, so the value of len will be greater than 0.

	len1 = int32((int64(code) - int64(*(*uintptr)(unsafe.Pointer(bp + 88)))) / 1)
	if !(len1 > 0) {
		goto __405
	}

	repcode = uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 88 /* tempcode */)))))

	// There is a table for possessifying opcodes, all of which are less
	//         than OP_CALLOUT. A zero entry means there is no possessified version.
	//

	if !(repcode < OP_CALLOUT && int32(opcode_possessify[repcode]) > 0) {
		goto __406
	}
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 88 /* tempcode */)))) = opcode_possessify[repcode]
	goto __407
__406:

	libc.Xmemmove(tls, *(*uintptr)(unsafe.Pointer(bp + 88))+uintptr(1)+uintptr(DLINK_SIZE), *(*uintptr)(unsafe.Pointer(bp + 88 /* tempcode */)), uint64(len1*(DPCRE2_CODE_UNIT_WIDTH/8)))
	code += uintptr(1 + DLINK_SIZE)
	len1 = len1 + (1 + DLINK_SIZE)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 88 /* tempcode */)))) = OP_ONCE
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = OP_KET
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)) = TPCRE2_UCHAR8(len1 >> 8)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)) = TPCRE2_UCHAR8(len1 & 255)
	code += uintptr(DLINK_SIZE)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 88 /* tempcode */)) + 1)) = TPCRE2_UCHAR8(len1 >> 8)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 88 /* tempcode */)) + 2)) = TPCRE2_UCHAR8(len1 & 255)
__407:
	;
__405:
	;
__390:
	;

	// We set the "follows varying string" flag for subsequently encountered
	//     reqcus if it isn't already set and we have just passed a varying length
	//     item.

END_REPEAT:
	*(*Tuint32_t)(unsafe.Pointer(cb + 276)) |= reqvary
	goto __12

	// ===================================================================
	// Handle a 32-bit data character with a value greater than META_END.

__67:
	*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) += 4
	goto NORMAL_CHAR

	// ===============================================================
	// Handle a back reference by number, which is the meta argument. The
	//     pattern offsets for back references to group numbers less than 10 are held
	//     in a special vector, to avoid using more than two parsed pattern elements
	//     in 64-bit environments. We only need the offset to the first occurrence,
	//     because if that doesn't fail, subsequent ones will also be OK.

__68:
	if !(meta_arg < Tuint32_t(10)) {
		goto __408
	}
	offset = *(*Tsize_t)(unsafe.Pointer(cb + 88 + uintptr(meta_arg)*8))
	goto __409
__408:
	offset = Tsize_t(*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 1*4)))<<32 | Tsize_t(*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 2*4)))
	*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) += 4 * uintptr(2)
__409:
	;

	if !(meta_arg > (*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount) {
		goto __410
	}

	(*Tcompile_block_8)(unsafe.Pointer(cb)).Ferroroffset = offset
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR15 // Non-existent subpattern
	return 0
__410:
	;

	// Come here from named backref handling when the reference is to a
	//     single group (that is, not to a duplicated name). The back reference
	//     data will have already been updated. We must disable firstcu if not
	//     set, to cope with cases like (?=(\w+))\1: which would otherwise set ':'
	//     later.

HANDLE_SINGLE_REFERENCE:
	if !(firstcuflags == DREQ_UNSET) {
		goto __411
	}
	zerofirstcuflags = libc.AssignUint32(&firstcuflags, DREQ_NONE)
__411:
	;
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = func() uint8 {
		if options&DPCRE2_CASELESS != Tuint32_t(0) {
			return OP_REFI
		}
		return OP_REF
	}()
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)) = TPCRE2_UCHAR8(meta_arg >> 8)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)) = TPCRE2_UCHAR8(meta_arg & Tuint32_t(255))
	code += uintptr(DIMM2_SIZE)

	// Update the map of back references, and keep the highest one. We
	//     could do this in parse_regex() for numerical back references, but not
	//     for named back references, because we don't know the numbers to which
	//     named back references refer. So we do it all in this function.

	*(*Tuint32_t)(unsafe.Pointer(cb + 252)) |= func() uint32 {
		if meta_arg < Tuint32_t(32) {
			return uint32(1) << meta_arg
		}
		return uint32(1)
	}()
	if !(meta_arg > (*Tcompile_block_8)(unsafe.Pointer(cb)).Ftop_backref) {
		goto __412
	}
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Ftop_backref = meta_arg
__412:
	;
	goto __12

	// ===============================================================
	// Handle recursion by inserting the number of the called group (which is
	//     the meta argument) after OP_RECURSE. At the end of compiling the pattern is
	//     scanned and these numbers are replaced by offsets within the pattern. It is
	//     done like this to avoid problems with forward references and adjusting
	//     offsets when groups are duplicated and moved (as discovered in previous
	//     implementations). Note that a recursion does not have a set first
	//     character.

__69:
	offset = Tsize_t(*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 1*4)))<<32 | Tsize_t(*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 2*4)))
	*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) += 4 * uintptr(2)

	if !(meta_arg > (*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount) {
		goto __413
	}

	(*Tcompile_block_8)(unsafe.Pointer(cb)).Ferroroffset = offset
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR15 // Non-existent subpattern
	return 0
__413:
	;
HANDLE_NUMERICAL_RECURSION:
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)) = OP_RECURSE
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)) = TPCRE2_UCHAR8(meta_arg >> 8)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)) = TPCRE2_UCHAR8(meta_arg & Tuint32_t(255))
	code += uintptr(1 + DLINK_SIZE)
	groupsetfirstcu = DFALSE
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Fhad_recurse = DTRUE
	if !(firstcuflags == DREQ_UNSET) {
		goto __414
	}
	firstcuflags = DREQ_NONE
__414:
	;
	zerofirstcu = firstcu
	zerofirstcuflags = firstcuflags
	goto __12

	// ===============================================================
	// Handle capturing parentheses; the number is the meta argument.

__70:
	bravalue = OP_CBRA
	skipunits = Tuint32_t(DIMM2_SIZE)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3)) = TPCRE2_UCHAR8(meta_arg >> 8)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 4)) = TPCRE2_UCHAR8(meta_arg & Tuint32_t(255))
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Flastcapture = meta_arg
	goto GROUP_PROCESS_NOTE_EMPTY

	// ===============================================================
	// Handle escape sequence items. For ones like \d, the ESC_values are
	//     arranged to be the same as the corresponding OP_values in the default case
	//     when PCRE2_UCP is not set (which is the only case in which they will appear
	//     here).
	//
	//     Note: \Q and \E are never seen here, as they were dealt with in
	//     parse_pattern(). Neither are numerical back references or recursions, which
	//     were turned into META_BACKREF or META_RECURSE items, respectively. \k and
	//     \g, when followed by names, are turned into META_BACKREF_BYNAME or
	//     META_RECURSE_BYNAME.

__71:

	// We can test for escape sequences that consume a character because their
	//     values lie between ESC_b and ESC_Z; this may have to change if any new ones
	//     are ever created. For these sequences, we disable the setting of a first
	//     character if it hasn't already been set.

	if !(meta_arg > ESC_b && meta_arg < ESC_Z) {
		goto __415
	}

	matched_char = DTRUE
	if !(firstcuflags == DREQ_UNSET) {
		goto __416
	}
	firstcuflags = DREQ_NONE
__416:
	;
__415:
	;

	// Set values to reset to if this is followed by a zero repeat.

	zerofirstcu = firstcu
	zerofirstcuflags = firstcuflags
	zeroreqcu = reqcu
	zeroreqcuflags = reqcuflags

	// If Unicode is not supported, \P and \p are not allowed and are
	//     faulted at parse time, so will never appear here.

	if !(meta_arg == ESC_P || meta_arg == ESC_p) {
		goto __417
	}

	ptype1 = *(*Tuint32_t)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 96)), 4))) >> 16
	pdata1 = *(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)))) & Tuint32_t(0xffff)

	// The special case of \p{Any} is compiled to OP_ALLANY so as to benefit
	//       from the auto-anchoring code.

	if !(meta_arg == ESC_p && ptype1 == Tuint32_t(DPT_ANY)) {
		goto __418
	}

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = OP_ALLANY
	goto __419
__418:

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = func() uint8 {
		if meta_arg == ESC_p {
			return OP_PROP
		}
		return OP_NOTPROP
	}()
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = TPCRE2_UCHAR8(ptype1)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = TPCRE2_UCHAR8(pdata1)
__419:
	;
	goto __12 // End META_ESCAPE
__417:
	;

	// \K is forbidden in lookarounds since 10.38 because that's what Perl has
	//     done. However, there's an option, in case anyone was relying on it.

	if !(int32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fassert_depth) > 0 && meta_arg == ESC_K && (*Tpcre2_real_compile_context_8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fcx)).Fextra_options&DPCRE2_EXTRA_ALLOW_LOOKAROUND_BSK == Tuint32_t(0)) {
		goto __420
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR99
	return 0
__420:
	;

	// For the rest (including \X when Unicode is supported - if not it's
	//     faulted at parse time), the OP value is the escape value when PCRE2_UCP is
	//     not set; if it is set, these escapes do not show up here because they are
	//     converted into Unicode property tests in parse_regex(). Note that \b and \B
	//     do a one-character lookbehind, and \A also behaves as if it does.

	if !(meta_arg == ESC_C) {
		goto __421
	}
	*(*Tuint32_t)(unsafe.Pointer(cb + 208)) |= Tuint32_t(DPCRE2_HASBKC)
__421:
	; // Record
	if !((meta_arg == ESC_b || meta_arg == ESC_B || meta_arg == ESC_A) && (*Tcompile_block_8)(unsafe.Pointer(cb)).Fmax_lookbehind == 0) {
		goto __422
	}
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Fmax_lookbehind = 1
__422:
	;

	// In non-UTF mode, and for both 32-bit modes, we turn \C into OP_ALLANY
	//     instead of OP_ANYBYTE so that it works in DFA mode and in lookbehinds.

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = func() uint8 {
		if !(utf != 0) && meta_arg == ESC_C {
			return OP_ALLANY
		}
		return uint8(meta_arg)
	}()
	goto __12 // End META_ESCAPE

	// ===================================================================
	// Handle an unrecognized meta value. A parsed pattern value less than
	//     META_END is a literal. Otherwise we have a problem.

__72:
	if !(meta >= DMETA_END) {
		goto __423
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR89 // Internal error - unrecognized.
	return 0
__423:
	;

	// Handle a literal character. We come here by goto in the case of a
	//     32-bit, non-UTF character whose value is greater than META_END.

NORMAL_CHAR:
	meta = *(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)))) // Get the full 32 bits
NORMAL_CHAR_SET: // Character is already in meta
	matched_char = DTRUE

	// For caseless UTF or UCP mode, check whether this character has more than
	//     one other case. If so, generate a special OP_PROP item instead of OP_CHARI.
	//

	if !((utf != 0 || ucp != 0) && options&DPCRE2_CASELESS != Tuint32_t(0)) {
		goto __424
	}

	caseset = Tuint32_t((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(meta)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(meta)%DUCD_BLOCK_SIZE])*12)).Fcaseset)
	if !(caseset != Tuint32_t(0)) {
		goto __425
	}

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = OP_PROP
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = TPCRE2_UCHAR8(DPT_CLIST)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = TPCRE2_UCHAR8(caseset)
	if !(firstcuflags == DREQ_UNSET) {
		goto __426
	}
	firstcuflags = libc.AssignUint32(&zerofirstcuflags, DREQ_NONE)
__426:
	;
	goto __12 // End handling this meta item
__425:
	;
__424:
	;

	// Caseful matches, or caseless and not one of the multicase characters. We
	//     come here by goto in the case of a positive class that contains only
	//     case-partners of a character with just two cases; matched_char has already
	//     been set TRUE and options fudged if necessary.

CLASS_CASELESS_CHAR:

	// Get the character's code units into mcbuffer, with the length in
	//     mclength. When not in UTF mode, the length is always 1.

	if !(utf != 0) {
		goto __427
	}
	mclength = X_pcre2_ord2utf_8(tls, meta, bp+72)
	goto __428
__427:

	mclength = Tuint32_t(1)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(bp + 72)) = TPCRE2_UCHAR8(meta)
__428:
	;

	// Generate the appropriate code

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = func() uint8 {
		if options&DPCRE2_CASELESS != Tuint32_t(0) {
			return OP_CHARI
		}
		return OP_CHAR
	}()
	libc.Xmemcpy(tls, code, bp+72, uint64(mclength*Tuint32_t(DPCRE2_CODE_UNIT_WIDTH/8)))
	code += uintptr(mclength)

	// Remember if \r or \n were seen

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bp + 72))) == '\015' || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bp + 72))) == '\012') {
		goto __429
	}
	*(*Tuint32_t)(unsafe.Pointer(cb + 208)) |= Tuint32_t(DPCRE2_HASCRORLF)
__429:
	;

	// Set the first and required code units appropriately. If no previous
	//     first code unit, set it from this character, but revert to none on a zero
	//     repeat. Otherwise, leave the firstcu value alone, and don't change it on
	//     a zero repeat.

	if !(firstcuflags == DREQ_UNSET) {
		goto __430
	}

	zerofirstcuflags = DREQ_NONE
	zeroreqcu = reqcu
	zeroreqcuflags = reqcuflags

	// If the character is more than one code unit long, we can set a single
	//       firstcu only if it is not to be matched caselessly. Multiple possible
	//       starting code units may be picked up later in the studying code.

	if !(mclength == Tuint32_t(1) || req_caseopt == Tuint32_t(0)) {
		goto __432
	}

	firstcu = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bp + 72)))
	firstcuflags = req_caseopt
	if !(mclength != Tuint32_t(1)) {
		goto __434
	}

	reqcu = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + libc.UintptrFromInt32(-1))))
	reqcuflags = (*Tcompile_block_8)(unsafe.Pointer(cb)).Freq_varyopt
__434:
	;
	goto __433
__432:
	firstcuflags = libc.AssignUint32(&reqcuflags, DREQ_NONE)
__433:
	;
	goto __431
__430:

	zerofirstcu = firstcu
	zerofirstcuflags = firstcuflags
	zeroreqcu = reqcu
	zeroreqcuflags = reqcuflags
	if !(mclength == Tuint32_t(1) || req_caseopt == Tuint32_t(0)) {
		goto __435
	}

	reqcu = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + libc.UintptrFromInt32(-1))))
	reqcuflags = req_caseopt | (*Tcompile_block_8)(unsafe.Pointer(cb)).Freq_varyopt
__435:
	;
__431:
	;

	// If caselessness was temporarily instated, reset it.

	if !(reset_caseful != 0) {
		goto __436
	}

	options = options & libc.CplUint32(DPCRE2_CASELESS)
	req_caseopt = Tuint32_t(0)
	reset_caseful = DFALSE
__436:
	;

	goto __12 // End literal character handling
__12:
	; // End of big switch
	goto __2
__2:
	*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) += 4
	goto __1
	goto __3
__3:
	;
	return int32(0) // End of big loop

	// Control never reaches here.
}

// ************************************************
//
//   Compile regex: a sequence of alternatives    *
//

// On entry, pptr is pointing past the bracket meta, but on return it points to
// the closing bracket or META_END. The code variable is pointing at the code unit
// into which the BRA operator has been stored. This function is used during the
// pre-compile phase when we are trying to find out the amount of memory needed,
// as well as during the real compile phase. The value of lengthptr distinguishes
// the two phases.
//
// Arguments:
//   options           option bits, including any changes for this subpattern
//   codeptr           -> the address of the current code pointer
//   pptrptr           -> the address of the current parsed pattern pointer
//   errorcodeptr      -> pointer to error code variable
//   skipunits         skip this many code units at start (for brackets and OP_COND)
//   firstcuptr        place to put the first required code unit
//   firstcuflagsptr   place to put the first code unit flags
//   reqcuptr          place to put the last required code unit
//   reqcuflagsptr     place to put the last required code unit flags
//   bcptr             pointer to the chain of currently open branches
//   cb                points to the data block with tables pointers etc.
//   lengthptr         NULL during the real compile phase
//                     points to length accumulator during pre-compile phase
//
// Returns:            0 There has been an error
//                    +1 Success, this group must match at least one character
//                    -1 Success, this group may match an empty string

func compile_regex(tls *libc.TLS, options Tuint32_t, codeptr uintptr, pptrptr uintptr, errorcodeptr uintptr, skipunits Tuint32_t, firstcuptr uintptr, firstcuflagsptr uintptr, reqcuptr uintptr, reqcuflagsptr uintptr, bcptr uintptr, cb uintptr, lengthptr uintptr) int32 { /* pcre2_compile.c:8095:1: */
	bp := tls.Alloc(80)
	defer tls.Free(80)
	*(*Tuint32_t)(unsafe.Pointer(bp + 16)) = options

	*(*uintptr)(unsafe.Pointer(bp + 24 /* code */)) = *(*uintptr)(unsafe.Pointer(codeptr))
	var last_branch uintptr = *(*uintptr)(unsafe.Pointer(bp + 24 /* code */))
	var start_bracket uintptr = *(*uintptr)(unsafe.Pointer(bp + 24 /* code */))
	var lookbehind TBOOL
	// var capitem Topen_capitem at bp, 16

	var capnumber int32 = 0
	var okreturn int32 = 1
	*(*uintptr)(unsafe.Pointer(bp + 32 /* pptr */)) = *(*uintptr)(unsafe.Pointer(pptrptr))
	var firstcu Tuint32_t
	var reqcu Tuint32_t
	var lookbehindlength Tuint32_t
	var firstcuflags Tuint32_t
	var reqcuflags Tuint32_t
	// var branchfirstcu Tuint32_t at bp+40, 4

	// var branchreqcu Tuint32_t at bp+48, 4

	// var branchfirstcuflags Tuint32_t at bp+44, 4

	// var branchreqcuflags Tuint32_t at bp+52, 4

	// var length Tsize_t at bp+72, 8

	// var bc Tbranch_chain_8 at bp+56, 16

	// If set, call the external function that checks for stack availability.

	if (*Tpcre2_real_compile_context_8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fcx)).Fstack_guard != uintptr(0) && (*struct {
		f func(*libc.TLS, Tuint32_t, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_real_compile_context_8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fcx)).Fstack_guard})).f(tls, uint32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fparens_depth), (*Tpcre2_real_compile_context_8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fcx)).Fstack_guard_data) != 0 {
		*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR33
		return 0
	}

	// Miscellaneous initialization

	(*Tbranch_chain_8)(unsafe.Pointer(bp + 56 /* &bc */)).Fouter = bcptr
	(*Tbranch_chain_8)(unsafe.Pointer(bp + 56 /* &bc */)).Fcurrent_branch = *(*uintptr)(unsafe.Pointer(bp + 24 /* code */))

	firstcu = libc.AssignUint32(&reqcu, Tuint32_t(0))
	firstcuflags = libc.AssignUint32(&reqcuflags, DREQ_UNSET)

	// Accumulate the length for use in the pre-compile phase. Start with the
	// length of the BRA and KET and any extra code units that are required at the
	// beginning. We accumulate in a local variable to save frequent testing of
	// lengthptr for NULL. We cannot do this by looking at the value of 'code' at the
	// start and end of each alternative, because compiled items are discarded during
	// the pre-compile phase so that the workspace is not exceeded.

	*(*Tsize_t)(unsafe.Pointer(bp + 72 /* length */)) = Tsize_t(Tuint32_t(2+2*DLINK_SIZE) + skipunits)

	// Remember if this is a lookbehind assertion, and if it is, save its length
	// and skip over the pattern offset.

	lookbehind = libc.Bool32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24))))) == OP_ASSERTBACK || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24))))) == OP_ASSERTBACK_NOT || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24))))) == OP_ASSERTBACK_NA)

	if lookbehind != 0 {
		lookbehindlength = *(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32)) + libc.UintptrFromInt32(-1)*4)) & 0x0000ffff
		*(*uintptr)(unsafe.Pointer(bp + 32 /* pptr */)) += 4 * uintptr(DSIZEOFFSET)
	} else {
		lookbehindlength = Tuint32_t(0)
	}

	// If this is a capturing subpattern, add to the chain of open capturing items
	// so that we can detect them if (*ACCEPT) is encountered. Note that only OP_CBRA
	// need be tested here; changing this opcode to one of its variants, e.g.
	// OP_SCBRAPOS, happens later, after the group has been compiled.

	if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24))))) == OP_CBRA {
		capnumber = int32(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24)) + 3)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24)) + 4)))))
		(*Topen_capitem)(unsafe.Pointer(bp /* &capitem */)).Fnumber = Tuint16_t(capnumber)
		(*Topen_capitem)(unsafe.Pointer(bp /* &capitem */)).Fnext = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fopen_caps
		(*Topen_capitem)(unsafe.Pointer(bp /* &capitem */)).Fassert_depth = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fassert_depth
		(*Tcompile_block_8)(unsafe.Pointer(cb)).Fopen_caps = bp /* &capitem */
	}

	// Offset is set zero to mark that this bracket is still open

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24 /* code */)) + 1)) = TPCRE2_UCHAR8(int32(0) >> 8)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24 /* code */)) + 2)) = TPCRE2_UCHAR8(0 & 255)
	*(*uintptr)(unsafe.Pointer(bp + 24 /* code */)) += uintptr(Tuint32_t(1+DLINK_SIZE) + skipunits)

	// Loop for each alternative branch

	for {
		var branch_return int32

		// Insert OP_REVERSE if this is as lookbehind assertion.

		if lookbehind != 0 && lookbehindlength > Tuint32_t(0) {
			*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 24 /* code */)), 1))) = OP_REVERSE
			*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24 /* code */)))) = TPCRE2_UCHAR8(lookbehindlength >> 8)
			*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24 /* code */)) + 1)) = TPCRE2_UCHAR8(lookbehindlength & Tuint32_t(255))
			*(*uintptr)(unsafe.Pointer(bp + 24 /* code */)) += uintptr(DLINK_SIZE)
			*(*Tsize_t)(unsafe.Pointer(bp + 72 /* length */)) += uint64(1 + DLINK_SIZE)
		}

		// Now compile the branch; in the pre-compile phase its length gets added
		//   into the length.

		if libc.AssignInt32(&branch_return, compile_branch(tls, bp+16, bp+24, bp+32, errorcodeptr, bp+40,
			bp+44, bp+48, bp+52, bp+56,
			cb, func() uintptr {
				if lengthptr == uintptr(0) {
					return uintptr(0)
				}
				return bp + 72
			}())) == 0 {
			return 0
		}

		// If a branch can match an empty string, so can the whole group.

		if branch_return < 0 {
			okreturn = -1
		}

		// In the real compile phase, there is some post-processing to be done.

		if lengthptr == uintptr(0) {
			// If this is the first branch, the firstcu and reqcu values for the
			//     branch become the values for the regex.

			if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(last_branch))) != OP_ALT {
				firstcu = *(*Tuint32_t)(unsafe.Pointer(bp + 40 /* branchfirstcu */))
				firstcuflags = *(*Tuint32_t)(unsafe.Pointer(bp + 44 /* branchfirstcuflags */))
				reqcu = *(*Tuint32_t)(unsafe.Pointer(bp + 48 /* branchreqcu */))
				reqcuflags = *(*Tuint32_t)(unsafe.Pointer(bp + 52 /* branchreqcuflags */))
			} else {
				// If we previously had a firstcu, but it doesn't match the new branch,
				//       we have to abandon the firstcu for the regex, but if there was
				//       previously no reqcu, it takes on the value of the old firstcu.

				if firstcuflags != *(*Tuint32_t)(unsafe.Pointer(bp + 44)) || firstcu != *(*Tuint32_t)(unsafe.Pointer(bp + 40)) {
					if firstcuflags < DREQ_NONE {
						if reqcuflags >= DREQ_NONE {
							reqcu = firstcu
							reqcuflags = firstcuflags
						}
					}
					firstcuflags = DREQ_NONE
				}

				// If we (now or from before) have no firstcu, a firstcu from the
				//       branch becomes a reqcu if there isn't a branch reqcu.

				if firstcuflags >= DREQ_NONE && *(*Tuint32_t)(unsafe.Pointer(bp + 44)) < DREQ_NONE && *(*Tuint32_t)(unsafe.Pointer(bp + 52)) >= DREQ_NONE {
					*(*Tuint32_t)(unsafe.Pointer(bp + 48 /* branchreqcu */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 40 /* branchfirstcu */))
					*(*Tuint32_t)(unsafe.Pointer(bp + 52 /* branchreqcuflags */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 44 /* branchfirstcuflags */))
				}

				// Now ensure that the reqcus match

				if reqcuflags&libc.CplUint32(DREQ_VARY) != *(*Tuint32_t)(unsafe.Pointer(bp + 52))&libc.CplUint32(DREQ_VARY) || reqcu != *(*Tuint32_t)(unsafe.Pointer(bp + 48)) {
					reqcuflags = DREQ_NONE
				} else {
					reqcu = *(*Tuint32_t)(unsafe.Pointer(bp + 48 /* branchreqcu */))
					reqcuflags = reqcuflags | *(*Tuint32_t)(unsafe.Pointer(bp + 52)) // To "or" REQ_VARY if present
				}
			}
		}

		// Handle reaching the end of the expression, either ')' or end of pattern.
		//   In the real compile phase, go back through the alternative branches and
		//   reverse the chain of offsets, with the field in the BRA item now becoming an
		//   offset to the first alternative. If there are no alternatives, it points to
		//   the end of the group. The length in the terminating ket is always the length
		//   of the whole bracketed item. Return leaving the pointer at the terminating
		//   char.

		if *(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32))))&0xffff0000 != DMETA_ALT {
			if lengthptr == uintptr(0) {
				var branch_length Tsize_t = Tsize_t((int64(*(*uintptr)(unsafe.Pointer(bp + 24))) - int64(last_branch)) / 1)
				for __ccgo := true; __ccgo; __ccgo = branch_length > uint64(0) {
					var prev_length Tsize_t = Tsize_t(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(last_branch + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(last_branch + 2)))))
					*(*TPCRE2_UCHAR8)(unsafe.Pointer(last_branch + 1)) = TPCRE2_UCHAR8(branch_length >> 8)
					*(*TPCRE2_UCHAR8)(unsafe.Pointer(last_branch + 2)) = TPCRE2_UCHAR8(branch_length & uint64(255))
					branch_length = prev_length
					last_branch -= uintptr(branch_length)
				}
			}

			// Fill in the ket

			*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24 /* code */)))) = OP_KET
			*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24 /* code */)) + 1)) = TPCRE2_UCHAR8(int32((int64(*(*uintptr)(unsafe.Pointer(bp + 24)))-int64(start_bracket))/1) >> 8)
			*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24 /* code */)) + 2)) = TPCRE2_UCHAR8(int32((int64(*(*uintptr)(unsafe.Pointer(bp + 24)))-int64(start_bracket))/1) & 255)
			*(*uintptr)(unsafe.Pointer(bp + 24 /* code */)) += uintptr(1 + DLINK_SIZE)

			// If it was a capturing subpattern, remove the block from the chain.

			if capnumber > 0 {
				(*Tcompile_block_8)(unsafe.Pointer(cb)).Fopen_caps = (*Topen_capitem)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fopen_caps)).Fnext
			}

			// Set values to pass back

			*(*uintptr)(unsafe.Pointer(codeptr)) = *(*uintptr)(unsafe.Pointer(bp + 24 /* code */))
			*(*uintptr)(unsafe.Pointer(pptrptr)) = *(*uintptr)(unsafe.Pointer(bp + 32 /* pptr */))
			*(*Tuint32_t)(unsafe.Pointer(firstcuptr)) = firstcu
			*(*Tuint32_t)(unsafe.Pointer(firstcuflagsptr)) = firstcuflags
			*(*Tuint32_t)(unsafe.Pointer(reqcuptr)) = reqcu
			*(*Tuint32_t)(unsafe.Pointer(reqcuflagsptr)) = reqcuflags
			if lengthptr != uintptr(0) {
				if uint64(0x7fffffff-20)-*(*Tsize_t)(unsafe.Pointer(lengthptr)) < *(*Tsize_t)(unsafe.Pointer(bp + 72)) {
					*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR20
					return 0
				}
				*(*Tsize_t)(unsafe.Pointer(lengthptr)) += *(*Tsize_t)(unsafe.Pointer(bp + 72))
			}
			return okreturn
		}

		// Another branch follows. In the pre-compile phase, we can move the code
		//   pointer back to where it was for the start of the first branch. (That is,
		//   pretend that each branch is the only one.)
		//
		//   In the real compile phase, insert an ALT node. Its length field points back
		//   to the previous branch while the bracket remains open. At the end the chain
		//   is reversed. It's done like this so that the start of the bracket has a
		//   zero offset until it is closed, making it possible to detect recursion.

		if lengthptr != uintptr(0) {
			*(*uintptr)(unsafe.Pointer(bp + 24 /* code */)) = *(*uintptr)(unsafe.Pointer(codeptr)) + uintptr(1) + uintptr(DLINK_SIZE) + uintptr(skipunits)
			*(*Tsize_t)(unsafe.Pointer(bp + 72 /* length */)) += uint64(1 + DLINK_SIZE)
		} else {
			*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24 /* code */)))) = OP_ALT
			*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24 /* code */)) + 1)) = TPCRE2_UCHAR8(int32((int64(*(*uintptr)(unsafe.Pointer(bp + 24)))-int64(last_branch))/1) >> 8)
			*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24 /* code */)) + 2)) = TPCRE2_UCHAR8(int32((int64(*(*uintptr)(unsafe.Pointer(bp + 24)))-int64(last_branch))/1) & 255)
			(*Tbranch_chain_8)(unsafe.Pointer(bp + 56 /* &bc */)).Fcurrent_branch = libc.AssignUintptr(&last_branch, *(*uintptr)(unsafe.Pointer(bp + 24 /* code */)))
			*(*uintptr)(unsafe.Pointer(bp + 24 /* code */)) += uintptr(1 + DLINK_SIZE)
		}

		// Set the lookbehind length (if not in a lookbehind the value will be zero)
		//   and then advance past the vertical bar.

		lookbehindlength = *(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32)))) & 0x0000ffff
		*(*uintptr)(unsafe.Pointer(bp + 32 /* pptr */)) += 4
	}
	return int32(0)
	// Control never reaches here
}

// ************************************************
//
//          Check for anchored pattern            *
//

// Try to find out if this is an anchored regular expression. Consider each
// alternative branch. If they all start with OP_SOD or OP_CIRC, or with a bracket
// all of whose alternatives start with OP_SOD or OP_CIRC (recurse ad lib), then
// it's anchored. However, if this is a multiline pattern, then only OP_SOD will
// be found, because ^ generates OP_CIRCM in that mode.
//
// We can also consider a regex to be anchored if OP_SOM starts all its branches.
// This is the code for \G, which means "match at start of match position, taking
// into account the match offset".
//
// A branch is also implicitly anchored if it starts with .* and DOTALL is set,
// because that will try the rest of the pattern at all possible matching points,
// so there is no point trying again.... er ....
//
// .... except when the .* appears inside capturing parentheses, and there is a
// subsequent back reference to those parentheses. We haven't enough information
// to catch that case precisely.
//
// At first, the best we could do was to detect when .* was in capturing brackets
// and the highest back reference was greater than or equal to that level.
// However, by keeping a bitmap of the first 31 back references, we can catch some
// of the more common cases more precisely.
//
// ... A second exception is when the .* appears inside an atomic group, because
// this prevents the number of characters it matches from being adjusted.
//
// Arguments:
//   code           points to start of the compiled pattern
//   bracket_map    a bitmap of which brackets we are inside while testing; this
//                    handles up to substring 31; after that we just have to take
//                    the less precise approach
//   cb             points to the compile data block
//   atomcount      atomic group level
//   inassert       TRUE if in an assertion
//
// Returns:     TRUE or FALSE

func is_anchored(tls *libc.TLS, code TPCRE2_SPTR8, bracket_map Tuint32_t, cb uintptr, atomcount int32, inassert TBOOL) TBOOL { /* pcre2_compile.c:8394:1: */
	for __ccgo := true; __ccgo; __ccgo = int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code))) == OP_ALT {
		var scode TPCRE2_SPTR8 = first_significant_code(tls,
			code+uintptr(X_pcre2_OP_lengths_8[*(*TPCRE2_UCHAR8)(unsafe.Pointer(code))]), DFALSE)
		var op int32 = int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(scode)))

		// Non-capturing brackets

		if op == OP_BRA || op == OP_BRAPOS || op == OP_SBRA || op == OP_SBRAPOS {
			if !(is_anchored(tls, scode, bracket_map, cb, atomcount, inassert) != 0) {
				return DFALSE
			}
		} else if op == OP_CBRA || op == OP_CBRAPOS || op == OP_SCBRA || op == OP_SCBRAPOS {
			var n int32 = int32(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(scode + 3)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(scode + 4)))))
			var new_map Tuint32_t = bracket_map | func() uint32 {
				if n < 32 {
					return uint32(1) << n
				}
				return uint32(1)
			}()
			if !(is_anchored(tls, scode, new_map, cb, atomcount, inassert) != 0) {
				return DFALSE
			}
		} else if op == OP_ASSERT || op == OP_ASSERT_NA {
			if !(is_anchored(tls, scode, bracket_map, cb, atomcount, DTRUE) != 0) {
				return DFALSE
			}
		} else if op == OP_COND || op == OP_SCOND {
			if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(scode + uintptr(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(scode + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(scode + 2)))))))) != OP_ALT {
				return DFALSE
			}
			if !(is_anchored(tls, scode, bracket_map, cb, atomcount, inassert) != 0) {
				return DFALSE
			}
		} else if op == OP_ONCE {
			if !(is_anchored(tls, scode, bracket_map, cb, atomcount+1, inassert) != 0) {
				return DFALSE
			}
		} else if op == OP_TYPESTAR || op == OP_TYPEMINSTAR || op == OP_TYPEPOSSTAR {
			if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(scode + 1))) != OP_ALLANY || bracket_map&(*Tcompile_block_8)(unsafe.Pointer(cb)).Fbackref_map != Tuint32_t(0) || atomcount > 0 || (*Tcompile_block_8)(unsafe.Pointer(cb)).Fhad_pruneorskip != 0 || inassert != 0 || (*Tcompile_block_8)(unsafe.Pointer(cb)).Fexternal_options&DPCRE2_NO_DOTSTAR_ANCHOR != Tuint32_t(0) {
				return DFALSE
			}
		} else if op != OP_SOD && op != OP_SOM && op != OP_CIRC {
			return DFALSE
		}

		code += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))))
	} // Loop for each alternative
	return DTRUE
}

// ************************************************
//
//         Check for starting with ^ or .*        *
//

// This is called to find out if every branch starts with ^ or .* so that
// "first char" processing can be done to speed things up in multiline
// matching and for non-DOTALL patterns that start with .* (which must start at
// the beginning or after \n). As in the case of is_anchored() (see above), we
// have to take account of back references to capturing brackets that contain .*
// because in that case we can't make the assumption. Also, the appearance of .*
// inside atomic brackets or in an assertion, or in a pattern that contains *PRUNE
// or *SKIP does not count, because once again the assumption no longer holds.
//
// Arguments:
//   code           points to start of the compiled pattern or a group
//   bracket_map    a bitmap of which brackets we are inside while testing; this
//                    handles up to substring 31; after that we just have to take
//                    the less precise approach
//   cb             points to the compile data
//   atomcount      atomic group level
//   inassert       TRUE if in an assertion
//
// Returns:         TRUE or FALSE

func is_startline(tls *libc.TLS, code TPCRE2_SPTR8, bracket_map uint32, cb uintptr, atomcount int32, inassert TBOOL) TBOOL { /* pcre2_compile.c:8499:1: */
	for __ccgo := true; __ccgo; __ccgo = int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code))) == OP_ALT {
		var scode TPCRE2_SPTR8 = first_significant_code(tls,
			code+uintptr(X_pcre2_OP_lengths_8[*(*TPCRE2_UCHAR8)(unsafe.Pointer(code))]), DFALSE)
		var op int32 = int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(scode)))

		// If we are at the start of a conditional assertion group, *both* the
		//    conditional assertion *and* what follows the condition must satisfy the test
		//    for start of line. Other kinds of condition fail. Note that there may be an
		//    auto-callout at the start of a condition.

		if op == OP_COND {
			scode += TPCRE2_SPTR8(1 + DLINK_SIZE)

			if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(scode))) == OP_CALLOUT {
				scode += TPCRE2_SPTR8(X_pcre2_OP_lengths_8[OP_CALLOUT])
			} else if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(scode))) == OP_CALLOUT_STR {
				scode += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(scode + 5)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(scode + 6)))))
			}

			switch int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(scode))) {
			case OP_CREF:
				fallthrough
			case OP_DNCREF:
				fallthrough
			case OP_RREF:
				fallthrough
			case OP_DNRREF:
				fallthrough
			case OP_FAIL:
				fallthrough
			case OP_FALSE:
				fallthrough
			case OP_TRUE:
				return DFALSE
				fallthrough

			default: // Assertion
				if !(is_startline(tls, scode, bracket_map, cb, atomcount, DTRUE) != 0) {
					return DFALSE
				}
				for __ccgo1 := true; __ccgo1; __ccgo1 = int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(scode))) == OP_ALT {
					scode += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(scode + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(scode + 2)))))
				}
				scode += TPCRE2_SPTR8(1 + DLINK_SIZE)
				break
			}
			scode = first_significant_code(tls, scode, DFALSE)
			op = int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(scode)))
		}

		// Non-capturing brackets

		if op == OP_BRA || op == OP_BRAPOS || op == OP_SBRA || op == OP_SBRAPOS {
			if !(is_startline(tls, scode, bracket_map, cb, atomcount, inassert) != 0) {
				return DFALSE
			}
		} else if op == OP_CBRA || op == OP_CBRAPOS || op == OP_SCBRA || op == OP_SCBRAPOS {
			var n int32 = int32(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(scode + 3)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(scode + 4)))))
			var new_map int32 = int32(bracket_map | func() uint32 {
				if n < 32 {
					return uint32(1) << n
				}
				return uint32(1)
			}())
			if !(is_startline(tls, scode, uint32(new_map), cb, atomcount, inassert) != 0) {
				return DFALSE
			}
		} else if op == OP_ASSERT || op == OP_ASSERT_NA {
			if !(is_startline(tls, scode, bracket_map, cb, atomcount, DTRUE) != 0) {
				return DFALSE
			}
		} else if op == OP_ONCE {
			if !(is_startline(tls, scode, bracket_map, cb, atomcount+1, inassert) != 0) {
				return DFALSE
			}
		} else if op == OP_TYPESTAR || op == OP_TYPEMINSTAR || op == OP_TYPEPOSSTAR {
			if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(scode + 1))) != OP_ANY || bracket_map&(*Tcompile_block_8)(unsafe.Pointer(cb)).Fbackref_map != uint32(0) || atomcount > 0 || (*Tcompile_block_8)(unsafe.Pointer(cb)).Fhad_pruneorskip != 0 || inassert != 0 || (*Tcompile_block_8)(unsafe.Pointer(cb)).Fexternal_options&DPCRE2_NO_DOTSTAR_ANCHOR != Tuint32_t(0) {
				return DFALSE
			}
		} else if op != OP_CIRC && op != OP_CIRCM {
			return DFALSE
		}

		// Move on to the next alternative

		code += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))))
	} // Loop for each alternative
	return DTRUE
}

// ************************************************
//
//   Scan compiled regex for recursion reference  *
//

// This function scans through a compiled pattern until it finds an instance of
// OP_RECURSE.
//
// Arguments:
//   code        points to start of expression
//   utf         TRUE in UTF mode
//
// Returns:      pointer to the opcode for OP_RECURSE, or NULL if not found

func find_recurse(tls *libc.TLS, code TPCRE2_SPTR8, utf TBOOL) TPCRE2_SPTR8 { /* pcre2_compile.c:8621:1: */
	for {
		var c TPCRE2_UCHAR8 = *(*TPCRE2_UCHAR8)(unsafe.Pointer(code))
		if int32(c) == OP_END {
			return uintptr(0)
		}
		if int32(c) == OP_RECURSE {
			return code
		}

		// XCLASS is used for classes that cannot be represented just by a bit map.
		//   This includes negated single high-valued characters. CALLOUT_STR is used for
		//   callouts with string arguments. In both cases the length in the table is
		//   zero; the actual length is stored in the compiled code.

		if int32(c) == OP_XCLASS {
			code += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))))
		} else if int32(c) == OP_CALLOUT_STR {
			code += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 5)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 6)))))
		} else {
			switch int32(c) {
			case OP_TYPESTAR:
				fallthrough
			case OP_TYPEMINSTAR:
				fallthrough
			case OP_TYPEPLUS:
				fallthrough
			case OP_TYPEMINPLUS:
				fallthrough
			case OP_TYPEQUERY:
				fallthrough
			case OP_TYPEMINQUERY:
				fallthrough
			case OP_TYPEPOSSTAR:
				fallthrough
			case OP_TYPEPOSPLUS:
				fallthrough
			case OP_TYPEPOSQUERY:
				if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1))) == OP_PROP || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1))) == OP_NOTPROP {
					code += uintptr(2)
				}
				break
				fallthrough

			case OP_TYPEPOSUPTO:
				fallthrough
			case OP_TYPEUPTO:
				fallthrough
			case OP_TYPEMINUPTO:
				fallthrough
			case OP_TYPEEXACT:
				if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3))) == OP_PROP || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3))) == OP_NOTPROP {
					code += uintptr(2)
				}
				break
				fallthrough

			case OP_MARK:
				fallthrough
			case OP_COMMIT_ARG:
				fallthrough
			case OP_PRUNE_ARG:
				fallthrough
			case OP_SKIP_ARG:
				fallthrough
			case OP_THEN_ARG:
				code += TPCRE2_SPTR8(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))
				break
			}

			// Add in the fixed length from the table

			code += TPCRE2_SPTR8(X_pcre2_OP_lengths_8[c])

			// In UTF-8 and UTF-16 modes, opcodes that are followed by a character may
			//     be followed by a multi-unit character. The length in the table is a
			//     minimum, so we have to arrange to skip the extra units.

			if utf != 0 {
				switch int32(c) {
				case OP_CHAR:
					fallthrough
				case OP_CHARI:
					fallthrough
				case OP_NOT:
					fallthrough
				case OP_NOTI:
					fallthrough
				case OP_EXACT:
					fallthrough
				case OP_EXACTI:
					fallthrough
				case OP_NOTEXACT:
					fallthrough
				case OP_NOTEXACTI:
					fallthrough
				case OP_UPTO:
					fallthrough
				case OP_UPTOI:
					fallthrough
				case OP_NOTUPTO:
					fallthrough
				case OP_NOTUPTOI:
					fallthrough
				case OP_MINUPTO:
					fallthrough
				case OP_MINUPTOI:
					fallthrough
				case OP_NOTMINUPTO:
					fallthrough
				case OP_NOTMINUPTOI:
					fallthrough
				case OP_POSUPTO:
					fallthrough
				case OP_POSUPTOI:
					fallthrough
				case OP_NOTPOSUPTO:
					fallthrough
				case OP_NOTPOSUPTOI:
					fallthrough
				case OP_STAR:
					fallthrough
				case OP_STARI:
					fallthrough
				case OP_NOTSTAR:
					fallthrough
				case OP_NOTSTARI:
					fallthrough
				case OP_MINSTAR:
					fallthrough
				case OP_MINSTARI:
					fallthrough
				case OP_NOTMINSTAR:
					fallthrough
				case OP_NOTMINSTARI:
					fallthrough
				case OP_POSSTAR:
					fallthrough
				case OP_POSSTARI:
					fallthrough
				case OP_NOTPOSSTAR:
					fallthrough
				case OP_NOTPOSSTARI:
					fallthrough
				case OP_PLUS:
					fallthrough
				case OP_PLUSI:
					fallthrough
				case OP_NOTPLUS:
					fallthrough
				case OP_NOTPLUSI:
					fallthrough
				case OP_MINPLUS:
					fallthrough
				case OP_MINPLUSI:
					fallthrough
				case OP_NOTMINPLUS:
					fallthrough
				case OP_NOTMINPLUSI:
					fallthrough
				case OP_POSPLUS:
					fallthrough
				case OP_POSPLUSI:
					fallthrough
				case OP_NOTPOSPLUS:
					fallthrough
				case OP_NOTPOSPLUSI:
					fallthrough
				case OP_QUERY:
					fallthrough
				case OP_QUERYI:
					fallthrough
				case OP_NOTQUERY:
					fallthrough
				case OP_NOTQUERYI:
					fallthrough
				case OP_MINQUERY:
					fallthrough
				case OP_MINQUERYI:
					fallthrough
				case OP_NOTMINQUERY:
					fallthrough
				case OP_NOTMINQUERYI:
					fallthrough
				case OP_POSQUERY:
					fallthrough
				case OP_POSQUERYI:
					fallthrough
				case OP_NOTPOSQUERY:
					fallthrough
				case OP_NOTPOSQUERYI:
					if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + libc.UintptrFromInt32(-1)))) >= 0xc0 {
						code += TPCRE2_SPTR8(X_pcre2_utf8_table4[uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + libc.UintptrFromInt32(-1))))&0x3f])
					}
					break
				}
			}
		}
	}
	return TPCRE2_SPTR8(0)
}

// ************************************************
//
//    Check for asserted fixed first code unit    *
//

// During compilation, the "first code unit" settings from forward assertions
// are discarded, because they can cause conflicts with actual literals that
// follow. However, if we end up without a first code unit setting for an
// unanchored pattern, it is worth scanning the regex to see if there is an
// initial asserted first code unit. If all branches start with the same asserted
// code unit, or with a non-conditional bracket all of whose alternatives start
// with the same asserted code unit (recurse ad lib), then we return that code
// unit, with the flags set to zero or REQ_CASELESS; otherwise return zero with
// REQ_NONE in the flags.
//
// Arguments:
//   code       points to start of compiled pattern
//   flags      points to the first code unit flags
//   inassert   non-zero if in an assertion
//
// Returns:     the fixed first code unit, or 0 with REQ_NONE in flags

func find_firstassertedcu(tls *libc.TLS, code TPCRE2_SPTR8, flags uintptr, inassert Tuint32_t) Tuint32_t { /* pcre2_compile.c:8777:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var c Tuint32_t = Tuint32_t(0)
	var cflags Tuint32_t = DREQ_NONE

	*(*Tuint32_t)(unsafe.Pointer(flags)) = DREQ_NONE
	for __ccgo := true; __ccgo; __ccgo = int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code))) == OP_ALT {
		var d Tuint32_t
		// var dflags Tuint32_t at bp, 4

		var xl int32
		if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code))) == OP_CBRA || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code))) == OP_SCBRA || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code))) == OP_CBRAPOS || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code))) == OP_SCBRAPOS {
			xl = DIMM2_SIZE
		} else {
			xl = 0
		}
		var scode TPCRE2_SPTR8 = first_significant_code(tls, code+uintptr(1)+uintptr(DLINK_SIZE)+uintptr(xl), DTRUE)
		var op TPCRE2_UCHAR8 = *(*TPCRE2_UCHAR8)(unsafe.Pointer(scode))

		switch int32(op) {
		default:
			return Tuint32_t(0)

		case OP_BRA:
			fallthrough
		case OP_BRAPOS:
			fallthrough
		case OP_CBRA:
			fallthrough
		case OP_SCBRA:
			fallthrough
		case OP_CBRAPOS:
			fallthrough
		case OP_SCBRAPOS:
			fallthrough
		case OP_ASSERT:
			fallthrough
		case OP_ASSERT_NA:
			fallthrough
		case OP_ONCE:
			fallthrough
		case OP_SCRIPT_RUN:
			d = find_firstassertedcu(tls, scode, bp, inassert+func() uint32 {
				if int32(op) == OP_ASSERT || int32(op) == OP_ASSERT_NA {
					return uint32(1)
				}
				return uint32(0)
			}())
			if *(*Tuint32_t)(unsafe.Pointer(bp)) >= DREQ_NONE {
				return Tuint32_t(0)
			}
			if cflags >= DREQ_NONE {
				c = d
				cflags = *(*Tuint32_t)(unsafe.Pointer(bp /* dflags */))
			} else if c != d || cflags != *(*Tuint32_t)(unsafe.Pointer(bp)) {
				return Tuint32_t(0)
			}
			break

		case OP_EXACT:
			scode += TPCRE2_SPTR8(DIMM2_SIZE)
			fallthrough
		// Fall through

		case OP_CHAR:
			fallthrough
		case OP_PLUS:
			fallthrough
		case OP_MINPLUS:
			fallthrough
		case OP_POSPLUS:
			if inassert == Tuint32_t(0) {
				return Tuint32_t(0)
			}
			if cflags >= DREQ_NONE {
				c = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(scode + 1)))
				cflags = Tuint32_t(0)
			} else if c != Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(scode + 1))) {
				return Tuint32_t(0)
			}
			break

		case OP_EXACTI:
			scode += TPCRE2_SPTR8(DIMM2_SIZE)
			fallthrough
		// Fall through

		case OP_CHARI:
			fallthrough
		case OP_PLUSI:
			fallthrough
		case OP_MINPLUSI:
			fallthrough
		case OP_POSPLUSI:
			if inassert == Tuint32_t(0) {
				return Tuint32_t(0)
			}

			// If the character is more than one code unit long, we cannot set its
			//      first code unit when matching caselessly. Later scanning may pick up
			//      multiple code units.

			if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(scode + 1))) >= 0x80 {
				return Tuint32_t(0)
			}

			if cflags >= DREQ_NONE {
				c = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(scode + 1)))
				cflags = DREQ_CASELESS
			} else if c != Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(scode + 1))) {
				return Tuint32_t(0)
			}
			break
		}

		code += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))))
	}

	*(*Tuint32_t)(unsafe.Pointer(flags)) = cflags
	return c
}

// ************************************************
//
//     Add an entry to the name/number table      *
//

// This function is called between compiling passes to add an entry to the
// name/number table, maintaining alphabetical order. Checking for permitted
// and forbidden duplicates has already been done.
//
// Arguments:
//   cb           the compile data block
//   name         the name to add
//   length       the length of the name
//   groupno      the group number
//   tablecount   the count of names in the table so far
//
// Returns:       nothing

func add_name_to_table(tls *libc.TLS, cb uintptr, name TPCRE2_SPTR8, length int32, groupno uint32, tablecount Tuint32_t) { /* pcre2_compile.c:8882:1: */
	var i Tuint32_t
	var slot uintptr = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fname_table

	for i = Tuint32_t(0); i < tablecount; i++ {
		var crc int32 = libc.Xmemcmp(tls, name, slot+uintptr(DIMM2_SIZE), uint64(length*(DPCRE2_CODE_UNIT_WIDTH/8)))
		if crc == 0 && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(slot + uintptr(DIMM2_SIZE+length)))) != 0 {
			crc = -1
		} // Current name is a substring

		// Make space in the table and break the loop for an earlier name. For a
		//   duplicate or later name, carry on. We do this for duplicates so that in the
		//   simple case (when ?(| is not used) they are in order of their numbers. In all
		//   cases they are in the order in which they appear in the pattern.

		if crc < 0 {
			libc.Xmemmove(tls, slot+uintptr((*Tcompile_block_8)(unsafe.Pointer(cb)).Fname_entry_size), slot,
				uint64((tablecount-i)*Tuint32_t((*Tcompile_block_8)(unsafe.Pointer(cb)).Fname_entry_size)*Tuint32_t(DPCRE2_CODE_UNIT_WIDTH/8)))
			break
		}

		// Continue the loop for a later or duplicate name

		slot += uintptr((*Tcompile_block_8)(unsafe.Pointer(cb)).Fname_entry_size)
	}

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(slot)) = TPCRE2_UCHAR8(groupno >> 8)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(slot + 1)) = TPCRE2_UCHAR8(groupno & uint32(255))
	libc.Xmemcpy(tls, slot+uintptr(DIMM2_SIZE), name, uint64(length*(DPCRE2_CODE_UNIT_WIDTH/8)))

	// Add a terminating zero and fill the rest of the slot with zeroes so that
	// the memory is all initialized. Otherwise valgrind moans about uninitialized
	// memory when saving serialized compiled patterns.

	libc.Xmemset(tls, slot+uintptr(DIMM2_SIZE)+uintptr(length), 0,
		uint64((int32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fname_entry_size)-length-DIMM2_SIZE)*(DPCRE2_CODE_UNIT_WIDTH/8)))
}

// ************************************************
//
//             Skip in parsed pattern             *
//

// This function is called to skip parts of the parsed pattern when finding the
// length of a lookbehind branch. It is called after (*ACCEPT) and (*FAIL) to find
// the end of the branch, it is called to skip over an internal lookaround or
// (DEFINE) group, and it is also called to skip to the end of a class, during
// which it will never encounter nested groups (but there's no need to have
// special code for that).
//
// When called to find the end of a branch or group, pptr must point to the first
// meta code inside the branch, not the branch-starting code. In other cases it
// can point to the item that causes the function to be called.
//
// Arguments:
//   pptr       current pointer to skip from
//   skiptype   PSKIP_CLASS when skipping to end of class
//              PSKIP_ALT when META_ALT ends the skip
//              PSKIP_KET when only META_KET ends the skip
//
// Returns:     new value of pptr
//              NULL if META_END is reached - should never occur
//                or for an unknown meta value - likewise

func parsed_skip(tls *libc.TLS, pptr uintptr, skiptype Tuint32_t) uintptr { /* pcre2_compile.c:8950:17: */
	var nestlevel Tuint32_t = Tuint32_t(0)

	for ; ; pptr += 4 {
		var meta Tuint32_t = *(*Tuint32_t)(unsafe.Pointer(pptr)) & 0xffff0000

		switch meta {
		default: // Just skip over most items
			if meta < DMETA_END {
				continue
			} // Literal
			break

		// This should never occur.

		case DMETA_END:
			return uintptr(0)

		// The data for these items is variable in length.

		case DMETA_BACKREF: // Offset is present only if group >= 10
			if *(*Tuint32_t)(unsafe.Pointer(pptr))&0x0000ffff >= Tuint32_t(10) {
				pptr += 4 * uintptr(DSIZEOFFSET)
			}
			break

		case DMETA_ESCAPE: // A few escapes are followed by data items.
			switch *(*Tuint32_t)(unsafe.Pointer(pptr)) & 0x0000ffff {
			case ESC_P:
				fallthrough
			case ESC_p:
				pptr += 4 * uintptr(1)
				break

			case ESC_g:
				fallthrough
			case ESC_k:
				pptr += 4 * uintptr(1+DSIZEOFFSET)
				break
			}
			break

		case DMETA_MARK:
			fallthrough // Add the length of the name.
		case DMETA_COMMIT_ARG:
			fallthrough
		case DMETA_PRUNE_ARG:
			fallthrough
		case DMETA_SKIP_ARG:
			fallthrough
		case DMETA_THEN_ARG:
			pptr += 4 * uintptr(*(*Tuint32_t)(unsafe.Pointer(pptr + 1*4)))
			break

		// These are the "active" items in this loop.

		case DMETA_CLASS_END:
			if skiptype == PSKIP_CLASS {
				return pptr
			}
			break

		case DMETA_ATOMIC:
			fallthrough
		case DMETA_CAPTURE:
			fallthrough
		case DMETA_COND_ASSERT:
			fallthrough
		case DMETA_COND_DEFINE:
			fallthrough
		case DMETA_COND_NAME:
			fallthrough
		case DMETA_COND_NUMBER:
			fallthrough
		case DMETA_COND_RNAME:
			fallthrough
		case DMETA_COND_RNUMBER:
			fallthrough
		case DMETA_COND_VERSION:
			fallthrough
		case DMETA_LOOKAHEAD:
			fallthrough
		case DMETA_LOOKAHEADNOT:
			fallthrough
		case DMETA_LOOKAHEAD_NA:
			fallthrough
		case DMETA_LOOKBEHIND:
			fallthrough
		case DMETA_LOOKBEHINDNOT:
			fallthrough
		case DMETA_LOOKBEHIND_NA:
			fallthrough
		case DMETA_NOCAPTURE:
			fallthrough
		case DMETA_SCRIPT_RUN:
			nestlevel++
			break

		case DMETA_ALT:
			if nestlevel == Tuint32_t(0) && skiptype == PSKIP_ALT {
				return pptr
			}
			break

		case DMETA_KET:
			if nestlevel == Tuint32_t(0) {
				return pptr
			}
			nestlevel--
			break
		}

		// The extra data item length for each meta is in a table.

		meta = meta >> 16 & Tuint32_t(0x7fff)
		if uint64(meta) >= uint64(unsafe.Sizeof(meta_extra_lengths)) {
			return uintptr(0)
		}
		pptr += 4 * uintptr(meta_extra_lengths[meta])
	}
	// Control never reaches here
	return pptr
}

// ************************************************
//
//       Find length of a parsed group            *
//

// This is called for nested groups within a branch of a lookbehind whose
// length is being computed. If all the branches in the nested group have the same
// length, that is OK. On entry, the pointer must be at the first element after
// the group initializing code. On exit it points to OP_KET. Caching is used to
// improve processing speed when the same capturing group occurs many times.
//
// Arguments:
//   pptrptr     pointer to pointer in the parsed pattern
//   isinline    FALSE if a reference or recursion; TRUE for inline group
//   errcodeptr  pointer to the errorcode
//   lcptr       pointer to the loop counter
//   group       number of captured group or -1 for a non-capturing group
//   recurses    chain of recurse_check to catch mutual recursion
//   cb          pointer to the compile data
//
// Returns:      the group length or a negative number

func get_grouplength(tls *libc.TLS, pptrptr uintptr, isinline TBOOL, errcodeptr uintptr, lcptr uintptr, group int32, recurses uintptr, cb uintptr) int32 { /* pcre2_compile.c:9070:1: */
	var branchlength int32
	var grouplength int32
	var groupinfo Tuint32_t
	grouplength = -1

	// The cache can be used only if there is no possibility of there being two
	// groups with the same number. We do not need to set the end pointer for a group
	// that is being processed as a back reference or recursion, but we must do so for
	// an inline group.

	if !(group > 0 && (*Tcompile_block_8)(unsafe.Pointer(cb)).Fexternal_flags&Tuint32_t(DPCRE2_DUPCAPUSED) == Tuint32_t(0)) {
		goto __1
	}

	groupinfo = *(*Tuint32_t)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fgroupinfo + uintptr(group)*4))
	if !(groupinfo&DGI_NOT_FIXED_LENGTH != Tuint32_t(0)) {
		goto __2
	}
	return -1
__2:
	;
	if !(groupinfo&DGI_SET_FIXED_LENGTH != Tuint32_t(0)) {
		goto __3
	}

	if !(isinline != 0) {
		goto __4
	}
	*(*uintptr)(unsafe.Pointer(pptrptr)) = parsed_skip(tls, *(*uintptr)(unsafe.Pointer(pptrptr)), PSKIP_KET)
__4:
	;
	return int32(groupinfo & DGI_FIXED_LENGTH_MASK)
__3:
	;
__1:
	;

	// Scan the group. In this case we find the end pointer of necessity.

__5:

	branchlength = get_branchlength(tls, pptrptr, errcodeptr, lcptr, recurses, cb)
	if !(branchlength < 0) {
		goto __8
	}
	goto ISNOTFIXED
__8:
	;
	if !(grouplength == -1) {
		goto __9
	}
	grouplength = branchlength
	goto __10
__9:
	if !(grouplength != branchlength) {
		goto __11
	}
	goto ISNOTFIXED
__11:
	;
__10:
	;
	if !(*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(pptrptr)))) == DMETA_KET) {
		goto __12
	}
	goto __7
__12:
	;
	*(*uintptr)(unsafe.Pointer(pptrptr)) += uintptr(1) * 4 // Skip META_ALT
	goto __6
__6:
	goto __5
	goto __7
__7:
	;

	if !(group > 0) {
		goto __13
	}
	*(*Tuint32_t)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fgroupinfo + uintptr(group)*4)) |= DGI_SET_FIXED_LENGTH | uint32(grouplength)
__13:
	;
	return grouplength

ISNOTFIXED:
	if !(group > 0) {
		goto __14
	}
	*(*Tuint32_t)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fgroupinfo + uintptr(group)*4)) |= DGI_NOT_FIXED_LENGTH
__14:
	;
	return -1
}

// ************************************************
//
//        Find length of a parsed branch          *
//

// Return a fixed length for a branch in a lookbehind, giving an error if the
// length is not fixed. On entry, *pptrptr points to the first element inside the
// branch. On exit it is set to point to the ALT or KET.
//
// Arguments:
//   pptrptr     pointer to pointer in the parsed pattern
//   errcodeptr  pointer to error code
//   lcptr       pointer to loop counter
//   recurses    chain of recurse_check to catch mutual recursion
//   cb          pointer to compile block
//
// Returns:      the length, or a negative value on error

func get_branchlength(tls *libc.TLS, pptrptr uintptr, errcodeptr uintptr, lcptr uintptr, recurses uintptr, cb uintptr) int32 { /* pcre2_compile.c:9134:1: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var branchlength int32
	var grouplength int32
	var lastitemlength Tuint32_t
	// var pptr uintptr at bp, 8

	var offset Tsize_t
	// var this_recurse Tparsed_recurse_check at bp+16, 16

	var i int32
	var name TPCRE2_SPTR8
	var is_dupname TBOOL
	var ng uintptr
	var meta_code Tuint32_t
	var length Tuint32_t
	var r uintptr
	// var gptr uintptr at bp+8, 8

	var gptrend uintptr
	var escape Tuint32_t
	var group Tuint32_t
	var itemlength Tuint32_t
	branchlength = 0
	lastitemlength = Tuint32_t(0)
	*(*uintptr)(unsafe.Pointer(bp /* pptr */)) = *(*uintptr)(unsafe.Pointer(pptrptr))

	// A large and/or complex regex can take too long to process. This can happen
	// more often when (?| groups are present in the pattern because their length
	// cannot be cached.

	if !(libc.PostIncInt32(&*(*int32)(unsafe.Pointer(lcptr)), 1) > 2000) {
		goto __1
	}

	*(*int32)(unsafe.Pointer(errcodeptr)) = ERR35 // Lookbehind is too complicated
	return -1
__1:
	;

	// Scan the branch, accumulating the length.

__2:
	;
	group = Tuint32_t(0)
	itemlength = Tuint32_t(0)

	if !(*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) < DMETA_END) {
		goto __5
	}

	itemlength = Tuint32_t(1)
	goto __6
__5:
	switch *(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) & 0xffff0000 {
	case DMETA_KET:
		goto __8
	case DMETA_ALT:
		goto __9

	// (*ACCEPT) and (*FAIL) terminate the branch, but we must skip to the
	//     actual termination.

	case DMETA_ACCEPT:
		goto __10
	case DMETA_FAIL:
		goto __11

	case DMETA_MARK:
		goto __12
	case DMETA_COMMIT_ARG:
		goto __13
	case DMETA_PRUNE_ARG:
		goto __14
	case DMETA_SKIP_ARG:
		goto __15
	case DMETA_THEN_ARG:
		goto __16

	case DMETA_CIRCUMFLEX:
		goto __17
	case DMETA_COMMIT:
		goto __18
	case DMETA_DOLLAR:
		goto __19
	case DMETA_PRUNE:
		goto __20
	case DMETA_SKIP:
		goto __21
	case DMETA_THEN:
		goto __22

	case DMETA_OPTIONS:
		goto __23

	case DMETA_BIGVALUE:
		goto __24

	case DMETA_CLASS:
		goto __25
	case DMETA_CLASS_NOT:
		goto __26

	case DMETA_CLASS_EMPTY_NOT:
		goto __27
	case DMETA_DOT:
		goto __28

	case DMETA_CALLOUT_NUMBER:
		goto __29

	case DMETA_CALLOUT_STRING:
		goto __30

	// Only some escapes consume a character. Of those, \R and \X are never
	//     allowed because they might match more than character. \C is allowed only in
	//     32-bit and non-UTF 8/16-bit modes.

	case DMETA_ESCAPE:
		goto __31

	// Lookaheads do not contribute to the length of this branch, but they may
	//     contain lookbehinds within them whose lengths need to be set.

	case DMETA_LOOKAHEAD:
		goto __32
	case DMETA_LOOKAHEADNOT:
		goto __33
	case DMETA_LOOKAHEAD_NA:
		goto __34

	// A nested lookbehind does not contribute any length to this lookbehind,
	//     but must itself be checked and have its lengths set.

	case DMETA_LOOKBEHIND:
		goto __35
	case DMETA_LOOKBEHINDNOT:
		goto __36
	case DMETA_LOOKBEHIND_NA:
		goto __37

	// Back references and recursions are handled by very similar code. At this
	//     stage, the names generated in the parsing pass are available, but the main
	//     name table has not yet been created. So for the named varieties, scan the
	//     list of names in order to get the number of the first one in the pattern,
	//     and whether or not this name is duplicated.

	case DMETA_BACKREF_BYNAME:
		goto __38
	// Fall through

	case DMETA_RECURSE_BYNAME:
		goto __39 // Duplicate name or number

	// The offset values for back references < 10 are in a separate vector
	//     because otherwise they would use more than two parsed pattern elements on
	//     64-bit systems.

	case DMETA_BACKREF:
		goto __40

	// Fall through
	// For groups >= 10 - picking up group twice does no harm.

	// A true recursion implies not fixed length, but a subroutine call may
	//     be OK. Back reference "recursions" are also failed.

	case DMETA_RECURSE:
		goto __41

	// A (DEFINE) group is never obeyed inline and so it does not contribute to
	//     the length of this branch. Skip from the following item to the next
	//     unpaired ket.

	case DMETA_COND_DEFINE:
		goto __42

	// Check other nested groups - advance past the initial data for each type
	//     and then seek a fixed length with get_grouplength().

	case DMETA_COND_NAME:
		goto __43
	case DMETA_COND_NUMBER:
		goto __44
	case DMETA_COND_RNAME:
		goto __45
	case DMETA_COND_RNUMBER:
		goto __46

	case DMETA_COND_ASSERT:
		goto __47

	case DMETA_COND_VERSION:
		goto __48

	case DMETA_CAPTURE:
		goto __49
	// Fall through

	case DMETA_ATOMIC:
		goto __50
	case DMETA_NOCAPTURE:
		goto __51
	case DMETA_SCRIPT_RUN:
		goto __52

	// Exact repetition is OK; variable repetition is not. A repetition of zero
	//     must subtract the length that has already been added.

	case DMETA_MINMAX:
		goto __53
	case DMETA_MINMAX_PLUS:
		goto __54
	case DMETA_MINMAX_QUERY:
		goto __55
	// Fall through

	// Any other item means this branch does not have a fixed length.

	default:
		goto __56
	}
	goto __7

__8:
__9:
	goto EXIT

	// (*ACCEPT) and (*FAIL) terminate the branch, but we must skip to the
	//     actual termination.

__10:
__11:
	*(*uintptr)(unsafe.Pointer(bp /* pptr */)) = parsed_skip(tls, *(*uintptr)(unsafe.Pointer(bp /* pptr */)), PSKIP_ALT)
	if !(*(*uintptr)(unsafe.Pointer(bp)) == uintptr(0)) {
		goto __57
	}
	goto PARSED_SKIP_FAILED
__57:
	;
	goto EXIT

__12:
__13:
__14:
__15:
__16:
	*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 1*4))+Tuint32_t(1))
	goto __7

__17:
__18:
__19:
__20:
__21:
__22:
	goto __7

__23:
	*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(1)
	goto __7

__24:
	itemlength = Tuint32_t(1)
	*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(1)
	goto __7

__25:
__26:
	itemlength = Tuint32_t(1)
	*(*uintptr)(unsafe.Pointer(bp /* pptr */)) = parsed_skip(tls, *(*uintptr)(unsafe.Pointer(bp /* pptr */)), PSKIP_CLASS)
	if !(*(*uintptr)(unsafe.Pointer(bp)) == uintptr(0)) {
		goto __58
	}
	goto PARSED_SKIP_FAILED
__58:
	;
	goto __7

__27:
__28:
	itemlength = Tuint32_t(1)
	goto __7

__29:
	*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(3)
	goto __7

__30:
	*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(3+DSIZEOFFSET)
	goto __7

	// Only some escapes consume a character. Of those, \R and \X are never
	//     allowed because they might match more than character. \C is allowed only in
	//     32-bit and non-UTF 8/16-bit modes.

__31:
	escape = *(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) & 0x0000ffff
	if !(escape == ESC_R || escape == ESC_X) {
		goto __59
	}
	return -1
__59:
	;
	if !(escape > ESC_b && escape < ESC_Z) {
		goto __60
	}

	if !((*Tcompile_block_8)(unsafe.Pointer(cb)).Fexternal_options&DPCRE2_UTF != Tuint32_t(0) && escape == ESC_C) {
		goto __61
	}

	*(*int32)(unsafe.Pointer(errcodeptr)) = ERR36
	return -1
__61:
	;
	itemlength = Tuint32_t(1)
	if !(escape == ESC_p || escape == ESC_P) {
		goto __62
	}
	*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4
__62:
	; // Skip prop data
__60:
	;
	goto __7

	// Lookaheads do not contribute to the length of this branch, but they may
	//     contain lookbehinds within them whose lengths need to be set.

__32:
__33:
__34:
	*(*int32)(unsafe.Pointer(errcodeptr)) = check_lookbehinds(tls, *(*uintptr)(unsafe.Pointer(bp))+uintptr(1)*4, bp, recurses, cb, lcptr)
	if !(*(*int32)(unsafe.Pointer(errcodeptr)) != 0) {
		goto __63
	}
	return -1
__63:
	;

	// Ignore any qualifiers that follow a lookahead assertion.

	switch *(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* pptr */)) + 1*4)) {
	case DMETA_ASTERISK:
		goto __65
	case DMETA_ASTERISK_PLUS:
		goto __66
	case DMETA_ASTERISK_QUERY:
		goto __67
	case DMETA_PLUS:
		goto __68
	case DMETA_PLUS_PLUS:
		goto __69
	case DMETA_PLUS_QUERY:
		goto __70
	case DMETA_QUERY:
		goto __71
	case DMETA_QUERY_PLUS:
		goto __72
	case DMETA_QUERY_QUERY:
		goto __73

	case DMETA_MINMAX:
		goto __74
	case DMETA_MINMAX_PLUS:
		goto __75
	case DMETA_MINMAX_QUERY:
		goto __76

	default:
		goto __77
	}
	goto __64

__65:
__66:
__67:
__68:
__69:
__70:
__71:
__72:
__73:
	*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4
	goto __64

__74:
__75:
__76:
	*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(3)
	goto __64

__77:
	goto __64
__64:
	;
	goto __7

	// A nested lookbehind does not contribute any length to this lookbehind,
	//     but must itself be checked and have its lengths set.

__35:
__36:
__37:
	if !!(set_lookbehind_lengths(tls, bp, errcodeptr, lcptr, recurses, cb) != 0) {
		goto __78
	}
	return -1
__78:
	;
	goto __7

	// Back references and recursions are handled by very similar code. At this
	//     stage, the names generated in the parsing pass are available, but the main
	//     name table has not yet been created. So for the named varieties, scan the
	//     list of names in order to get the number of the first one in the pattern,
	//     and whether or not this name is duplicated.

__38:
	if !((*Tcompile_block_8)(unsafe.Pointer(cb)).Fexternal_options&DPCRE2_MATCH_UNSET_BACKREF != Tuint32_t(0)) {
		goto __79
	}
	goto ISNOTFIXED
__79:
	;
	// Fall through

__39:

	is_dupname = DFALSE
	ng = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fnamed_groups
	meta_code = *(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) & 0xffff0000
	length = *(*Tuint32_t)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp)), 4)))

	offset = Tsize_t(*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 1*4)))<<32 | Tsize_t(*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 2*4)))
	*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(2)

	name = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_pattern + uintptr(offset)
	i = 0
__80:
	if !(i < int32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnames_found)) {
		goto __82
	}

	if !(length == Tuint32_t((*Tnamed_group_8)(unsafe.Pointer(ng)).Flength) && X_pcre2_strncmp_8(tls, name, (*Tnamed_group_8)(unsafe.Pointer(ng)).Fname, uint64(length)) == 0) {
		goto __83
	}

	group = (*Tnamed_group_8)(unsafe.Pointer(ng)).Fnumber
	is_dupname = TBOOL((*Tnamed_group_8)(unsafe.Pointer(ng)).Fisdup)
	goto __82
__83:
	;
	goto __81
__81:
	i++
	ng += 16
	goto __80
	goto __82
__82:
	;

	if !(group == Tuint32_t(0)) {
		goto __84
	}

	*(*int32)(unsafe.Pointer(errcodeptr)) = ERR15 // Non-existent subpattern
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Ferroroffset = offset
	return -1
__84:
	;

	// A numerical back reference can be fixed length if duplicate capturing
	//       groups are not being used. A non-duplicate named back reference can also
	//       be handled.

	if !(meta_code == DMETA_RECURSE_BYNAME || !(is_dupname != 0) && (*Tcompile_block_8)(unsafe.Pointer(cb)).Fexternal_flags&Tuint32_t(DPCRE2_DUPCAPUSED) == Tuint32_t(0)) {
		goto __85
	}
	goto RECURSE_OR_BACKREF_LENGTH
__85:
	; // Handle as a numbered version.

	goto ISNOTFIXED // Duplicate name or number

	// The offset values for back references < 10 are in a separate vector
	//     because otherwise they would use more than two parsed pattern elements on
	//     64-bit systems.

__40:
	if !((*Tcompile_block_8)(unsafe.Pointer(cb)).Fexternal_options&DPCRE2_MATCH_UNSET_BACKREF != Tuint32_t(0) || (*Tcompile_block_8)(unsafe.Pointer(cb)).Fexternal_flags&Tuint32_t(DPCRE2_DUPCAPUSED) != Tuint32_t(0)) {
		goto __86
	}
	goto ISNOTFIXED
__86:
	;
	group = *(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) & 0x0000ffff
	if !(group < Tuint32_t(10)) {
		goto __87
	}

	offset = *(*Tsize_t)(unsafe.Pointer(cb + 88 + uintptr(group)*8))
	goto RECURSE_OR_BACKREF_LENGTH
__87:
	;

	// Fall through
	// For groups >= 10 - picking up group twice does no harm.

	// A true recursion implies not fixed length, but a subroutine call may
	//     be OK. Back reference "recursions" are also failed.

__41:
	group = *(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) & 0x0000ffff
	offset = Tsize_t(*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 1*4)))<<32 | Tsize_t(*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 2*4)))
	*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(2)

RECURSE_OR_BACKREF_LENGTH:
	if !(group > (*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount) {
		goto __88
	}

	(*Tcompile_block_8)(unsafe.Pointer(cb)).Ferroroffset = offset
	*(*int32)(unsafe.Pointer(errcodeptr)) = ERR15 // Non-existent subpattern
	return -1
__88:
	;
	if !(group == Tuint32_t(0)) {
		goto __89
	}
	goto ISNOTFIXED
__89:
	; // Local recursion
	*(*uintptr)(unsafe.Pointer(bp + 8 /* gptr */)) = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fparsed_pattern
__90:
	if !(*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))) != DMETA_END) {
		goto __92
	}

	if !(*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))&0xffff0000 == DMETA_BIGVALUE) {
		goto __93
	}
	*(*uintptr)(unsafe.Pointer(bp + 8 /* gptr */)) += 4
	goto __94
__93:
	if !(*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))) == DMETA_CAPTURE|group) {
		goto __95
	}
	goto __92
__95:
	;
__94:
	;
	goto __91
__91:
	*(*uintptr)(unsafe.Pointer(bp + 8 /* gptr */)) += 4
	goto __90
	goto __92
__92:
	;

	// We must start the search for the end of the group at the first meta code
	//     inside the group. Otherwise it will be treated as an enclosed group.

	gptrend = parsed_skip(tls, *(*uintptr)(unsafe.Pointer(bp + 8))+uintptr(1)*4, PSKIP_KET)
	if !(gptrend == uintptr(0)) {
		goto __96
	}
	goto PARSED_SKIP_FAILED
__96:
	;
	if !(*(*uintptr)(unsafe.Pointer(bp)) > *(*uintptr)(unsafe.Pointer(bp + 8)) && *(*uintptr)(unsafe.Pointer(bp)) < gptrend) {
		goto __97
	}
	goto ISNOTFIXED
__97:
	; // Local recursion
	r = recurses
__98:
	if !(r != uintptr(0)) {
		goto __100
	}
	if !((*Tparsed_recurse_check)(unsafe.Pointer(r)).Fgroupptr == *(*uintptr)(unsafe.Pointer(bp + 8))) {
		goto __101
	}
	goto __100
__101:
	;
	goto __99
__99:
	r = (*Tparsed_recurse_check)(unsafe.Pointer(r)).Fprev
	goto __98
	goto __100
__100:
	;
	if !(r != uintptr(0)) {
		goto __102
	}
	goto ISNOTFIXED
__102:
	; // Mutual recursion
	(*Tparsed_recurse_check)(unsafe.Pointer(bp + 16 /* &this_recurse */)).Fprev = recurses
	(*Tparsed_recurse_check)(unsafe.Pointer(bp + 16 /* &this_recurse */)).Fgroupptr = *(*uintptr)(unsafe.Pointer(bp + 8 /* gptr */))

	// We do not need to know the position of the end of the group, that is,
	//     gptr is not used after the call to get_grouplength(). Setting the second
	//     argument FALSE stops it scanning for the end when the length can be found
	//     in the cache.

	*(*uintptr)(unsafe.Pointer(bp + 8 /* gptr */)) += 4
	grouplength = get_grouplength(tls, bp+8, DFALSE, errcodeptr, lcptr, int32(group),
		bp+16, cb)
	if !(grouplength < 0) {
		goto __103
	}

	if !(*(*int32)(unsafe.Pointer(errcodeptr)) == 0) {
		goto __104
	}
	goto ISNOTFIXED
__104:
	;
	return -1 // Error already set
__103:
	;
	itemlength = Tuint32_t(grouplength)
	goto __7

	// A (DEFINE) group is never obeyed inline and so it does not contribute to
	//     the length of this branch. Skip from the following item to the next
	//     unpaired ket.

__42:
	*(*uintptr)(unsafe.Pointer(bp /* pptr */)) = parsed_skip(tls, *(*uintptr)(unsafe.Pointer(bp))+uintptr(1)*4, PSKIP_KET)
	goto __7

	// Check other nested groups - advance past the initial data for each type
	//     and then seek a fixed length with get_grouplength().

__43:
__44:
__45:
__46:
	*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(2+DSIZEOFFSET)
	goto CHECK_GROUP

__47:
	*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(1)
	goto CHECK_GROUP

__48:
	*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(4)
	goto CHECK_GROUP

__49:
	group = *(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) & 0x0000ffff
	// Fall through

__50:
__51:
__52:
	*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4
CHECK_GROUP:
	grouplength = get_grouplength(tls, bp, DTRUE, errcodeptr, lcptr, int32(group),
		recurses, cb)
	if !(grouplength < 0) {
		goto __105
	}
	return -1
__105:
	;
	itemlength = Tuint32_t(grouplength)
	goto __7

	// Exact repetition is OK; variable repetition is not. A repetition of zero
	//     must subtract the length that has already been added.

__53:
__54:
__55:
	if !(*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 1*4)) == *(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 2*4))) {
		goto __106
	}

	switch *(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* pptr */)) + 1*4)) {
	case Tuint32_t(0):
		goto __108

	case Tuint32_t(1):
		goto __109

	default:
		goto __110
	}
	goto __107

__108:
	branchlength = int32(Tuint32_t(branchlength) - lastitemlength)
	goto __107

__109:
	itemlength = Tuint32_t(0)
	goto __107

__110: // Check for integer overflow
	if !(lastitemlength != Tuint32_t(0) && Tuint32_t(0x7fffffff)/lastitemlength < *(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 1*4))-Tuint32_t(1)) {
		goto __111
	}

	*(*int32)(unsafe.Pointer(errcodeptr)) = ERR87 // Integer overflow; lookbehind too big
	return -1
__111:
	;
	itemlength = (*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 1*4)) - Tuint32_t(1)) * lastitemlength
	goto __107
__107:
	;
	*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(2)
	goto __7
__106:
	;
	// Fall through

	// Any other item means this branch does not have a fixed length.

__56:
ISNOTFIXED:
	*(*int32)(unsafe.Pointer(errcodeptr)) = ERR25 // Not fixed length
	return -1
__7:
	;
__6:
	;

	// Add the item length to the branchlength, checking for integer overflow and
	//   for the branch length exceeding the limit.

	if !(0x7fffffff-branchlength < int32(itemlength) || libc.AssignAddInt32(&branchlength, int32(itemlength)) > 65535) {
		goto __112
	}

	*(*int32)(unsafe.Pointer(errcodeptr)) = ERR87
	return -1
__112:
	;

	// Save this item length for use if the next item is a quantifier.

	lastitemlength = itemlength
	goto __3
__3:
	*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4
	goto __2
	goto __4
__4:
	;

EXIT:
	*(*uintptr)(unsafe.Pointer(pptrptr)) = *(*uintptr)(unsafe.Pointer(bp /* pptr */))
	return branchlength

PARSED_SKIP_FAILED:
	*(*int32)(unsafe.Pointer(errcodeptr)) = ERR90
	return -1
}

// ************************************************
//
//        Set lengths in a lookbehind             *
//

// This function is called for each lookbehind, to set the lengths in its
// branches. An error occurs if any branch does not have a fixed length that is
// less than the maximum (65535). On exit, the pointer must be left on the final
// ket.
//
// The function also maintains the max_lookbehind value. Any lookbehind branch
// that contains a nested lookbehind may actually look further back than the
// length of the branch. The additional amount is passed back from
// get_branchlength() as an "extra" value.
//
// Arguments:
//   pptrptr     pointer to pointer in the parsed pattern
//   errcodeptr  pointer to error code
//   lcptr       pointer to loop counter
//   recurses    chain of recurse_check to catch mutual recursion
//   cb          pointer to compile block
//
// Returns:      TRUE if all is well
//               FALSE otherwise, with error code and offset set

func set_lookbehind_lengths(tls *libc.TLS, pptrptr uintptr, errcodeptr uintptr, lcptr uintptr, recurses uintptr, cb uintptr) TBOOL { /* pcre2_compile.c:9545:1: */
	var offset Tsize_t
	var branchlength int32
	var bptr uintptr = *(*uintptr)(unsafe.Pointer(pptrptr))

	{
		offset = Tsize_t(*(*Tuint32_t)(unsafe.Pointer(bptr + 1*4)))<<32 | Tsize_t(*(*Tuint32_t)(unsafe.Pointer(bptr + 2*4)))
	}
	// Offset for error messages
	*(*uintptr)(unsafe.Pointer(pptrptr)) += uintptr(DSIZEOFFSET) * 4

	for __ccgo := true; __ccgo; __ccgo = *(*Tuint32_t)(unsafe.Pointer(bptr)) == DMETA_ALT {
		*(*uintptr)(unsafe.Pointer(pptrptr)) += uintptr(1) * 4
		branchlength = get_branchlength(tls, pptrptr, errcodeptr, lcptr, recurses, cb)
		if branchlength < 0 {
			// The errorcode and offset may already be set from a nested lookbehind.
			if *(*int32)(unsafe.Pointer(errcodeptr)) == 0 {
				*(*int32)(unsafe.Pointer(errcodeptr)) = ERR25
			}
			if (*Tcompile_block_8)(unsafe.Pointer(cb)).Ferroroffset == libc.CplUint64(uint64(0)) {
				(*Tcompile_block_8)(unsafe.Pointer(cb)).Ferroroffset = offset
			}
			return DFALSE
		}
		if branchlength > (*Tcompile_block_8)(unsafe.Pointer(cb)).Fmax_lookbehind {
			(*Tcompile_block_8)(unsafe.Pointer(cb)).Fmax_lookbehind = branchlength
		}
		*(*Tuint32_t)(unsafe.Pointer(bptr)) |= Tuint32_t(branchlength) // branchlength never more than 65535
		bptr = *(*uintptr)(unsafe.Pointer(pptrptr))
	}

	return DTRUE
}

// ************************************************
//
//         Check parsed pattern lookbehinds       *
//

// This function is called at the end of parsing a pattern if any lookbehinds
// were encountered. It scans the parsed pattern for them, calling
// set_lookbehind_lengths() for each one. At the start, the errorcode is zero and
// the error offset is marked unset. The enables the functions above not to
// override settings from deeper nestings.
//
// This function is called recursively from get_branchlength() for lookaheads in
// order to process any lookbehinds that they may contain. It stops when it hits a
// non-nested closing parenthesis in this case, returning a pointer to it.
//
// Arguments
//   pptr      points to where to start (start of pattern or start of lookahead)
//   retptr    if not NULL, return the ket pointer here
//   recurses  chain of recurse_check to catch mutual recursion
//   cb        points to the compile block
//   lcptr     points to loop counter
//
// Returns:    0 on success, or an errorcode (cb->erroroffset will be set)

func check_lookbehinds(tls *libc.TLS, pptr uintptr, retptr uintptr, recurses uintptr, cb uintptr, lcptr uintptr) int32 { /* pcre2_compile.c:9602:1: */
	bp := tls.Alloc(12)
	defer tls.Free(12)
	*(*uintptr)(unsafe.Pointer(bp)) = pptr

	*(*int32)(unsafe.Pointer(bp + 8 /* errorcode */)) = 0
	var nestlevel int32 = 0

	(*Tcompile_block_8)(unsafe.Pointer(cb)).Ferroroffset = libc.CplUint64(uint64(0))

	for ; *(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) != DMETA_END; *(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 {
		if *(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) < DMETA_END {
			continue
		} // Literal

		switch *(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) & 0xffff0000 {
		default:
			return ERR70 // Unrecognized meta code

		case DMETA_ESCAPE:
			if *(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))-DMETA_ESCAPE == ESC_P || *(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))-DMETA_ESCAPE == ESC_p {
				*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(1)
			}
			break

		case DMETA_KET:
			if libc.PreDecInt32(&nestlevel, 1) < 0 {
				if retptr != uintptr(0) {
					*(*uintptr)(unsafe.Pointer(retptr)) = *(*uintptr)(unsafe.Pointer(bp /* pptr */))
				}
				return 0
			}
			break

		case DMETA_ATOMIC:
			fallthrough
		case DMETA_CAPTURE:
			fallthrough
		case DMETA_COND_ASSERT:
			fallthrough
		case DMETA_LOOKAHEAD:
			fallthrough
		case DMETA_LOOKAHEADNOT:
			fallthrough
		case DMETA_LOOKAHEAD_NA:
			fallthrough
		case DMETA_NOCAPTURE:
			fallthrough
		case DMETA_SCRIPT_RUN:
			nestlevel++
			break

		case DMETA_ACCEPT:
			fallthrough
		case DMETA_ALT:
			fallthrough
		case DMETA_ASTERISK:
			fallthrough
		case DMETA_ASTERISK_PLUS:
			fallthrough
		case DMETA_ASTERISK_QUERY:
			fallthrough
		case DMETA_BACKREF:
			fallthrough
		case DMETA_CIRCUMFLEX:
			fallthrough
		case DMETA_CLASS:
			fallthrough
		case DMETA_CLASS_EMPTY:
			fallthrough
		case DMETA_CLASS_EMPTY_NOT:
			fallthrough
		case DMETA_CLASS_END:
			fallthrough
		case DMETA_CLASS_NOT:
			fallthrough
		case DMETA_COMMIT:
			fallthrough
		case DMETA_DOLLAR:
			fallthrough
		case DMETA_DOT:
			fallthrough
		case DMETA_FAIL:
			fallthrough
		case DMETA_PLUS:
			fallthrough
		case DMETA_PLUS_PLUS:
			fallthrough
		case DMETA_PLUS_QUERY:
			fallthrough
		case DMETA_PRUNE:
			fallthrough
		case DMETA_QUERY:
			fallthrough
		case DMETA_QUERY_PLUS:
			fallthrough
		case DMETA_QUERY_QUERY:
			fallthrough
		case DMETA_RANGE_ESCAPED:
			fallthrough
		case DMETA_RANGE_LITERAL:
			fallthrough
		case DMETA_SKIP:
			fallthrough
		case DMETA_THEN:
			break

		case DMETA_RECURSE:
			*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(DSIZEOFFSET)
			break

		case DMETA_BACKREF_BYNAME:
			fallthrough
		case DMETA_RECURSE_BYNAME:
			*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(1+DSIZEOFFSET)
			break

		case DMETA_COND_DEFINE:
			*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(DSIZEOFFSET)
			nestlevel++
			break

		case DMETA_COND_NAME:
			fallthrough
		case DMETA_COND_NUMBER:
			fallthrough
		case DMETA_COND_RNAME:
			fallthrough
		case DMETA_COND_RNUMBER:
			*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(1+DSIZEOFFSET)
			nestlevel++
			break

		case DMETA_COND_VERSION:
			*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(3)
			nestlevel++
			break

		case DMETA_CALLOUT_STRING:
			*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(3+DSIZEOFFSET)
			break

		case DMETA_BIGVALUE:
			fallthrough
		case DMETA_OPTIONS:
			fallthrough
		case DMETA_POSIX:
			fallthrough
		case DMETA_POSIX_NEG:
			*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(1)
			break

		case DMETA_MINMAX:
			fallthrough
		case DMETA_MINMAX_QUERY:
			fallthrough
		case DMETA_MINMAX_PLUS:
			*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(2)
			break

		case DMETA_CALLOUT_NUMBER:
			*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(3)
			break

		case DMETA_MARK:
			fallthrough
		case DMETA_COMMIT_ARG:
			fallthrough
		case DMETA_PRUNE_ARG:
			fallthrough
		case DMETA_SKIP_ARG:
			fallthrough
		case DMETA_THEN_ARG:
			*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(Tuint32_t(1)+*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 1*4)))
			break

		case DMETA_LOOKBEHIND:
			fallthrough
		case DMETA_LOOKBEHINDNOT:
			fallthrough
		case DMETA_LOOKBEHIND_NA:
			if !(set_lookbehind_lengths(tls, bp, bp+8, lcptr, recurses, cb) != 0) {
				return *(*int32)(unsafe.Pointer(bp + 8 /* errorcode */))
			}
			break
		}
	}

	return 0
}

// ************************************************
//
//     External function to compile a pattern     *
//

// This function reads a regular expression in the form of a string and returns
// a pointer to a block of store holding a compiled version of the expression.
//
// Arguments:
//   pattern       the regular expression
//   patlen        the length of the pattern, or PCRE2_ZERO_TERMINATED
//   options       option bits
//   errorptr      pointer to errorcode
//   erroroffset   pointer to error offset
//   ccontext      points to a compile context or is NULL
//
// Returns:        pointer to compiled data block, or NULL on error,
//                 with errorcode and erroroffset set

func Xpcre2_compile_8(tls *libc.TLS, pattern TPCRE2_SPTR8, patlen Tsize_t, options Tuint32_t, errorptr uintptr, erroroffset uintptr, ccontext uintptr) uintptr { /* pcre2_compile.c:9761:27: */
	bp := tls.Alloc(17928)
	defer tls.Free(17928)

	var utf TBOOL // Set TRUE for UTF mode
	var ucp TBOOL // Set TRUE for UCP mode
	// var has_lookbehind TBOOL at bp+17744, 4
	// Set TRUE if a lookbehind is found
	var zero_terminated TBOOL
	_ = zero_terminated // Set TRUE for zero-terminated pattern
	var re uintptr      // What we will return
	// var cb Tcompile_block_8 at bp+17440, 304
	// "Static" compile-time data
	var tables uintptr // Char tables base pointer

	// var code uintptr at bp+17752, 8
	// Current pointer in compiled code
	var codestart TPCRE2_SPTR8 // Start of compiled code
	var ptr TPCRE2_SPTR8       // Current pointer in pattern
	// var pptr uintptr at bp+17760, 8
	// Current pointer in parsed pattern

	// var length Tsize_t at bp+17792, 8
	// Allow for final END opcode
	var usedlength Tsize_t         // Actual length used
	var re_blocksize Tsize_t       // Size of memory block
	var big32count Tsize_t         // 32-bit literals >= 0x80000000
	var parsed_size_needed Tsize_t // Needed for parsed pattern

	// var firstcuflags Tuint32_t at bp+17776, 4

	// var reqcuflags Tuint32_t at bp+17784, 4
	// Type of first/req code unit
	// var firstcu Tuint32_t at bp+17772, 4

	// var reqcu Tuint32_t at bp+17780, 4
	// Value of first/req code unit
	var setflags Tuint32_t // NL and BSR set flags

	var skipatstart Tuint32_t // When checking (*UTF) etc
	var limit_heap Tuint32_t
	var limit_match Tuint32_t // Unset match limits
	var limit_depth Tuint32_t
	var newline int32 // Unset; can be set by the pattern
	var bsr int32     // Unset; can be set by the pattern
	// var errorcode int32 at bp+17768, 4
	// Initialize to avoid compiler warn
	var regexrc int32 // Return from compile

	var i Tuint32_t // Local loop counter

	// Comments at the head of this file explain about these variables.

	// var stack_groupinfo [256]Tuint32_t at bp+12000, 1024

	// var stack_parsed_pattern [1024]Tuint32_t at bp+13344, 4096

	// var named_groups [20]Tnamed_group_8 at bp+13024, 320

	// The workspace is used in different ways in the different compiling phases.
	// It needs to be 16-bit aligned for the preliminary parsing scan.

	// var c16workspace [3000]Tuint32_t at bp, 12000

	var cworkspace uintptr
	var c Tuint32_t
	var pp Tuint32_t
	var p uintptr
	var heap_parsed_pattern uintptr
	// var loopcount int32 at bp+17748, 4

	var ng uintptr
	var search_from TPCRE2_SPTR8
	var p1 int32
	var groupnumber int32
	var rcode uintptr
	var rgroup TPCRE2_SPTR8
	var ccount uint32
	var start int32
	// var rc [8]Trecurse_cache at bp+17800, 128

	var temp uintptr
	var minminlength int32
	*(*TBOOL)(unsafe.Pointer(bp + 17744 /* has_lookbehind */)) = DFALSE
	re = uintptr(0)
	*(*Tsize_t)(unsafe.Pointer(bp + 17792 /* length */)) = uint64(1)
	big32count = uint64(0)
	setflags = Tuint32_t(0)
	limit_heap = 4294967295
	limit_match = 4294967295
	limit_depth = 4294967295
	newline = 0
	bsr = 0
	*(*int32)(unsafe.Pointer(bp + 17768 /* errorcode */)) = 0
	cworkspace = bp /* c16workspace */

	// -------------- Check arguments and set up the pattern -----------------

	// There must be error code and offset pointers.

	if !(errorptr == uintptr(0) || erroroffset == uintptr(0)) {
		goto __1
	}
	return uintptr(0)
__1:
	;
	*(*int32)(unsafe.Pointer(errorptr)) = ERR0
	*(*Tsize_t)(unsafe.Pointer(erroroffset)) = uint64(0)

	// There must be a pattern!

	if !(pattern == uintptr(0)) {
		goto __2
	}

	*(*int32)(unsafe.Pointer(errorptr)) = ERR16
	return uintptr(0)
__2:
	;

	// A NULL compile context means "use a default context"

	if !(ccontext == uintptr(0)) {
		goto __3
	}
	ccontext = uintptr(unsafe.Pointer(&X_pcre2_default_compile_context_8))
__3:
	;

	// PCRE2_MATCH_INVALID_UTF implies UTF

	if !(options&DPCRE2_MATCH_INVALID_UTF != Tuint32_t(0)) {
		goto __4
	}
	options = options | DPCRE2_UTF
__4:
	;

	// Check that all undefined public option bits are zero.

	if !(options&libc.CplUint32(DPCRE2_ANCHORED|DPCRE2_AUTO_CALLOUT|DPCRE2_CASELESS|DPCRE2_ENDANCHORED|DPCRE2_FIRSTLINE|DPCRE2_LITERAL|DPCRE2_MATCH_INVALID_UTF|DPCRE2_NO_START_OPTIMIZE|DPCRE2_NO_UTF_CHECK|DPCRE2_USE_OFFSET_LIMIT|DPCRE2_UTF|DPCRE2_ALLOW_EMPTY_CLASS|DPCRE2_ALT_BSUX|DPCRE2_ALT_CIRCUMFLEX|DPCRE2_ALT_VERBNAMES|DPCRE2_DOLLAR_ENDONLY|DPCRE2_DOTALL|DPCRE2_DUPNAMES|DPCRE2_EXTENDED|DPCRE2_EXTENDED_MORE|DPCRE2_MATCH_UNSET_BACKREF|DPCRE2_MULTILINE|DPCRE2_NEVER_BACKSLASH_C|DPCRE2_NEVER_UCP|DPCRE2_NEVER_UTF|DPCRE2_NO_AUTO_CAPTURE|DPCRE2_NO_AUTO_POSSESS|DPCRE2_NO_DOTSTAR_ANCHOR|DPCRE2_UCP|DPCRE2_UNGREEDY) != Tuint32_t(0) || (*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fextra_options&libc.CplUint32(DPCRE2_EXTRA_MATCH_LINE|DPCRE2_EXTRA_MATCH_WORD|DPCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES|DPCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL|DPCRE2_EXTRA_ESCAPED_CR_IS_LF|DPCRE2_EXTRA_ALT_BSUX|DPCRE2_EXTRA_ALLOW_LOOKAROUND_BSK) != Tuint32_t(0)) {
		goto __5
	}

	*(*int32)(unsafe.Pointer(errorptr)) = ERR17
	return uintptr(0)
__5:
	;

	if !(options&DPCRE2_LITERAL != Tuint32_t(0) && (options&libc.CplUint32(DPCRE2_ANCHORED|DPCRE2_AUTO_CALLOUT|DPCRE2_CASELESS|DPCRE2_ENDANCHORED|DPCRE2_FIRSTLINE|DPCRE2_LITERAL|DPCRE2_MATCH_INVALID_UTF|DPCRE2_NO_START_OPTIMIZE|DPCRE2_NO_UTF_CHECK|DPCRE2_USE_OFFSET_LIMIT|DPCRE2_UTF) != Tuint32_t(0) || (*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fextra_options&libc.CplUint32(DPCRE2_EXTRA_MATCH_LINE|DPCRE2_EXTRA_MATCH_WORD) != Tuint32_t(0))) {
		goto __6
	}

	*(*int32)(unsafe.Pointer(errorptr)) = ERR92
	return uintptr(0)
__6:
	;

	// A zero-terminated pattern is indicated by the special length value
	// PCRE2_ZERO_TERMINATED. Check for an overlong pattern.

	if !(libc.AssignInt32(&zero_terminated, libc.Bool32(patlen == libc.CplUint64(uint64(0)))) != 0) {
		goto __7
	}
	patlen = X_pcre2_strlen_8(tls, pattern)
__7:
	;

	if !(patlen > (*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fmax_pattern_length) {
		goto __8
	}

	*(*int32)(unsafe.Pointer(errorptr)) = ERR88
	return uintptr(0)
__8:
	;

	// From here on, all returns from this function should end up going via the
	// EXIT label.

	// ------------ Initialize the "static" compile data --------------

	if (*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Ftables != uintptr(0) {
		tables = (*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Ftables
	} else {
		tables = uintptr(unsafe.Pointer(&X_pcre2_default_tables_8))
	}

	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Flcc = tables + uintptr(Dlcc_offset)     // Individual
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Ffcc = tables + uintptr(Dfcc_offset)     //   character
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fcbits = tables + uintptr(Dcbits_offset) //      tables
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fctypes = tables + uintptr(Dcbits_offset+Dcbit_length)

	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fassert_depth = Tuint16_t(0)
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fbracount = Tuint32_t(0)
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fcx = ccontext
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fdupnames = DFALSE
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fend_pattern = pattern + uintptr(patlen)
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Ferroroffset = uint64(0)
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fexternal_flags = Tuint32_t(0)
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fexternal_options = options
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fgroupinfo = bp + 12000 /* &stack_groupinfo[0] */
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fhad_recurse = DFALSE
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Flastcapture = Tuint32_t(0)
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fmax_lookbehind = 0
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fname_entry_size = Tuint16_t(0)
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fname_table = uintptr(0)
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fnamed_groups = bp + 13024 /* &named_groups[0] */
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fnamed_group_list_size = Tuint32_t(DNAMED_GROUP_LIST_SIZE)
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fnames_found = Tuint16_t(0)
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fopen_caps = uintptr(0)
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fparens_depth = Tuint16_t(0)
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fparsed_pattern = bp + 13344 /* &stack_parsed_pattern[0] */
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Freq_varyopt = Tuint32_t(0)
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fstart_code = cworkspace
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fstart_pattern = pattern
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fstart_workspace = cworkspace
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fworkspace_size = uint64(3000 * DLINK_SIZE)

	// Maximum back reference and backref bitmap. The bitmap records up to 31 back
	// references to help in deciding whether (.*) can be treated as anchored or not.

	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Ftop_backref = Tuint32_t(0)
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fbackref_map = Tuint32_t(0)

	// Escape sequences \1 to \9 are always back references, but as they are only
	// two characters long, only two elements can be used in the parsed_pattern
	// vector. The first contains the reference, and we'd like to use the second to
	// record the offset in the pattern, so that forward references to non-existent
	// groups can be diagnosed later with an offset. However, on 64-bit systems,
	// PCRE2_SIZE won't fit. Instead, we have a vector of offsets for the first
	// occurrence of \1 to \9, indexed by the second parsed_pattern value. All other
	// references have enough space for the offset to be put into the parsed pattern.

	i = Tuint32_t(0)
__9:
	if !(i < Tuint32_t(10)) {
		goto __11
	}
	*(*Tsize_t)(unsafe.Pointer(bp + 17440 + 88 + uintptr(i)*8)) = libc.CplUint64(uint64(0))
	goto __10
__10:
	i++
	goto __9
	goto __11
__11:
	;

	// --------------- Start looking at the pattern ---------------

	// Unless PCRE2_LITERAL is set, check for global one-time option settings at
	// the start of the pattern, and remember the offset to the actual regex. With
	// valgrind support, make the terminator of a zero-terminated pattern
	// inaccessible. This catches bugs that would otherwise only show up for
	// non-zero-terminated patterns.

	ptr = pattern
	skipatstart = Tuint32_t(0)

	if !(options&DPCRE2_LITERAL == Tuint32_t(0)) {
		goto __12
	}

__13:
	if !(patlen-Tsize_t(skipatstart) >= uint64(2) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + uintptr(skipatstart)))) == '\050' && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + uintptr(skipatstart+Tuint32_t(1))))) == '\052') {
		goto __14
	}

	i = Tuint32_t(0)
__15:
	if !(uint64(i) < uint64(unsafe.Sizeof(pso_list))/uint64(unsafe.Sizeof(Tpso{}))) {
		goto __17
	}

	p = uintptr(unsafe.Pointer(&pso_list)) + uintptr(i)*16

	if !(patlen-Tsize_t(skipatstart)-uint64(2) >= Tsize_t((*Tpso)(unsafe.Pointer(p)).Flength) && X_pcre2_strncmp_c8_8(tls, ptr+uintptr(skipatstart)+uintptr(2), (*Tpso)(unsafe.Pointer(p)).Fname,
		uint64((*Tpso)(unsafe.Pointer(p)).Flength)) == 0) {
		goto __18
	}

	skipatstart = skipatstart + Tuint32_t(int32((*Tpso)(unsafe.Pointer(p)).Flength)+2)
	switch int32((*Tpso)(unsafe.Pointer(p)).Ftype) {
	case PSO_OPT:
		goto __20

	case PSO_FLG:
		goto __21

	case PSO_NL:
		goto __22

	case PSO_BSR:
		goto __23

	case PSO_LIMM:
		goto __24
	case PSO_LIMD:
		goto __25
	case PSO_LIMH:
		goto __26
	}
	goto __19

__20:
	*(*Tuint32_t)(unsafe.Pointer(bp + 17440 + 204)) |= (*Tpso)(unsafe.Pointer(p)).Fvalue
	goto __19

__21:
	setflags = setflags | (*Tpso)(unsafe.Pointer(p)).Fvalue
	goto __19

__22:
	newline = int32((*Tpso)(unsafe.Pointer(p)).Fvalue)
	setflags = setflags | Tuint32_t(DPCRE2_NL_SET)
	goto __19

__23:
	bsr = int32((*Tpso)(unsafe.Pointer(p)).Fvalue)
	setflags = setflags | Tuint32_t(DPCRE2_BSR_SET)
	goto __19

__24:
__25:
__26:
	c = Tuint32_t(0)
	pp = skipatstart
	if !!(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + uintptr(pp)))) >= '\060' && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + uintptr(pp)))) <= '\071') {
		goto __27
	}

	*(*int32)(unsafe.Pointer(bp + 17768 /* errorcode */)) = ERR60
	ptr += TPCRE2_SPTR8(pp)
	goto HAD_EARLY_ERROR
__27:
	;
__28:
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + uintptr(pp)))) >= '\060' && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + uintptr(pp)))) <= '\071') {
		goto __29
	}

	if !(c > 4294967295/uint32(10)-uint32(1)) {
		goto __30
	}
	goto __29
__30:
	; // Integer overflow
	c = c*Tuint32_t(10) + Tuint32_t(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + uintptr(libc.PostIncUint32(&pp, 1)))))-'\060')
	goto __28
__29:
	;
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + uintptr(libc.PostIncUint32(&pp, 1))))) != '\051') {
		goto __31
	}

	*(*int32)(unsafe.Pointer(bp + 17768 /* errorcode */)) = ERR60
	ptr += TPCRE2_SPTR8(pp)
	goto HAD_EARLY_ERROR
__31:
	;
	if !(int32((*Tpso)(unsafe.Pointer(p)).Ftype) == PSO_LIMH) {
		goto __32
	}
	limit_heap = c
	goto __33
__32:
	if !(int32((*Tpso)(unsafe.Pointer(p)).Ftype) == PSO_LIMM) {
		goto __34
	}
	limit_match = c
	goto __35
__34:
	limit_depth = c
__35:
	;
__33:
	;
	skipatstart = skipatstart + (pp - skipatstart)
	goto __19
__19:
	;
	goto __17 // Out of the table scan loop
__18:
	;
	goto __16
__16:
	i++
	goto __15
	goto __17
__17:
	;
	if !(uint64(i) >= uint64(unsafe.Sizeof(pso_list))/uint64(unsafe.Sizeof(Tpso{}))) {
		goto __36
	}
	goto __14
__36:
	; // Out of pso loop
	goto __13
__14:
	;
__12:
	;

	// End of pattern-start options; advance to start of real regex.

	ptr += TPCRE2_SPTR8(skipatstart)

	// Can't support UTF or UCP if PCRE2 was built without Unicode support.

	// Check UTF. We have the original options in 'options', with that value as
	// modified by (*UTF) etc in cb->external_options. The extra option
	// PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES is not permitted in UTF-16 mode because the
	// surrogate code points cannot be represented in UTF-16.

	utf = libc.Bool32((*Tcompile_block_8)(unsafe.Pointer(bp+17440)).Fexternal_options&DPCRE2_UTF != Tuint32_t(0))
	if !(utf != 0) {
		goto __37
	}

	if !(options&DPCRE2_NEVER_UTF != Tuint32_t(0)) {
		goto __38
	}

	*(*int32)(unsafe.Pointer(bp + 17768 /* errorcode */)) = ERR74
	goto HAD_EARLY_ERROR
__38:
	;
	if !(options&DPCRE2_NO_UTF_CHECK == Tuint32_t(0) && libc.AssignPtrInt32(bp+17768, X_pcre2_valid_utf_8(tls, pattern, patlen, erroroffset)) != 0) {
		goto __39
	}
	goto HAD_ERROR
__39:
	; // Offset was set by valid_utf()

__37:
	;

	// Check UCP lockout.

	ucp = libc.Bool32((*Tcompile_block_8)(unsafe.Pointer(bp+17440)).Fexternal_options&DPCRE2_UCP != Tuint32_t(0))
	if !(ucp != 0 && (*Tcompile_block_8)(unsafe.Pointer(bp+17440)).Fexternal_options&DPCRE2_NEVER_UCP != Tuint32_t(0)) {
		goto __40
	}

	*(*int32)(unsafe.Pointer(bp + 17768 /* errorcode */)) = ERR75
	goto HAD_EARLY_ERROR
__40:
	;

	// Process the BSR setting.

	if !(bsr == 0) {
		goto __41
	}
	bsr = int32((*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fbsr_convention)
__41:
	;

	// Process the newline setting.

	if !(newline == 0) {
		goto __42
	}
	newline = int32((*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fnewline_convention)
__42:
	;
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fnltype = Tuint32_t(DNLTYPE_FIXED)
	switch newline {
	case DPCRE2_NEWLINE_CR:
		goto __44

	case DPCRE2_NEWLINE_LF:
		goto __45

	case DPCRE2_NEWLINE_NUL:
		goto __46

	case DPCRE2_NEWLINE_CRLF:
		goto __47

	case DPCRE2_NEWLINE_ANY:
		goto __48

	case DPCRE2_NEWLINE_ANYCRLF:
		goto __49

	default:
		goto __50
	}
	goto __43

__44:
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fnllen = Tuint32_t(1)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(bp + 17440 + 272)) = TPCRE2_UCHAR8('\015')
	goto __43

__45:
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fnllen = Tuint32_t(1)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(bp + 17440 + 272)) = TPCRE2_UCHAR8('\012')
	goto __43

__46:
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fnllen = Tuint32_t(1)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(bp + 17440 + 272)) = TPCRE2_UCHAR8(0)
	goto __43

__47:
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fnllen = Tuint32_t(2)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(bp + 17440 + 272)) = TPCRE2_UCHAR8('\015')
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(bp + 17440 + 272 + 1)) = TPCRE2_UCHAR8('\012')
	goto __43

__48:
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fnltype = Tuint32_t(DNLTYPE_ANY)
	goto __43

__49:
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fnltype = Tuint32_t(DNLTYPE_ANYCRLF)
	goto __43

__50:
	*(*int32)(unsafe.Pointer(bp + 17768 /* errorcode */)) = ERR56
	goto HAD_EARLY_ERROR
__43:
	;

	// Pre-scan the pattern to do two things: (1) Discover the named groups and
	// their numerical equivalents, so that this information is always available for
	// the remaining processing. (2) At the same time, parse the pattern and put a
	// processed version into the parsed_pattern vector. This has escapes interpreted
	// and comments removed (amongst other things).
	//
	// In all but one case, when PCRE2_AUTO_CALLOUT is not set, the number of unsigned
	// 32-bit ints in the parsed pattern is bounded by the length of the pattern plus
	// one (for the terminator) plus four if PCRE2_EXTRA_WORD or PCRE2_EXTRA_LINE is
	// set. The exceptional case is when running in 32-bit, non-UTF mode, when literal
	// characters greater than META_END (0x80000000) have to be coded as two units. In
	// this case, therefore, we scan the pattern to check for such values.

	// Ensure that the parsed pattern buffer is big enough. When PCRE2_AUTO_CALLOUT
	// is set we have to assume a numerical callout (4 elements) for each character
	// plus one at the end. This is overkill, but memory is plentiful these days. For
	// many smaller patterns the vector on the stack (which was set up above) can be
	// used.

	parsed_size_needed = patlen - Tsize_t(skipatstart) + big32count

	if !((*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fextra_options&(DPCRE2_EXTRA_MATCH_WORD|DPCRE2_EXTRA_MATCH_LINE) != Tuint32_t(0)) {
		goto __51
	}
	parsed_size_needed = parsed_size_needed + uint64(4)
__51:
	;

	if !(options&DPCRE2_AUTO_CALLOUT != Tuint32_t(0)) {
		goto __52
	}
	parsed_size_needed = (parsed_size_needed + uint64(1)) * uint64(5)
__52:
	;

	if !(parsed_size_needed >= uint64(DPARSED_PATTERN_DEFAULT_SIZE)) {
		goto __53
	}

	heap_parsed_pattern = (*struct {
		f func(*libc.TLS, Tsize_t, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fmemctl.Fmalloc})).f(tls,
		(parsed_size_needed+uint64(1))*Tsize_t(unsafe.Sizeof(Tuint32_t(0))), (*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fmemctl.Fmemory_data)
	if !(heap_parsed_pattern == uintptr(0)) {
		goto __54
	}

	*(*int32)(unsafe.Pointer(errorptr)) = ERR21
	goto EXIT
__54:
	;
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fparsed_pattern = heap_parsed_pattern
__53:
	;
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fparsed_pattern_end = (*Tcompile_block_8)(unsafe.Pointer(bp+17440)).Fparsed_pattern + uintptr(parsed_size_needed)*4 + uintptr(1)*4

	// Do the parsing scan.

	*(*int32)(unsafe.Pointer(bp + 17768 /* errorcode */)) = parse_regex(tls, ptr, (*Tcompile_block_8)(unsafe.Pointer(bp+17440 /* &cb */)).Fexternal_options, bp+17744, bp+17440)
	if !(*(*int32)(unsafe.Pointer(bp + 17768)) != 0) {
		goto __55
	}
	goto HAD_CB_ERROR
__55:
	;

	// Workspace is needed to remember information about numbered groups: whether a
	// group can match an empty string and what its fixed length is. This is done to
	// avoid the possibility of recursive references causing very long compile times
	// when checking these features. Unnumbered groups do not have this exposure since
	// they cannot be referenced. We use an indexed vector for this purpose. If there
	// are sufficiently few groups, the default vector on the stack, as set up above,
	// can be used. Otherwise we have to get/free a special vector. The vector must be
	// initialized to zero.

	if !((*Tcompile_block_8)(unsafe.Pointer(bp+17440)).Fbracount >= Tuint32_t(DGROUPINFO_DEFAULT_SIZE)) {
		goto __56
	}

	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fgroupinfo = (*struct {
		f func(*libc.TLS, Tsize_t, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fmemctl.Fmalloc})).f(tls,
		uint64((*Tcompile_block_8)(unsafe.Pointer(bp+17440)).Fbracount+Tuint32_t(1))*uint64(unsafe.Sizeof(Tuint32_t(0))), (*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fmemctl.Fmemory_data)
	if !((*Tcompile_block_8)(unsafe.Pointer(bp+17440)).Fgroupinfo == uintptr(0)) {
		goto __57
	}

	*(*int32)(unsafe.Pointer(bp + 17768 /* errorcode */)) = ERR21
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Ferroroffset = uint64(0)
	goto HAD_CB_ERROR
__57:
	;
__56:
	;
	libc.Xmemset(tls, (*Tcompile_block_8)(unsafe.Pointer(bp+17440 /* &cb */)).Fgroupinfo, 0, uint64((*Tcompile_block_8)(unsafe.Pointer(bp+17440)).Fbracount+Tuint32_t(1))*uint64(unsafe.Sizeof(Tuint32_t(0))))

	// If there were any lookbehinds, scan the parsed pattern to figure out their
	// lengths.

	if !(*(*TBOOL)(unsafe.Pointer(bp + 17744)) != 0) {
		goto __58
	}

	*(*int32)(unsafe.Pointer(bp + 17748 /* loopcount */)) = 0
	*(*int32)(unsafe.Pointer(bp + 17768 /* errorcode */)) = check_lookbehinds(tls, (*Tcompile_block_8)(unsafe.Pointer(bp+17440 /* &cb */)).Fparsed_pattern, uintptr(0), uintptr(0), bp+17440, bp+17748)
	if !(*(*int32)(unsafe.Pointer(bp + 17768)) != 0) {
		goto __59
	}
	goto HAD_CB_ERROR
__59:
	;
__58:
	;

	// For debugging, there is a function that shows the parsed data vector.

	// For debugging capturing information this code can be enabled.

	// Pretend to compile the pattern while actually just accumulating the amount
	// of memory required in the 'length' variable. This behaviour is triggered by
	// passing a non-NULL final argument to compile_regex(). We pass a block of
	// workspace (cworkspace) for it to compile parts of the pattern into; the
	// compiled code is discarded when it is no longer needed, so hopefully this
	// workspace will never overflow, though there is a test for its doing so.
	//
	// On error, errorcode will be set non-zero, so we don't need to look at the
	// result of the function. The initial options have been put into the cb block,
	// but we still have to pass a separate options variable (the first argument)
	// because the options may change as the pattern is processed.

	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Ferroroffset = patlen // For any subsequent errors that do not set it
	*(*uintptr)(unsafe.Pointer(bp + 17760 /* pptr */)) = (*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fparsed_pattern
	*(*uintptr)(unsafe.Pointer(bp + 17752 /* code */)) = cworkspace
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 17752 /* code */)))) = OP_BRA

	compile_regex(tls, (*Tcompile_block_8)(unsafe.Pointer(bp+17440 /* &cb */)).Fexternal_options, bp+17752, bp+17760, bp+17768, uint32(0), bp+17772,
		bp+17776, bp+17780, bp+17784, uintptr(0), bp+17440, bp+17792)

	if !(*(*int32)(unsafe.Pointer(bp + 17768)) != 0) {
		goto __60
	}
	goto HAD_CB_ERROR
__60:
	; // Offset is in cb.erroroffset

	// This should be caught in compile_regex(), but just in case...

	if !(*(*Tsize_t)(unsafe.Pointer(bp + 17792)) > uint64(int32(1)<<16)) {
		goto __61
	}

	*(*int32)(unsafe.Pointer(bp + 17768 /* errorcode */)) = ERR20
	goto HAD_CB_ERROR
__61:
	;

	// Compute the size of, and then get and initialize, the data block for storing
	// the compiled pattern and names table. Integer overflow should no longer be
	// possible because nowadays we limit the maximum value of cb.names_found and
	// cb.name_entry_size.

	re_blocksize = uint64(unsafe.Sizeof(Tpcre2_real_code_8{})) + (*(*Tsize_t)(unsafe.Pointer(bp + 17792))+Tsize_t((*Tcompile_block_8)(unsafe.Pointer(bp+17440)).Fnames_found)*Tsize_t((*Tcompile_block_8)(unsafe.Pointer(bp+17440)).Fname_entry_size))*uint64(DPCRE2_CODE_UNIT_WIDTH/8)
	re = (*struct {
		f func(*libc.TLS, Tsize_t, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fmemctl.Fmalloc})).f(tls, re_blocksize, (*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fmemctl.Fmemory_data)
	if !(re == uintptr(0)) {
		goto __62
	}

	*(*int32)(unsafe.Pointer(bp + 17768 /* errorcode */)) = ERR21
	goto HAD_CB_ERROR
__62:
	;

	// The compiler may put padding at the end of the pcre2_real_code structure in
	// order to round it up to a multiple of 4 or 8 bytes. This means that when a
	// compiled pattern is copied (for example, when serialized) undefined bytes are
	// read, and this annoys debuggers such as valgrind. To avoid this, we explicitly
	// write to the last 8 bytes of the structure before setting the fields.

	libc.Xmemset(tls, re+uintptr(uint64(unsafe.Sizeof(Tpcre2_real_code_8{})))-uintptr(8), 0, uint64(8))
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fmemctl = (*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fmemctl
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftables = tables
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fexecutable_jit = uintptr(0)
	libc.Xmemset(tls, re+40, 0, uint64(32)*uint64(unsafe.Sizeof(Tuint8_t(0))))
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fblocksize = re_blocksize
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fmagic_number = uint32(DMAGIC_NUMBER)
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fcompile_options = options
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options = (*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fexternal_options
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fextra_options = (*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fextra_options
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags = Tuint32_t(DPCRE2_CODE_UNIT_WIDTH/8) | (*Tcompile_block_8)(unsafe.Pointer(bp+17440)).Fexternal_flags | setflags
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flimit_heap = limit_heap
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flimit_match = limit_match
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flimit_depth = limit_depth
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ffirst_codeunit = Tuint32_t(0)
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flast_codeunit = Tuint32_t(0)
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fbsr_convention = Tuint16_t(bsr)
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fnewline_convention = Tuint16_t(newline)
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fmax_lookbehind = Tuint16_t(0)
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fminlength = Tuint16_t(0)
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftop_bracket = Tuint16_t(0)
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftop_backref = Tuint16_t(0)
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fname_entry_size = (*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fname_entry_size
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fname_count = (*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fnames_found

	// The basic block is immediately followed by the name table, and the compiled
	// code follows after that.

	codestart = re + uintptr(uint64(unsafe.Sizeof(Tpcre2_real_code_8{}))) + uintptr(int32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fname_entry_size)*int32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fname_count))

	// Update the compile data block for the actual compile. The starting points of
	// the name/number translation table and of the code are passed around in the
	// compile data block. The start/end pattern and initial options are already set
	// from the pre-compile phase, as is the name_entry_size field.

	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fparens_depth = Tuint16_t(0)
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fassert_depth = Tuint16_t(0)
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Flastcapture = Tuint32_t(0)
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fname_table = re + uintptr(uint64(unsafe.Sizeof(Tpcre2_real_code_8{})))
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fstart_code = codestart
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Freq_varyopt = Tuint32_t(0)
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fhad_accept = DFALSE
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fhad_pruneorskip = DFALSE
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fopen_caps = uintptr(0)

	// If any named groups were found, create the name/number table from the list
	// created in the pre-pass.

	if !(int32((*Tcompile_block_8)(unsafe.Pointer(bp+17440)).Fnames_found) > 0) {
		goto __63
	}

	ng = (*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fnamed_groups
	i = Tuint32_t(0)
__64:
	if !(i < Tuint32_t((*Tcompile_block_8)(unsafe.Pointer(bp+17440)).Fnames_found)) {
		goto __66
	}
	add_name_to_table(tls, bp+17440, (*Tnamed_group_8)(unsafe.Pointer(ng)).Fname, int32((*Tnamed_group_8)(unsafe.Pointer(ng)).Flength), (*Tnamed_group_8)(unsafe.Pointer(ng)).Fnumber, i)
	goto __65
__65:
	i++
	ng += 16
	goto __64
	goto __66
__66:
	;
__63:
	;

	// Set up a starting, non-extracting bracket, then compile the expression. On
	// error, errorcode will be set non-zero, so we don't need to look at the result
	// of the function here.

	*(*uintptr)(unsafe.Pointer(bp + 17760 /* pptr */)) = (*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fparsed_pattern
	*(*uintptr)(unsafe.Pointer(bp + 17752 /* code */)) = codestart
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 17752 /* code */)))) = OP_BRA
	regexrc = compile_regex(tls, (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options, bp+17752, bp+17760, bp+17768, uint32(0),
		bp+17772, bp+17776, bp+17780, bp+17784, uintptr(0), bp+17440, uintptr(0))
	if !(regexrc < 0) {
		goto __67
	}
	*(*Tuint32_t)(unsafe.Pointer(re + 96)) |= Tuint32_t(DPCRE2_MATCH_EMPTY)
__67:
	;
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftop_bracket = Tuint16_t((*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fbracount)
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftop_backref = Tuint16_t((*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Ftop_backref)
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fmax_lookbehind = Tuint16_t((*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fmax_lookbehind)

	if !((*Tcompile_block_8)(unsafe.Pointer(bp+17440)).Fhad_accept != 0) {
		goto __68
	}

	*(*Tuint32_t)(unsafe.Pointer(bp + 17780 /* reqcu */)) = Tuint32_t(0) // Must disable after (*ACCEPT)
	*(*Tuint32_t)(unsafe.Pointer(bp + 17784 /* reqcuflags */)) = DREQ_NONE
	*(*Tuint32_t)(unsafe.Pointer(re + 96)) |= Tuint32_t(DPCRE2_HASACCEPT) // Disables minimum length
__68:
	;

	// Fill in the final opcode and check for disastrous overflow. If no overflow,
	// but the estimated length exceeds the really used length, adjust the value of
	// re->blocksize, and if valgrind support is configured, mark the extra allocated
	// memory as unaddressable, so that any out-of-bound reads can be detected.

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 17752 /* code */)), 1))) = OP_END
	usedlength = Tsize_t((int64(*(*uintptr)(unsafe.Pointer(bp + 17752))) - int64(codestart)) / 1)
	if !(usedlength > *(*Tsize_t)(unsafe.Pointer(bp + 17792))) {
		goto __69
	}
	*(*int32)(unsafe.Pointer(bp + 17768 /* errorcode */)) = ERR23
	goto __70
__69:

	*(*Tsize_t)(unsafe.Pointer(re + 72)) -= (*(*Tsize_t)(unsafe.Pointer(bp + 17792)) - usedlength) * uint64(DPCRE2_CODE_UNIT_WIDTH/8)
__70:
	;

	// Scan the pattern for recursion/subroutine calls and convert the group
	// numbers into offsets. Maintain a small cache so that repeated groups containing
	// recursions are efficiently handled.

	if !(*(*int32)(unsafe.Pointer(bp + 17768)) == 0 && (*Tcompile_block_8)(unsafe.Pointer(bp+17440)).Fhad_recurse != 0) {
		goto __71
	}

	ccount = uint32(0)
	start = DRSCAN_CACHE_SIZE

	rcode = find_recurse(tls, codestart, utf)
__72:
	if !(rcode != uintptr(0)) {
		goto __74
	}

	groupnumber = int32(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(rcode + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(rcode + 2)))))
	if !(groupnumber == 0) {
		goto __75
	}
	rgroup = codestart
	goto __76
__75:

	search_from = codestart
	rgroup = uintptr(0)
	i = Tuint32_t(0)
	p1 = start
__77:
	if !(i < ccount) {
		goto __79
	}

	if !(groupnumber == (*Trecurse_cache)(unsafe.Pointer(bp+17800+uintptr(p1)*16)).Fgroupnumber) {
		goto __80
	}

	rgroup = (*Trecurse_cache)(unsafe.Pointer(bp + 17800 + uintptr(p1)*16)).Fgroup
	goto __79
__80:
	;

	// Group n+1 must always start to the right of group n, so we can save
	//         search time below when the new group number is greater than any of the
	//         previously found groups.

	if !(groupnumber > (*Trecurse_cache)(unsafe.Pointer(bp+17800+uintptr(p1)*16)).Fgroupnumber) {
		goto __81
	}
	search_from = (*Trecurse_cache)(unsafe.Pointer(bp + 17800 + uintptr(p1)*16)).Fgroup
__81:
	;
	goto __78
__78:
	i++
	p1 = (p1 + 1) & 7
	goto __77
	goto __79
__79:
	;

	if !(rgroup == uintptr(0)) {
		goto __82
	}

	rgroup = X_pcre2_find_bracket_8(tls, search_from, utf, groupnumber)
	if !(rgroup == uintptr(0)) {
		goto __83
	}

	*(*int32)(unsafe.Pointer(bp + 17768 /* errorcode */)) = ERR53
	goto __74
__83:
	;
	if !(libc.PreDecInt32(&start, 1) < 0) {
		goto __84
	}
	start = DRSCAN_CACHE_SIZE - 1
__84:
	;
	(*Trecurse_cache)(unsafe.Pointer(bp + 17800 + uintptr(start)*16)).Fgroupnumber = groupnumber
	(*Trecurse_cache)(unsafe.Pointer(bp + 17800 + uintptr(start)*16)).Fgroup = rgroup
	if !(ccount < uint32(DRSCAN_CACHE_SIZE)) {
		goto __85
	}
	ccount++
__85:
	;
__82:
	;
__76:
	;

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(rcode + 1)) = TPCRE2_UCHAR8((int64(rgroup) - int64(codestart)) / 1 >> 8)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(rcode + 2)) = TPCRE2_UCHAR8((int64(rgroup) - int64(codestart)) / 1 & int64(255))
	goto __73
__73:
	rcode = find_recurse(tls, rcode+uintptr(1)+uintptr(DLINK_SIZE), utf)
	goto __72
	goto __74
__74:
	;
__71:
	;

	// In rare debugging situations we sometimes need to look at the compiled code
	// at this stage.

	// Unless disabled, check whether any single character iterators can be
	// auto-possessified. The function overwrites the appropriate opcode values, so
	// the type of the pointer must be cast. NOTE: the intermediate variable "temp" is
	// used in this code because at least one compiler gives a warning about loss of
	// "const" attribute if the cast (PCRE2_UCHAR *)codestart is used directly in the
	// function call.

	if !(*(*int32)(unsafe.Pointer(bp + 17768)) == 0 && (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_NO_AUTO_POSSESS == Tuint32_t(0)) {
		goto __86
	}

	temp = codestart
	if !(X_pcre2_auto_possessify_8(tls, temp, bp+17440) != 0) {
		goto __87
	}
	*(*int32)(unsafe.Pointer(bp + 17768 /* errorcode */)) = ERR80
__87:
	;
__86:
	;

	// Failed to compile, or error while post-processing.

	if !(*(*int32)(unsafe.Pointer(bp + 17768)) != 0) {
		goto __88
	}
	goto HAD_CB_ERROR
__88:
	;

	// Successful compile. If the anchored option was not passed, set it if
	// we can determine that the pattern is anchored by virtue of ^ characters or \A
	// or anything else, such as starting with non-atomic .* when DOTALL is set and
	// there are no occurrences of *PRUNE or *SKIP (though there is an option to
	// disable this case).

	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_ANCHORED == Tuint32_t(0) && is_anchored(tls, codestart, uint32(0), bp+17440, 0, DFALSE) != 0) {
		goto __89
	}
	*(*Tuint32_t)(unsafe.Pointer(re + 88)) |= DPCRE2_ANCHORED
__89:
	;

	// Set up the first code unit or startline flag, the required code unit, and
	// then study the pattern. This code need not be obeyed if PCRE2_NO_START_OPTIMIZE
	// is set, as the data it would create will not be used. Note that a first code
	// unit (but not the startline flag) is useful for anchored patterns because it
	// can still give a quick "no match" and also avoid searching for a last code
	// unit.

	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_NO_START_OPTIMIZE == Tuint32_t(0)) {
		goto __90
	}

	minminlength = 0 // For minimal minlength from first/required CU

	// If we do not have a first code unit, see if there is one that is asserted
	//   (these are not saved during the compile because they can cause conflicts with
	//   actual literals that follow).

	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 17776)) >= DREQ_NONE) {
		goto __91
	}
	*(*Tuint32_t)(unsafe.Pointer(bp + 17772 /* firstcu */)) = find_firstassertedcu(tls, codestart, bp+17776, uint32(0))
__91:
	;

	// Save the data for a first code unit. The existence of one means the
	//   minimum length must be at least 1.

	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 17776)) < DREQ_NONE) {
		goto __92
	}

	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ffirst_codeunit = *(*Tuint32_t)(unsafe.Pointer(bp + 17772 /* firstcu */))
	*(*Tuint32_t)(unsafe.Pointer(re + 96)) |= Tuint32_t(DPCRE2_FIRSTSET)
	minminlength++

	// Handle caseless first code units.

	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 17776))&DREQ_CASELESS != Tuint32_t(0)) {
		goto __94
	}

	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 17772)) < Tuint32_t(128) || !(utf != 0) && !(ucp != 0) && *(*Tuint32_t)(unsafe.Pointer(bp + 17772)) < Tuint32_t(255)) {
		goto __95
	}

	if !(Tuint32_t(*(*Tuint8_t)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(bp+17440)).Ffcc + uintptr(*(*Tuint32_t)(unsafe.Pointer(bp + 17772)))))) != *(*Tuint32_t)(unsafe.Pointer(bp + 17772))) {
		goto __97
	}
	*(*Tuint32_t)(unsafe.Pointer(re + 96)) |= Tuint32_t(DPCRE2_FIRSTCASELESS)
__97:
	;
	goto __96
__95:
	if !(ucp != 0 && !(utf != 0) && Tuint32_t(int32(*(*Tuint32_t)(unsafe.Pointer(bp + 17772)))+(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(*(*Tuint32_t)(unsafe.Pointer(bp + 17772)))/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(*(*Tuint32_t)(unsafe.Pointer(bp + 17772)))%DUCD_BLOCK_SIZE])*12)).Fother_case) != *(*Tuint32_t)(unsafe.Pointer(bp + 17772))) {
		goto __98
	}
	*(*Tuint32_t)(unsafe.Pointer(re + 96)) |= Tuint32_t(DPCRE2_FIRSTCASELESS)
__98:
	;
__96:
	;
__94:
	;
	goto __93
__92:
	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_ANCHORED == Tuint32_t(0) && is_startline(tls, codestart, uint32(0), bp+17440, 0, DFALSE) != 0) {
		goto __99
	}
	*(*Tuint32_t)(unsafe.Pointer(re + 96)) |= Tuint32_t(DPCRE2_STARTLINE)
__99:
	;
__93:
	;

	// Handle the "required code unit", if one is set. In the UTF case we can
	//   increment the minimum minimum length only if we are sure this really is a
	//   different character and not a non-starting code unit of the first character,
	//   because the minimum length count is in characters, not code units.

	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 17784)) < DREQ_NONE) {
		goto __100
	}

	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_UTF == Tuint32_t(0) || *(*Tuint32_t)(unsafe.Pointer(bp + 17776)) >= DREQ_NONE || *(*Tuint32_t)(unsafe.Pointer(bp + 17772))&Tuint32_t(0x80) == Tuint32_t(0) || *(*Tuint32_t)(unsafe.Pointer(bp + 17780))&Tuint32_t(0x80) == Tuint32_t(0)) {
		goto __101
	} /* Req is ASCII */

	minminlength++
__101:
	;

	// In the case of an anchored pattern, set up the value only if it follows
	//     a variable length item in the pattern.

	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_ANCHORED == Tuint32_t(0) || *(*Tuint32_t)(unsafe.Pointer(bp + 17784))&DREQ_VARY != Tuint32_t(0)) {
		goto __102
	}

	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flast_codeunit = *(*Tuint32_t)(unsafe.Pointer(bp + 17780 /* reqcu */))
	*(*Tuint32_t)(unsafe.Pointer(re + 96)) |= Tuint32_t(DPCRE2_LASTSET)

	// Handle caseless required code units as for first code units (above).

	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 17784))&DREQ_CASELESS != Tuint32_t(0)) {
		goto __103
	}

	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 17780)) < Tuint32_t(128) || !(utf != 0) && !(ucp != 0) && *(*Tuint32_t)(unsafe.Pointer(bp + 17780)) < Tuint32_t(255)) {
		goto __104
	}

	if !(Tuint32_t(*(*Tuint8_t)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(bp+17440)).Ffcc + uintptr(*(*Tuint32_t)(unsafe.Pointer(bp + 17780)))))) != *(*Tuint32_t)(unsafe.Pointer(bp + 17780))) {
		goto __106
	}
	*(*Tuint32_t)(unsafe.Pointer(re + 96)) |= Tuint32_t(DPCRE2_LASTCASELESS)
__106:
	;
	goto __105
__104:
	if !(ucp != 0 && !(utf != 0) && Tuint32_t(int32(*(*Tuint32_t)(unsafe.Pointer(bp + 17780)))+(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(*(*Tuint32_t)(unsafe.Pointer(bp + 17780)))/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(*(*Tuint32_t)(unsafe.Pointer(bp + 17780)))%DUCD_BLOCK_SIZE])*12)).Fother_case) != *(*Tuint32_t)(unsafe.Pointer(bp + 17780))) {
		goto __107
	}
	*(*Tuint32_t)(unsafe.Pointer(re + 96)) |= Tuint32_t(DPCRE2_LASTCASELESS)
__107:
	;
__105:
	;
__103:
	;
__102:
	;
__100:
	;

	// Study the compiled pattern to set up information such as a bitmap of
	//   starting code units and a minimum matching length.

	if !(X_pcre2_study_8(tls, re) != 0) {
		goto __108
	}

	*(*int32)(unsafe.Pointer(bp + 17768 /* errorcode */)) = ERR31
	goto HAD_CB_ERROR
__108:
	;

	// If study() set a bitmap of starting code units, it implies a minimum
	//   length of at least one.

	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&Tuint32_t(DPCRE2_FIRSTMAPSET) != Tuint32_t(0) && minminlength == 0) {
		goto __109
	}
	minminlength = 1
__109:
	;

	// If the minimum length set (or not set) by study() is less than the minimum
	//   implied by required code units, override it.

	if !(int32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fminlength) < minminlength) {
		goto __110
	}
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fminlength = Tuint16_t(minminlength)
__110:
	;
__90:
	; // End of start-of-match optimizations.

	// Control ends up here in all cases. When running under valgrind, make a
	// pattern's terminating zero defined again. If memory was obtained for the parsed
	// version of the pattern, free it before returning. Also free the list of named
	// groups if a larger one had to be obtained, and likewise the group information
	// vector.

EXIT:
	if !((*Tcompile_block_8)(unsafe.Pointer(bp+17440)).Fparsed_pattern != bp+13344) {
		goto __111
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fmemctl.Ffree})).f(tls, (*Tcompile_block_8)(unsafe.Pointer(bp+17440 /* &cb */)).Fparsed_pattern, (*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fmemctl.Fmemory_data)
__111:
	;
	if !((*Tcompile_block_8)(unsafe.Pointer(bp+17440)).Fnamed_group_list_size > Tuint32_t(DNAMED_GROUP_LIST_SIZE)) {
		goto __112
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fmemctl.Ffree})).f(tls, (*Tcompile_block_8)(unsafe.Pointer(bp+17440 /* &cb */)).Fnamed_groups, (*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fmemctl.Fmemory_data)
__112:
	;
	if !((*Tcompile_block_8)(unsafe.Pointer(bp+17440)).Fgroupinfo != bp+12000) {
		goto __113
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fmemctl.Ffree})).f(tls, (*Tcompile_block_8)(unsafe.Pointer(bp+17440 /* &cb */)).Fgroupinfo, (*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fmemctl.Fmemory_data)
__113:
	;
	return re // Will be NULL after an error

	// Errors discovered in parse_regex() set the offset value in the compile
	// block. Errors discovered before it is called must compute it from the ptr
	// value. After parse_regex() is called, the offset in the compile block is set to
	// the end of the pattern, but certain errors in compile_regex() may reset it if
	// an offset is available in the parsed pattern.

HAD_CB_ERROR:
	ptr = pattern + uintptr((*Tcompile_block_8)(unsafe.Pointer(bp+17440)).Ferroroffset)

HAD_EARLY_ERROR:
	*(*Tsize_t)(unsafe.Pointer(erroroffset)) = Tsize_t((int64(ptr) - int64(pattern)) / 1)

HAD_ERROR:
	*(*int32)(unsafe.Pointer(errorptr)) = *(*int32)(unsafe.Pointer(bp + 17768 /* errorcode */))
	Xpcre2_code_free_8(tls, re)
	re = uintptr(0)
	goto EXIT
	return uintptr(0)
}

// End of pcre2_compile.c

// ************************************************
//
//      Perl-Compatible Regular Expressions       *
//

// PCRE is a library of functions to support regular expressions whose syntax
// and semantics are as close as possible to those of the Perl 5 language.
//
//                        Written by Philip Hazel
//      Original API code Copyright (c) 1997-2012 University of Cambridge
//           New API code Copyright (c) 2016-2020 University of Cambridge
//
// -----------------------------------------------------------------------------
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//
//     * Neither the name of the University of Cambridge nor the names of its
//       contributors may be used to endorse or promote products derived from
//       this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
// -----------------------------------------------------------------------------

// src/config.h.  Generated from config.h.in by configure.
// src/config.h.in.  Generated from configure.ac by autoheader.

// PCRE2 is written in Standard C, but there are a few non-standard things it
// can cope with, allowing it to run on SunOS4 and other "close to standard"
// systems.
//
// In environments that support the GNU autotools, config.h.in is converted into
// config.h by the "configure" script. In environments that use CMake,
// config-cmake.in is converted into config.h. If you are going to build PCRE2 "by
// hand" without using "configure" or CMake, you should copy the distributed
// config.h.generic to config.h, and edit the macro definitions to be the way you
// need them. You must then add -DHAVE_CONFIG_H to all of your compile commands,
// so that config.h is included at the start of every source.
//
// Alternatively, you can avoid editing by using -D on the compiler command line
// to set the macro values. In this case, you do not have to set -DHAVE_CONFIG_H,
// but if you do, default values will be taken from config.h for non-boolean
// macros that are not defined on the command line.
//
// Boolean macros such as HAVE_STDLIB_H and SUPPORT_PCRE2_8 should either be
// defined (conventionally to 1) for TRUE, and not defined at all for FALSE. All
// such macros are listed as a commented #undef in config.h.generic. Macros such
// as MATCH_LIMIT, whose actual value is relevant, have defaults defined, but are
// surrounded by #ifndef/#endif lines so that the value can be overridden by -D.
//
// PCRE2 uses memmove() if HAVE_MEMMOVE is defined; otherwise it uses bcopy() if
// HAVE_BCOPY is defined. If your system has neither bcopy() nor memmove(), make
// sure both macros are undefined; an emulation function will then be used.

// By default, the \R escape sequence matches any Unicode line ending
//    character or sequence of characters. If BSR_ANYCRLF is defined (to any
//    value), this is changed so that backslash-R matches only CR, LF, or CRLF.
//    The build-time default can be overridden by the user of PCRE2 at runtime.
//
// #undef BSR_ANYCRLF

// Define to any value to disable the use of the z and t modifiers in
//    formatting settings such as %zu or %td (this is rarely needed).
// #undef DISABLE_PERCENT_ZT

// If you are compiling for a system that uses EBCDIC instead of ASCII
//    character codes, define this macro to any value. When EBCDIC is set, PCRE2
//    assumes that all input strings are in EBCDIC. If you do not define this
//    macro, PCRE2 will assume input strings are ASCII or UTF-8/16/32 Unicode. It
//    is not possible to build a version of PCRE2 that supports both EBCDIC and
//    UTF-8/16/32.
// #undef EBCDIC

// In an EBCDIC environment, define this macro to any value to arrange for the
//    NL character to be 0x25 instead of the default 0x15. NL plays the role that
//    LF does in an ASCII/Unicode environment.
// #undef EBCDIC_NL25

// Define this if your compiler supports __attribute__((uninitialized))
// #undef HAVE_ATTRIBUTE_UNINITIALIZED

// Define to 1 if you have the `bcopy' function.

// Define to 1 if you have the <bzlib.h> header file.

// Define to 1 if you have the <dirent.h> header file.

// Define to 1 if you have the <dlfcn.h> header file.

// Define to 1 if you have the <editline/readline.h> header file.
// #undef HAVE_EDITLINE_READLINE_H

// Define to 1 if you have the <edit/readline/readline.h> header file.
// #undef HAVE_EDIT_READLINE_READLINE_H

// Define to 1 if you have the <inttypes.h> header file.

// Define to 1 if you have the <limits.h> header file.

// Define to 1 if you have the `memfd_create' function.

// Define to 1 if you have the `memmove' function.

// Define to 1 if you have the <minix/config.h> header file.
// #undef HAVE_MINIX_CONFIG_H

// Define to 1 if you have the `mkostemp' function.

// Define if you have POSIX threads libraries and header files.
// #undef HAVE_PTHREAD

// Have PTHREAD_PRIO_INHERIT.
// #undef HAVE_PTHREAD_PRIO_INHERIT

// Define to 1 if you have the <readline.h> header file.
// #undef HAVE_READLINE_H

// Define to 1 if you have the <readline/history.h> header file.
// #undef HAVE_READLINE_HISTORY_H

// Define to 1 if you have the <readline/readline.h> header file.
// #undef HAVE_READLINE_READLINE_H

// Define to 1 if you have the `realpath' function.

// Define to 1 if you have the `secure_getenv' function.

// Define to 1 if you have the <stdint.h> header file.

// Define to 1 if you have the <stdio.h> header file.

// Define to 1 if you have the <stdlib.h> header file.

// Define to 1 if you have the `strerror' function.

// Define to 1 if you have the <strings.h> header file.

// Define to 1 if you have the <string.h> header file.

// Define to 1 if you have the <sys/stat.h> header file.

// Define to 1 if you have the <sys/types.h> header file.

// Define to 1 if you have the <sys/wait.h> header file.

// Define to 1 if you have the <unistd.h> header file.

// Define to 1 if the compiler supports simple visibility declarations.

// Define to 1 if you have the <wchar.h> header file.

// Define to 1 if you have the <windows.h> header file.
// #undef HAVE_WINDOWS_H

// Define to 1 if you have the <zlib.h> header file.

// This limits the amount of memory that may be used while matching a pattern.
//    It applies to both pcre2_match() and pcre2_dfa_match(). It does not apply
//    to JIT matching. The value is in kibibytes (units of 1024 bytes).

// The value of LINK_SIZE determines the number of bytes used to store links
//    as offsets within the compiled regex. The default is 2, which allows for
//    compiled patterns up to 65535 code units long. This covers the vast
//    majority of cases. However, PCRE2 can also be compiled to use 3 or 4 bytes
//    instead. This allows for longer patterns in extreme cases.

// Define to the sub-directory where libtool stores uninstalled libraries.

// The value of MATCH_LIMIT determines the default number of times the
//    pcre2_match() function can record a backtrack position during a single
//    matching attempt. The value is also used to limit a loop counter in
//    pcre2_dfa_match(). There is a runtime interface for setting a different
//    limit. The limit exists in order to catch runaway regular expressions that
//    take for ever to determine that they do not match. The default is set very
//    large so that it does not accidentally catch legitimate cases.

// The above limit applies to all backtracks, whether or not they are nested.
//    In some environments it is desirable to limit the nesting of backtracking
//    (that is, the depth of tree that is searched) more strictly, in order to
//    restrict the maximum amount of heap memory that is used. The value of
//    MATCH_LIMIT_DEPTH provides this facility. To have any useful effect, it
//    must be less than the value of MATCH_LIMIT. The default is to use the same
//    value as MATCH_LIMIT. There is a runtime method for setting a different
//    limit. In the case of pcre2_dfa_match(), this limit controls the depth of
//    the internal nested function calls that are used for pattern recursions,
//    lookarounds, and atomic groups.

// This limit is parameterized just in case anybody ever wants to change it.
//    Care must be taken if it is increased, because it guards against integer
//    overflow caused by enormously large patterns.

// This limit is parameterized just in case anybody ever wants to change it.
//    Care must be taken if it is increased, because it guards against integer
//    overflow caused by enormously large patterns.

// Defining NEVER_BACKSLASH_C locks out the use of \C in all patterns.
// #undef NEVER_BACKSLASH_C

// The value of NEWLINE_DEFAULT determines the default newline character
//    sequence. PCRE2 client programs can override this by selecting other values
//    at run time. The valid values are 1 (CR), 2 (LF), 3 (CRLF), 4 (ANY), 5
//    (ANYCRLF), and 6 (NUL).

// Name of package

// Define to the address where bug reports for this package should be sent.

// Define to the full name of this package.

// Define to the full name and version of this package.

// Define to the one symbol short name of this package.

// Define to the home page for this package.

// Define to the version of this package.

// The value of PARENS_NEST_LIMIT specifies the maximum depth of nested
//    parentheses (of any kind) in a pattern. This limits the amount of system
//    stack that is used while compiling a pattern.

// The value of PCRE2GREP_BUFSIZE is the starting size of the buffer used by
//    pcre2grep to hold parts of the file it is searching. The buffer will be
//    expanded up to PCRE2GREP_MAX_BUFSIZE if necessary, for files containing
//    very long lines. The actual amount of memory used by pcre2grep is three
//    times this number, because it allows for the buffering of "before" and
//    "after" lines.

// The value of PCRE2GREP_MAX_BUFSIZE specifies the maximum size of the buffer
//    used by pcre2grep to hold parts of the file it is searching. The actual
//    amount of memory used by pcre2grep is three times this number, because it
//    allows for the buffering of "before" and "after" lines.

// to make a symbol visible

// to make a symbol visible

// Define to any value to include debugging code.
// #undef PCRE2_DEBUG

// to make a symbol visible

// If you are compiling for a system other than a Unix-like system or
//    Win32, and it needs some magic to be inserted before the definition
//    of a function that is exported by the library, define this macro to
//    contain the relevant magic. If you do not define this macro, a suitable
//     __declspec value is used for Windows systems; in other environments
//    "extern" is used for a C compiler and "extern C" for a C++ compiler.
//    This macro apears at the start of every exported function that is part
//    of the external API. It does not appear on functions that are "external"
//    in the C sense, but which are internal to the library.

// Define to any value if linking statically (TODO: make nice with Libtool)
// #undef PCRE2_STATIC

// Define to necessary symbol if this constant uses a non-standard name on
//    your system.
// #undef PTHREAD_CREATE_JOINABLE

// Define to any non-zero number to enable support for SELinux compatible
//    executable memory allocator in JIT. Note that this will have no effect
//    unless SUPPORT_JIT is also defined.
// #undef SLJIT_PROT_EXECUTABLE_ALLOCATOR

// Define to 1 if all of the C90 standard headers exist (not just the ones
//    required in a freestanding environment). This macro is provided for
//    backward compatibility; new code need not use it.

// Define to any value to enable support for Just-In-Time compiling.
// #undef SUPPORT_JIT

// Define to any value to allow pcre2grep to be linked with libbz2, so that it
//    is able to handle .bz2 files.
// #undef SUPPORT_LIBBZ2

// Define to any value to allow pcre2test to be linked with libedit.
// #undef SUPPORT_LIBEDIT

// Define to any value to allow pcre2test to be linked with libreadline.
// #undef SUPPORT_LIBREADLINE

// Define to any value to allow pcre2grep to be linked with libz, so that it
//    is able to handle .gz files.
// #undef SUPPORT_LIBZ

// Define to any value to enable callout script support in pcre2grep.

// Define to any value to enable fork support in pcre2grep callout scripts.
//    This will have no effect unless SUPPORT_PCRE2GREP_CALLOUT is also defined.
//

// Define to any value to enable JIT support in pcre2grep. Note that this will
//    have no effect unless SUPPORT_JIT is also defined.
// #undef SUPPORT_PCRE2GREP_JIT

// Define to any value to enable the 16 bit PCRE2 library.
// #undef SUPPORT_PCRE2_16

// Define to any value to enable the 32 bit PCRE2 library.
// #undef SUPPORT_PCRE2_32

// Define to any value to enable the 8 bit PCRE2 library.

// Define to any value to enable support for Unicode and UTF encoding. This
//    will work even in an EBCDIC environment, but it is incompatible with the
//    EBCDIC macro. That is, PCRE2 can support *either* EBCDIC code *or*
//    ASCII/Unicode, but not both at once.

// Define to any value for valgrind support to find invalid memory reads.
// #undef SUPPORT_VALGRIND

// Enable extensions on AIX 3, Interix.
// Enable general extensions on macOS.
// Enable general extensions on Solaris.
// Enable GNU extensions on systems that have them.
// Enable X/Open compliant socket functions that do not require linking
//    with -lxnet on HP-UX 11.11.
// Identify the host operating system as Minix.
//    This macro does not affect the system headers' behavior.
//    A future release of Autoconf may stop defining this macro.
// # undef _MINIX
// Enable general extensions on NetBSD.
//    Enable NetBSD compatibility extensions on Minix.
// Enable OpenBSD compatibility extensions on NetBSD.
//    Oddly enough, this does nothing on OpenBSD.
// Define to 1 if needed for POSIX-compatible behavior.
// # undef _POSIX_SOURCE
// Define to 2 if needed for POSIX-compatible behavior.
// # undef _POSIX_1_SOURCE
// Enable POSIX-compatible threading on Solaris.
// Enable extensions specified by ISO/IEC TS 18661-5:2014.
// Enable extensions specified by ISO/IEC TS 18661-1:2014.
// Enable extensions specified by ISO/IEC TS 18661-2:2015.
// Enable extensions specified by ISO/IEC TS 18661-4:2015.
// Enable extensions specified by ISO/IEC TS 18661-3:2015.
// Enable extensions specified by ISO/IEC TR 24731-2:2010.
// Enable extensions specified by ISO/IEC 24747:2009.
// Enable extensions on HP NonStop.
// Enable X/Open extensions.  Define to 500 only if necessary
//    to make mbstate_t available.
// # undef _XOPEN_SOURCE

// Version number of package

// Define to empty if `const' does not conform to ANSI C.
// #undef const

// Define to the type of a signed integer type of width exactly 64 bits if
//    such a type exists and the standard includes do not define it.
// #undef int64_t

// Define to `unsigned int' if <sys/types.h> does not define.
// #undef size_t

// Save the configured link size, which is in bytes. In 16-bit and 32-bit modes
// its value gets changed by pcre2_intmodedep.h (included by pcre2_internal.h) to
// be in code units.

var configured_link_size int32 = DLINK_SIZE /* pcre2_config.c:49:12 */

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// These macros are the standard way of turning unquoted text into C strings.
// They allow macros like PCRE2_MAJOR to be defined without quotes, which is
// convenient for user programs that want to test their values.

// ************************************************
//
// Return info about what features are configured *
//

// If where is NULL, the length of memory required is returned.
//
// Arguments:
//   what             what information is required
//   where            where to put the information
//
// Returns:           0 if a numerical value is returned
//                    >= 0 if a string value
//                    PCRE2_ERROR_BADOPTION if "where" not recognized
//                      or JIT target requested when JIT not enabled

func Xpcre2_config_8(tls *libc.TLS, what Tuint32_t, where uintptr) int32 { /* pcre2_config.c:78:1: */
	if where == uintptr(0) {
		switch what {
		default:
			return -34
			fallthrough

		case Tuint32_t(DPCRE2_CONFIG_BSR):
			fallthrough
		case Tuint32_t(DPCRE2_CONFIG_COMPILED_WIDTHS):
			fallthrough
		case Tuint32_t(DPCRE2_CONFIG_DEPTHLIMIT):
			fallthrough
		case Tuint32_t(DPCRE2_CONFIG_HEAPLIMIT):
			fallthrough
		case Tuint32_t(DPCRE2_CONFIG_JIT):
			fallthrough
		case Tuint32_t(DPCRE2_CONFIG_LINKSIZE):
			fallthrough
		case Tuint32_t(DPCRE2_CONFIG_MATCHLIMIT):
			fallthrough
		case Tuint32_t(DPCRE2_CONFIG_NEVER_BACKSLASH_C):
			fallthrough
		case Tuint32_t(DPCRE2_CONFIG_NEWLINE):
			fallthrough
		case Tuint32_t(DPCRE2_CONFIG_PARENSLIMIT):
			fallthrough
		case Tuint32_t(DPCRE2_CONFIG_STACKRECURSE):
			fallthrough // Obsolete
		case Tuint32_t(DPCRE2_CONFIG_TABLES_LENGTH):
			fallthrough
		case Tuint32_t(DPCRE2_CONFIG_UNICODE):
			return int32(unsafe.Sizeof(Tuint32_t(0)))
			fallthrough

		// These are handled below

		case Tuint32_t(DPCRE2_CONFIG_JITTARGET):
			fallthrough
		case Tuint32_t(DPCRE2_CONFIG_UNICODE_VERSION):
			fallthrough
		case Tuint32_t(DPCRE2_CONFIG_VERSION):
			break
		}
	}

	switch what {
	default:
		return -34

	case Tuint32_t(DPCRE2_CONFIG_BSR):
		*(*Tuint32_t)(unsafe.Pointer(where)) = Tuint32_t(DPCRE2_BSR_UNICODE)
		break

	case Tuint32_t(DPCRE2_CONFIG_COMPILED_WIDTHS):
		*(*Tuint32_t)(unsafe.Pointer(where)) = Tuint32_t(0 +
			1)
		break

	case Tuint32_t(DPCRE2_CONFIG_DEPTHLIMIT):
		*(*Tuint32_t)(unsafe.Pointer(where)) = Tuint32_t(DMATCH_LIMIT)
		break

	case Tuint32_t(DPCRE2_CONFIG_HEAPLIMIT):
		*(*Tuint32_t)(unsafe.Pointer(where)) = Tuint32_t(DHEAP_LIMIT)
		break

	case Tuint32_t(DPCRE2_CONFIG_JIT):
		*(*Tuint32_t)(unsafe.Pointer(where)) = Tuint32_t(0)
		break

	case Tuint32_t(DPCRE2_CONFIG_JITTARGET):
		return -34

	case Tuint32_t(DPCRE2_CONFIG_LINKSIZE):
		*(*Tuint32_t)(unsafe.Pointer(where)) = Tuint32_t(configured_link_size)
		break

	case Tuint32_t(DPCRE2_CONFIG_MATCHLIMIT):
		*(*Tuint32_t)(unsafe.Pointer(where)) = Tuint32_t(DMATCH_LIMIT)
		break

	case Tuint32_t(DPCRE2_CONFIG_NEWLINE):
		*(*Tuint32_t)(unsafe.Pointer(where)) = Tuint32_t(DNEWLINE_DEFAULT)
		break

	case Tuint32_t(DPCRE2_CONFIG_NEVER_BACKSLASH_C):
		*(*Tuint32_t)(unsafe.Pointer(where)) = Tuint32_t(0)
		break

	case Tuint32_t(DPCRE2_CONFIG_PARENSLIMIT):
		*(*Tuint32_t)(unsafe.Pointer(where)) = Tuint32_t(DPARENS_NEST_LIMIT)
		break

	// This is now obsolete. The stack is no longer used via recursion for
	//   handling backtracking in pcre2_match().

	case Tuint32_t(DPCRE2_CONFIG_STACKRECURSE):
		*(*Tuint32_t)(unsafe.Pointer(where)) = Tuint32_t(0)
		break

	case Tuint32_t(DPCRE2_CONFIG_TABLES_LENGTH):
		*(*Tuint32_t)(unsafe.Pointer(where)) = Tuint32_t(Dcbits_offset + Dcbit_length + 256)
		break

	case Tuint32_t(DPCRE2_CONFIG_UNICODE_VERSION):
		{
			var v uintptr = X_pcre2_unicode_version_8
			return int32(uint64(1) + func() uint64 {
				if where == uintptr(0) {
					return libc.Xstrlen(tls, v)
				}
				return X_pcre2_strcpy_c8_8(tls, where, v)
			}())

		}
		break

	case Tuint32_t(DPCRE2_CONFIG_UNICODE):
		*(*Tuint32_t)(unsafe.Pointer(where)) = Tuint32_t(1)
		break

	// The hackery in setting "v" below is to cope with the case when
	//   PCRE2_PRERELEASE is set to an empty string (which it is for real releases).
	//   If the second alternative is used in this case, it does not leave a space
	//   before the date. On the other hand, if all four macros are put into a single
	//   XSTRING when PCRE2_PRERELEASE is not empty, an unwanted space is inserted.
	//   There are problems using an "obvious" approach like this:
	//
	//      XSTRING(PCRE2_MAJOR) "." XSTRING(PCRE_MINOR)
	//      XSTRING(PCRE2_PRERELEASE) " " XSTRING(PCRE_DATE)
	//
	//   because, when PCRE2_PRERELEASE is empty, this leads to an attempted expansion
	//   of STRING(). The C standard states: "If (before argument substitution) any
	//   argument consists of no preprocessing tokens, the behavior is undefined." It
	//   turns out the gcc treats this case as a single empty string - which is what
	//   we really want - but Visual C grumbles about the lack of an argument for the
	//   macro. Unfortunately, both are within their rights. As there seems to be no
	//   way to test for a macro's value being empty at compile time, we have to
	//   resort to a runtime test.

	case Tuint32_t(DPCRE2_CONFIG_VERSION):
		{
			var v uintptr
			if int32(*(*uint8)(unsafe.Pointer(ts + 630 + 1))) == 0 {
				v = ts + 632 /* "10.40 2022-04-14" */
			} else {
				v = ts + 649 /* "10.402022-04-14" */
			}
			return int32(uint64(1) + func() uint64 {
				if where == uintptr(0) {
					return libc.Xstrlen(tls, v)
				}
				return X_pcre2_strcpy_c8_8(tls, where, v)
			}())

		}
	}

	return 0
}

// End of pcre2_config.c

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// ************************************************
//
//          Default malloc/free functions         *
//

// Ignore the "user data" argument in each case.

func default_malloc(tls *libc.TLS, size Tsize_t, data uintptr) uintptr { /* pcre2_context.c:56:13: */
	_ = data
	return libc.Xmalloc(tls, size)
}

func default_free(tls *libc.TLS, block uintptr, data uintptr) { /* pcre2_context.c:63:13: */
	_ = data
	libc.Xfree(tls, block)
}

// ************************************************
//
//        Get a block and save memory control     *
//

// This internal function is called to get a block of memory in which the
// memory control data is to be stored at the start for future use.
//
// Arguments:
//   size        amount of memory required
//   memctl      pointer to a memctl block or NULL
//
// Returns:      pointer to memory or NULL on failure

func X_pcre2_memctl_malloc_8(tls *libc.TLS, size Tsize_t, memctl uintptr) uintptr { /* pcre2_context.c:85:13: */
	var newmemctl uintptr
	var yield uintptr
	if memctl == uintptr(0) {
		yield = libc.Xmalloc(tls, size)
	} else {
		yield = (*struct {
			f func(*libc.TLS, Tsize_t, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_memctl)(unsafe.Pointer(memctl)).Fmalloc})).f(tls, size, (*Tpcre2_memctl)(unsafe.Pointer(memctl)).Fmemory_data)
	}
	if yield == uintptr(0) {
		return uintptr(0)
	}
	newmemctl = yield
	if memctl == uintptr(0) {
		(*Tpcre2_memctl)(unsafe.Pointer(newmemctl)).Fmalloc = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, Tsize_t, uintptr) uintptr
		}{default_malloc}))
		(*Tpcre2_memctl)(unsafe.Pointer(newmemctl)).Ffree = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr)
		}{default_free}))
		(*Tpcre2_memctl)(unsafe.Pointer(newmemctl)).Fmemory_data = uintptr(0)
	} else {
		*(*Tpcre2_memctl)(unsafe.Pointer(newmemctl)) = *(*Tpcre2_memctl)(unsafe.Pointer(memctl))
	}
	return yield
}

// ************************************************
//
//          Create and initialize contexts        *
//

// Initializing for compile and match contexts is done in separate, private
// functions so that these can be called from functions such as pcre2_compile()
// when an external context is not supplied. The initializing functions have an
// option to set up default memory management.

func Xpcre2_general_context_create_8(tls *libc.TLS, private_malloc uintptr, private_free uintptr, memory_data uintptr) uintptr { /* pcre2_context.c:114:38: */
	var gcontext uintptr
	if private_malloc == uintptr(0) {
		private_malloc = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, Tsize_t, uintptr) uintptr
		}{default_malloc}))
	}
	if private_free == uintptr(0) {
		private_free = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr)
		}{default_free}))
	}
	gcontext = (*struct {
		f func(*libc.TLS, Tsize_t, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{private_malloc})).f(tls, uint64(unsafe.Sizeof(Tpcre2_real_general_context_8{})), memory_data)
	if gcontext == uintptr(0) {
		return uintptr(0)
	}
	(*Tpcre2_general_context_8)(unsafe.Pointer(gcontext)).Fmemctl.Fmalloc = private_malloc
	(*Tpcre2_general_context_8)(unsafe.Pointer(gcontext)).Fmemctl.Ffree = private_free
	(*Tpcre2_general_context_8)(unsafe.Pointer(gcontext)).Fmemctl.Fmemory_data = memory_data
	return gcontext
}

// A default compile context is set up to save having to initialize at run time
// when no context is supplied to the compile function.

var X_pcre2_default_compile_context_8 = Tpcre2_compile_context_8{
	Fmemctl:             Tpcre2_memctl{Fmalloc: 0, Ffree: 0}, // Stack guard data
	Ftables:             0,                                   // Character tables
	Fmax_pattern_length: libc.CplUint64(uint64(0)),
	Fbsr_convention:     Tuint16_t(DPCRE2_BSR_UNICODE), // Backslash R default
	Fnewline_convention: Tuint16_t(DNEWLINE_DEFAULT),   // Newline convention
	Fparens_nest_limit:  Tuint32_t(DPARENS_NEST_LIMIT)} /* pcre2_context.c:133:29 */

// Extra options

// The create function copies the default into the new memory, but must
// override the default memory handling functions if a gcontext was provided.

func Xpcre2_compile_context_create_8(tls *libc.TLS, gcontext uintptr) uintptr { /* pcre2_context.c:147:38: */
	var ccontext uintptr = X_pcre2_memctl_malloc_8(tls,
		uint64(unsafe.Sizeof(Tpcre2_real_compile_context_8{})), gcontext)
	if ccontext == uintptr(0) {
		return uintptr(0)
	}
	*(*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)) = X_pcre2_default_compile_context_8
	if gcontext != uintptr(0) {
		*(*Tpcre2_memctl)(unsafe.Pointer(ccontext)) = *(*Tpcre2_memctl)(unsafe.Pointer(gcontext))
	}
	return ccontext
}

// A default match context is set up to save having to initialize at run time
// when no context is supplied to a match function.

var X_pcre2_default_match_context_8 = Tpcre2_match_context_8{
	Fmemctl:       Tpcre2_memctl{Fmalloc: 0, Ffree: 0}, // Substitute callout data
	Foffset_limit: libc.CplUint64(uint64(0)),
	Fheap_limit:   Tuint32_t(DHEAP_LIMIT),
	Fmatch_limit:  Tuint32_t(DMATCH_LIMIT),
	Fdepth_limit:  Tuint32_t(DMATCH_LIMIT)} /* pcre2_context.c:163:27 */

// The create function copies the default into the new memory, but must
// override the default memory handling functions if a gcontext was provided.

func Xpcre2_match_context_create_8(tls *libc.TLS, gcontext uintptr) uintptr { /* pcre2_context.c:181:36: */
	var mcontext uintptr = X_pcre2_memctl_malloc_8(tls,
		uint64(unsafe.Sizeof(Tpcre2_real_match_context_8{})), gcontext)
	if mcontext == uintptr(0) {
		return uintptr(0)
	}
	*(*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)) = X_pcre2_default_match_context_8
	if gcontext != uintptr(0) {
		*(*Tpcre2_memctl)(unsafe.Pointer(mcontext)) = *(*Tpcre2_memctl)(unsafe.Pointer(gcontext))
	}
	return mcontext
}

// A default convert context is set up to save having to initialize at run time
// when no context is supplied to the convert function.

var X_pcre2_default_convert_context_8 = Tpcre2_convert_context_8{
	Fmemctl:         Tpcre2_memctl{Fmalloc: 0, Ffree: 0}, // Default memory handling
	Fglob_separator: Tuint32_t('\057'),                   // Default path separator
	Fglob_escape:    Tuint32_t('\134'),                   // Default escape character
} /* pcre2_context.c:197:29 */

// The create function copies the default into the new memory, but must
// override the default memory handling functions if a gcontext was provided.

func Xpcre2_convert_context_create_8(tls *libc.TLS, gcontext uintptr) uintptr { /* pcre2_context.c:211:38: */
	var ccontext uintptr = X_pcre2_memctl_malloc_8(tls,
		uint64(unsafe.Sizeof(Tpcre2_real_convert_context_8{})), gcontext)
	if ccontext == uintptr(0) {
		return uintptr(0)
	}
	*(*Tpcre2_convert_context_8)(unsafe.Pointer(ccontext)) = X_pcre2_default_convert_context_8
	if gcontext != uintptr(0) {
		*(*Tpcre2_memctl)(unsafe.Pointer(ccontext)) = *(*Tpcre2_memctl)(unsafe.Pointer(gcontext))
	}
	return ccontext
}

// ************************************************
//
//              Context copy functions            *
//

func Xpcre2_general_context_copy_8(tls *libc.TLS, gcontext uintptr) uintptr { /* pcre2_context.c:228:38: */
	var new uintptr = (*struct {
		f func(*libc.TLS, Tsize_t, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_general_context_8)(unsafe.Pointer(gcontext)).Fmemctl.Fmalloc})).f(tls, uint64(unsafe.Sizeof(Tpcre2_real_general_context_8{})),
		(*Tpcre2_general_context_8)(unsafe.Pointer(gcontext)).Fmemctl.Fmemory_data)
	if new == uintptr(0) {
		return uintptr(0)
	}
	libc.Xmemcpy(tls, new, gcontext, uint64(unsafe.Sizeof(Tpcre2_real_general_context_8{})))
	return new
}

func Xpcre2_compile_context_copy_8(tls *libc.TLS, ccontext uintptr) uintptr { /* pcre2_context.c:240:38: */
	var new uintptr = (*struct {
		f func(*libc.TLS, Tsize_t, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fmemctl.Fmalloc})).f(tls, uint64(unsafe.Sizeof(Tpcre2_real_compile_context_8{})),
		(*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fmemctl.Fmemory_data)
	if new == uintptr(0) {
		return uintptr(0)
	}
	libc.Xmemcpy(tls, new, ccontext, uint64(unsafe.Sizeof(Tpcre2_real_compile_context_8{})))
	return new
}

func Xpcre2_match_context_copy_8(tls *libc.TLS, mcontext uintptr) uintptr { /* pcre2_context.c:252:36: */
	var new uintptr = (*struct {
		f func(*libc.TLS, Tsize_t, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fmemctl.Fmalloc})).f(tls, uint64(unsafe.Sizeof(Tpcre2_real_match_context_8{})),
		(*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fmemctl.Fmemory_data)
	if new == uintptr(0) {
		return uintptr(0)
	}
	libc.Xmemcpy(tls, new, mcontext, uint64(unsafe.Sizeof(Tpcre2_real_match_context_8{})))
	return new
}

func Xpcre2_convert_context_copy_8(tls *libc.TLS, ccontext uintptr) uintptr { /* pcre2_context.c:265:38: */
	var new uintptr = (*struct {
		f func(*libc.TLS, Tsize_t, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_convert_context_8)(unsafe.Pointer(ccontext)).Fmemctl.Fmalloc})).f(tls, uint64(unsafe.Sizeof(Tpcre2_real_convert_context_8{})),
		(*Tpcre2_convert_context_8)(unsafe.Pointer(ccontext)).Fmemctl.Fmemory_data)
	if new == uintptr(0) {
		return uintptr(0)
	}
	libc.Xmemcpy(tls, new, ccontext, uint64(unsafe.Sizeof(Tpcre2_real_convert_context_8{})))
	return new
}

// ************************************************
//
//              Context free functions            *
//

func Xpcre2_general_context_free_8(tls *libc.TLS, gcontext uintptr) { /* pcre2_context.c:282:1: */
	if gcontext != uintptr(0) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_general_context_8)(unsafe.Pointer(gcontext)).Fmemctl.Ffree})).f(tls, gcontext, (*Tpcre2_general_context_8)(unsafe.Pointer(gcontext)).Fmemctl.Fmemory_data)
	}
}

func Xpcre2_compile_context_free_8(tls *libc.TLS, ccontext uintptr) { /* pcre2_context.c:290:1: */
	if ccontext != uintptr(0) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fmemctl.Ffree})).f(tls, ccontext, (*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fmemctl.Fmemory_data)
	}
}

func Xpcre2_match_context_free_8(tls *libc.TLS, mcontext uintptr) { /* pcre2_context.c:298:1: */
	if mcontext != uintptr(0) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fmemctl.Ffree})).f(tls, mcontext, (*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fmemctl.Fmemory_data)
	}
}

func Xpcre2_convert_context_free_8(tls *libc.TLS, ccontext uintptr) { /* pcre2_context.c:306:1: */
	if ccontext != uintptr(0) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_convert_context_8)(unsafe.Pointer(ccontext)).Fmemctl.Ffree})).f(tls, ccontext, (*Tpcre2_convert_context_8)(unsafe.Pointer(ccontext)).Fmemctl.Fmemory_data)
	}
}

// ************************************************
//
//             Set values in contexts             *
//

// All these functions return 0 for success or PCRE2_ERROR_BADDATA if invalid
// data is given. Only some of the functions are able to test the validity of the
// data.

// ------------ Compile context ------------

func Xpcre2_set_character_tables_8(tls *libc.TLS, ccontext uintptr, tables uintptr) int32 { /* pcre2_context.c:325:1: */
	(*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Ftables = tables
	return 0
}

func Xpcre2_set_bsr_8(tls *libc.TLS, ccontext uintptr, value Tuint32_t) int32 { /* pcre2_context.c:333:1: */
	switch value {
	case Tuint32_t(DPCRE2_BSR_ANYCRLF):
		fallthrough
	case Tuint32_t(DPCRE2_BSR_UNICODE):
		(*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fbsr_convention = Tuint16_t(value)
		return 0

	default:
		return -29
	}
	return int32(0)
}

func Xpcre2_set_max_pattern_length_8(tls *libc.TLS, ccontext uintptr, length Tsize_t) int32 { /* pcre2_context.c:348:1: */
	(*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fmax_pattern_length = length
	return 0
}

func Xpcre2_set_newline_8(tls *libc.TLS, ccontext uintptr, newline Tuint32_t) int32 { /* pcre2_context.c:355:1: */
	switch newline {
	case Tuint32_t(DPCRE2_NEWLINE_CR):
		fallthrough
	case Tuint32_t(DPCRE2_NEWLINE_LF):
		fallthrough
	case Tuint32_t(DPCRE2_NEWLINE_CRLF):
		fallthrough
	case Tuint32_t(DPCRE2_NEWLINE_ANY):
		fallthrough
	case Tuint32_t(DPCRE2_NEWLINE_ANYCRLF):
		fallthrough
	case Tuint32_t(DPCRE2_NEWLINE_NUL):
		(*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fnewline_convention = Tuint16_t(newline)
		return 0

	default:
		return -29
	}
	return int32(0)
}

func Xpcre2_set_parens_nest_limit_8(tls *libc.TLS, ccontext uintptr, limit Tuint32_t) int32 { /* pcre2_context.c:374:1: */
	(*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fparens_nest_limit = limit
	return 0
}

func Xpcre2_set_compile_extra_options_8(tls *libc.TLS, ccontext uintptr, options Tuint32_t) int32 { /* pcre2_context.c:381:1: */
	(*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fextra_options = options
	return 0
}

func Xpcre2_set_compile_recursion_guard_8(tls *libc.TLS, ccontext uintptr, guard uintptr, user_data uintptr) int32 { /* pcre2_context.c:388:1: */
	(*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fstack_guard = guard
	(*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fstack_guard_data = user_data
	return 0
}

// ------------ Match context ------------

func Xpcre2_set_callout_8(tls *libc.TLS, mcontext uintptr, callout uintptr, callout_data uintptr) int32 { /* pcre2_context.c:400:1: */
	(*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fcallout = callout
	(*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fcallout_data = callout_data
	return 0
}

func Xpcre2_set_substitute_callout_8(tls *libc.TLS, mcontext uintptr, substitute_callout uintptr, substitute_callout_data uintptr) int32 { /* pcre2_context.c:409:1: */
	(*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fsubstitute_callout = substitute_callout
	(*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fsubstitute_callout_data = substitute_callout_data
	return 0
}

func Xpcre2_set_heap_limit_8(tls *libc.TLS, mcontext uintptr, limit Tuint32_t) int32 { /* pcre2_context.c:419:1: */
	(*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fheap_limit = limit
	return 0
}

func Xpcre2_set_match_limit_8(tls *libc.TLS, mcontext uintptr, limit Tuint32_t) int32 { /* pcre2_context.c:426:1: */
	(*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fmatch_limit = limit
	return 0
}

func Xpcre2_set_depth_limit_8(tls *libc.TLS, mcontext uintptr, limit Tuint32_t) int32 { /* pcre2_context.c:433:1: */
	(*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fdepth_limit = limit
	return 0
}

func Xpcre2_set_offset_limit_8(tls *libc.TLS, mcontext uintptr, limit Tsize_t) int32 { /* pcre2_context.c:440:1: */
	(*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Foffset_limit = limit
	return 0
}

// This function became obsolete at release 10.30. It is kept as a synonym for
// backwards compatibility.

func Xpcre2_set_recursion_limit_8(tls *libc.TLS, mcontext uintptr, limit Tuint32_t) int32 { /* pcre2_context.c:450:1: */
	return Xpcre2_set_depth_limit_8(tls, mcontext, limit)
}

func Xpcre2_set_recursion_memory_management_8(tls *libc.TLS, mcontext uintptr, mymalloc uintptr, myfree uintptr, mydata uintptr) int32 { /* pcre2_context.c:456:1: */
	_ = mcontext
	_ = mymalloc
	_ = myfree
	_ = mydata
	return 0
}

// ------------ Convert context ------------

func Xpcre2_set_glob_separator_8(tls *libc.TLS, ccontext uintptr, separator Tuint32_t) int32 { /* pcre2_context.c:470:1: */
	if separator != Tuint32_t('\057') && separator != Tuint32_t('\134') && separator != Tuint32_t('\056') {
		return -29
	}
	(*Tpcre2_convert_context_8)(unsafe.Pointer(ccontext)).Fglob_separator = separator
	return 0
}

func Xpcre2_set_glob_escape_8(tls *libc.TLS, ccontext uintptr, escape Tuint32_t) int32 { /* pcre2_context.c:479:1: */
	if escape > Tuint32_t(255) || escape != Tuint32_t(0) && !(int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(escape))*2)))&int32(_ISpunct) != 0) {
		return -29
	}
	(*Tpcre2_convert_context_8)(unsafe.Pointer(ccontext)).Fglob_escape = escape
	return 0
}

// End of pcre2_context.c

// Macro to add a character string to the output buffer, checking for overflow.

// Literals that must be escaped: \ ? * + | . ^ $ { } [ ] ( )

var pcre2_escaped_literals uintptr = ts + 665 /* "\\?*+|.^${}[]()" */ /* pcre2_convert.c:87:19 */

// Recognized escaped metacharacters in POSIX basic patterns.

var posix_meta_escapes uintptr = ts + 680 /* "(){}123456789" */ /* pcre2_convert.c:96:19 */

// ************************************************
//
//           Convert a POSIX pattern              *
//

// This function handles both basic and extended POSIX patterns.
//
// Arguments:
//   pattype        the pattern type
//   pattern        the pattern
//   plength        length in code units
//   utf            TRUE if UTF
//   use_buffer     where to put the output
//   use_length     length of use_buffer
//   bufflenptr     where to put the used length
//   dummyrun       TRUE if a dummy run
//   ccontext       the convert context
//
// Returns:         0 => success
//                 !0 => error code

func convert_posix(tls *libc.TLS, pattype Tuint32_t, pattern TPCRE2_SPTR8, plength Tsize_t, utf TBOOL, use_buffer uintptr, use_length Tsize_t, bufflenptr uintptr, dummyrun TBOOL, ccontext uintptr) int32 { /* pcre2_convert.c:125:1: */
	var s uintptr
	var posix TPCRE2_SPTR8
	var p uintptr
	var pp uintptr
	var endp uintptr // Allow for trailing zero
	var convlength Tsize_t
	var bracount Tuint32_t
	var posix_state Tuint32_t
	var lastspecial Tuint32_t
	var extended TBOOL
	var nextisliteral TBOOL
	var c Tuint32_t
	var sc Tuint32_t
	var clength int32
	posix = pattern
	p = use_buffer
	pp = p
	endp = p + uintptr(use_length) - uintptr(1)
	convlength = uint64(0)
	bracount = Tuint32_t(0)
	posix_state = POSIX_START_REGEX
	lastspecial = Tuint32_t(0)
	extended = libc.Bool32(pattype&DPCRE2_CONVERT_POSIX_EXTENDED != Tuint32_t(0))
	nextisliteral = DFALSE

	_ = utf      // Not used when Unicode not supported
	_ = ccontext // Not currently used

	// Initialize default for error offset as end of input.

	*(*Tsize_t)(unsafe.Pointer(bufflenptr)) = plength
	s = ts + 694
__1:
	if !(int32(*(*uint8)(unsafe.Pointer(s))) != 0) {
		goto __3
	}
	if !(p >= endp) {
		goto __4
	}
	return -48
__4:
	;
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))) = TPCRE2_UCHAR8(*(*uint8)(unsafe.Pointer(s)))
	goto __2
__2:
	s++
	goto __1
	goto __3
__3:
	;

	// Now scan the input.

__5:
	if !(plength > uint64(0)) {
		goto __6
	}
	clength = 1

	// Add in the length of the last item, then, if in the dummy run, pull the
	//   pointer back to the start of the (temporary) buffer and then remember the
	//   start of the next item.

	convlength = convlength + Tsize_t((int64(p)-int64(pp))/1)
	if !(dummyrun != 0) {
		goto __7
	}
	p = use_buffer
__7:
	;
	pp = p

	// Pick up the next character

	c = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(posix)))
	if !(utf != 0 && c >= 0xc0) {
		goto __8
	}
	if !(c&0x20 == Tuint32_t(0)) {
		goto __9
	}
	c = c&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(posix + 1)))&0x3f
	clength++
	goto __10
__9:
	if !(c&0x10 == Tuint32_t(0)) {
		goto __11
	}
	c = c&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(posix + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(posix + 2)))&0x3f
	clength = clength + 2
	goto __12
__11:
	if !(c&0x08 == Tuint32_t(0)) {
		goto __13
	}
	c = c&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(posix + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(posix + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(posix + 3)))&0x3f
	clength = clength + 3
	goto __14
__13:
	if !(c&0x04 == Tuint32_t(0)) {
		goto __15
	}
	c = c&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(posix + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(posix + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(posix + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(posix + 4)))&0x3f
	clength = clength + 4
	goto __16
__15:
	c = c&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(posix + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(posix + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(posix + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(posix + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(posix + 5)))&0x3f
	clength = clength + 5
__16:
	;
__14:
	;
__12:
	;
__10:
	;
__8:
	;

	posix += TPCRE2_SPTR8(clength)
	plength = plength - Tsize_t(clength)

	if nextisliteral != 0 {
		sc = uint32(0)
	} else {
		sc = c
	}
	nextisliteral = DFALSE

	// Handle a character within a class.

	if !(posix_state >= POSIX_CLASS_NOT_STARTED) {
		goto __17
	}

	if !(c == Tuint32_t('\135')) {
		goto __19
	}

	s = ts + 701
__21:
	if !(int32(*(*uint8)(unsafe.Pointer(s))) != 0) {
		goto __23
	}
	if !(p >= endp) {
		goto __24
	}
	return -48
__24:
	;
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))) = TPCRE2_UCHAR8(*(*uint8)(unsafe.Pointer(s)))
	goto __22
__22:
	s++
	goto __21
	goto __23
__23:
	;

	posix_state = POSIX_NOT_BRACKET
	goto __20
__19:

	switch posix_state {
	case POSIX_CLASS_STARTED:
		goto __26
	// Fall through

	case POSIX_CLASS_NOT_STARTED:
		goto __27

	case POSIX_CLASS_STARTING:
		goto __28
	}
	goto __25

__26:
	if !(c <= Tuint32_t(127) && int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(c))*2)))&int32(_ISlower) != 0) {
		goto __29
	}
	goto __25
__29:
	; // Remain in started state
	posix_state = POSIX_CLASS_NOT_STARTED
	if !(c == Tuint32_t('\072') && plength > uint64(0) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(posix))) == '\135') {
		goto __30
	}

	s = ts + 703
__31:
	if !(int32(*(*uint8)(unsafe.Pointer(s))) != 0) {
		goto __33
	}
	if !(p >= endp) {
		goto __34
	}
	return -48
__34:
	;
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))) = TPCRE2_UCHAR8(*(*uint8)(unsafe.Pointer(s)))
	goto __32
__32:
	s++
	goto __31
	goto __33
__33:
	;

	plength--
	posix++
	goto __5 // With next character after :]
__30:
	;
	// Fall through

__27:
	if !(c == Tuint32_t('\133')) {
		goto __35
	}
	posix_state = POSIX_CLASS_STARTING
__35:
	;
	goto __25

__28:
	if !(c == Tuint32_t('\072')) {
		goto __36
	}
	posix_state = POSIX_CLASS_STARTED
__36:
	;
	goto __25
__25:
	;

	if !(c == Tuint32_t('\134')) {
		goto __37
	}
	s = ts + 706
__38:
	if !(int32(*(*uint8)(unsafe.Pointer(s))) != 0) {
		goto __40
	}
	if !(p >= endp) {
		goto __41
	}
	return -48
__41:
	;
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))) = TPCRE2_UCHAR8(*(*uint8)(unsafe.Pointer(s)))
	goto __39
__39:
	s++
	goto __38
	goto __40
__40:
	;
__37:
	;

	if !(p+uintptr(clength) > endp) {
		goto __42
	}
	return -48
__42:
	;
	libc.Xmemcpy(tls, p, posix-uintptr(clength), uint64(clength*(DPCRE2_CODE_UNIT_WIDTH/8)))
	p += uintptr(clength)
__20:
	;
	goto __18
__17:
	switch sc {
	case Tuint32_t('\133'):
		goto __44

	case Tuint32_t('\134'):
		goto __45

	case Tuint32_t('\051'):
		goto __46

	case Tuint32_t('\050'):
		goto __47
	// Fall through

	case Tuint32_t('\077'):
		goto __48
	case Tuint32_t('\053'):
		goto __49
	case Tuint32_t('\173'):
		goto __50
	case Tuint32_t('\175'):
		goto __51
	case Tuint32_t('\174'):
		goto __52
	// Fall through

	case Tuint32_t('\056'):
		goto __53
	case Tuint32_t('\044'):
		goto __54

	case Tuint32_t('\052'):
		goto __55 // Ignore second and subsequent asterisks

	case Tuint32_t('\136'):
		goto __56
	// Fall through

	default:
		goto __57
	}
	goto __43

__44:
	s = ts + 708
__58:
	if !(int32(*(*uint8)(unsafe.Pointer(s))) != 0) {
		goto __60
	}
	if !(p >= endp) {
		goto __61
	}
	return -48
__61:
	;
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))) = TPCRE2_UCHAR8(*(*uint8)(unsafe.Pointer(s)))
	goto __59
__59:
	s++
	goto __58
	goto __60
__60:
	;

	// Handle start of "normal" character classes

	posix_state = POSIX_CLASS_NOT_STARTED

	// Handle ^ and ] as first characters

	if !(plength > uint64(0)) {
		goto __62
	}

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(posix))) == '\136') {
		goto __63
	}

	posix++
	plength--
	s = ts + 710
__64:
	if !(int32(*(*uint8)(unsafe.Pointer(s))) != 0) {
		goto __66
	}
	if !(p >= endp) {
		goto __67
	}
	return -48
__67:
	;
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))) = TPCRE2_UCHAR8(*(*uint8)(unsafe.Pointer(s)))
	goto __65
__65:
	s++
	goto __64
	goto __66
__66:
	;

__63:
	;
	if !(plength > uint64(0) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(posix))) == '\135') {
		goto __68
	}

	posix++
	plength--
	s = ts + 701
__69:
	if !(int32(*(*uint8)(unsafe.Pointer(s))) != 0) {
		goto __71
	}
	if !(p >= endp) {
		goto __72
	}
	return -48
__72:
	;
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))) = TPCRE2_UCHAR8(*(*uint8)(unsafe.Pointer(s)))
	goto __70
__70:
	s++
	goto __69
	goto __71
__71:
	;

__68:
	;
__62:
	;
	goto __43

__45:
	if !(plength == uint64(0)) {
		goto __73
	}
	return DPCRE2_ERROR_END_BACKSLASH
__73:
	;
	if !(extended != 0) {
		goto __74
	}
	nextisliteral = DTRUE
	goto __75
__74:

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(posix))) < 127 && libc.Xstrchr(tls, posix_meta_escapes, int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(posix)))) != uintptr(0)) {
		goto __76
	}

	if !(int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(posix))))*2)))&int32(_ISdigit) != 0) {
		goto __78
	}
	s = ts + 706
__79:
	if !(int32(*(*uint8)(unsafe.Pointer(s))) != 0) {
		goto __81
	}
	if !(p >= endp) {
		goto __82
	}
	return -48
__82:
	;
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))) = TPCRE2_UCHAR8(*(*uint8)(unsafe.Pointer(s)))
	goto __80
__80:
	s++
	goto __79
	goto __81
__81:
	;
__78:
	;

	if !(p+uintptr(1) > endp) {
		goto __83
	}
	return -48
__83:
	;
	lastspecial = Tuint32_t(libc.AssignPtrUint8(libc.PostIncUintptr(&p, 1), *(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&posix, 1)))))
	plength--
	goto __77
__76:
	nextisliteral = DTRUE
__77:
	;
__75:
	;
	goto __43

__46:
	if !(!(extended != 0) || bracount == Tuint32_t(0)) {
		goto __84
	}
	goto ESCAPE_LITERAL
__84:
	;
	bracount--
	goto COPY_SPECIAL

__47:
	bracount++
	// Fall through

__48:
__49:
__50:
__51:
__52:
	if !!(extended != 0) {
		goto __85
	}
	goto ESCAPE_LITERAL
__85:
	;
	// Fall through

__53:
__54:
	posix_state = POSIX_NOT_BRACKET
COPY_SPECIAL:
	lastspecial = c
	if !(p+uintptr(1) > endp) {
		goto __86
	}
	return -48
__86:
	;
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))) = TPCRE2_UCHAR8(c)
	goto __43

__55:
	if !(lastspecial != Tuint32_t('\052')) {
		goto __87
	}

	if !(!(extended != 0) && (posix_state < POSIX_NOT_BRACKET || lastspecial == Tuint32_t('\050'))) {
		goto __88
	}
	goto ESCAPE_LITERAL
__88:
	;
	goto COPY_SPECIAL
__87:
	;
	goto __43 // Ignore second and subsequent asterisks

__56:
	if !(extended != 0) {
		goto __89
	}
	goto COPY_SPECIAL
__89:
	;
	if !(posix_state == POSIX_START_REGEX || lastspecial == Tuint32_t('\050')) {
		goto __90
	}

	posix_state = POSIX_ANCHORED
	goto COPY_SPECIAL
__90:
	;
	// Fall through

__57:
	if !(c < Tuint32_t(128) && libc.Xstrchr(tls, pcre2_escaped_literals, int32(c)) != uintptr(0)) {
		goto __91
	}

ESCAPE_LITERAL:
	s = ts + 706
__92:
	if !(int32(*(*uint8)(unsafe.Pointer(s))) != 0) {
		goto __94
	}
	if !(p >= endp) {
		goto __95
	}
	return -48
__95:
	;
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))) = TPCRE2_UCHAR8(*(*uint8)(unsafe.Pointer(s)))
	goto __93
__93:
	s++
	goto __92
	goto __94
__94:
	;

__91:
	;
	lastspecial = Tuint32_t(0xff) // Indicates nothing special
	if !(p+uintptr(clength) > endp) {
		goto __96
	}
	return -48
__96:
	;
	libc.Xmemcpy(tls, p, posix-uintptr(clength), uint64(clength*(DPCRE2_CODE_UNIT_WIDTH/8)))
	p += uintptr(clength)
	posix_state = POSIX_NOT_BRACKET
	goto __43
__43:
	;
__18:
	;
	goto __5
__6:
	;

	if !(posix_state >= POSIX_CLASS_NOT_STARTED) {
		goto __97
	}
	return DPCRE2_ERROR_MISSING_SQUARE_BRACKET
__97:
	;
	convlength = convlength + Tsize_t((int64(p)-int64(pp))/1) // Final segment
	*(*Tsize_t)(unsafe.Pointer(bufflenptr)) = convlength
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))) = TPCRE2_UCHAR8(0)
	return 0
}

// ************************************************
//
//           Convert a glob pattern               *
//

// Context for writing the output into a buffer.

type Spcre2_output_context = struct {
	Foutput      uintptr
	Foutput_end  TPCRE2_SPTR8
	Foutput_size Tsize_t
	Fout_str     [8]Tuint8_t
} /* pcre2_convert.c:369:9 */

// ************************************************
//
//           Convert a glob pattern               *
//

// Context for writing the output into a buffer.

type Tpcre2_output_context = Spcre2_output_context /* pcre2_convert.c:374:3 */

// Write a character into the output.
//
// Arguments:
//   out            output context
//   chr            the next character

func convert_glob_write(tls *libc.TLS, out uintptr, chr TPCRE2_UCHAR8) { /* pcre2_convert.c:385:1: */
	(*Tpcre2_output_context)(unsafe.Pointer(out)).Foutput_size++

	if (*Tpcre2_output_context)(unsafe.Pointer(out)).Foutput < (*Tpcre2_output_context)(unsafe.Pointer(out)).Foutput_end {
		*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Tpcre2_output_context)(unsafe.Pointer(out)).Foutput, 1))) = chr
	}
}

// Write a string into the output.
//
// Arguments:
//   out            output context
//   length         length of out->out_str

func convert_glob_write_str(tls *libc.TLS, out uintptr, length Tsize_t) { /* pcre2_convert.c:402:1: */
	var out_str uintptr = out + 24 /* &.out_str */
	var output uintptr = (*Tpcre2_output_context)(unsafe.Pointer(out)).Foutput
	var output_end TPCRE2_SPTR8 = (*Tpcre2_output_context)(unsafe.Pointer(out)).Foutput_end
	var output_size Tsize_t = (*Tpcre2_output_context)(unsafe.Pointer(out)).Foutput_size

	for __ccgo := true; __ccgo; __ccgo = libc.PreDecUint64(&length, 1) != uint64(0) {
		output_size++

		if output < output_end {
			*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&output, 1))) = *(*Tuint8_t)(unsafe.Pointer(libc.PostIncUintptr(&out_str, 1)))
		}
	}

	(*Tpcre2_output_context)(unsafe.Pointer(out)).Foutput = output
	(*Tpcre2_output_context)(unsafe.Pointer(out)).Foutput_size = output_size
}

// Prints the separator into the output.
//
// Arguments:
//   out            output context
//   separator      glob separator
//   with_escape    backslash is needed before separator

func convert_glob_print_separator(tls *libc.TLS, out uintptr, separator TPCRE2_UCHAR8, with_escape TBOOL) { /* pcre2_convert.c:432:1: */
	if with_escape != 0 {
		convert_glob_write(tls, out, uint8('\134'))
	}

	convert_glob_write(tls, out, separator)
}

// Prints a wildcard into the output.
//
// Arguments:
//   out            output context
//   separator      glob separator
//   with_escape    backslash is needed before separator

func convert_glob_print_wildcard(tls *libc.TLS, out uintptr, separator TPCRE2_UCHAR8, with_escape TBOOL) { /* pcre2_convert.c:451:1: */
	*(*Tuint8_t)(unsafe.Pointer(out + 24)) = Tuint8_t('\133')
	*(*Tuint8_t)(unsafe.Pointer(out + 24 + 1)) = Tuint8_t('\136')
	convert_glob_write_str(tls, out, uint64(2))

	convert_glob_print_separator(tls, out, separator, with_escape)

	convert_glob_write(tls, out, uint8('\135'))
}

// Parse a posix class.
//
// Arguments:
//   from           starting point of scanning the range
//   pattern_end    end of pattern
//   out            output context
//
// Returns:  >0 => class index
//           0  => malformed class

func convert_glob_parse_class(tls *libc.TLS, from uintptr, pattern_end TPCRE2_SPTR8, out uintptr) int32 { /* pcre2_convert.c:476:1: */
	var start TPCRE2_SPTR8 = *(*TPCRE2_SPTR8)(unsafe.Pointer(from)) + uintptr(1)
	var pattern TPCRE2_SPTR8 = start
	var class_ptr uintptr
	var c TPCRE2_UCHAR8
	var class_index int32

	for 1 != 0 {
		if pattern >= pattern_end {
			return 0
		}

		c = *(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&pattern, 1)))

		if int32(c) < '\141' || int32(c) > '\172' {
			break
		}
	}

	if int32(c) != '\072' || pattern >= pattern_end || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern))) != '\135' {
		return 0
	}

	class_ptr = posix_classes
	class_index = 1

	for 1 != 0 {
		if int32(*(*uint8)(unsafe.Pointer(class_ptr))) == 0 {
			return 0
		}

		pattern = start

		for int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern))) == int32(TPCRE2_UCHAR8(*(*uint8)(unsafe.Pointer(class_ptr)))) {
			if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern))) == '\072' {
				pattern += uintptr(2)
				start -= uintptr(2)

				for __ccgo := true; __ccgo; __ccgo = start < pattern {
					convert_glob_write(tls, out, *(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&start, 1))))
				}

				*(*TPCRE2_SPTR8)(unsafe.Pointer(from)) = pattern
				return class_index
			}
			pattern++
			class_ptr++
		}

		for int32(*(*uint8)(unsafe.Pointer(class_ptr))) != '\072' {
			class_ptr++
		}
		class_ptr++
		class_index++
	}
	return int32(0)
}

var posix_classes uintptr = ts + 712 /* "alnum:alpha:asci..." */ /* pcre2_convert.c:479:19 */

// Checks whether the character is in the class.
//
// Arguments:
//   class_index    class index
//   c              character
//
// Returns:   !0 => character is found in the class
//             0 => otherwise

func convert_glob_char_in_class(tls *libc.TLS, class_index int32, c TPCRE2_UCHAR8) TBOOL { /* pcre2_convert.c:542:1: */
	switch class_index {
	case 1:
		return int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(c))*2))) & int32(_ISalnum)
	case 2:
		return int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(c))*2))) & int32(_ISalpha)
	case 3:
		return 1
	case 4:
		return libc.Bool32(int32(c) == '\011' || int32(c) == '\040')
	case 5:
		return int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(c))*2))) & int32(_IScntrl)
	case 6:
		return int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(c))*2))) & int32(_ISdigit)
	case 7:
		return int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(c))*2))) & int32(_ISgraph)
	case 8:
		return int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(c))*2))) & int32(_ISlower)
	case 9:
		return int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(c))*2))) & int32(_ISprint)
	case 10:
		return int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(c))*2))) & int32(_ISpunct)
	case 11:
		return int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(c))*2))) & int32(_ISspace)
	case 12:
		return int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(c))*2))) & int32(_ISupper)
	case 13:
		return libc.Bool32(int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(c))*2)))&int32(_ISalnum) != 0 || int32(c) == '\137')
	default:
		return int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(c))*2))) & int32(_ISxdigit)
	}
	return TBOOL(0)
}

// Parse a range of characters.
//
// Arguments:
//   from           starting point of scanning the range
//   pattern_end    end of pattern
//   out            output context
//   separator      glob separator
//   with_escape    backslash is needed before separator
//
// Returns:         0 => success
//                 !0 => error code

func convert_glob_parse_range(tls *libc.TLS, from uintptr, pattern_end TPCRE2_SPTR8, out uintptr, utf TBOOL, separator TPCRE2_UCHAR8, with_escape TBOOL, escape TPCRE2_UCHAR8, no_wildsep TBOOL) int32 { /* pcre2_convert.c:577:1: */
	var is_negative TBOOL = DFALSE
	var separator_seen TBOOL = DFALSE
	var has_prev_c TBOOL
	var pattern TPCRE2_SPTR8 = *(*TPCRE2_SPTR8)(unsafe.Pointer(from))
	var char_start TPCRE2_SPTR8 = uintptr(0)
	var c Tuint32_t
	var prev_c Tuint32_t
	var len int32
	var class_index int32

	_ = utf // Avoid compiler warning.

	if pattern >= pattern_end {
		*(*TPCRE2_SPTR8)(unsafe.Pointer(from)) = pattern
		return DPCRE2_ERROR_MISSING_SQUARE_BRACKET
	}

	if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern))) == '\041' ||
		int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern))) == '\136' {
		pattern++

		if pattern >= pattern_end {
			*(*TPCRE2_SPTR8)(unsafe.Pointer(from)) = pattern
			return DPCRE2_ERROR_MISSING_SQUARE_BRACKET
		}

		is_negative = DTRUE

		*(*Tuint8_t)(unsafe.Pointer(out + 24)) = Tuint8_t('\133')
		*(*Tuint8_t)(unsafe.Pointer(out + 24 + 1)) = Tuint8_t('\136')
		len = 2

		if !(no_wildsep != 0) {
			if with_escape != 0 {
				*(*Tuint8_t)(unsafe.Pointer(out + 24 + uintptr(len))) = Tuint8_t('\134')
				len++
			}
			*(*Tuint8_t)(unsafe.Pointer(out + 24 + uintptr(len))) = separator
		}

		convert_glob_write_str(tls, out, uint64(len+1))
	} else {
		convert_glob_write(tls, out, uint8('\133'))
	}

	has_prev_c = DFALSE
	prev_c = Tuint32_t(0)

	if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern))) == '\135' {
		*(*Tuint8_t)(unsafe.Pointer(out + 24)) = Tuint8_t('\134')
		*(*Tuint8_t)(unsafe.Pointer(out + 24 + 1)) = Tuint8_t('\135')
		convert_glob_write_str(tls, out, uint64(2))
		has_prev_c = DTRUE
		prev_c = Tuint32_t('\135')
		pattern++
	}

	for pattern < pattern_end {
		char_start = pattern
		c = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&pattern, 1))))
		if utf != 0 && c >= 0xc0 {
			if c&0x20 == Tuint32_t(0) {
				c = c&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&pattern, 1))))&0x3f
			} else if c&0x10 == Tuint32_t(0) {
				c = c&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern + 1)))&0x3f
				pattern += uintptr(2)
			} else if c&0x08 == Tuint32_t(0) {
				c = c&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern + 2)))&0x3f
				pattern += uintptr(3)
			} else if c&0x04 == Tuint32_t(0) {
				c = c&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern + 3)))&0x3f
				pattern += uintptr(4)
			} else {
				c = c&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern + 4)))&0x3f
				pattern += uintptr(5)
			}
		}

		if c == Tuint32_t('\135') {
			convert_glob_write(tls, out, uint8(c))

			if !(is_negative != 0) && !(no_wildsep != 0) && separator_seen != 0 {
				*(*Tuint8_t)(unsafe.Pointer(out + 24)) = Tuint8_t('\050')
				*(*Tuint8_t)(unsafe.Pointer(out + 24 + 1)) = Tuint8_t('\077')
				*(*Tuint8_t)(unsafe.Pointer(out + 24 + 2)) = Tuint8_t('\074')
				*(*Tuint8_t)(unsafe.Pointer(out + 24 + 3)) = Tuint8_t('\041')
				convert_glob_write_str(tls, out, uint64(4))

				convert_glob_print_separator(tls, out, separator, with_escape)
				convert_glob_write(tls, out, uint8('\051'))
			}

			*(*TPCRE2_SPTR8)(unsafe.Pointer(from)) = pattern
			return 0
		}

		if pattern >= pattern_end {
			break
		}

		if c == Tuint32_t('\133') && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern))) == '\072' {
			*(*TPCRE2_SPTR8)(unsafe.Pointer(from)) = pattern
			class_index = convert_glob_parse_class(tls, from, pattern_end, out)

			if class_index != 0 {
				pattern = *(*TPCRE2_SPTR8)(unsafe.Pointer(from))

				has_prev_c = DFALSE
				prev_c = Tuint32_t(0)

				if !(is_negative != 0) && convert_glob_char_in_class(tls, class_index, separator) != 0 {
					separator_seen = DTRUE
				}
				continue
			}
		} else if c == Tuint32_t('\055') && has_prev_c != 0 && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern))) != '\135' {
			convert_glob_write(tls, out, uint8('\055'))

			char_start = pattern
			c = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&pattern, 1))))
			if utf != 0 && c >= 0xc0 {
				if c&0x20 == Tuint32_t(0) {
					c = c&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&pattern, 1))))&0x3f
				} else if c&0x10 == Tuint32_t(0) {
					c = c&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern + 1)))&0x3f
					pattern += uintptr(2)
				} else if c&0x08 == Tuint32_t(0) {
					c = c&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern + 2)))&0x3f
					pattern += uintptr(3)
				} else if c&0x04 == Tuint32_t(0) {
					c = c&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern + 3)))&0x3f
					pattern += uintptr(4)
				} else {
					c = c&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern + 4)))&0x3f
					pattern += uintptr(5)
				}
			}

			if pattern >= pattern_end {
				break
			}

			if int32(escape) != 0 && c == Tuint32_t(escape) {
				char_start = pattern
				c = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&pattern, 1))))
				if utf != 0 && c >= 0xc0 {
					if c&0x20 == Tuint32_t(0) {
						c = c&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&pattern, 1))))&0x3f
					} else if c&0x10 == Tuint32_t(0) {
						c = c&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern + 1)))&0x3f
						pattern += uintptr(2)
					} else if c&0x08 == Tuint32_t(0) {
						c = c&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern + 2)))&0x3f
						pattern += uintptr(3)
					} else if c&0x04 == Tuint32_t(0) {
						c = c&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern + 3)))&0x3f
						pattern += uintptr(4)
					} else {
						c = c&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern + 4)))&0x3f
						pattern += uintptr(5)
					}
				}

			} else if c == Tuint32_t('\133') && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern))) == '\072' {
				*(*TPCRE2_SPTR8)(unsafe.Pointer(from)) = pattern
				return -64
			}

			if prev_c > c {
				*(*TPCRE2_SPTR8)(unsafe.Pointer(from)) = pattern
				return -64
			}

			if prev_c < Tuint32_t(separator) && Tuint32_t(separator) < c {
				separator_seen = DTRUE
			}

			has_prev_c = DFALSE
			prev_c = Tuint32_t(0)
		} else {
			if int32(escape) != 0 && c == Tuint32_t(escape) {
				char_start = pattern
				c = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&pattern, 1))))
				if utf != 0 && c >= 0xc0 {
					if c&0x20 == Tuint32_t(0) {
						c = c&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&pattern, 1))))&0x3f
					} else if c&0x10 == Tuint32_t(0) {
						c = c&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern + 1)))&0x3f
						pattern += uintptr(2)
					} else if c&0x08 == Tuint32_t(0) {
						c = c&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern + 2)))&0x3f
						pattern += uintptr(3)
					} else if c&0x04 == Tuint32_t(0) {
						c = c&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern + 3)))&0x3f
						pattern += uintptr(4)
					} else {
						c = c&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(pattern + 4)))&0x3f
						pattern += uintptr(5)
					}
				}

				if pattern >= pattern_end {
					break
				}
			}

			has_prev_c = DTRUE
			prev_c = c
		}

		if c == Tuint32_t('\133') || c == Tuint32_t('\135') || c == Tuint32_t('\134') || c == Tuint32_t('\055') {
			convert_glob_write(tls, out, uint8('\134'))
		}

		if c == Tuint32_t(separator) {
			separator_seen = DTRUE
		}

		for __ccgo := true; __ccgo; __ccgo = char_start < pattern {
			convert_glob_write(tls, out, *(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&char_start, 1))))
		}
	}

	*(*TPCRE2_SPTR8)(unsafe.Pointer(from)) = pattern
	return DPCRE2_ERROR_MISSING_SQUARE_BRACKET
}

// Prints a (*COMMIT) into the output.
//
// Arguments:
//   out            output context

func convert_glob_print_commit(tls *libc.TLS, out uintptr) { /* pcre2_convert.c:754:1: */
	*(*Tuint8_t)(unsafe.Pointer(out + 24)) = Tuint8_t('\050')
	*(*Tuint8_t)(unsafe.Pointer(out + 24 + 1)) = Tuint8_t('\052')
	*(*Tuint8_t)(unsafe.Pointer(out + 24 + 2)) = Tuint8_t('\103')
	*(*Tuint8_t)(unsafe.Pointer(out + 24 + 3)) = Tuint8_t('\117')
	*(*Tuint8_t)(unsafe.Pointer(out + 24 + 4)) = Tuint8_t('\115')
	*(*Tuint8_t)(unsafe.Pointer(out + 24 + 5)) = Tuint8_t('\115')
	*(*Tuint8_t)(unsafe.Pointer(out + 24 + 6)) = Tuint8_t('\111')
	*(*Tuint8_t)(unsafe.Pointer(out + 24 + 7)) = Tuint8_t('\124')
	convert_glob_write_str(tls, out, uint64(8))
	convert_glob_write(tls, out, uint8('\051'))
}

// Bash glob converter.
//
// Arguments:
//   pattype        the pattern type
//   pattern        the pattern
//   plength        length in code units
//   utf            TRUE if UTF
//   use_buffer     where to put the output
//   use_length     length of use_buffer
//   bufflenptr     where to put the used length
//   dummyrun       TRUE if a dummy run
//   ccontext       the convert context
//
// Returns:         0 => success
//                 !0 => error code

func convert_glob(tls *libc.TLS, options Tuint32_t, pattern TPCRE2_SPTR8, plength Tsize_t, utf TBOOL, use_buffer uintptr, use_length Tsize_t, bufflenptr uintptr, dummyrun TBOOL, ccontext uintptr) int32 { /* pcre2_convert.c:787:1: */
	bp := tls.Alloc(40)
	defer tls.Free(40)
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 32)) = pattern

	// var out Tpcre2_output_context at bp, 32

	var pattern_start TPCRE2_SPTR8 = *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 32 /* pattern */))
	var pattern_end TPCRE2_SPTR8 = *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 32)) + uintptr(plength)
	var separator TPCRE2_UCHAR8 = TPCRE2_UCHAR8((*Tpcre2_convert_context_8)(unsafe.Pointer(ccontext)).Fglob_separator)
	var escape TPCRE2_UCHAR8 = TPCRE2_UCHAR8((*Tpcre2_convert_context_8)(unsafe.Pointer(ccontext)).Fglob_escape)
	var c TPCRE2_UCHAR8
	var no_wildsep TBOOL = libc.Bool32(options&DPCRE2_CONVERT_GLOB_NO_WILD_SEPARATOR != Tuint32_t(0))
	var no_starstar TBOOL = libc.Bool32(options&DPCRE2_CONVERT_GLOB_NO_STARSTAR != Tuint32_t(0))
	var in_atomic TBOOL = DFALSE
	var after_starstar TBOOL = DFALSE
	var no_slash_z TBOOL = DFALSE
	var with_escape TBOOL
	var is_start TBOOL
	var after_separator TBOOL
	var result int32 = 0

	_ = utf // Avoid compiler warning.

	if utf != 0 && (int32(separator) >= 128 || int32(escape) >= 128) {
		// Currently only ASCII characters are supported.
		*(*Tsize_t)(unsafe.Pointer(bufflenptr)) = uint64(0)
		return -64
	}

	with_escape = libc.Bool32(libc.Xstrchr(tls, pcre2_escaped_literals, int32(separator)) != uintptr(0))

	// Initialize default for error offset as end of input.
	(*Tpcre2_output_context)(unsafe.Pointer(bp /* &out */)).Foutput = use_buffer
	(*Tpcre2_output_context)(unsafe.Pointer(bp /* &out */)).Foutput_end = use_buffer + uintptr(use_length)
	(*Tpcre2_output_context)(unsafe.Pointer(bp /* &out */)).Foutput_size = uint64(0)

	*(*Tuint8_t)(unsafe.Pointer(bp + 24)) = Tuint8_t('\050')
	*(*Tuint8_t)(unsafe.Pointer(bp + 24 + 1)) = Tuint8_t('\077')
	*(*Tuint8_t)(unsafe.Pointer(bp + 24 + 2)) = Tuint8_t('\163')
	*(*Tuint8_t)(unsafe.Pointer(bp + 24 + 3)) = Tuint8_t('\051')
	convert_glob_write_str(tls, bp, uint64(4))

	is_start = DTRUE

	if *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 32)) < pattern_end && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 32))))) == '\052' {
		if no_wildsep != 0 {
			is_start = DFALSE
		} else if !(no_starstar != 0) && *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 32))+uintptr(1) < pattern_end && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 32)) + 1))) == '\052' {
			is_start = DFALSE
		}
	}

	if is_start != 0 {
		*(*Tuint8_t)(unsafe.Pointer(bp + 24)) = Tuint8_t('\134')
		*(*Tuint8_t)(unsafe.Pointer(bp + 24 + 1)) = Tuint8_t('\101')
		convert_glob_write_str(tls, bp, uint64(2))
	}

	for *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 32)) < pattern_end {
		c = *(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 32 /* pattern */)), 1)))

		if int32(c) == '\052' {
			is_start = libc.Bool32(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 32)) == pattern_start+uintptr(1))

			if in_atomic != 0 {
				convert_glob_write(tls, bp, uint8('\051'))
				in_atomic = DFALSE
			}

			if !(no_starstar != 0) && *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 32)) < pattern_end && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 32))))) == '\052' {
				after_separator = libc.Bool32(is_start != 0 || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 32)) + libc.UintptrFromInt32(-2)))) == int32(separator))

				for __ccgo := true; __ccgo; __ccgo = *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 32)) < pattern_end && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 32))))) == '\052' {
					*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 32 /* pattern */))++
				}

				if *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 32)) >= pattern_end {
					no_slash_z = DTRUE
					break
				}

				after_starstar = DTRUE

				if after_separator != 0 && int32(escape) != 0 && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 32))))) == int32(escape) && *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 32))+uintptr(1) < pattern_end && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 32)) + 1))) == int32(separator) {
					*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 32 /* pattern */))++
				}

				if is_start != 0 {
					if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 32))))) != int32(separator) {
						continue
					}

					*(*Tuint8_t)(unsafe.Pointer(bp + 24)) = Tuint8_t('\050')
					*(*Tuint8_t)(unsafe.Pointer(bp + 24 + 1)) = Tuint8_t('\077')
					*(*Tuint8_t)(unsafe.Pointer(bp + 24 + 2)) = Tuint8_t('\072')
					*(*Tuint8_t)(unsafe.Pointer(bp + 24 + 3)) = Tuint8_t('\134')
					*(*Tuint8_t)(unsafe.Pointer(bp + 24 + 4)) = Tuint8_t('\101')
					*(*Tuint8_t)(unsafe.Pointer(bp + 24 + 5)) = Tuint8_t('\174')
					convert_glob_write_str(tls, bp, uint64(6))

					convert_glob_print_separator(tls, bp, separator, with_escape)
					convert_glob_write(tls, bp, uint8('\051'))

					*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 32 /* pattern */))++
					continue
				}

				convert_glob_print_commit(tls, bp)

				if !(after_separator != 0) || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 32))))) != int32(separator) {
					*(*Tuint8_t)(unsafe.Pointer(bp + 24)) = Tuint8_t('\056')
					*(*Tuint8_t)(unsafe.Pointer(bp + 24 + 1)) = Tuint8_t('\052')
					*(*Tuint8_t)(unsafe.Pointer(bp + 24 + 2)) = Tuint8_t('\077')
					convert_glob_write_str(tls, bp, uint64(3))
					continue
				}

				*(*Tuint8_t)(unsafe.Pointer(bp + 24)) = Tuint8_t('\050')
				*(*Tuint8_t)(unsafe.Pointer(bp + 24 + 1)) = Tuint8_t('\077')
				*(*Tuint8_t)(unsafe.Pointer(bp + 24 + 2)) = Tuint8_t('\072')
				*(*Tuint8_t)(unsafe.Pointer(bp + 24 + 3)) = Tuint8_t('\056')
				*(*Tuint8_t)(unsafe.Pointer(bp + 24 + 4)) = Tuint8_t('\052')
				*(*Tuint8_t)(unsafe.Pointer(bp + 24 + 5)) = Tuint8_t('\077')

				convert_glob_write_str(tls, bp, uint64(6))

				convert_glob_print_separator(tls, bp, separator, with_escape)

				*(*Tuint8_t)(unsafe.Pointer(bp + 24)) = Tuint8_t('\051')
				*(*Tuint8_t)(unsafe.Pointer(bp + 24 + 1)) = Tuint8_t('\077')
				*(*Tuint8_t)(unsafe.Pointer(bp + 24 + 2)) = Tuint8_t('\077')
				convert_glob_write_str(tls, bp, uint64(3))

				*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 32 /* pattern */))++
				continue
			}

			if *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 32)) < pattern_end && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 32))))) == '\052' {
				for __ccgo1 := true; __ccgo1; __ccgo1 = *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 32)) < pattern_end && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 32))))) == '\052' {
					*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 32 /* pattern */))++
				}
			}

			if no_wildsep != 0 {
				if *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 32)) >= pattern_end {
					no_slash_z = DTRUE
					break
				}

				// Start check must be after the end check.
				if is_start != 0 {
					continue
				}
			}

			if !(is_start != 0) {
				if after_starstar != 0 {
					*(*Tuint8_t)(unsafe.Pointer(bp + 24)) = Tuint8_t('\050')
					*(*Tuint8_t)(unsafe.Pointer(bp + 24 + 1)) = Tuint8_t('\077')
					*(*Tuint8_t)(unsafe.Pointer(bp + 24 + 2)) = Tuint8_t('\076')
					convert_glob_write_str(tls, bp, uint64(3))
					in_atomic = DTRUE
				} else {
					convert_glob_print_commit(tls, bp)
				}
			}

			if no_wildsep != 0 {
				convert_glob_write(tls, bp, uint8('\056'))
			} else {
				convert_glob_print_wildcard(tls, bp, separator, with_escape)
			}

			*(*Tuint8_t)(unsafe.Pointer(bp + 24)) = Tuint8_t('\052')
			*(*Tuint8_t)(unsafe.Pointer(bp + 24 + 1)) = Tuint8_t('\077')
			if *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 32)) >= pattern_end {
				*(*Tuint8_t)(unsafe.Pointer(bp + 24 + 1)) = Tuint8_t('\053')
			}
			convert_glob_write_str(tls, bp, uint64(2))
			continue
		}

		if int32(c) == '\077' {
			if no_wildsep != 0 {
				convert_glob_write(tls, bp, uint8('\056'))
			} else {
				convert_glob_print_wildcard(tls, bp, separator, with_escape)
			}
			continue
		}

		if int32(c) == '\133' {
			result = convert_glob_parse_range(tls, bp+32, pattern_end,
				bp, utf, separator, with_escape, escape, no_wildsep)
			if result != 0 {
				break
			}
			continue
		}

		if int32(escape) != 0 && int32(c) == int32(escape) {
			if *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 32)) >= pattern_end {
				result = -64
				break
			}
			c = *(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 32 /* pattern */)), 1)))
		}

		if int32(c) < 128 && libc.Xstrchr(tls, pcre2_escaped_literals, int32(c)) != uintptr(0) {
			convert_glob_write(tls, bp, uint8('\134'))
		}

		convert_glob_write(tls, bp, c)
	}

	if result == 0 {
		if !(no_slash_z != 0) {
			*(*Tuint8_t)(unsafe.Pointer(bp + 24)) = Tuint8_t('\134')
			*(*Tuint8_t)(unsafe.Pointer(bp + 24 + 1)) = Tuint8_t('\172')
			convert_glob_write_str(tls, bp, uint64(2))
		}

		if in_atomic != 0 {
			convert_glob_write(tls, bp, uint8('\051'))
		}

		convert_glob_write(tls, bp, uint8(0))

		if !(dummyrun != 0) && (*Tpcre2_output_context)(unsafe.Pointer(bp)).Foutput_size != Tsize_t((int64((*Tpcre2_output_context)(unsafe.Pointer(bp)).Foutput)-int64(use_buffer))/1) {
			result = -48
		}
	}

	if result != 0 {
		*(*Tsize_t)(unsafe.Pointer(bufflenptr)) = Tsize_t((int64(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 32))) - int64(pattern_start)) / 1)
		return result
	}

	*(*Tsize_t)(unsafe.Pointer(bufflenptr)) = (*Tpcre2_output_context)(unsafe.Pointer(bp)).Foutput_size - uint64(1)
	return 0
}

// ************************************************
//
//                Convert pattern                 *
//

// This is the external-facing function for converting other forms of pattern
// into PCRE2 regular expression patterns. On error, the bufflenptr argument is
// used to return an offset in the original pattern.
//
// Arguments:
//   pattern     the input pattern
//   plength     length of input, or PCRE2_ZERO_TERMINATED
//   options     options bits
//   buffptr     pointer to pointer to output buffer
//   bufflenptr  pointer to length of output buffer
//   ccontext    convert context or NULL
//
// Returns:      0 for success, else an error code (+ve or -ve)

func Xpcre2_pattern_convert_8(tls *libc.TLS, pattern TPCRE2_SPTR8, plength Tsize_t, options Tuint32_t, buffptr uintptr, bufflenptr uintptr, ccontext uintptr) int32 { /* pcre2_convert.c:1057:1: */
	bp := tls.Alloc(112)
	defer tls.Free(112)

	var i int32
	var rc int32
	// var dummy_buffer [100]TPCRE2_UCHAR8 at bp, 100

	var use_buffer uintptr = bp /* dummy_buffer */
	var use_length Tsize_t = uint64(DDUMMY_BUFFER_SIZE)
	var utf TBOOL = libc.Bool32(options&DPCRE2_CONVERT_UTF != Tuint32_t(0))
	var pattype Tuint32_t = options & (DPCRE2_CONVERT_GLOB | DPCRE2_CONVERT_POSIX_BASIC | DPCRE2_CONVERT_POSIX_EXTENDED)

	if pattern == uintptr(0) || bufflenptr == uintptr(0) {
		return -51
	}

	if options&libc.CplUint32(DPCRE2_CONVERT_UTF|DPCRE2_CONVERT_NO_UTF_CHECK|DPCRE2_CONVERT_GLOB_NO_WILD_SEPARATOR|DPCRE2_CONVERT_GLOB_NO_STARSTAR|(DPCRE2_CONVERT_GLOB|DPCRE2_CONVERT_POSIX_BASIC|DPCRE2_CONVERT_POSIX_EXTENDED)) != Tuint32_t(0) || pattype&(^pattype+Tuint32_t(1)) != pattype || pattype == Tuint32_t(0) {
		*(*Tsize_t)(unsafe.Pointer(bufflenptr)) = uint64(0) // Error offset
		return -34
	}

	if plength == libc.CplUint64(uint64(0)) {
		plength = X_pcre2_strlen_8(tls, pattern)
	}
	if ccontext == uintptr(0) {
		ccontext = uintptr(unsafe.Pointer(&X_pcre2_default_convert_context_8))
	}

	// Check UTF if required.

	if utf != 0 && options&DPCRE2_CONVERT_NO_UTF_CHECK == Tuint32_t(0) {
		// var erroroffset Tsize_t at bp+104, 8

		rc = X_pcre2_valid_utf_8(tls, pattern, plength, bp+104)
		if rc != 0 {
			*(*Tsize_t)(unsafe.Pointer(bufflenptr)) = *(*Tsize_t)(unsafe.Pointer(bp + 104 /* erroroffset */))
			return rc
		}
	}

	// If buffptr is not NULL, and what it points to is not NULL, we are being
	// provided with a buffer and a length, so set them as the buffer to use.

	if buffptr != uintptr(0) && *(*uintptr)(unsafe.Pointer(buffptr)) != uintptr(0) {
		use_buffer = *(*uintptr)(unsafe.Pointer(buffptr))
		use_length = *(*Tsize_t)(unsafe.Pointer(bufflenptr))
	}

	// Call an individual converter, either just once (if a buffer was provided or
	// just the length is needed), or twice (if a memory allocation is required).

	for i = 0; i < 2; i++ {
		var allocated uintptr
		var dummyrun TBOOL = libc.Bool32(buffptr == uintptr(0) || *(*uintptr)(unsafe.Pointer(buffptr)) == uintptr(0))

		switch pattype {
		case DPCRE2_CONVERT_GLOB:
			rc = convert_glob(tls, options&libc.CplUint32(DPCRE2_CONVERT_GLOB), pattern, plength, utf,
				use_buffer, use_length, bufflenptr, dummyrun, ccontext)
			break

		case DPCRE2_CONVERT_POSIX_BASIC:
			fallthrough
		case DPCRE2_CONVERT_POSIX_EXTENDED:
			rc = convert_posix(tls, pattype, pattern, plength, utf, use_buffer, use_length,
				bufflenptr, dummyrun, ccontext)
			break

		default:
			*(*Tsize_t)(unsafe.Pointer(bufflenptr)) = uint64(0) // Error offset
			return -44
		}

		if rc != 0 || buffptr == uintptr(0) || *(*uintptr)(unsafe.Pointer(buffptr)) != uintptr(0) { // Buffer was provided or allocated
			return rc
		}

		// Allocate memory for the buffer, with hidden space for an allocator at
		//   the start. The next time round the loop runs the conversion for real.

		allocated = X_pcre2_memctl_malloc_8(tls, uint64(unsafe.Sizeof(Tpcre2_memctl{}))+(*(*Tsize_t)(unsafe.Pointer(bufflenptr))+uint64(1))*uint64(DPCRE2_CODE_UNIT_WIDTH), ccontext)
		if allocated == uintptr(0) {
			return -48
		}
		*(*uintptr)(unsafe.Pointer(buffptr)) = allocated + uintptr(uint64(unsafe.Sizeof(Tpcre2_memctl{})))

		use_buffer = *(*uintptr)(unsafe.Pointer(buffptr))
		use_length = *(*Tsize_t)(unsafe.Pointer(bufflenptr)) + uint64(1)
	}

	// Control should never get here.

	return -44
}

// ************************************************
//
//            Free converted pattern              *
//

// This frees a converted pattern that was put in newly-allocated memory.
//
// Argument:   the converted pattern
// Returns:    nothing

func Xpcre2_converted_pattern_free_8(tls *libc.TLS, converted uintptr) { /* pcre2_convert.c:1172:1: */
	if converted != uintptr(0) {
		var memctl uintptr = converted - uintptr(uint64(unsafe.Sizeof(Tpcre2_memctl{})))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_memctl)(unsafe.Pointer(memctl)).Ffree})).f(tls, memctl, (*Tpcre2_memctl)(unsafe.Pointer(memctl)).Fmemory_data)
	}
}

// End of pcre2_convert.c

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// ************************************************
//
//      Code parameters and static tables         *
//

// These are offsets that are used to turn the OP_TYPESTAR and friends opcodes
// into others, under special conditions. A gap of 20 between the blocks should be
// enough. The resulting opcodes don't have to be less than 256 because they are
// never stored, so we push them well clear of the normal opcodes.

// This table identifies those opcodes that are followed immediately by a
// character that is to be tested in some way. This makes it possible to
// centralize the loading of these characters. In the case of Type * etc, the
// "character" is the opcode for \D, \d, \S, \s, \W, or \w, which will always be a
// small value. Non-zero values in the table are the offsets from the opcode where
// the character is to be found. ***NOTE*** If the start of this table is
// modified, the three tables that follow must also be modified.

var coptable = [168]Tuint8_t{
	Tuint8_t(0),                                                     // End
	Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), // \A, \G, \K, \B, \b
	Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), // \D, \d, \S, \s, \W, \w
	Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), // Any, AllAny, Anybyte
	Tuint8_t(0), Tuint8_t(0), // \P, \p
	Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), // \R, \H, \h, \V, \v
	Tuint8_t(0),                                                                  // \X
	Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), // \Z, \z, $, $M, ^, ^M
	Tuint8_t(1), // Char
	Tuint8_t(1), // Chari
	Tuint8_t(1), // not
	Tuint8_t(1), // noti
	// Positive single-char repeats
	Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), // *, *?, +, +?, ?, ??
	Tuint8_t(1 + DIMM2_SIZE), Tuint8_t(1 + DIMM2_SIZE),
	Tuint8_t(1 + DIMM2_SIZE),
	Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1 + DIMM2_SIZE),
	Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), // *I, *?I, +I, +?I, ?I, ??I
	Tuint8_t(1 + DIMM2_SIZE), Tuint8_t(1 + DIMM2_SIZE),
	Tuint8_t(1 + DIMM2_SIZE),
	Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1 + DIMM2_SIZE),
	// Negative single-char repeats - only for chars < 256
	Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), // NOT *, *?, +, +?, ?, ??
	Tuint8_t(1 + DIMM2_SIZE), Tuint8_t(1 + DIMM2_SIZE),
	Tuint8_t(1 + DIMM2_SIZE),
	Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1 + DIMM2_SIZE),
	Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), // NOT *I, *?I, +I, +?I, ?I, ??I
	Tuint8_t(1 + DIMM2_SIZE), Tuint8_t(1 + DIMM2_SIZE),
	Tuint8_t(1 + DIMM2_SIZE),
	Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1 + DIMM2_SIZE),
	// Positive type repeats
	Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), // Type *, *?, +, +?, ?, ??
	Tuint8_t(1 + DIMM2_SIZE), Tuint8_t(1 + DIMM2_SIZE),
	Tuint8_t(1 + DIMM2_SIZE),
	Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1 + DIMM2_SIZE),
	// Character class & ref repeats
	Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), // *, *?, +, +?, ?, ??
	Tuint8_t(0), Tuint8_t(0), // CRRANGE, CRMINRANGE
	Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), // Possessive *+, ++, ?+, CRPOSRANGE
	Tuint8_t(0),                                                     // CLASS
	Tuint8_t(0),                                                     // NCLASS
	Tuint8_t(0),                                                     // XCLASS - variable length
	Tuint8_t(0),                                                     // REF
	Tuint8_t(0),                                                     // REFI
	Tuint8_t(0),                                                     // DNREF
	Tuint8_t(0),                                                     // DNREFI
	Tuint8_t(0),                                                     // RECURSE
	Tuint8_t(0),                                                     // CALLOUT
	Tuint8_t(0),                                                     // CALLOUT_STR
	Tuint8_t(0),                                                     // Alt
	Tuint8_t(0),                                                     // Ket
	Tuint8_t(0),                                                     // KetRmax
	Tuint8_t(0),                                                     // KetRmin
	Tuint8_t(0),                                                     // KetRpos
	Tuint8_t(0),                                                     // Reverse
	Tuint8_t(0),                                                     // Assert
	Tuint8_t(0),                                                     // Assert not
	Tuint8_t(0),                                                     // Assert behind
	Tuint8_t(0),                                                     // Assert behind not
	Tuint8_t(0),                                                     // NA assert
	Tuint8_t(0),                                                     // NA assert behind
	Tuint8_t(0),                                                     // ONCE
	Tuint8_t(0),                                                     // SCRIPT_RUN
	Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), // BRA, BRAPOS, CBRA, CBRAPOS, COND
	Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), // SBRA, SBRAPOS, SCBRA, SCBRAPOS, SCOND
	Tuint8_t(0), Tuint8_t(0), // CREF, DNCREF
	Tuint8_t(0), Tuint8_t(0), // RREF, DNRREF
	Tuint8_t(0), Tuint8_t(0), // FALSE, TRUE
	Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), // BRAZERO, BRAMINZERO, BRAPOSZERO
	Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), // MARK, PRUNE, PRUNE_ARG
	Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), // SKIP, SKIP_ARG, THEN, THEN_ARG
	Tuint8_t(0), Tuint8_t(0), // COMMIT, COMMIT_ARG
	Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), // FAIL, ACCEPT, ASSERT_ACCEPT
	Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), // CLOSE, SKIPZERO, DEFINE
} /* pcre2_dfa_match.c:116:22 */

// This table identifies those opcodes that inspect a character. It is used to
// remember the fact that a character could have been inspected when the end of
// the subject is reached. ***NOTE*** If the start of this table is modified, the
// two tables that follow must also be modified.

var poptable = [168]Tuint8_t{
	Tuint8_t(0),                                                     // End
	Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(1), Tuint8_t(1), // \A, \G, \K, \B, \b
	Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), // \D, \d, \S, \s, \W, \w
	Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), // Any, AllAny, Anybyte
	Tuint8_t(1), Tuint8_t(1), // \P, \p
	Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), // \R, \H, \h, \V, \v
	Tuint8_t(1),                                                                  // \X
	Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), // \Z, \z, $, $M, ^, ^M
	Tuint8_t(1), // Char
	Tuint8_t(1), // Chari
	Tuint8_t(1), // not
	Tuint8_t(1), // noti
	// Positive single-char repeats
	Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), // *, *?, +, +?, ?, ??
	Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), // upto, minupto, exact
	Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), // *+, ++, ?+, upto+
	Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), // *I, *?I, +I, +?I, ?I, ??I
	Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), // upto I, minupto I, exact I
	Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), // *+I, ++I, ?+I, upto+I
	// Negative single-char repeats - only for chars < 256
	Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), // NOT *, *?, +, +?, ?, ??
	Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), // NOT upto, minupto, exact
	Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), // NOT *+, ++, ?+, upto+
	Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), // NOT *I, *?I, +I, +?I, ?I, ??I
	Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), // NOT upto I, minupto I, exact I
	Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), // NOT *+I, ++I, ?+I, upto+I
	// Positive type repeats
	Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), // Type *, *?, +, +?, ?, ??
	Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), // Type upto, minupto, exact
	Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), // Type *+, ++, ?+, upto+
	// Character class & ref repeats
	Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), // *, *?, +, +?, ?, ??
	Tuint8_t(1), Tuint8_t(1), // CRRANGE, CRMINRANGE
	Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), // Possessive *+, ++, ?+, CRPOSRANGE
	Tuint8_t(1),                                                     // CLASS
	Tuint8_t(1),                                                     // NCLASS
	Tuint8_t(1),                                                     // XCLASS - variable length
	Tuint8_t(0),                                                     // REF
	Tuint8_t(0),                                                     // REFI
	Tuint8_t(0),                                                     // DNREF
	Tuint8_t(0),                                                     // DNREFI
	Tuint8_t(0),                                                     // RECURSE
	Tuint8_t(0),                                                     // CALLOUT
	Tuint8_t(0),                                                     // CALLOUT_STR
	Tuint8_t(0),                                                     // Alt
	Tuint8_t(0),                                                     // Ket
	Tuint8_t(0),                                                     // KetRmax
	Tuint8_t(0),                                                     // KetRmin
	Tuint8_t(0),                                                     // KetRpos
	Tuint8_t(0),                                                     // Reverse
	Tuint8_t(0),                                                     // Assert
	Tuint8_t(0),                                                     // Assert not
	Tuint8_t(0),                                                     // Assert behind
	Tuint8_t(0),                                                     // Assert behind not
	Tuint8_t(0),                                                     // NA assert
	Tuint8_t(0),                                                     // NA assert behind
	Tuint8_t(0),                                                     // ONCE
	Tuint8_t(0),                                                     // SCRIPT_RUN
	Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), // BRA, BRAPOS, CBRA, CBRAPOS, COND
	Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), // SBRA, SBRAPOS, SCBRA, SCBRAPOS, SCOND
	Tuint8_t(0), Tuint8_t(0), // CREF, DNCREF
	Tuint8_t(0), Tuint8_t(0), // RREF, DNRREF
	Tuint8_t(0), Tuint8_t(0), // FALSE, TRUE
	Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), // BRAZERO, BRAMINZERO, BRAPOSZERO
	Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), // MARK, PRUNE, PRUNE_ARG
	Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), // SKIP, SKIP_ARG, THEN, THEN_ARG
	Tuint8_t(0), Tuint8_t(0), // COMMIT, COMMIT_ARG
	Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), // FAIL, ACCEPT, ASSERT_ACCEPT
	Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), // CLOSE, SKIPZERO, DEFINE
} /* pcre2_dfa_match.c:198:22 */

// These 2 tables allow for compact code for testing for \D, \d, \S, \s, \W,
// and \w

var toptable1 = [14]Tuint8_t{
	Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0),
	Tuint8_t(Dctype_digit), Tuint8_t(Dctype_digit),
	Tuint8_t(Dctype_space), Tuint8_t(Dctype_space),
	Tuint8_t(Dctype_word), Tuint8_t(Dctype_word),
	Tuint8_t(0), Tuint8_t(0), // OP_ANY, OP_ALLANY
} /* pcre2_dfa_match.c:273:22 */

var toptable2 = [14]Tuint8_t{
	Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0), Tuint8_t(0),
	Tuint8_t(Dctype_digit), Tuint8_t(0),
	Tuint8_t(Dctype_space), Tuint8_t(0),
	Tuint8_t(Dctype_word), Tuint8_t(0),
	Tuint8_t(1), Tuint8_t(1), // OP_ANY, OP_ALLANY
} /* pcre2_dfa_match.c:281:22 */

// Structure for holding data about a particular state, which is in effect the
// current data for an active path through the match tree. It must consist
// entirely of ints because the working vector we are passed, and which we put
// these structures in, is a vector of ints.

type Sstateblock = struct {
	Foffset int32
	Fcount  int32
	Fdata   int32
} /* pcre2_dfa_match.c:295:9 */

// Structure for holding data about a particular state, which is in effect the
// current data for an active path through the match tree. It must consist
// entirely of ints because the working vector we are passed, and which we put
// these structures in, is a vector of ints.

type Tstateblock = Sstateblock /* pcre2_dfa_match.c:299:3 */

// Before version 10.32 the recursive calls of internal_dfa_match() were passed
// local working space and output vectors that were created on the stack. This has
// caused issues for some patterns, especially in small-stack environments such as
// Windows. A new scheme is now in use which sets up a vector on the stack, but if
// this is too small, heap memory is used, up to the heap_limit. The main
// parameters are all numbers of ints because the workspace is a vector of ints.
//
// The size of the starting stack vector, DFA_START_RWS_SIZE, is in bytes, and is
// defined in pcre2_internal.h so as to be available to pcre2test when it is
// finding the minimum heap requirement for a match.

// This structure is at the start of each workspace block.

type SRWS_anchor = struct {
	Fnext uintptr
	Fsize Tuint32_t
	Ffree Tuint32_t
} /* pcre2_dfa_match.c:324:9 */

// Before version 10.32 the recursive calls of internal_dfa_match() were passed
// local working space and output vectors that were created on the stack. This has
// caused issues for some patterns, especially in small-stack environments such as
// Windows. A new scheme is now in use which sets up a vector on the stack, but if
// this is too small, heap memory is used, up to the heap_limit. The main
// parameters are all numbers of ints because the workspace is a vector of ints.
//
// The size of the starting stack vector, DFA_START_RWS_SIZE, is in bytes, and is
// defined in pcre2_internal.h so as to be available to pcre2test when it is
// finding the minimum heap requirement for a match.

// This structure is at the start of each workspace block.

type TRWS_anchor = SRWS_anchor /* pcre2_dfa_match.c:328:3 */

// ************************************************
//
//               Process a callout                *
//

// This function is called to perform a callout.
//
// Arguments:
//   code              current code pointer
//   offsets           points to current capture offsets
//   current_subject   start of current subject match
//   ptr               current position in subject
//   mb                the match block
//   extracode         extra code offset when called from condition
//   lengthptr         where to return the callout length
//
// Returns:            the return from the callout

func do_callout(tls *libc.TLS, code TPCRE2_SPTR8, offsets uintptr, current_subject TPCRE2_SPTR8, ptr TPCRE2_SPTR8, mb uintptr, extracode Tsize_t, lengthptr uintptr) int32 { /* pcre2_dfa_match.c:353:1: */
	var cb uintptr = (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fcb

	*(*Tsize_t)(unsafe.Pointer(lengthptr)) = func() uint64 {
		if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + uintptr(extracode)))) == OP_CALLOUT {
			return Tsize_t(X_pcre2_OP_lengths_8[OP_CALLOUT])
		}
		return Tsize_t(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + uintptr(uint64(1+2*DLINK_SIZE)+extracode))))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + uintptr(uint64(1+2*DLINK_SIZE)+extracode+uint64(1)))))))
	}()

	if (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fcallout == uintptr(0) {
		return 0
	} // No callout provided

	// Fixed fields in the callout block are set once and for all at the start of
	// matching.

	(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Foffset_vector = offsets
	(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fstart_match = Tsize_t((int64(current_subject) - int64((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_subject)) / 1)
	(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fcurrent_position = Tsize_t((int64(ptr) - int64((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_subject)) / 1)
	(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fpattern_position = Tsize_t(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + uintptr(uint64(1)+extracode))))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + uintptr(uint64(1)+extracode+uint64(1)))))))
	(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fnext_item_length = Tsize_t(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + uintptr(uint64(1+DLINK_SIZE)+extracode))))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + uintptr(uint64(1+DLINK_SIZE)+extracode+uint64(1)))))))

	if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + uintptr(extracode)))) == OP_CALLOUT {
		(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fcallout_number = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + uintptr(uint64(1+2*DLINK_SIZE)+extracode))))
		(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fcallout_string_offset = uint64(0)
		(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fcallout_string = uintptr(0)
		(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fcallout_string_length = uint64(0)
	} else {
		(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fcallout_number = Tuint32_t(0)
		(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fcallout_string_offset = Tsize_t(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + uintptr(uint64(1+3*DLINK_SIZE)+extracode))))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + uintptr(uint64(1+3*DLINK_SIZE)+extracode+uint64(1)))))))
		(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fcallout_string = code + uintptr(uint64(1+4*DLINK_SIZE)+extracode) + uintptr(1)
		(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fcallout_string_length = *(*Tsize_t)(unsafe.Pointer(lengthptr)) - uint64(1+4*DLINK_SIZE) - uint64(2)
	}

	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fcallout})).f(tls, cb, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fcallout_data)
}

// ************************************************
//
//         Expand local workspace memory          *
//

// This function is called when internal_dfa_match() is about to be called
// recursively and there is insufficient working space left in the current
// workspace block. If there's an existing next block, use it; otherwise get a new
// block unless the heap limit is reached.
//
// Arguments:
//   rwsptr     pointer to block pointer (updated)
//   ovecsize   space needed for an ovector
//   mb         the match block
//
// Returns:     0 rwsptr has been updated
//             !0 an error code

func more_workspace(tls *libc.TLS, rwsptr uintptr, ovecsize uint32, mb uintptr) int32 { /* pcre2_dfa_match.c:413:1: */
	var rws uintptr = *(*uintptr)(unsafe.Pointer(rwsptr))
	var new uintptr

	if (*TRWS_anchor)(unsafe.Pointer(rws)).Fnext != uintptr(0) {
		new = (*TRWS_anchor)(unsafe.Pointer(rws)).Fnext
	} else {
		var newsize Tuint32_t
		if (*TRWS_anchor)(unsafe.Pointer(rws)).Fsize >= 4294967295/uint32(2) {
			newsize = 4294967295 / uint32(2)
		} else {
			newsize = (*TRWS_anchor)(unsafe.Pointer(rws)).Fsize * Tuint32_t(2)
		}
		var newsizeK Tuint32_t = Tuint32_t(uint64(newsize) / (uint64(1024) / uint64(unsafe.Sizeof(int32(0)))))

		if Tsize_t(newsizeK)+(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fheap_used > (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fheap_limit {
			newsizeK = Tuint32_t((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fheap_limit - (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fheap_used)
		}
		newsize = Tuint32_t(uint64(newsizeK) * (uint64(1024) / uint64(unsafe.Sizeof(int32(0)))))

		if uint64(newsize) < uint64(uint32(DRWS_RSIZE)+ovecsize)+uint64(unsafe.Sizeof(TRWS_anchor{}))/uint64(unsafe.Sizeof(int32(0))) {
			return -63
		}
		new = (*struct {
			f func(*libc.TLS, Tsize_t, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmemctl.Fmalloc})).f(tls, uint64(newsize)*uint64(unsafe.Sizeof(int32(0))), (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmemctl.Fmemory_data)
		if new == uintptr(0) {
			return -48
		}
		*(*Tsize_t)(unsafe.Pointer(mb + 88)) += Tsize_t(newsizeK)
		(*TRWS_anchor)(unsafe.Pointer(new)).Fnext = uintptr(0)
		(*TRWS_anchor)(unsafe.Pointer(new)).Fsize = newsize
		(*TRWS_anchor)(unsafe.Pointer(rws)).Fnext = new
	}

	(*TRWS_anchor)(unsafe.Pointer(new)).Ffree = Tuint32_t(uint64((*TRWS_anchor)(unsafe.Pointer(new)).Fsize) - uint64(unsafe.Sizeof(TRWS_anchor{}))/uint64(unsafe.Sizeof(int32(0))))
	*(*uintptr)(unsafe.Pointer(rwsptr)) = new
	return 0
}

// ************************************************
//
//     Match a Regular Expression - DFA engine    *
//

// This internal function applies a compiled pattern to a subject string,
// starting at a given point, using a DFA engine. This function is called from the
// external one, possibly multiple times if the pattern is not anchored. The
// function calls itself recursively for some kinds of subpattern.
//
// Arguments:
//   mb                the match_data block with fixed information
//   this_start_code   the opening bracket of this subexpression's code
//   current_subject   where we currently are in the subject string
//   start_offset      start offset in the subject string
//   offsets           vector to contain the matching string offsets
//   offsetcount       size of same
//   workspace         vector of workspace
//   wscount           size of same
//   rlevel            function call recursion level
//
// Returns:            > 0 => number of match offset pairs placed in offsets
//                     = 0 => offsets overflowed; longest matches are present
//                      -1 => failed to match
//                    < -1 => some kind of unexpected problem
//
// The following macros are used for adding states to the two state vectors (one
// for the current character, one for the following character).

// And now, here is the code

func internal_dfa_match(tls *libc.TLS, mb uintptr, this_start_code TPCRE2_SPTR8, current_subject TPCRE2_SPTR8, start_offset Tsize_t, offsets uintptr, offsetcount Tuint32_t, workspace uintptr, wscount int32, rlevel Tuint32_t, RWS uintptr) int32 { /* pcre2_dfa_match.c:522:1: */
	bp := tls.Alloc(96)
	defer tls.Free(96)

	var active_states uintptr
	var new_states uintptr
	var temp_states uintptr
	var next_active_state uintptr
	var next_new_state uintptr
	var ctypes uintptr
	var lcc uintptr
	var fcc uintptr
	var ptr TPCRE2_SPTR8
	var end_code TPCRE2_SPTR8
	// var new_recursive Tdfa_recursion_info at bp+48, 24

	var active_count int32
	var new_count int32
	var match_count int32

	// Some fields in the mb block are frequently referenced, so we load them into
	// independent variables in the hope that this will perform better.

	var start_subject TPCRE2_SPTR8
	var end_subject TPCRE2_SPTR8
	var start_code TPCRE2_SPTR8
	var utf TBOOL
	var utf_or_ucp TBOOL
	var reset_could_continue TBOOL
	var back Tsize_t
	var current_offset Tsize_t
	var bstate int32
	var revlen Tuint32_t
	var back1 Tsize_t
	var max_back Tsize_t
	var gone_back Tsize_t
	var length int32
	var cat Tuint32_t
	var temp TPCRE2_SPTR8
	var temp1 TPCRE2_SPTR8
	var cat1 Tuint32_t
	var left_word int32
	var right_word int32
	var OK TBOOL
	var cp uintptr
	var prop uintptr
	var OK1 TBOOL
	var cp1 uintptr
	var prop1 uintptr
	// var ncount int32 at bp, 4

	var ncount1 int32
	var OK2 TBOOL
	var OK3 TBOOL
	var OK4 TBOOL
	var cp2 uintptr
	var prop2 uintptr
	// var ncount2 int32 at bp+4, 4

	var ncount3 int32
	var OK5 TBOOL
	var OK6 TBOOL
	var OK7 TBOOL
	var cp3 uintptr
	var prop3 uintptr
	var nptr TPCRE2_SPTR8
	// var ncount4 int32 at bp+8, 4

	var ncount5 int32
	var OK8 TBOOL
	var OK9 TBOOL
	var othercase uint32
	// var ncount6 int32 at bp+12, 4

	var nptr1 TPCRE2_SPTR8
	var otherd Tuint32_t
	var otherd1 Tuint32_t
	var otherd2 Tuint32_t
	var otherd3 Tuint32_t
	var otherd4 Tuint32_t
	var otherd5 Tuint32_t
	var max int32
	var isinclass TBOOL
	var next_state_offset int32
	var ecode TPCRE2_SPTR8
	var rc int32
	var local_workspace uintptr
	var local_offsets uintptr
	var endasscode TPCRE2_SPTR8
	// var rws uintptr at bp+16, 8

	// var callout_length Tsize_t at bp+24, 8

	var value uint32
	var rc1 int32
	var local_workspace1 uintptr
	var local_offsets1 uintptr
	var asscode TPCRE2_SPTR8
	var endasscode1 TPCRE2_SPTR8
	// var rws1 uintptr at bp+32, 8

	var codelink int32
	var condcode TPCRE2_UCHAR8
	var p TPCRE2_SPTR8
	var pp TPCRE2_SPTR8
	var charcount Tsize_t
	var rc2 int32
	var local_workspace2 uintptr
	var local_offsets2 uintptr
	// var rws2 uintptr at bp+40, 8

	var ri uintptr
	var callpat TPCRE2_SPTR8
	var recno Tuint32_t
	var p1 TPCRE2_SPTR8
	var pp1 TPCRE2_SPTR8
	var end_subpattern TPCRE2_SPTR8
	var next_state_offset1 int32
	var rc3 int32
	var local_workspace3 uintptr
	var local_offsets3 uintptr
	var charcount1 Tsize_t
	var matched_count Tsize_t
	var local_ptr TPCRE2_SPTR8
	// var rws3 uintptr at bp+72, 8

	var allow_zero TBOOL
	var p2 TPCRE2_SPTR8
	var pp2 TPCRE2_SPTR8
	var end_subpattern1 TPCRE2_SPTR8
	var charcount2 Tsize_t
	var next_state_offset2 int32
	var repeat_state_offset int32
	var rc4 int32
	var local_workspace4 uintptr
	var local_offsets4 uintptr
	// var rws4 uintptr at bp+80, 8

	// var callout_length1 Tsize_t at bp+88, 8

	var current_state uintptr
	var caseless TBOOL
	var code TPCRE2_SPTR8
	var codevalue Tuint32_t
	var state_offset int32
	var rrc int32
	var count int32
	var i int32
	var j int32
	var clen int32
	var dlen int32
	var c Tuint32_t
	var d Tuint32_t
	var forced_fail int32
	var partial_newline TBOOL
	var could_continue TBOOL
	start_subject = (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_subject
	end_subject = (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject
	start_code = (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_code
	utf = libc.Bool32((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fpoptions&DPCRE2_UTF != Tuint32_t(0))
	utf_or_ucp = libc.Bool32(utf != 0 || (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fpoptions&DPCRE2_UCP != Tuint32_t(0))
	reset_could_continue = DFALSE

	if !(libc.PostIncUint32(&(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmatch_call_count, 1) >= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmatch_limit) {
		goto __1
	}
	return -47
__1:
	;
	if !(libc.PostIncUint32(&rlevel, 1) > (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmatch_limit_depth) {
		goto __2
	}
	return -53
__2:
	;
	offsetcount = offsetcount & libc.Uint32(libc.Uint32FromInt32(-2)) // Round down

	wscount = wscount - 2
	wscount = (wscount - wscount%(int32(uint64(unsafe.Sizeof(Tstateblock{}))/uint64(unsafe.Sizeof(int32(0))))*2)) / (2 * int32(uint64(unsafe.Sizeof(Tstateblock{}))/uint64(unsafe.Sizeof(int32(0)))))

	ctypes = (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Ftables + uintptr(Dcbits_offset+Dcbit_length)
	lcc = (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Ftables + uintptr(Dlcc_offset)
	fcc = (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Ftables + uintptr(Dfcc_offset)

	match_count = -1 // A negative number

	active_states = workspace + uintptr(2)*4
	next_new_state = libc.AssignUintptr(&new_states, active_states+uintptr(wscount)*12)
	new_count = 0

	// The first thing in any (sub) pattern is a bracket of some sort. Push all
	// the alternative states onto the list, and find out where the end is. This
	// makes is possible to use this function recursively, when we want to stop at a
	// matching internal ket rather than at the end.
	//
	// If we are dealing with a backward assertion we have to find out the maximum
	// amount to move back, and set up each alternative appropriately.

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(this_start_code))) == OP_ASSERTBACK || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(this_start_code))) == OP_ASSERTBACK_NOT) {
		goto __3
	}

	max_back = uint64(0)

	end_code = this_start_code
__5:

	back = Tsize_t(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(end_code + 4)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(end_code + 5)))))
	if !(back > max_back) {
		goto __8
	}
	max_back = back
__8:
	;
	end_code += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(end_code + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(end_code + 2)))))
	goto __6
__6:
	if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(end_code))) == OP_ALT {
		goto __5
	}
	goto __7
__7:
	;

	// If we can't go back the amount required for the longest lookbehind
	//   pattern, go back as far as we can; some alternatives may still be viable.

	// In character mode we have to step back character by character

	if !(utf != 0) {
		goto __9
	}

	gone_back = uint64(0)
__11:
	if !(gone_back < max_back) {
		goto __13
	}

	if !(current_subject <= start_subject) {
		goto __14
	}
	goto __13
__14:
	;
	current_subject--
__15:
	if !(current_subject > start_subject && uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(current_subject)))&0xc0 == 0x80) {
		goto __16
	}
	current_subject--
	goto __15
__16:
	;
	goto __12
__12:
	gone_back++
	goto __11
	goto __13
__13:
	;
	goto __10
__9:

	/* In byte-mode we can do this quickly. */

	current_offset = Tsize_t((int64(current_subject) - int64(start_subject)) / 1)
	if current_offset < max_back {
		gone_back = current_offset
	} else {
		gone_back = max_back
	}
	current_subject -= TPCRE2_SPTR8(gone_back)
__10:
	;

	// Save the earliest consulted character

	if !(current_subject < (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr) {
		goto __17
	}
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr = current_subject
__17:
	;

	// Now we can process the individual branches. There will be an OP_REVERSE at
	//   the start of each branch, except when the length of the branch is zero.

	end_code = this_start_code
__18:

	if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(end_code + 3))) == OP_REVERSE {
		revlen = uint32(1 + DLINK_SIZE)
	} else {
		revlen = uint32(0)
	}
	if revlen == Tuint32_t(0) {
		back1 = uint64(0)
	} else {
		back1 = Tsize_t(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(end_code + 4)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(end_code + 5)))))
	}
	if !(back1 <= gone_back) {
		goto __21
	}

	bstate = int32((int64(end_code)-int64(start_code))/1 + int64(1) + int64(DLINK_SIZE) + int64(revlen))
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __22
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -bstate
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = int32(gone_back - back1)
	next_new_state += 12
	goto __23
__22:
	return -43
__23:
	;
__21:
	;
	end_code += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(end_code + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(end_code + 2)))))
	goto __19
__19:
	if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(end_code))) == OP_ALT {
		goto __18
	}
	goto __20
__20:
	;
	goto __4
__3:

	end_code = this_start_code

	// Restarting

	if !(rlevel == Tuint32_t(1) && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_DFA_RESTART != Tuint32_t(0)) {
		goto __24
	}

__26:
	end_code += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(end_code + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(end_code + 2)))))
	goto __27
__27:
	if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(end_code))) == OP_ALT {
		goto __26
	}
	goto __28
__28:
	;
	new_count = *(*int32)(unsafe.Pointer(workspace + 1*4))
	if !!(*(*int32)(unsafe.Pointer(workspace)) != 0) {
		goto __29
	}
	libc.Xmemcpy(tls, new_states, active_states, Tsize_t(new_count)*Tsize_t(unsafe.Sizeof(Tstateblock{})))
__29:
	;
	goto __25
__24:

	length = 1 + DLINK_SIZE + func() int32 {
		if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(this_start_code))) == OP_CBRA || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(this_start_code))) == OP_SCBRA || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(this_start_code))) == OP_CBRAPOS || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(this_start_code))) == OP_SCBRAPOS {
			return DIMM2_SIZE
		}
		return 0
	}()
__30:

	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __33
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = int32((int64(end_code)-int64(start_code))/1 + int64(length))
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __34
__33:
	return -43
__34:
	;
	end_code += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(end_code + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(end_code + 2)))))
	length = 1 + DLINK_SIZE
	goto __31
__31:
	if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(end_code))) == OP_ALT {
		goto __30
	}
	goto __32
__32:
	;
__25:
	;
__4:
	;

	*(*int32)(unsafe.Pointer(workspace)) = 0 // Bit indicating which vector is current

	// Loop for scanning the subject

	ptr = current_subject
__35:
	forced_fail = 0
	partial_newline = DFALSE
	could_continue = reset_could_continue
	reset_could_continue = DFALSE

	if !(ptr > (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Flast_used_ptr) {
		goto __38
	}
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Flast_used_ptr = ptr
__38:
	;

	// Make the new state list into the active state list and empty the
	//   new state list.

	temp_states = active_states
	active_states = new_states
	new_states = temp_states
	active_count = new_count
	new_count = 0

	*(*int32)(unsafe.Pointer(workspace)) ^= 1 // Remember for the restarting feature
	*(*int32)(unsafe.Pointer(workspace + 1*4)) = active_count

	// Set the pointers for adding new states

	next_active_state = active_states + uintptr(active_count)*12
	next_new_state = new_states

	// Load the current character from the subject outside the loop, as many
	//   different states may want to look at it, and we assume that at least one
	//   will.

	if !(ptr < end_subject) {
		goto __39
	}

	clen = 1 // Number of data items in the character
	c = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr)))
	if !(utf != 0 && c >= 0xc0) {
		goto __41
	}
	if !(c&0x20 == Tuint32_t(0)) {
		goto __42
	}
	c = c&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 1)))&0x3f
	clen++
	goto __43
__42:
	if !(c&0x10 == Tuint32_t(0)) {
		goto __44
	}
	c = c&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 2)))&0x3f
	clen = clen + 2
	goto __45
__44:
	if !(c&0x08 == Tuint32_t(0)) {
		goto __46
	}
	c = c&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 3)))&0x3f
	clen = clen + 3
	goto __47
__46:
	if !(c&0x04 == Tuint32_t(0)) {
		goto __48
	}
	c = c&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 4)))&0x3f
	clen = clen + 4
	goto __49
__48:
	c = c&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 5)))&0x3f
	clen = clen + 5
__49:
	;
__47:
	;
__45:
	;
__43:
	;
__41:
	;

	goto __40
__39:

	clen = 0 // This indicates the end of the subject
	c = DNOTACHAR // This value should never actually be used
__40:
	;

	// Scan up the active states and act on each one. The result of an action
	//   may be to add more states to the currently active list (e.g. on hitting a
	//   parenthesis) or it may be to put states on the new list, for considering
	//   when we move the character pointer on.

	i = 0
__50:
	if !(i < active_count) {
		goto __52
	}
	current_state = active_states + uintptr(i)*12
	caseless = DFALSE
	state_offset = (*Tstateblock)(unsafe.Pointer(current_state)).Foffset

	// A negative offset is a special case meaning "hold off going to this
	//     (negated) state until the number of characters in the data field have
	//     been skipped". If the could_continue flag was passed over from a previous
	//     state, arrange for it to passed on.

	if !(state_offset < 0) {
		goto __53
	}

	if !((*Tstateblock)(unsafe.Pointer(current_state)).Fdata > 0) {
		goto __54
	}

	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __56
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = (*Tstateblock)(unsafe.Pointer(current_state)).Fcount
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = (*Tstateblock)(unsafe.Pointer(current_state)).Fdata - 1
	next_new_state += 12
	goto __57
__56:
	return -43
__57:
	;
	if !(could_continue != 0) {
		goto __58
	}
	reset_could_continue = DTRUE
__58:
	;
	goto __51
	goto __55
__54:

	(*Tstateblock)(unsafe.Pointer(current_state)).Foffset = libc.AssignInt32(&state_offset, -state_offset)
__55:
	;
__53:
	;

	// Check for a duplicate state with the same count, and skip if found.
	//     See the note at the head of this module about the possibility of improving
	//     performance here.

	j = 0
__59:
	if !(j < i) {
		goto __61
	}

	if !((*Tstateblock)(unsafe.Pointer(active_states+uintptr(j)*12)).Foffset == state_offset && (*Tstateblock)(unsafe.Pointer(active_states+uintptr(j)*12)).Fcount == (*Tstateblock)(unsafe.Pointer(current_state)).Fcount) {
		goto __62
	}
	goto NEXT_ACTIVE_STATE
__62:
	;
	goto __60
__60:
	j++
	goto __59
	goto __61
__61:
	;

	// The state offset is the offset to the opcode

	code = start_code + uintptr(state_offset)
	codevalue = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code)))

	// If this opcode inspects a character, but we are at the end of the
	//     subject, remember the fact for use when testing for a partial match.

	if !(clen == 0 && int32(poptable[codevalue]) != 0) {
		goto __63
	}
	could_continue = DTRUE
__63:
	;

	// If this opcode is followed by an inline character, load it. It is
	//     tempting to test for the presence of a subject character here, but that
	//     is wrong, because sometimes zero repetitions of the subject are
	//     permitted.
	//
	//     We also use this mechanism for opcodes such as OP_TYPEPLUS that take an
	//     argument that is not a data character - but is always one byte long because
	//     the values are small. We have to take special action to deal with  \P, \p,
	//     \H, \h, \V, \v and \X in this case. To keep the other cases fast, convert
	//     these ones to new opcodes.

	if !(int32(coptable[codevalue]) > 0) {
		goto __64
	}

	dlen = 1
	if !(utf != 0) {
		goto __66
	}
	d = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + uintptr(coptable[codevalue]))))
	if !(d >= 0xc0) {
		goto __68
	}
	if !(d&0x20 == Tuint32_t(0)) {
		goto __69
	}
	d = d&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + uintptr(coptable[codevalue]) + 1)))&0x3f
	dlen++
	goto __70
__69:
	if !(d&0x10 == Tuint32_t(0)) {
		goto __71
	}
	d = d&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + uintptr(coptable[codevalue]) + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + uintptr(coptable[codevalue]) + 2)))&0x3f
	dlen = dlen + 2
	goto __72
__71:
	if !(d&0x08 == Tuint32_t(0)) {
		goto __73
	}
	d = d&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + uintptr(coptable[codevalue]) + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + uintptr(coptable[codevalue]) + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + uintptr(coptable[codevalue]) + 3)))&0x3f
	dlen = dlen + 3
	goto __74
__73:
	if !(d&0x04 == Tuint32_t(0)) {
		goto __75
	}
	d = d&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + uintptr(coptable[codevalue]) + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + uintptr(coptable[codevalue]) + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + uintptr(coptable[codevalue]) + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + uintptr(coptable[codevalue]) + 4)))&0x3f
	dlen = dlen + 4
	goto __76
__75:
	d = d&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + uintptr(coptable[codevalue]) + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + uintptr(coptable[codevalue]) + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + uintptr(coptable[codevalue]) + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + uintptr(coptable[codevalue]) + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + uintptr(coptable[codevalue]) + 5)))&0x3f
	dlen = dlen + 5
__76:
	;
__74:
	;
__72:
	;
__70:
	;
__68:
	;

	goto __67
__66:
	d = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + uintptr(coptable[codevalue]))))
__67:
	;
	if !(codevalue >= OP_TYPESTAR) {
		goto __77
	}

	switch d {
	case OP_ANYBYTE:
		goto __79
	case OP_NOTPROP:
		goto __80
	case OP_PROP:
		goto __81
	case OP_ANYNL:
		goto __82
	case OP_EXTUNI:
		goto __83
	case OP_NOT_HSPACE:
		goto __84
	case OP_HSPACE:
		goto __85
	case OP_NOT_VSPACE:
		goto __86
	case OP_VSPACE:
		goto __87
	default:
		goto __88
	}
	goto __78

__79:
	return -42
__80:
__81:
	codevalue = codevalue + Tuint32_t(DOP_PROP_EXTRA)
	goto __78
__82:
	codevalue = codevalue + Tuint32_t(DOP_ANYNL_EXTRA)
	goto __78
__83:
	codevalue = codevalue + Tuint32_t(DOP_EXTUNI_EXTRA)
	goto __78
__84:
__85:
	codevalue = codevalue + Tuint32_t(DOP_HSPACE_EXTRA)
	goto __78
__86:
__87:
	codevalue = codevalue + Tuint32_t(DOP_VSPACE_EXTRA)
	goto __78
__88:
	goto __78
__78:
	;
__77:
	;
	goto __65
__64:

	dlen = 0 // Not strictly necessary, but compilers moan
	d = DNOTACHAR // if these variables are not set.
__65:
	;

	// Now process the individual opcodes

	switch codevalue {
	// ==========================================================================
	// These cases are never obeyed. This is a fudge that causes a compile-
	//       time error if the vectors coptable or poptable, which are indexed by
	//       opcode, are not the correct length. It seems to be the only way to do
	//       such a check at compile time, as the sizeof() operator does not work
	//       in the C preprocessor.

	case OP_TABLE_LENGTH:
		goto __90
	case Tuint32_t(OP_TABLE_LENGTH + libc.Bool32(uint64(unsafe.Sizeof(coptable)) == OP_TABLE_LENGTH && uint64(unsafe.Sizeof(poptable)) == OP_TABLE_LENGTH)):
		goto __91

		// ==========================================================================
	// Reached a closing bracket. If not at the end of the pattern, carry
	//       on with the next opcode. For repeating opcodes, also add the repeat
	//       state. Note that KETRPOS will always be encountered at the end of the
	//       subpattern, because the possessive subpattern repeats are always handled
	//       using recursive calls. Thus, it never adds any new states.
	//
	//       At the end of the (sub)pattern, unless we have an empty string and
	//       PCRE2_NOTEMPTY is set, or PCRE2_NOTEMPTY_ATSTART is set and we are at the
	//       start of the subject, save the match data, shifting up all previous
	//       matches so we always have the longest first.

	case OP_KET:
		goto __92
	case OP_KETRMIN:
		goto __93
	case OP_KETRMAX:
		goto __94
	case OP_KETRPOS:
		goto __95

		// ==========================================================================
	// These opcodes add to the current list of states without looking
	//       at the current character.

	//-----------------------------------------------------------------
	case OP_ALT:
		goto __96

	//-----------------------------------------------------------------
	case OP_BRA:
		goto __97
	case OP_SBRA:
		goto __98

	//-----------------------------------------------------------------
	case OP_CBRA:
		goto __99
	case OP_SCBRA:
		goto __100

	//-----------------------------------------------------------------
	case OP_BRAZERO:
		goto __101
	case OP_BRAMINZERO:
		goto __102

	//-----------------------------------------------------------------
	case OP_SKIPZERO:
		goto __103

	//-----------------------------------------------------------------
	case OP_CIRC:
		goto __104

	//-----------------------------------------------------------------
	case OP_CIRCM:
		goto __105

	//-----------------------------------------------------------------
	case OP_EOD:
		goto __106

	//-----------------------------------------------------------------
	case OP_SOD:
		goto __107

	//-----------------------------------------------------------------
	case OP_SOM:
		goto __108

		// ==========================================================================
	// These opcodes inspect the next subject character, and sometimes
	//       the previous one as well, but do not have an argument. The variable
	//       clen contains the length of the current character and is zero if we are
	//       at the end of the subject.

	//-----------------------------------------------------------------
	case OP_ANY:
		goto __109

	//-----------------------------------------------------------------
	case OP_ALLANY:
		goto __110

	//-----------------------------------------------------------------
	case OP_EODN:
		goto __111

	//-----------------------------------------------------------------
	case OP_DOLL:
		goto __112

	//-----------------------------------------------------------------
	case OP_DOLLM:
		goto __113

	//-----------------------------------------------------------------

	case OP_DIGIT:
		goto __114
	case OP_WHITESPACE:
		goto __115
	case OP_WORDCHAR:
		goto __116

	//-----------------------------------------------------------------
	case OP_NOT_DIGIT:
		goto __117
	case OP_NOT_WHITESPACE:
		goto __118
	case OP_NOT_WORDCHAR:
		goto __119

	//-----------------------------------------------------------------
	case OP_WORD_BOUNDARY:
		goto __120
	case OP_NOT_WORD_BOUNDARY:
		goto __121

	//-----------------------------------------------------------------
	// Check the next character by Unicode property. We will get here only
	//       if the support is in the binary; otherwise a compile-time error occurs.
	//

	case OP_PROP:
		goto __122
	case OP_NOTPROP:
		goto __123

		// ==========================================================================
	// These opcodes likewise inspect the subject character, but have an
	//       argument that is not a data character. It is one of these opcodes:
	//       OP_ANY, OP_ALLANY, OP_DIGIT, OP_NOT_DIGIT, OP_WHITESPACE, OP_NOT_SPACE,
	//       OP_WORDCHAR, OP_NOT_WORDCHAR. The value is loaded into d.

	case OP_TYPEPLUS:
		goto __124
	case OP_TYPEMINPLUS:
		goto __125
	case OP_TYPEPOSPLUS:
		goto __126

	//-----------------------------------------------------------------
	case OP_TYPEQUERY:
		goto __127
	case OP_TYPEMINQUERY:
		goto __128
	case OP_TYPEPOSQUERY:
		goto __129

	//-----------------------------------------------------------------
	case OP_TYPESTAR:
		goto __130
	case OP_TYPEMINSTAR:
		goto __131
	case OP_TYPEPOSSTAR:
		goto __132

	//-----------------------------------------------------------------
	case OP_TYPEEXACT:
		goto __133

	//-----------------------------------------------------------------
	case OP_TYPEUPTO:
		goto __134
	case OP_TYPEMINUPTO:
		goto __135
	case OP_TYPEPOSUPTO:
		goto __136

		// ==========================================================================
	// These are virtual opcodes that are used when something like
	//       OP_TYPEPLUS has OP_PROP, OP_NOTPROP, OP_ANYNL, or OP_EXTUNI as its
	//       argument. It keeps the code above fast for the other cases. The argument
	//       is in the d variable.

	case Tuint32_t(DOP_PROP_EXTRA + OP_TYPEPLUS):
		goto __137
	case Tuint32_t(DOP_PROP_EXTRA + OP_TYPEMINPLUS):
		goto __138
	case Tuint32_t(DOP_PROP_EXTRA + OP_TYPEPOSPLUS):
		goto __139

	//-----------------------------------------------------------------
	case Tuint32_t(DOP_EXTUNI_EXTRA + OP_TYPEPLUS):
		goto __140
	case Tuint32_t(DOP_EXTUNI_EXTRA + OP_TYPEMINPLUS):
		goto __141
	case Tuint32_t(DOP_EXTUNI_EXTRA + OP_TYPEPOSPLUS):
		goto __142

	//-----------------------------------------------------------------
	case Tuint32_t(DOP_ANYNL_EXTRA + OP_TYPEPLUS):
		goto __143
	case Tuint32_t(DOP_ANYNL_EXTRA + OP_TYPEMINPLUS):
		goto __144
	case Tuint32_t(DOP_ANYNL_EXTRA + OP_TYPEPOSPLUS):
		goto __145

	//-----------------------------------------------------------------
	case Tuint32_t(DOP_VSPACE_EXTRA + OP_TYPEPLUS):
		goto __146
	case Tuint32_t(DOP_VSPACE_EXTRA + OP_TYPEMINPLUS):
		goto __147
	case Tuint32_t(DOP_VSPACE_EXTRA + OP_TYPEPOSPLUS):
		goto __148

	//-----------------------------------------------------------------
	case Tuint32_t(DOP_HSPACE_EXTRA + OP_TYPEPLUS):
		goto __149
	case Tuint32_t(DOP_HSPACE_EXTRA + OP_TYPEMINPLUS):
		goto __150
	case Tuint32_t(DOP_HSPACE_EXTRA + OP_TYPEPOSPLUS):
		goto __151

	//-----------------------------------------------------------------
	case Tuint32_t(DOP_PROP_EXTRA + OP_TYPEQUERY):
		goto __152
	case Tuint32_t(DOP_PROP_EXTRA + OP_TYPEMINQUERY):
		goto __153
	case Tuint32_t(DOP_PROP_EXTRA + OP_TYPEPOSQUERY):
		goto __154

	case Tuint32_t(DOP_PROP_EXTRA + OP_TYPESTAR):
		goto __155
	case Tuint32_t(DOP_PROP_EXTRA + OP_TYPEMINSTAR):
		goto __156
	case Tuint32_t(DOP_PROP_EXTRA + OP_TYPEPOSSTAR):
		goto __157

	//-----------------------------------------------------------------
	case Tuint32_t(DOP_EXTUNI_EXTRA + OP_TYPEQUERY):
		goto __158
	case Tuint32_t(DOP_EXTUNI_EXTRA + OP_TYPEMINQUERY):
		goto __159
	case Tuint32_t(DOP_EXTUNI_EXTRA + OP_TYPEPOSQUERY):
		goto __160

	case Tuint32_t(DOP_EXTUNI_EXTRA + OP_TYPESTAR):
		goto __161
	case Tuint32_t(DOP_EXTUNI_EXTRA + OP_TYPEMINSTAR):
		goto __162
	case Tuint32_t(DOP_EXTUNI_EXTRA + OP_TYPEPOSSTAR):
		goto __163

	//-----------------------------------------------------------------
	case Tuint32_t(DOP_ANYNL_EXTRA + OP_TYPEQUERY):
		goto __164
	case Tuint32_t(DOP_ANYNL_EXTRA + OP_TYPEMINQUERY):
		goto __165
	case Tuint32_t(DOP_ANYNL_EXTRA + OP_TYPEPOSQUERY):
		goto __166

	case Tuint32_t(DOP_ANYNL_EXTRA + OP_TYPESTAR):
		goto __167
	case Tuint32_t(DOP_ANYNL_EXTRA + OP_TYPEMINSTAR):
		goto __168
	case Tuint32_t(DOP_ANYNL_EXTRA + OP_TYPEPOSSTAR):
		goto __169

	//-----------------------------------------------------------------
	case Tuint32_t(DOP_VSPACE_EXTRA + OP_TYPEQUERY):
		goto __170
	case Tuint32_t(DOP_VSPACE_EXTRA + OP_TYPEMINQUERY):
		goto __171
	case Tuint32_t(DOP_VSPACE_EXTRA + OP_TYPEPOSQUERY):
		goto __172

	case Tuint32_t(DOP_VSPACE_EXTRA + OP_TYPESTAR):
		goto __173
	case Tuint32_t(DOP_VSPACE_EXTRA + OP_TYPEMINSTAR):
		goto __174
	case Tuint32_t(DOP_VSPACE_EXTRA + OP_TYPEPOSSTAR):
		goto __175

	//-----------------------------------------------------------------
	case Tuint32_t(DOP_HSPACE_EXTRA + OP_TYPEQUERY):
		goto __176
	case Tuint32_t(DOP_HSPACE_EXTRA + OP_TYPEMINQUERY):
		goto __177
	case Tuint32_t(DOP_HSPACE_EXTRA + OP_TYPEPOSQUERY):
		goto __178

	case Tuint32_t(DOP_HSPACE_EXTRA + OP_TYPESTAR):
		goto __179
	case Tuint32_t(DOP_HSPACE_EXTRA + OP_TYPEMINSTAR):
		goto __180
	case Tuint32_t(DOP_HSPACE_EXTRA + OP_TYPEPOSSTAR):
		goto __181

	//-----------------------------------------------------------------
	case Tuint32_t(DOP_PROP_EXTRA + OP_TYPEEXACT):
		goto __182
	case Tuint32_t(DOP_PROP_EXTRA + OP_TYPEUPTO):
		goto __183
	case Tuint32_t(DOP_PROP_EXTRA + OP_TYPEMINUPTO):
		goto __184
	case Tuint32_t(DOP_PROP_EXTRA + OP_TYPEPOSUPTO):
		goto __185

	//-----------------------------------------------------------------
	case Tuint32_t(DOP_EXTUNI_EXTRA + OP_TYPEEXACT):
		goto __186
	case Tuint32_t(DOP_EXTUNI_EXTRA + OP_TYPEUPTO):
		goto __187
	case Tuint32_t(DOP_EXTUNI_EXTRA + OP_TYPEMINUPTO):
		goto __188
	case Tuint32_t(DOP_EXTUNI_EXTRA + OP_TYPEPOSUPTO):
		goto __189

	//-----------------------------------------------------------------
	case Tuint32_t(DOP_ANYNL_EXTRA + OP_TYPEEXACT):
		goto __190
	case Tuint32_t(DOP_ANYNL_EXTRA + OP_TYPEUPTO):
		goto __191
	case Tuint32_t(DOP_ANYNL_EXTRA + OP_TYPEMINUPTO):
		goto __192
	case Tuint32_t(DOP_ANYNL_EXTRA + OP_TYPEPOSUPTO):
		goto __193

	//-----------------------------------------------------------------
	case Tuint32_t(DOP_VSPACE_EXTRA + OP_TYPEEXACT):
		goto __194
	case Tuint32_t(DOP_VSPACE_EXTRA + OP_TYPEUPTO):
		goto __195
	case Tuint32_t(DOP_VSPACE_EXTRA + OP_TYPEMINUPTO):
		goto __196
	case Tuint32_t(DOP_VSPACE_EXTRA + OP_TYPEPOSUPTO):
		goto __197

	//-----------------------------------------------------------------
	case Tuint32_t(DOP_HSPACE_EXTRA + OP_TYPEEXACT):
		goto __198
	case Tuint32_t(DOP_HSPACE_EXTRA + OP_TYPEUPTO):
		goto __199
	case Tuint32_t(DOP_HSPACE_EXTRA + OP_TYPEMINUPTO):
		goto __200
	case Tuint32_t(DOP_HSPACE_EXTRA + OP_TYPEPOSUPTO):
		goto __201

		// ==========================================================================
	// These opcodes are followed by a character that is usually compared
	//       to the current subject character; it is loaded into d. We still get
	//       here even if there is no subject character, because in some cases zero
	//       repetitions are permitted.

	//-----------------------------------------------------------------
	case OP_CHAR:
		goto __202

	//-----------------------------------------------------------------
	case OP_CHARI:
		goto __203

	//-----------------------------------------------------------------
	// This is a tricky one because it can match more than one character.
	//       Find out how many characters to skip, and then set up a negative state
	//       to wait for them to pass before continuing.

	case OP_EXTUNI:
		goto __204

	//-----------------------------------------------------------------
	// This is a tricky like EXTUNI because it too can match more than one
	//       character (when CR is followed by LF). In this case, set up a negative
	//       state to wait for one character to pass before continuing.

	case OP_ANYNL:
		goto __205

	//-----------------------------------------------------------------
	case OP_NOT_VSPACE:
		goto __206

	//-----------------------------------------------------------------
	case OP_VSPACE:
		goto __207

	//-----------------------------------------------------------------
	case OP_NOT_HSPACE:
		goto __208

	//-----------------------------------------------------------------
	case OP_HSPACE:
		goto __209

	//-----------------------------------------------------------------
	// Match a negated single character casefully.

	case OP_NOT:
		goto __210

	//-----------------------------------------------------------------
	// Match a negated single character caselessly.

	case OP_NOTI:
		goto __211

	//-----------------------------------------------------------------
	case OP_PLUSI:
		goto __212
	case OP_MINPLUSI:
		goto __213
	case OP_POSPLUSI:
		goto __214
	case OP_NOTPLUSI:
		goto __215
	case OP_NOTMINPLUSI:
		goto __216
	case OP_NOTPOSPLUSI:
		goto __217

	// Fall through
	case OP_PLUS:
		goto __218
	case OP_MINPLUS:
		goto __219
	case OP_POSPLUS:
		goto __220
	case OP_NOTPLUS:
		goto __221
	case OP_NOTMINPLUS:
		goto __222
	case OP_NOTPOSPLUS:
		goto __223

	//-----------------------------------------------------------------
	case OP_QUERYI:
		goto __224
	case OP_MINQUERYI:
		goto __225
	case OP_POSQUERYI:
		goto __226
	case OP_NOTQUERYI:
		goto __227
	case OP_NOTMINQUERYI:
		goto __228
	case OP_NOTPOSQUERYI:
		goto __229
	// Fall through
	case OP_QUERY:
		goto __230
	case OP_MINQUERY:
		goto __231
	case OP_POSQUERY:
		goto __232
	case OP_NOTQUERY:
		goto __233
	case OP_NOTMINQUERY:
		goto __234
	case OP_NOTPOSQUERY:
		goto __235

	//-----------------------------------------------------------------
	case OP_STARI:
		goto __236
	case OP_MINSTARI:
		goto __237
	case OP_POSSTARI:
		goto __238
	case OP_NOTSTARI:
		goto __239
	case OP_NOTMINSTARI:
		goto __240
	case OP_NOTPOSSTARI:
		goto __241
	// Fall through
	case OP_STAR:
		goto __242
	case OP_MINSTAR:
		goto __243
	case OP_POSSTAR:
		goto __244
	case OP_NOTSTAR:
		goto __245
	case OP_NOTMINSTAR:
		goto __246
	case OP_NOTPOSSTAR:
		goto __247

	//-----------------------------------------------------------------
	case OP_EXACTI:
		goto __248
	case OP_NOTEXACTI:
		goto __249
	// Fall through
	case OP_EXACT:
		goto __250
	case OP_NOTEXACT:
		goto __251

	//-----------------------------------------------------------------
	case OP_UPTOI:
		goto __252
	case OP_MINUPTOI:
		goto __253
	case OP_POSUPTOI:
		goto __254
	case OP_NOTUPTOI:
		goto __255
	case OP_NOTMINUPTOI:
		goto __256
	case OP_NOTPOSUPTOI:
		goto __257
	// Fall through
	case OP_UPTO:
		goto __258
	case OP_MINUPTO:
		goto __259
	case OP_POSUPTO:
		goto __260
	case OP_NOTUPTO:
		goto __261
	case OP_NOTMINUPTO:
		goto __262
	case OP_NOTPOSUPTO:
		goto __263

		// ==========================================================================
	// These are the class-handling opcodes

	case OP_CLASS:
		goto __264
	case OP_NCLASS:
		goto __265
	case OP_XCLASS:
		goto __266

		// ==========================================================================
	// These are the opcodes for fancy brackets of various kinds. We have
	//       to use recursion in order to handle them. The "always failing" assertion
	//       (?!) is optimised to OP_FAIL when compiling, so we have to support that,
	//       though the other "backtracking verbs" are not supported.

	case OP_FAIL:
		goto __267

	case OP_ASSERT:
		goto __268
	case OP_ASSERT_NOT:
		goto __269
	case OP_ASSERTBACK:
		goto __270
	case OP_ASSERTBACK_NOT:
		goto __271

	//-----------------------------------------------------------------
	case OP_COND:
		goto __272
	case OP_SCOND:
		goto __273

	//-----------------------------------------------------------------
	case OP_RECURSE:
		goto __274

	//-----------------------------------------------------------------
	case OP_BRAPOS:
		goto __275
	case OP_SBRAPOS:
		goto __276
	case OP_CBRAPOS:
		goto __277
	case OP_SCBRAPOS:
		goto __278
	case OP_BRAPOSZERO:
		goto __279

	//-----------------------------------------------------------------
	case OP_ONCE:
		goto __280

		// ==========================================================================
	// Handle callouts

	case OP_CALLOUT:
		goto __281
	case OP_CALLOUT_STR:
		goto __282

		// ==========================================================================
	default:
		goto __283
	}
	goto __89

	// ==========================================================================
	// These cases are never obeyed. This is a fudge that causes a compile-
	//       time error if the vectors coptable or poptable, which are indexed by
	//       opcode, are not the correct length. It seems to be the only way to do
	//       such a check at compile time, as the sizeof() operator does not work
	//       in the C preprocessor.

__90:
__91:
	return 0

	// ==========================================================================
	// Reached a closing bracket. If not at the end of the pattern, carry
	//       on with the next opcode. For repeating opcodes, also add the repeat
	//       state. Note that KETRPOS will always be encountered at the end of the
	//       subpattern, because the possessive subpattern repeats are always handled
	//       using recursive calls. Thus, it never adds any new states.
	//
	//       At the end of the (sub)pattern, unless we have an empty string and
	//       PCRE2_NOTEMPTY is set, or PCRE2_NOTEMPTY_ATSTART is set and we are at the
	//       start of the subject, save the match data, shifting up all previous
	//       matches so we always have the longest first.

__92:
__93:
__94:
__95:
	if !(code != end_code) {
		goto __284
	}

	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __286
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 1 + DLINK_SIZE
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __287
__286:
	return -43
__287:
	;
	if !(codevalue != OP_KET) {
		goto __288
	}

	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __289
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset - int32(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))))
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __290
__289:
	return -43
__290:
	;
__288:
	;
	goto __285
__284:

	if !(ptr > current_subject || (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_NOTEMPTY == Tuint32_t(0) && ((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_NOTEMPTY_ATSTART == Tuint32_t(0) || current_subject > start_subject+uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_offset))) {
		goto __291
	}

	if !(match_count < 0) {
		goto __292
	}
	if offsetcount >= Tuint32_t(2) {
		match_count = 1
	} else {
		match_count = 0
	}
	goto __293
__292:
	if !(match_count > 0 && libc.PreIncInt32(&match_count, 1)*2 > int32(offsetcount)) {
		goto __294
	}
	match_count = 0
__294:
	;
__293:
	;
	count = func() int32 {
		if match_count == 0 {
			return int32(offsetcount)
		}
		return match_count * 2
	}() - 2
	if !(count > 0) {
		goto __295
	}
	libc.Xmemmove(tls, offsets+uintptr(2)*8, offsets,
		Tsize_t(count)*Tsize_t(unsafe.Sizeof(Tsize_t(0))))
__295:
	;
	if !(offsetcount >= Tuint32_t(2)) {
		goto __296
	}

	*(*Tsize_t)(unsafe.Pointer(offsets)) = Tsize_t((int64(current_subject) - int64(start_subject)) / 1)
	*(*Tsize_t)(unsafe.Pointer(offsets + 1*8)) = Tsize_t((int64(ptr) - int64(start_subject)) / 1)
__296:
	;
	if !((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_DFA_SHORTEST != Tuint32_t(0)) {
		goto __297
	}
	return match_count
__297:
	;
__291:
	;
__285:
	;
	goto __89

	// ==========================================================================
	// These opcodes add to the current list of states without looking
	//       at the current character.

	//-----------------------------------------------------------------
__96:
__298:
	code += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))))
	goto __299
__299:
	if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code))) == OP_ALT {
		goto __298
	}
	goto __300
__300:
	;
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __301
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = int32((int64(code) - int64(start_code)) / 1)
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __302
__301:
	return -43
__302:
	;
	goto __89

	//-----------------------------------------------------------------
__97:
__98:
__303:

	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __306
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = int32((int64(code)-int64(start_code))/1 + int64(1) + int64(DLINK_SIZE))
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __307
__306:
	return -43
__307:
	;
	code += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))))
	goto __304
__304:
	if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code))) == OP_ALT {
		goto __303
	}
	goto __305
__305:
	;
	goto __89

	//-----------------------------------------------------------------
__99:
__100:
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __308
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = int32((int64(code)-int64(start_code))/1 + int64(1) + int64(DLINK_SIZE) + int64(DIMM2_SIZE))
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __309
__308:
	return -43
__309:
	;
	code += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))))
__310:
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code))) == OP_ALT) {
		goto __311
	}

	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __312
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = int32((int64(code)-int64(start_code))/1 + int64(1) + int64(DLINK_SIZE))
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __313
__312:
	return -43
__313:
	;
	code += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))))
	goto __310
__311:
	;
	goto __89

	//-----------------------------------------------------------------
__101:
__102:
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __314
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __315
__314:
	return -43
__315:
	;
	code += TPCRE2_SPTR8(uint32(1) + uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3)))))
__316:
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code))) == OP_ALT) {
		goto __317
	}
	code += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))))
	goto __316
__317:
	;
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __318
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = int32((int64(code)-int64(start_code))/1 + int64(1) + int64(DLINK_SIZE))
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __319
__318:
	return -43
__319:
	;
	goto __89

	//-----------------------------------------------------------------
__103:
	code += TPCRE2_SPTR8(uint32(1) + uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3)))))
__320:
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code))) == OP_ALT) {
		goto __321
	}
	code += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))))
	goto __320
__321:
	;
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __322
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = int32((int64(code)-int64(start_code))/1 + int64(1) + int64(DLINK_SIZE))
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __323
__322:
	return -43
__323:
	;
	goto __89

	//-----------------------------------------------------------------
__104:
	if !(ptr == start_subject && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_NOTBOL == Tuint32_t(0)) {
		goto __324
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __325
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __326
__325:
	return -43
__326:
	;
__324:
	;
	goto __89

	//-----------------------------------------------------------------
__105:
	if !(ptr == start_subject && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_NOTBOL == Tuint32_t(0) || (ptr != end_subject || (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fpoptions&DPCRE2_ALT_CIRCUMFLEX != Tuint32_t(0)) &&
		func() int32 {
			if (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype != Tuint32_t(DNLTYPE_FIXED) {
				return libc.Bool32(ptr > (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_subject && X_pcre2_was_newline_8(tls, ptr, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_subject, mb+120, utf) != 0)
			}
			return libc.Bool32(ptr >= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_subject+uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr - uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen)))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128))) && ((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(1) || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr - uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen) + uintptr(1)))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128 + 1)))))
		}() != 0) {
		goto __327
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __328
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __329
__328:
	return -43
__329:
	;
__327:
	;
	goto __89

	//-----------------------------------------------------------------
__106:
	if !(ptr >= end_subject) {
		goto __330
	}

	if !((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_PARTIAL_HARD != Tuint32_t(0)) {
		goto __331
	}
	return -2
	goto __332
__331:
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __333
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __334
__333:
	return -43
__334:
	;
__332:
	;
__330:
	;
	goto __89

	//-----------------------------------------------------------------
__107:
	if !(ptr == start_subject) {
		goto __335
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __336
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __337
__336:
	return -43
__337:
	;
__335:
	;
	goto __89

	//-----------------------------------------------------------------
__108:
	if !(ptr == start_subject+uintptr(start_offset)) {
		goto __338
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __339
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __340
__339:
	return -43
__340:
	;
__338:
	;
	goto __89

	// ==========================================================================
	// These opcodes inspect the next subject character, and sometimes
	//       the previous one as well, but do not have an argument. The variable
	//       clen contains the length of the current character and is zero if we are
	//       at the end of the subject.

	//-----------------------------------------------------------------
__109:
	if !(clen > 0 && !(func() int32 {
		if (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype != Tuint32_t(DNLTYPE_FIXED) {
			return libc.Bool32(ptr < (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, ptr, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+120, utf) != 0)
		}
		return libc.Bool32(ptr <= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128))) && ((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(1) || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + uintptr(1)))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128 + 1)))))
	}() != 0)) {
		goto __341
	}

	if !(ptr+uintptr(1) >= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_PARTIAL_HARD != Tuint32_t(0) && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype == Tuint32_t(DNLTYPE_FIXED) && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(2) && c == Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128)))) {
		goto __342
	}

	could_continue = libc.AssignInt32(&partial_newline, DTRUE)
	goto __343
__342:

	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __344
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __345
__344:
	return -43
__345:
	;
__343:
	;
__341:
	;
	goto __89

	//-----------------------------------------------------------------
__110:
	if !(clen > 0) {
		goto __346
	}
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __347
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __348
__347:
	return -43
__348:
	;
__346:
	;
	goto __89

	//-----------------------------------------------------------------
__111:
	if !(clen == 0 || func() int32 {
		if (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype != Tuint32_t(DNLTYPE_FIXED) {
			return libc.Bool32(ptr < (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, ptr, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+120, utf) != 0)
		}
		return libc.Bool32(ptr <= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128))) && ((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(1) || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + uintptr(1)))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128 + 1)))))
	}() != 0 && ptr == end_subject-uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen)) {
		goto __349
	}

	if !((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_PARTIAL_HARD != Tuint32_t(0)) {
		goto __350
	}
	return -2
__350:
	;
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __351
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __352
__351:
	return -43
__352:
	;
__349:
	;
	goto __89

	//-----------------------------------------------------------------
__112:
	if !((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_NOTEOL == Tuint32_t(0)) {
		goto __353
	}

	if !(clen == 0 && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_PARTIAL_HARD != Tuint32_t(0)) {
		goto __354
	}
	could_continue = DTRUE
	goto __355
__354:
	if !(clen == 0 || (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fpoptions&DPCRE2_DOLLAR_ENDONLY == Tuint32_t(0) && func() int32 {
		if (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype != Tuint32_t(DNLTYPE_FIXED) {
			return libc.Bool32(ptr < (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, ptr, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+120, utf) != 0)
		}
		return libc.Bool32(ptr <= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128))) && ((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(1) || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + uintptr(1)))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128 + 1)))))
	}() != 0 && ptr == end_subject-uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen)) {
		goto __356
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __358
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __359
__358:
	return -43
__359:
	;
	goto __357
__356:
	if !(ptr+uintptr(1) >= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&(DPCRE2_PARTIAL_HARD|DPCRE2_PARTIAL_SOFT) != Tuint32_t(0) && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype == Tuint32_t(DNLTYPE_FIXED) && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(2) && c == Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128)))) {
		goto __360
	}

	if !((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_PARTIAL_HARD != Tuint32_t(0)) {
		goto __361
	}

	reset_could_continue = DTRUE
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __363
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -(state_offset + 1)
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = 1
	next_new_state += 12
	goto __364
__363:
	return -43
__364:
	;
	goto __362
__361:
	could_continue = libc.AssignInt32(&partial_newline, DTRUE)
__362:
	;
__360:
	;
__357:
	;
__355:
	;
__353:
	;
	goto __89

	//-----------------------------------------------------------------
__113:
	if !((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_NOTEOL == Tuint32_t(0)) {
		goto __365
	}

	if !(clen == 0 && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_PARTIAL_HARD != Tuint32_t(0)) {
		goto __367
	}
	could_continue = DTRUE
	goto __368
__367:
	if !(clen == 0 || (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fpoptions&DPCRE2_DOLLAR_ENDONLY == Tuint32_t(0) && func() int32 {
		if (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype != Tuint32_t(DNLTYPE_FIXED) {
			return libc.Bool32(ptr < (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, ptr, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+120, utf) != 0)
		}
		return libc.Bool32(ptr <= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128))) && ((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(1) || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + uintptr(1)))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128 + 1)))))
	}() != 0) {
		goto __369
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __371
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __372
__371:
	return -43
__372:
	;
	goto __370
__369:
	if !(ptr+uintptr(1) >= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&(DPCRE2_PARTIAL_HARD|DPCRE2_PARTIAL_SOFT) != Tuint32_t(0) && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype == Tuint32_t(DNLTYPE_FIXED) && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(2) && c == Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128)))) {
		goto __373
	}

	if !((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_PARTIAL_HARD != Tuint32_t(0)) {
		goto __374
	}

	reset_could_continue = DTRUE
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __376
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -(state_offset + 1)
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = 1
	next_new_state += 12
	goto __377
__376:
	return -43
__377:
	;
	goto __375
__374:
	could_continue = libc.AssignInt32(&partial_newline, DTRUE)
__375:
	;
__373:
	;
__370:
	;
__368:
	;
	goto __366
__365:
	if !(func() int32 {
		if (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype != Tuint32_t(DNLTYPE_FIXED) {
			return libc.Bool32(ptr < (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, ptr, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+120, utf) != 0)
		}
		return libc.Bool32(ptr <= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128))) && ((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(1) || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + uintptr(1)))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128 + 1)))))
	}() != 0) {
		goto __378
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __379
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __380
__379:
	return -43
__380:
	;
__378:
	;
__366:
	;
	goto __89

	//-----------------------------------------------------------------

__114:
__115:
__116:
	if !(clen > 0 && c < Tuint32_t(256) && int32(*(*Tuint8_t)(unsafe.Pointer(ctypes + uintptr(c))))&int32(toptable1[codevalue])^int32(toptable2[codevalue]) != 0) {
		goto __381
	}
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __382
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __383
__382:
	return -43
__383:
	;
__381:
	;
	goto __89

	//-----------------------------------------------------------------
__117:
__118:
__119:
	if !(clen > 0 && (c >= Tuint32_t(256) || int32(*(*Tuint8_t)(unsafe.Pointer(ctypes + uintptr(c))))&int32(toptable1[codevalue])^int32(toptable2[codevalue]) != 0)) {
		goto __384
	}
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __385
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __386
__385:
	return -43
__386:
	;
__384:
	;
	goto __89

	//-----------------------------------------------------------------
__120:
__121:

	if !(ptr > start_subject) {
		goto __387
	}

	temp = ptr - uintptr(1)
	if !(temp < (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr) {
		goto __389
	}
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr = temp
__389:
	;
	if !(utf != 0) {
		goto __390
	}
__391:
	if !(uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(temp)))&0xc0 == 0x80) {
		goto __392
	}
	temp--
	goto __391
__392:
	;
__390:
	;
	d = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(temp)))
	if !(utf != 0 && d >= 0xc0) {
		goto __393
	}
	if !(d&0x20 == Tuint32_t(0)) {
		goto __394
	}
	d = d&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(temp + 1)))&0x3f
	goto __395
__394:
	if !(d&0x10 == Tuint32_t(0)) {
		goto __396
	}
	d = d&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(temp + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(temp + 2)))&0x3f
	goto __397
__396:
	if !(d&0x08 == Tuint32_t(0)) {
		goto __398
	}
	d = d&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(temp + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(temp + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(temp + 3)))&0x3f
	goto __399
__398:
	if !(d&0x04 == Tuint32_t(0)) {
		goto __400
	}
	d = d&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(temp + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(temp + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(temp + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(temp + 4)))&0x3f
	goto __401
__400:
	d = d&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(temp + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(temp + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(temp + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(temp + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(temp + 5)))&0x3f
__401:
	;
__399:
	;
__397:
	;
__395:
	;
__393:
	;

	if !((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fpoptions&DPCRE2_UCP != Tuint32_t(0)) {
		goto __402
	}

	if !(d == Tuint32_t('_')) {
		goto __404
	}
	left_word = DTRUE
	goto __405
__404:

	cat = X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(d)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(d)%DUCD_BLOCK_SIZE])*12)).Fchartype]
	left_word = libc.Bool32(cat == ucp_L || cat == ucp_N)
__405:
	;
	goto __403
__402:
	left_word = libc.Bool32(d < Tuint32_t(256) && int32(*(*Tuint8_t)(unsafe.Pointer(ctypes + uintptr(d))))&Dctype_word != 0)
__403:
	;
	goto __388
__387:
	left_word = DFALSE
__388:
	;

	if !(clen > 0) {
		goto __406
	}

	if !(ptr >= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Flast_used_ptr) {
		goto __408
	}

	temp1 = ptr + uintptr(1)
	if !(utf != 0) {
		goto __409
	}
__410:
	if !(temp1 < (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(temp1)))&0xc0 == 0x80) {
		goto __411
	}
	temp1++
	goto __410
__411:
	;
__409:
	;
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Flast_used_ptr = temp1
__408:
	;
	if !((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fpoptions&DPCRE2_UCP != Tuint32_t(0)) {
		goto __412
	}

	if !(c == Tuint32_t('_')) {
		goto __414
	}
	right_word = DTRUE
	goto __415
__414:

	cat1 = X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12)).Fchartype]
	right_word = libc.Bool32(cat1 == ucp_L || cat1 == ucp_N)
__415:
	;
	goto __413
__412:
	right_word = libc.Bool32(c < Tuint32_t(256) && int32(*(*Tuint8_t)(unsafe.Pointer(ctypes + uintptr(c))))&Dctype_word != 0)
__413:
	;
	goto __407
__406:
	right_word = DFALSE
__407:
	;

	if !(libc.Bool32(left_word == right_word) == libc.Bool32(codevalue == OP_NOT_WORD_BOUNDARY)) {
		goto __416
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __417
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __418
__417:
	return -43
__418:
	;
__416:
	;

	goto __89

	//-----------------------------------------------------------------
	// Check the next character by Unicode property. We will get here only
	//       if the support is in the binary; otherwise a compile-time error occurs.
	//

__122:
__123:
	if !(clen > 0) {
		goto __419
	}

	prop = uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12
	switch int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1))) {
	case DPT_ANY:
		goto __421

	case DPT_LAMP:
		goto __422

	case DPT_GC:
		goto __423

	case DPT_PC:
		goto __424

	case DPT_SC:
		goto __425

	case DPT_SCX:
		goto __426

	// These are specials for combination cases.

	case DPT_ALNUM:
		goto __427

	// Perl space used to exclude VT, but from Perl 5.18 it is included,
	//           which means that Perl space and POSIX space are now identical. PCRE
	//           was changed at release 8.34.

	case DPT_SPACE:
		goto __428 // Perl space
	case DPT_PXSPACE:
		goto __429

	case DPT_WORD:
		goto __430

	case DPT_CLIST:
		goto __431

	case DPT_UCNC:
		goto __432

	case DPT_BIDICL:
		goto __433

	case DPT_BOOL:
		goto __434

	// Should never occur, but keep compilers from grumbling.

	default:
		goto __435
	}
	goto __420

__421:
	OK = DTRUE
	goto __420

__422:
	OK = libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop)).Fchartype) == ucp_Lu || int32((*Tucd_record)(unsafe.Pointer(prop)).Fchartype) == ucp_Ll || int32((*Tucd_record)(unsafe.Pointer(prop)).Fchartype) == ucp_Lt)
	goto __420

__423:
	OK = libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2))))
	goto __420

__424:
	OK = libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop)).Fchartype) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2))))
	goto __420

__425:
	OK = libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop)).Fscript) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2))))
	goto __420

__426:
	OK = libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop)).Fscript) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2))) || *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_script_sets_8)) + uintptr(int32((*Tucd_record)(unsafe.Pointer(prop)).Fscriptx_bidiclass)&DUCD_SCRIPTX_MASK)*4 + uintptr(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))/32)*4))&(uint32(1)<<(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))%32)) != Tuint32_t(0))
	goto __420

	// These are specials for combination cases.

__427:
	OK = libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_L || X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_N)
	goto __420

	// Perl space used to exclude VT, but from Perl 5.18 it is included,
	//           which means that Perl space and POSIX space are now identical. PCRE
	//           was changed at release 8.34.

__428: // Perl space
__429: // POSIX space
	switch c {
	case Tuint32_t('\011'):
		goto __437
	case Tuint32_t('\040'):
		goto __438
	case Tuint32_t(uint8('\xa0')):
		goto __439
	case Tuint32_t(0x1680):
		goto __440 /* OGHAM SPACE MARK */
	case Tuint32_t(0x180e):
		goto __441 /* MONGOLIAN VOWEL SEPARATOR */
	case Tuint32_t(0x2000):
		goto __442 /* EN QUAD */
	case Tuint32_t(0x2001):
		goto __443 /* EM QUAD */
	case Tuint32_t(0x2002):
		goto __444 /* EN SPACE */
	case Tuint32_t(0x2003):
		goto __445 /* EM SPACE */
	case Tuint32_t(0x2004):
		goto __446 /* THREE-PER-EM SPACE */
	case Tuint32_t(0x2005):
		goto __447 /* FOUR-PER-EM SPACE */
	case Tuint32_t(0x2006):
		goto __448 /* SIX-PER-EM SPACE */
	case Tuint32_t(0x2007):
		goto __449 /* FIGURE SPACE */
	case Tuint32_t(0x2008):
		goto __450 /* PUNCTUATION SPACE */
	case Tuint32_t(0x2009):
		goto __451 /* THIN SPACE */
	case Tuint32_t(0x200A):
		goto __452 /* HAIR SPACE */
	case Tuint32_t(0x202f):
		goto __453 /* NARROW NO-BREAK SPACE */
	case Tuint32_t(0x205f):
		goto __454 /* MEDIUM MATHEMATICAL SPACE */
	case Tuint32_t(0x3000):
		goto __455
	case Tuint32_t('\012'):
		goto __456
	case Tuint32_t('\013'):
		goto __457
	case Tuint32_t('\014'):
		goto __458
	case Tuint32_t('\015'):
		goto __459
	case Tuint32_t(uint8('\x85')):
		goto __460
	case Tuint32_t(0x2028):
		goto __461 /* LINE SEPARATOR */
	case Tuint32_t(0x2029):
		goto __462

	default:
		goto __463
	}
	goto __436

__437:
__438:
__439:
__440: /* OGHAM SPACE MARK */
__441: /* MONGOLIAN VOWEL SEPARATOR */
__442: /* EN QUAD */
__443: /* EM QUAD */
__444: /* EN SPACE */
__445: /* EM SPACE */
__446: /* THREE-PER-EM SPACE */
__447: /* FOUR-PER-EM SPACE */
__448: /* SIX-PER-EM SPACE */
__449: /* FIGURE SPACE */
__450: /* PUNCTUATION SPACE */
__451: /* THIN SPACE */
__452: /* HAIR SPACE */
__453: /* NARROW NO-BREAK SPACE */
__454: /* MEDIUM MATHEMATICAL SPACE */
__455:
__456:
__457:
__458:
__459:
__460:
__461: /* LINE SEPARATOR */
__462:
	OK = DTRUE
	goto __436

__463:
	OK = libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_Z)
	goto __436
__436:
	;
	goto __420

__430:
	OK = libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_L || X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_N || c == Tuint32_t('\137'))
	goto __420

__431:
	cp = uintptr(unsafe.Pointer(&X_pcre2_ucd_caseless_sets_8)) + uintptr(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))*4
__464:

	if !(c < *(*Tuint32_t)(unsafe.Pointer(cp))) {
		goto __467
	}
	OK = DFALSE
	goto __466
__467:
	;
	if !(c == *(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&cp, 4)))) {
		goto __468
	}
	OK = DTRUE
	goto __466
__468:
	;
	goto __465
__465:
	goto __464
	goto __466
__466:
	;
	goto __420

__432:
	OK = libc.Bool32(c == Tuint32_t('\044') || c == Tuint32_t('\100') || c == Tuint32_t('\140') || c >= Tuint32_t(0xa0) && c <= Tuint32_t(0xd7ff) || c >= Tuint32_t(0xe000))
	goto __420

__433:
	OK = libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12)).Fscriptx_bidiclass)>>DUCD_BIDICLASS_SHIFT == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2))))
	goto __420

__434:
	OK = libc.Bool32(*(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_boolprop_sets_8)) + uintptr(int32((*Tucd_record)(unsafe.Pointer(prop)).Fbprops)&DUCD_BPROPS_MASK)*4 + uintptr(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))/32)*4))&(uint32(1)<<(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))%32)) != Tuint32_t(0))
	goto __420

	// Should never occur, but keep compilers from grumbling.

__435:
	OK = libc.Bool32(codevalue != OP_PROP)
	goto __420
__420:
	;

	if !(OK == libc.Bool32(codevalue == OP_PROP)) {
		goto __469
	}
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __470
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + 3
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __471
__470:
	return -43
__471:
	;
__469:
	;
__419:
	;
	goto __89

	// ==========================================================================
	// These opcodes likewise inspect the subject character, but have an
	//       argument that is not a data character. It is one of these opcodes:
	//       OP_ANY, OP_ALLANY, OP_DIGIT, OP_NOT_DIGIT, OP_WHITESPACE, OP_NOT_SPACE,
	//       OP_WORDCHAR, OP_NOT_WORDCHAR. The value is loaded into d.

__124:
__125:
__126:
	count = (*Tstateblock)(unsafe.Pointer(current_state)).Fcount // Already matched
	if !(count > 0) {
		goto __472
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __473
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 2
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __474
__473:
	return -43
__474:
	;
__472:
	;
	if !(clen > 0) {
		goto __475
	}

	if !(d == OP_ANY && ptr+uintptr(1) >= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_PARTIAL_HARD != Tuint32_t(0) && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype == Tuint32_t(DNLTYPE_FIXED) && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(2) && c == Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128)))) {
		goto __476
	}

	could_continue = libc.AssignInt32(&partial_newline, DTRUE)
	goto __477
__476:
	if !(c >= Tuint32_t(256) && d != OP_DIGIT && d != OP_WHITESPACE && d != OP_WORDCHAR || c < Tuint32_t(256) && (d != OP_ANY || !(func() int32 {
		if (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype != Tuint32_t(DNLTYPE_FIXED) {
			return libc.Bool32(ptr < (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, ptr, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+120, utf) != 0)
		}
		return libc.Bool32(ptr <= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128))) && ((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(1) || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + uintptr(1)))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128 + 1)))))
	}() != 0)) && int32(*(*Tuint8_t)(unsafe.Pointer(ctypes + uintptr(c))))&int32(toptable1[d])^int32(toptable2[d]) != 0) {
		goto __478
	}

	if !(count > 0 && codevalue == OP_TYPEPOSPLUS) {
		goto __479
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__479:
	;
	count++
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __480
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = count
	next_new_state += 12
	goto __481
__480:
	return -43
__481:
	;
__478:
	;
__477:
	;
__475:
	;
	goto __89

	//-----------------------------------------------------------------
__127:
__128:
__129:
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __482
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 2
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __483
__482:
	return -43
__483:
	;
	if !(clen > 0) {
		goto __484
	}

	if !(d == OP_ANY && ptr+uintptr(1) >= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_PARTIAL_HARD != Tuint32_t(0) && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype == Tuint32_t(DNLTYPE_FIXED) && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(2) && c == Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128)))) {
		goto __485
	}

	could_continue = libc.AssignInt32(&partial_newline, DTRUE)
	goto __486
__485:
	if !(c >= Tuint32_t(256) && d != OP_DIGIT && d != OP_WHITESPACE && d != OP_WORDCHAR || c < Tuint32_t(256) && (d != OP_ANY || !(func() int32 {
		if (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype != Tuint32_t(DNLTYPE_FIXED) {
			return libc.Bool32(ptr < (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, ptr, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+120, utf) != 0)
		}
		return libc.Bool32(ptr <= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128))) && ((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(1) || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + uintptr(1)))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128 + 1)))))
	}() != 0)) && int32(*(*Tuint8_t)(unsafe.Pointer(ctypes + uintptr(c))))&int32(toptable1[d])^int32(toptable2[d]) != 0) {
		goto __487
	}

	if !(codevalue == OP_TYPEPOSQUERY) {
		goto __488
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__488:
	;
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __489
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + 2
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __490
__489:
	return -43
__490:
	;
__487:
	;
__486:
	;
__484:
	;
	goto __89

	//-----------------------------------------------------------------
__130:
__131:
__132:
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __491
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 2
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __492
__491:
	return -43
__492:
	;
	if !(clen > 0) {
		goto __493
	}

	if !(d == OP_ANY && ptr+uintptr(1) >= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_PARTIAL_HARD != Tuint32_t(0) && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype == Tuint32_t(DNLTYPE_FIXED) && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(2) && c == Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128)))) {
		goto __494
	}

	could_continue = libc.AssignInt32(&partial_newline, DTRUE)
	goto __495
__494:
	if !(c >= Tuint32_t(256) && d != OP_DIGIT && d != OP_WHITESPACE && d != OP_WORDCHAR || c < Tuint32_t(256) && (d != OP_ANY || !(func() int32 {
		if (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype != Tuint32_t(DNLTYPE_FIXED) {
			return libc.Bool32(ptr < (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, ptr, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+120, utf) != 0)
		}
		return libc.Bool32(ptr <= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128))) && ((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(1) || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + uintptr(1)))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128 + 1)))))
	}() != 0)) && int32(*(*Tuint8_t)(unsafe.Pointer(ctypes + uintptr(c))))&int32(toptable1[d])^int32(toptable2[d]) != 0) {
		goto __496
	}

	if !(codevalue == OP_TYPEPOSSTAR) {
		goto __497
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__497:
	;
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __498
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __499
__498:
	return -43
__499:
	;
__496:
	;
__495:
	;
__493:
	;
	goto __89

	//-----------------------------------------------------------------
__133:
	count = (*Tstateblock)(unsafe.Pointer(current_state)).Fcount // Number already matched
	if !(clen > 0) {
		goto __500
	}

	if !(d == OP_ANY && ptr+uintptr(1) >= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_PARTIAL_HARD != Tuint32_t(0) && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype == Tuint32_t(DNLTYPE_FIXED) && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(2) && c == Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128)))) {
		goto __501
	}

	could_continue = libc.AssignInt32(&partial_newline, DTRUE)
	goto __502
__501:
	if !(c >= Tuint32_t(256) && d != OP_DIGIT && d != OP_WHITESPACE && d != OP_WORDCHAR || c < Tuint32_t(256) && (d != OP_ANY || !(func() int32 {
		if (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype != Tuint32_t(DNLTYPE_FIXED) {
			return libc.Bool32(ptr < (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, ptr, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+120, utf) != 0)
		}
		return libc.Bool32(ptr <= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128))) && ((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(1) || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + uintptr(1)))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128 + 1)))))
	}() != 0)) && int32(*(*Tuint8_t)(unsafe.Pointer(ctypes + uintptr(c))))&int32(toptable1[d])^int32(toptable2[d]) != 0) {
		goto __503
	}

	if !(libc.PreIncInt32(&count, 1) >= int32(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))))) {
		goto __504
	}
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __506
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + 1 + DIMM2_SIZE + 1
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __507
__506:
	return -43
__507:
	;
	goto __505
__504:
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __508
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = count
	next_new_state += 12
	goto __509
__508:
	return -43
__509:
	;
__505:
	;
__503:
	;
__502:
	;
__500:
	;
	goto __89

	//-----------------------------------------------------------------
__134:
__135:
__136:
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __510
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 2 + DIMM2_SIZE
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __511
__510:
	return -43
__511:
	;
	count = (*Tstateblock)(unsafe.Pointer(current_state)).Fcount // Number already matched
	if !(clen > 0) {
		goto __512
	}

	if !(d == OP_ANY && ptr+uintptr(1) >= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_PARTIAL_HARD != Tuint32_t(0) && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype == Tuint32_t(DNLTYPE_FIXED) && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(2) && c == Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128)))) {
		goto __513
	}

	could_continue = libc.AssignInt32(&partial_newline, DTRUE)
	goto __514
__513:
	if !(c >= Tuint32_t(256) && d != OP_DIGIT && d != OP_WHITESPACE && d != OP_WORDCHAR || c < Tuint32_t(256) && (d != OP_ANY || !(func() int32 {
		if (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype != Tuint32_t(DNLTYPE_FIXED) {
			return libc.Bool32(ptr < (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, ptr, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+120, utf) != 0)
		}
		return libc.Bool32(ptr <= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128))) && ((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(1) || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + uintptr(1)))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128 + 1)))))
	}() != 0)) && int32(*(*Tuint8_t)(unsafe.Pointer(ctypes + uintptr(c))))&int32(toptable1[d])^int32(toptable2[d]) != 0) {
		goto __515
	}

	if !(codevalue == OP_TYPEPOSUPTO) {
		goto __516
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__516:
	;
	if !(libc.PreIncInt32(&count, 1) >= int32(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))))) {
		goto __517
	}
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __519
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + 2 + DIMM2_SIZE
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __520
__519:
	return -43
__520:
	;
	goto __518
__517:
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __521
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = count
	next_new_state += 12
	goto __522
__521:
	return -43
__522:
	;
__518:
	;
__515:
	;
__514:
	;
__512:
	;
	goto __89

	// ==========================================================================
	// These are virtual opcodes that are used when something like
	//       OP_TYPEPLUS has OP_PROP, OP_NOTPROP, OP_ANYNL, or OP_EXTUNI as its
	//       argument. It keeps the code above fast for the other cases. The argument
	//       is in the d variable.

__137:
__138:
__139:
	count = (*Tstateblock)(unsafe.Pointer(current_state)).Fcount // Already matched
	if !(count > 0) {
		goto __523
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __524
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 4
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __525
__524:
	return -43
__525:
	;
__523:
	;
	if !(clen > 0) {
		goto __526
	}

	prop1 = uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12
	switch int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2))) {
	case DPT_ANY:
		goto __528

	case DPT_LAMP:
		goto __529

	case DPT_GC:
		goto __530

	case DPT_PC:
		goto __531

	case DPT_SC:
		goto __532

	case DPT_SCX:
		goto __533

	// These are specials for combination cases.

	case DPT_ALNUM:
		goto __534

	// Perl space used to exclude VT, but from Perl 5.18 it is included,
	//           which means that Perl space and POSIX space are now identical. PCRE
	//           was changed at release 8.34.

	case DPT_SPACE:
		goto __535 // Perl space
	case DPT_PXSPACE:
		goto __536

	case DPT_WORD:
		goto __537

	case DPT_CLIST:
		goto __538

	case DPT_UCNC:
		goto __539

	case DPT_BIDICL:
		goto __540

	case DPT_BOOL:
		goto __541

	// Should never occur, but keep compilers from grumbling.

	default:
		goto __542
	}
	goto __527

__528:
	OK1 = DTRUE
	goto __527

__529:
	OK1 = libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop1)).Fchartype) == ucp_Lu || int32((*Tucd_record)(unsafe.Pointer(prop1)).Fchartype) == ucp_Ll || int32((*Tucd_record)(unsafe.Pointer(prop1)).Fchartype) == ucp_Lt)
	goto __527

__530:
	OK1 = libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop1)).Fchartype] == Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3))))
	goto __527

__531:
	OK1 = libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop1)).Fchartype) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3))))
	goto __527

__532:
	OK1 = libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop1)).Fscript) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3))))
	goto __527

__533:
	OK1 = libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop1)).Fscript) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3))) || *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_script_sets_8)) + uintptr(int32((*Tucd_record)(unsafe.Pointer(prop1)).Fscriptx_bidiclass)&DUCD_SCRIPTX_MASK)*4 + uintptr(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3)))/32)*4))&(uint32(1)<<(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3)))%32)) != Tuint32_t(0))
	goto __527

	// These are specials for combination cases.

__534:
	OK1 = libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop1)).Fchartype] == ucp_L || X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop1)).Fchartype] == ucp_N)
	goto __527

	// Perl space used to exclude VT, but from Perl 5.18 it is included,
	//           which means that Perl space and POSIX space are now identical. PCRE
	//           was changed at release 8.34.

__535: // Perl space
__536: // POSIX space
	switch c {
	case Tuint32_t('\011'):
		goto __544
	case Tuint32_t('\040'):
		goto __545
	case Tuint32_t(uint8('\xa0')):
		goto __546
	case Tuint32_t(0x1680):
		goto __547 /* OGHAM SPACE MARK */
	case Tuint32_t(0x180e):
		goto __548 /* MONGOLIAN VOWEL SEPARATOR */
	case Tuint32_t(0x2000):
		goto __549 /* EN QUAD */
	case Tuint32_t(0x2001):
		goto __550 /* EM QUAD */
	case Tuint32_t(0x2002):
		goto __551 /* EN SPACE */
	case Tuint32_t(0x2003):
		goto __552 /* EM SPACE */
	case Tuint32_t(0x2004):
		goto __553 /* THREE-PER-EM SPACE */
	case Tuint32_t(0x2005):
		goto __554 /* FOUR-PER-EM SPACE */
	case Tuint32_t(0x2006):
		goto __555 /* SIX-PER-EM SPACE */
	case Tuint32_t(0x2007):
		goto __556 /* FIGURE SPACE */
	case Tuint32_t(0x2008):
		goto __557 /* PUNCTUATION SPACE */
	case Tuint32_t(0x2009):
		goto __558 /* THIN SPACE */
	case Tuint32_t(0x200A):
		goto __559 /* HAIR SPACE */
	case Tuint32_t(0x202f):
		goto __560 /* NARROW NO-BREAK SPACE */
	case Tuint32_t(0x205f):
		goto __561 /* MEDIUM MATHEMATICAL SPACE */
	case Tuint32_t(0x3000):
		goto __562
	case Tuint32_t('\012'):
		goto __563
	case Tuint32_t('\013'):
		goto __564
	case Tuint32_t('\014'):
		goto __565
	case Tuint32_t('\015'):
		goto __566
	case Tuint32_t(uint8('\x85')):
		goto __567
	case Tuint32_t(0x2028):
		goto __568 /* LINE SEPARATOR */
	case Tuint32_t(0x2029):
		goto __569

	default:
		goto __570
	}
	goto __543

__544:
__545:
__546:
__547: /* OGHAM SPACE MARK */
__548: /* MONGOLIAN VOWEL SEPARATOR */
__549: /* EN QUAD */
__550: /* EM QUAD */
__551: /* EN SPACE */
__552: /* EM SPACE */
__553: /* THREE-PER-EM SPACE */
__554: /* FOUR-PER-EM SPACE */
__555: /* SIX-PER-EM SPACE */
__556: /* FIGURE SPACE */
__557: /* PUNCTUATION SPACE */
__558: /* THIN SPACE */
__559: /* HAIR SPACE */
__560: /* NARROW NO-BREAK SPACE */
__561: /* MEDIUM MATHEMATICAL SPACE */
__562:
__563:
__564:
__565:
__566:
__567:
__568: /* LINE SEPARATOR */
__569:
	OK1 = DTRUE
	goto __543

__570:
	OK1 = libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop1)).Fchartype] == ucp_Z)
	goto __543
__543:
	;
	goto __527

__537:
	OK1 = libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop1)).Fchartype] == ucp_L || X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop1)).Fchartype] == ucp_N || c == Tuint32_t('\137'))
	goto __527

__538:
	cp1 = uintptr(unsafe.Pointer(&X_pcre2_ucd_caseless_sets_8)) + uintptr(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3)))*4
__571:

	if !(c < *(*Tuint32_t)(unsafe.Pointer(cp1))) {
		goto __574
	}
	OK1 = DFALSE
	goto __573
__574:
	;
	if !(c == *(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&cp1, 4)))) {
		goto __575
	}
	OK1 = DTRUE
	goto __573
__575:
	;
	goto __572
__572:
	goto __571
	goto __573
__573:
	;
	goto __527

__539:
	OK1 = libc.Bool32(c == Tuint32_t('\044') || c == Tuint32_t('\100') || c == Tuint32_t('\140') || c >= Tuint32_t(0xa0) && c <= Tuint32_t(0xd7ff) || c >= Tuint32_t(0xe000))
	goto __527

__540:
	OK1 = libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12)).Fscriptx_bidiclass)>>DUCD_BIDICLASS_SHIFT == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3))))
	goto __527

__541:
	OK1 = libc.Bool32(*(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_boolprop_sets_8)) + uintptr(int32((*Tucd_record)(unsafe.Pointer(prop1)).Fbprops)&DUCD_BPROPS_MASK)*4 + uintptr(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3)))/32)*4))&(uint32(1)<<(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3)))%32)) != Tuint32_t(0))
	goto __527

	// Should never occur, but keep compilers from grumbling.

__542:
	OK1 = libc.Bool32(codevalue != OP_PROP)
	goto __527
__527:
	;

	if !(OK1 == libc.Bool32(d == OP_PROP)) {
		goto __576
	}

	if !(count > 0 && codevalue == Tuint32_t(DOP_PROP_EXTRA+OP_TYPEPOSPLUS)) {
		goto __577
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__577:
	;
	count++
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __578
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = count
	next_new_state += 12
	goto __579
__578:
	return -43
__579:
	;
__576:
	;
__526:
	;
	goto __89

	//-----------------------------------------------------------------
__140:
__141:
__142:
	count = (*Tstateblock)(unsafe.Pointer(current_state)).Fcount // Already matched
	if !(count > 0) {
		goto __580
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __581
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 2
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __582
__581:
	return -43
__582:
	;
__580:
	;
	if !(clen > 0) {
		goto __583
	}

	*(*int32)(unsafe.Pointer(bp /* ncount */)) = 0
	if !(count > 0 && codevalue == Tuint32_t(DOP_EXTUNI_EXTRA+OP_TYPEPOSPLUS)) {
		goto __584
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__584:
	;
	X_pcre2_extuni_8(tls, c, ptr+uintptr(clen), (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_subject, end_subject, utf,
		bp)
	count++
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __585
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = count
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = *(*int32)(unsafe.Pointer(bp))
	next_new_state += 12
	goto __586
__585:
	return -43
__586:
	;
__583:
	;
	goto __89

	//-----------------------------------------------------------------
__143:
__144:
__145:
	count = (*Tstateblock)(unsafe.Pointer(current_state)).Fcount // Already matched
	if !(count > 0) {
		goto __587
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __588
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 2
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __589
__588:
	return -43
__589:
	;
__587:
	;
	if !(clen > 0) {
		goto __590
	}
	ncount1 = 0
	switch c {
	case Tuint32_t('\013'):
		goto __592
	case Tuint32_t('\014'):
		goto __593
	case Tuint32_t(uint8('\x85')):
		goto __594
	case Tuint32_t(0x2028):
		goto __595
	case Tuint32_t(0x2029):
		goto __596

	case Tuint32_t('\015'):
		goto __597
	case Tuint32_t('\012'):
		goto __598

	default:
		goto __599
	}
	goto __591

__592:
__593:
__594:
__595:
__596:
	if !(int32((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fbsr_convention) == DPCRE2_BSR_ANYCRLF) {
		goto __600
	}
	goto __591
__600:
	;
	goto ANYNL01

__597:
	if !(ptr+uintptr(1) < end_subject && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + uintptr(1)))) == '\012') {
		goto __601
	}
	ncount1 = 1
__601:
	;
	// Fall through

ANYNL01:
__598:
	if !(count > 0 && codevalue == Tuint32_t(DOP_ANYNL_EXTRA+OP_TYPEPOSPLUS)) {
		goto __602
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__602:
	;
	count++
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __603
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = count
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = ncount1
	next_new_state += 12
	goto __604
__603:
	return -43
__604:
	;
	goto __591

__599:
	goto __591
__591:
	;
__590:
	;
	goto __89

	//-----------------------------------------------------------------
__146:
__147:
__148:
	count = (*Tstateblock)(unsafe.Pointer(current_state)).Fcount // Already matched
	if !(count > 0) {
		goto __605
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __606
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 2
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __607
__606:
	return -43
__607:
	;
__605:
	;
	if !(clen > 0) {
		goto __608
	}

	switch c {
	case Tuint32_t('\012'):
		goto __610
	case Tuint32_t('\013'):
		goto __611
	case Tuint32_t('\014'):
		goto __612
	case Tuint32_t('\015'):
		goto __613
	case Tuint32_t(uint8('\x85')):
		goto __614
	case Tuint32_t(0x2028):
		goto __615 /* LINE SEPARATOR */
	case Tuint32_t(0x2029):
		goto __616

	default:
		goto __617
	}
	goto __609

__610:
__611:
__612:
__613:
__614:
__615: /* LINE SEPARATOR */
__616:
	OK2 = DTRUE
	goto __609

__617:
	OK2 = DFALSE
	goto __609
__609:
	;

	if !(OK2 == libc.Bool32(d == OP_VSPACE)) {
		goto __618
	}

	if !(count > 0 && codevalue == Tuint32_t(DOP_VSPACE_EXTRA+OP_TYPEPOSPLUS)) {
		goto __619
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__619:
	;
	count++
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __620
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = count
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = 0
	next_new_state += 12
	goto __621
__620:
	return -43
__621:
	;
__618:
	;
__608:
	;
	goto __89

	//-----------------------------------------------------------------
__149:
__150:
__151:
	count = (*Tstateblock)(unsafe.Pointer(current_state)).Fcount // Already matched
	if !(count > 0) {
		goto __622
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __623
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 2
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __624
__623:
	return -43
__624:
	;
__622:
	;
	if !(clen > 0) {
		goto __625
	}

	switch c {
	case Tuint32_t('\011'):
		goto __627
	case Tuint32_t('\040'):
		goto __628
	case Tuint32_t(uint8('\xa0')):
		goto __629
	case Tuint32_t(0x1680):
		goto __630 /* OGHAM SPACE MARK */
	case Tuint32_t(0x180e):
		goto __631 /* MONGOLIAN VOWEL SEPARATOR */
	case Tuint32_t(0x2000):
		goto __632 /* EN QUAD */
	case Tuint32_t(0x2001):
		goto __633 /* EM QUAD */
	case Tuint32_t(0x2002):
		goto __634 /* EN SPACE */
	case Tuint32_t(0x2003):
		goto __635 /* EM SPACE */
	case Tuint32_t(0x2004):
		goto __636 /* THREE-PER-EM SPACE */
	case Tuint32_t(0x2005):
		goto __637 /* FOUR-PER-EM SPACE */
	case Tuint32_t(0x2006):
		goto __638 /* SIX-PER-EM SPACE */
	case Tuint32_t(0x2007):
		goto __639 /* FIGURE SPACE */
	case Tuint32_t(0x2008):
		goto __640 /* PUNCTUATION SPACE */
	case Tuint32_t(0x2009):
		goto __641 /* THIN SPACE */
	case Tuint32_t(0x200A):
		goto __642 /* HAIR SPACE */
	case Tuint32_t(0x202f):
		goto __643 /* NARROW NO-BREAK SPACE */
	case Tuint32_t(0x205f):
		goto __644 /* MEDIUM MATHEMATICAL SPACE */
	case Tuint32_t(0x3000):
		goto __645

	default:
		goto __646
	}
	goto __626

__627:
__628:
__629:
__630: /* OGHAM SPACE MARK */
__631: /* MONGOLIAN VOWEL SEPARATOR */
__632: /* EN QUAD */
__633: /* EM QUAD */
__634: /* EN SPACE */
__635: /* EM SPACE */
__636: /* THREE-PER-EM SPACE */
__637: /* FOUR-PER-EM SPACE */
__638: /* SIX-PER-EM SPACE */
__639: /* FIGURE SPACE */
__640: /* PUNCTUATION SPACE */
__641: /* THIN SPACE */
__642: /* HAIR SPACE */
__643: /* NARROW NO-BREAK SPACE */
__644: /* MEDIUM MATHEMATICAL SPACE */
__645:
	OK3 = DTRUE
	goto __626

__646:
	OK3 = DFALSE
	goto __626
__626:
	;

	if !(OK3 == libc.Bool32(d == OP_HSPACE)) {
		goto __647
	}

	if !(count > 0 && codevalue == Tuint32_t(DOP_HSPACE_EXTRA+OP_TYPEPOSPLUS)) {
		goto __648
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__648:
	;
	count++
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __649
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = count
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = 0
	next_new_state += 12
	goto __650
__649:
	return -43
__650:
	;
__647:
	;
__625:
	;
	goto __89

	//-----------------------------------------------------------------
__152:
__153:
__154:
	count = 4
	goto QS1

__155:
__156:
__157:
	count = 0

QS1:

	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __651
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 4
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __652
__651:
	return -43
__652:
	;
	if !(clen > 0) {
		goto __653
	}

	prop2 = uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12
	switch int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2))) {
	case DPT_ANY:
		goto __655

	case DPT_LAMP:
		goto __656

	case DPT_GC:
		goto __657

	case DPT_PC:
		goto __658

	case DPT_SC:
		goto __659

	case DPT_SCX:
		goto __660

	// These are specials for combination cases.

	case DPT_ALNUM:
		goto __661

	// Perl space used to exclude VT, but from Perl 5.18 it is included,
	//           which means that Perl space and POSIX space are now identical. PCRE
	//           was changed at release 8.34.

	case DPT_SPACE:
		goto __662 // Perl space
	case DPT_PXSPACE:
		goto __663

	case DPT_WORD:
		goto __664

	case DPT_CLIST:
		goto __665

	case DPT_UCNC:
		goto __666

	case DPT_BIDICL:
		goto __667

	case DPT_BOOL:
		goto __668

	// Should never occur, but keep compilers from grumbling.

	default:
		goto __669
	}
	goto __654

__655:
	OK4 = DTRUE
	goto __654

__656:
	OK4 = libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop2)).Fchartype) == ucp_Lu || int32((*Tucd_record)(unsafe.Pointer(prop2)).Fchartype) == ucp_Ll || int32((*Tucd_record)(unsafe.Pointer(prop2)).Fchartype) == ucp_Lt)
	goto __654

__657:
	OK4 = libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop2)).Fchartype] == Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3))))
	goto __654

__658:
	OK4 = libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop2)).Fchartype) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3))))
	goto __654

__659:
	OK4 = libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop2)).Fscript) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3))))
	goto __654

__660:
	OK4 = libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop2)).Fscript) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3))) || *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_script_sets_8)) + uintptr(int32((*Tucd_record)(unsafe.Pointer(prop2)).Fscriptx_bidiclass)&DUCD_SCRIPTX_MASK)*4 + uintptr(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3)))/32)*4))&(uint32(1)<<(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3)))%32)) != Tuint32_t(0))
	goto __654

	// These are specials for combination cases.

__661:
	OK4 = libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop2)).Fchartype] == ucp_L || X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop2)).Fchartype] == ucp_N)
	goto __654

	// Perl space used to exclude VT, but from Perl 5.18 it is included,
	//           which means that Perl space and POSIX space are now identical. PCRE
	//           was changed at release 8.34.

__662: // Perl space
__663: // POSIX space
	switch c {
	case Tuint32_t('\011'):
		goto __671
	case Tuint32_t('\040'):
		goto __672
	case Tuint32_t(uint8('\xa0')):
		goto __673
	case Tuint32_t(0x1680):
		goto __674 /* OGHAM SPACE MARK */
	case Tuint32_t(0x180e):
		goto __675 /* MONGOLIAN VOWEL SEPARATOR */
	case Tuint32_t(0x2000):
		goto __676 /* EN QUAD */
	case Tuint32_t(0x2001):
		goto __677 /* EM QUAD */
	case Tuint32_t(0x2002):
		goto __678 /* EN SPACE */
	case Tuint32_t(0x2003):
		goto __679 /* EM SPACE */
	case Tuint32_t(0x2004):
		goto __680 /* THREE-PER-EM SPACE */
	case Tuint32_t(0x2005):
		goto __681 /* FOUR-PER-EM SPACE */
	case Tuint32_t(0x2006):
		goto __682 /* SIX-PER-EM SPACE */
	case Tuint32_t(0x2007):
		goto __683 /* FIGURE SPACE */
	case Tuint32_t(0x2008):
		goto __684 /* PUNCTUATION SPACE */
	case Tuint32_t(0x2009):
		goto __685 /* THIN SPACE */
	case Tuint32_t(0x200A):
		goto __686 /* HAIR SPACE */
	case Tuint32_t(0x202f):
		goto __687 /* NARROW NO-BREAK SPACE */
	case Tuint32_t(0x205f):
		goto __688 /* MEDIUM MATHEMATICAL SPACE */
	case Tuint32_t(0x3000):
		goto __689
	case Tuint32_t('\012'):
		goto __690
	case Tuint32_t('\013'):
		goto __691
	case Tuint32_t('\014'):
		goto __692
	case Tuint32_t('\015'):
		goto __693
	case Tuint32_t(uint8('\x85')):
		goto __694
	case Tuint32_t(0x2028):
		goto __695 /* LINE SEPARATOR */
	case Tuint32_t(0x2029):
		goto __696

	default:
		goto __697
	}
	goto __670

__671:
__672:
__673:
__674: /* OGHAM SPACE MARK */
__675: /* MONGOLIAN VOWEL SEPARATOR */
__676: /* EN QUAD */
__677: /* EM QUAD */
__678: /* EN SPACE */
__679: /* EM SPACE */
__680: /* THREE-PER-EM SPACE */
__681: /* FOUR-PER-EM SPACE */
__682: /* SIX-PER-EM SPACE */
__683: /* FIGURE SPACE */
__684: /* PUNCTUATION SPACE */
__685: /* THIN SPACE */
__686: /* HAIR SPACE */
__687: /* NARROW NO-BREAK SPACE */
__688: /* MEDIUM MATHEMATICAL SPACE */
__689:
__690:
__691:
__692:
__693:
__694:
__695: /* LINE SEPARATOR */
__696:
	OK4 = DTRUE
	goto __670

__697:
	OK4 = libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop2)).Fchartype] == ucp_Z)
	goto __670
__670:
	;
	goto __654

__664:
	OK4 = libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop2)).Fchartype] == ucp_L || X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop2)).Fchartype] == ucp_N || c == Tuint32_t('\137'))
	goto __654

__665:
	cp2 = uintptr(unsafe.Pointer(&X_pcre2_ucd_caseless_sets_8)) + uintptr(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3)))*4
__698:

	if !(c < *(*Tuint32_t)(unsafe.Pointer(cp2))) {
		goto __701
	}
	OK4 = DFALSE
	goto __700
__701:
	;
	if !(c == *(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&cp2, 4)))) {
		goto __702
	}
	OK4 = DTRUE
	goto __700
__702:
	;
	goto __699
__699:
	goto __698
	goto __700
__700:
	;
	goto __654

__666:
	OK4 = libc.Bool32(c == Tuint32_t('\044') || c == Tuint32_t('\100') || c == Tuint32_t('\140') || c >= Tuint32_t(0xa0) && c <= Tuint32_t(0xd7ff) || c >= Tuint32_t(0xe000))
	goto __654

__667:
	OK4 = libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12)).Fscriptx_bidiclass)>>DUCD_BIDICLASS_SHIFT == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3))))
	goto __654

__668:
	OK4 = libc.Bool32(*(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_boolprop_sets_8)) + uintptr(int32((*Tucd_record)(unsafe.Pointer(prop2)).Fbprops)&DUCD_BPROPS_MASK)*4 + uintptr(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3)))/32)*4))&(uint32(1)<<(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3)))%32)) != Tuint32_t(0))
	goto __654

	// Should never occur, but keep compilers from grumbling.

__669:
	OK4 = libc.Bool32(codevalue != OP_PROP)
	goto __654
__654:
	;

	if !(OK4 == libc.Bool32(d == OP_PROP)) {
		goto __703
	}

	if !(codevalue == Tuint32_t(DOP_PROP_EXTRA+OP_TYPEPOSSTAR) || codevalue == Tuint32_t(DOP_PROP_EXTRA+OP_TYPEPOSQUERY)) {
		goto __704
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__704:
	;
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __705
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + count
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __706
__705:
	return -43
__706:
	;
__703:
	;
__653:
	;
	goto __89

	//-----------------------------------------------------------------
__158:
__159:
__160:
	count = 2
	goto QS2

__161:
__162:
__163:
	count = 0

QS2:

	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __707
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 2
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __708
__707:
	return -43
__708:
	;
	if !(clen > 0) {
		goto __709
	}

	*(*int32)(unsafe.Pointer(bp + 4 /* ncount2 */)) = 0
	if !(codevalue == Tuint32_t(DOP_EXTUNI_EXTRA+OP_TYPEPOSSTAR) || codevalue == Tuint32_t(DOP_EXTUNI_EXTRA+OP_TYPEPOSQUERY)) {
		goto __710
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__710:
	;
	X_pcre2_extuni_8(tls, c, ptr+uintptr(clen), (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_subject, end_subject, utf,
		bp+4)
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __711
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -(state_offset + count)
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = *(*int32)(unsafe.Pointer(bp + 4))
	next_new_state += 12
	goto __712
__711:
	return -43
__712:
	;
__709:
	;
	goto __89

	//-----------------------------------------------------------------
__164:
__165:
__166:
	count = 2
	goto QS3

__167:
__168:
__169:
	count = 0

QS3:
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __713
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 2
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __714
__713:
	return -43
__714:
	;
	if !(clen > 0) {
		goto __715
	}
	ncount3 = 0
	switch c {
	case Tuint32_t('\013'):
		goto __717
	case Tuint32_t('\014'):
		goto __718
	case Tuint32_t(uint8('\x85')):
		goto __719
	case Tuint32_t(0x2028):
		goto __720
	case Tuint32_t(0x2029):
		goto __721

	case Tuint32_t('\015'):
		goto __722
	case Tuint32_t('\012'):
		goto __723

	default:
		goto __724
	}
	goto __716

__717:
__718:
__719:
__720:
__721:
	if !(int32((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fbsr_convention) == DPCRE2_BSR_ANYCRLF) {
		goto __725
	}
	goto __716
__725:
	;
	goto ANYNL02

__722:
	if !(ptr+uintptr(1) < end_subject && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + uintptr(1)))) == '\012') {
		goto __726
	}
	ncount3 = 1
__726:
	;
	// Fall through

ANYNL02:
__723:
	if !(codevalue == Tuint32_t(DOP_ANYNL_EXTRA+OP_TYPEPOSSTAR) || codevalue == Tuint32_t(DOP_ANYNL_EXTRA+OP_TYPEPOSQUERY)) {
		goto __727
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__727:
	;
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __728
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -(state_offset + count)
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = ncount3
	next_new_state += 12
	goto __729
__728:
	return -43
__729:
	;
	goto __716

__724:
	goto __716
__716:
	;
__715:
	;
	goto __89

	//-----------------------------------------------------------------
__170:
__171:
__172:
	count = 2
	goto QS4

__173:
__174:
__175:
	count = 0

QS4:
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __730
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 2
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __731
__730:
	return -43
__731:
	;
	if !(clen > 0) {
		goto __732
	}

	switch c {
	case Tuint32_t('\012'):
		goto __734
	case Tuint32_t('\013'):
		goto __735
	case Tuint32_t('\014'):
		goto __736
	case Tuint32_t('\015'):
		goto __737
	case Tuint32_t(uint8('\x85')):
		goto __738
	case Tuint32_t(0x2028):
		goto __739 /* LINE SEPARATOR */
	case Tuint32_t(0x2029):
		goto __740

	default:
		goto __741
	}
	goto __733

__734:
__735:
__736:
__737:
__738:
__739: /* LINE SEPARATOR */
__740:
	OK5 = DTRUE
	goto __733

__741:
	OK5 = DFALSE
	goto __733
__733:
	;
	if !(OK5 == libc.Bool32(d == OP_VSPACE)) {
		goto __742
	}

	if !(codevalue == Tuint32_t(DOP_VSPACE_EXTRA+OP_TYPEPOSSTAR) || codevalue == Tuint32_t(DOP_VSPACE_EXTRA+OP_TYPEPOSQUERY)) {
		goto __743
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__743:
	;
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __744
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -(state_offset + count)
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = 0
	next_new_state += 12
	goto __745
__744:
	return -43
__745:
	;
__742:
	;
__732:
	;
	goto __89

	//-----------------------------------------------------------------
__176:
__177:
__178:
	count = 2
	goto QS5

__179:
__180:
__181:
	count = 0

QS5:
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __746
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 2
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __747
__746:
	return -43
__747:
	;
	if !(clen > 0) {
		goto __748
	}

	switch c {
	case Tuint32_t('\011'):
		goto __750
	case Tuint32_t('\040'):
		goto __751
	case Tuint32_t(uint8('\xa0')):
		goto __752
	case Tuint32_t(0x1680):
		goto __753 /* OGHAM SPACE MARK */
	case Tuint32_t(0x180e):
		goto __754 /* MONGOLIAN VOWEL SEPARATOR */
	case Tuint32_t(0x2000):
		goto __755 /* EN QUAD */
	case Tuint32_t(0x2001):
		goto __756 /* EM QUAD */
	case Tuint32_t(0x2002):
		goto __757 /* EN SPACE */
	case Tuint32_t(0x2003):
		goto __758 /* EM SPACE */
	case Tuint32_t(0x2004):
		goto __759 /* THREE-PER-EM SPACE */
	case Tuint32_t(0x2005):
		goto __760 /* FOUR-PER-EM SPACE */
	case Tuint32_t(0x2006):
		goto __761 /* SIX-PER-EM SPACE */
	case Tuint32_t(0x2007):
		goto __762 /* FIGURE SPACE */
	case Tuint32_t(0x2008):
		goto __763 /* PUNCTUATION SPACE */
	case Tuint32_t(0x2009):
		goto __764 /* THIN SPACE */
	case Tuint32_t(0x200A):
		goto __765 /* HAIR SPACE */
	case Tuint32_t(0x202f):
		goto __766 /* NARROW NO-BREAK SPACE */
	case Tuint32_t(0x205f):
		goto __767 /* MEDIUM MATHEMATICAL SPACE */
	case Tuint32_t(0x3000):
		goto __768

	default:
		goto __769
	}
	goto __749

__750:
__751:
__752:
__753: /* OGHAM SPACE MARK */
__754: /* MONGOLIAN VOWEL SEPARATOR */
__755: /* EN QUAD */
__756: /* EM QUAD */
__757: /* EN SPACE */
__758: /* EM SPACE */
__759: /* THREE-PER-EM SPACE */
__760: /* FOUR-PER-EM SPACE */
__761: /* SIX-PER-EM SPACE */
__762: /* FIGURE SPACE */
__763: /* PUNCTUATION SPACE */
__764: /* THIN SPACE */
__765: /* HAIR SPACE */
__766: /* NARROW NO-BREAK SPACE */
__767: /* MEDIUM MATHEMATICAL SPACE */
__768:
	OK6 = DTRUE
	goto __749

__769:
	OK6 = DFALSE
	goto __749
__749:
	;

	if !(OK6 == libc.Bool32(d == OP_HSPACE)) {
		goto __770
	}

	if !(codevalue == Tuint32_t(DOP_HSPACE_EXTRA+OP_TYPEPOSSTAR) || codevalue == Tuint32_t(DOP_HSPACE_EXTRA+OP_TYPEPOSQUERY)) {
		goto __771
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__771:
	;
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __772
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -(state_offset + count)
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = 0
	next_new_state += 12
	goto __773
__772:
	return -43
__773:
	;
__770:
	;
__748:
	;
	goto __89

	//-----------------------------------------------------------------
__182:
__183:
__184:
__185:
	if !(codevalue != Tuint32_t(DOP_PROP_EXTRA+OP_TYPEEXACT)) {
		goto __774
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __775
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 1 + DIMM2_SIZE + 3
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __776
__775:
	return -43
__776:
	;
__774:
	;
	count = (*Tstateblock)(unsafe.Pointer(current_state)).Fcount // Number already matched
	if !(clen > 0) {
		goto __777
	}

	prop3 = uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12
	switch int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 4))) {
	case DPT_ANY:
		goto __779

	case DPT_LAMP:
		goto __780

	case DPT_GC:
		goto __781

	case DPT_PC:
		goto __782

	case DPT_SC:
		goto __783

	case DPT_SCX:
		goto __784

	// These are specials for combination cases.

	case DPT_ALNUM:
		goto __785

	// Perl space used to exclude VT, but from Perl 5.18 it is included,
	//           which means that Perl space and POSIX space are now identical. PCRE
	//           was changed at release 8.34.

	case DPT_SPACE:
		goto __786 // Perl space
	case DPT_PXSPACE:
		goto __787

	case DPT_WORD:
		goto __788

	case DPT_CLIST:
		goto __789

	case DPT_UCNC:
		goto __790

	case DPT_BIDICL:
		goto __791

	case DPT_BOOL:
		goto __792

	// Should never occur, but keep compilers from grumbling.

	default:
		goto __793
	}
	goto __778

__779:
	OK7 = DTRUE
	goto __778

__780:
	OK7 = libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop3)).Fchartype) == ucp_Lu || int32((*Tucd_record)(unsafe.Pointer(prop3)).Fchartype) == ucp_Ll || int32((*Tucd_record)(unsafe.Pointer(prop3)).Fchartype) == ucp_Lt)
	goto __778

__781:
	OK7 = libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop3)).Fchartype] == Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 5))))
	goto __778

__782:
	OK7 = libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop3)).Fchartype) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 5))))
	goto __778

__783:
	OK7 = libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop3)).Fscript) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 5))))
	goto __778

__784:
	OK7 = libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop3)).Fscript) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 5))) || *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_script_sets_8)) + uintptr(int32((*Tucd_record)(unsafe.Pointer(prop3)).Fscriptx_bidiclass)&DUCD_SCRIPTX_MASK)*4 + uintptr(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 5)))/32)*4))&(uint32(1)<<(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 5)))%32)) != Tuint32_t(0))
	goto __778

	// These are specials for combination cases.

__785:
	OK7 = libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop3)).Fchartype] == ucp_L || X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop3)).Fchartype] == ucp_N)
	goto __778

	// Perl space used to exclude VT, but from Perl 5.18 it is included,
	//           which means that Perl space and POSIX space are now identical. PCRE
	//           was changed at release 8.34.

__786: // Perl space
__787: // POSIX space
	switch c {
	case Tuint32_t('\011'):
		goto __795
	case Tuint32_t('\040'):
		goto __796
	case Tuint32_t(uint8('\xa0')):
		goto __797
	case Tuint32_t(0x1680):
		goto __798 /* OGHAM SPACE MARK */
	case Tuint32_t(0x180e):
		goto __799 /* MONGOLIAN VOWEL SEPARATOR */
	case Tuint32_t(0x2000):
		goto __800 /* EN QUAD */
	case Tuint32_t(0x2001):
		goto __801 /* EM QUAD */
	case Tuint32_t(0x2002):
		goto __802 /* EN SPACE */
	case Tuint32_t(0x2003):
		goto __803 /* EM SPACE */
	case Tuint32_t(0x2004):
		goto __804 /* THREE-PER-EM SPACE */
	case Tuint32_t(0x2005):
		goto __805 /* FOUR-PER-EM SPACE */
	case Tuint32_t(0x2006):
		goto __806 /* SIX-PER-EM SPACE */
	case Tuint32_t(0x2007):
		goto __807 /* FIGURE SPACE */
	case Tuint32_t(0x2008):
		goto __808 /* PUNCTUATION SPACE */
	case Tuint32_t(0x2009):
		goto __809 /* THIN SPACE */
	case Tuint32_t(0x200A):
		goto __810 /* HAIR SPACE */
	case Tuint32_t(0x202f):
		goto __811 /* NARROW NO-BREAK SPACE */
	case Tuint32_t(0x205f):
		goto __812 /* MEDIUM MATHEMATICAL SPACE */
	case Tuint32_t(0x3000):
		goto __813
	case Tuint32_t('\012'):
		goto __814
	case Tuint32_t('\013'):
		goto __815
	case Tuint32_t('\014'):
		goto __816
	case Tuint32_t('\015'):
		goto __817
	case Tuint32_t(uint8('\x85')):
		goto __818
	case Tuint32_t(0x2028):
		goto __819 /* LINE SEPARATOR */
	case Tuint32_t(0x2029):
		goto __820

	default:
		goto __821
	}
	goto __794

__795:
__796:
__797:
__798: /* OGHAM SPACE MARK */
__799: /* MONGOLIAN VOWEL SEPARATOR */
__800: /* EN QUAD */
__801: /* EM QUAD */
__802: /* EN SPACE */
__803: /* EM SPACE */
__804: /* THREE-PER-EM SPACE */
__805: /* FOUR-PER-EM SPACE */
__806: /* SIX-PER-EM SPACE */
__807: /* FIGURE SPACE */
__808: /* PUNCTUATION SPACE */
__809: /* THIN SPACE */
__810: /* HAIR SPACE */
__811: /* NARROW NO-BREAK SPACE */
__812: /* MEDIUM MATHEMATICAL SPACE */
__813:
__814:
__815:
__816:
__817:
__818:
__819: /* LINE SEPARATOR */
__820:
	OK7 = DTRUE
	goto __794

__821:
	OK7 = libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop3)).Fchartype] == ucp_Z)
	goto __794
__794:
	;
	goto __778

__788:
	OK7 = libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop3)).Fchartype] == ucp_L || X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop3)).Fchartype] == ucp_N || c == Tuint32_t('\137'))
	goto __778

__789:
	cp3 = uintptr(unsafe.Pointer(&X_pcre2_ucd_caseless_sets_8)) + uintptr(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 5)))*4
__822:

	if !(c < *(*Tuint32_t)(unsafe.Pointer(cp3))) {
		goto __825
	}
	OK7 = DFALSE
	goto __824
__825:
	;
	if !(c == *(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&cp3, 4)))) {
		goto __826
	}
	OK7 = DTRUE
	goto __824
__826:
	;
	goto __823
__823:
	goto __822
	goto __824
__824:
	;
	goto __778

__790:
	OK7 = libc.Bool32(c == Tuint32_t('\044') || c == Tuint32_t('\100') || c == Tuint32_t('\140') || c >= Tuint32_t(0xa0) && c <= Tuint32_t(0xd7ff) || c >= Tuint32_t(0xe000))
	goto __778

__791:
	OK7 = libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12)).Fscriptx_bidiclass)>>DUCD_BIDICLASS_SHIFT == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 5))))
	goto __778

__792:
	OK7 = libc.Bool32(*(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_boolprop_sets_8)) + uintptr(int32((*Tucd_record)(unsafe.Pointer(prop3)).Fbprops)&DUCD_BPROPS_MASK)*4 + uintptr(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 5)))/32)*4))&(uint32(1)<<(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 5)))%32)) != Tuint32_t(0))
	goto __778

	// Should never occur, but keep compilers from grumbling.

__793:
	OK7 = libc.Bool32(codevalue != OP_PROP)
	goto __778
__778:
	;

	if !(OK7 == libc.Bool32(d == OP_PROP)) {
		goto __827
	}

	if !(codevalue == Tuint32_t(DOP_PROP_EXTRA+OP_TYPEPOSUPTO)) {
		goto __828
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__828:
	;
	if !(libc.PreIncInt32(&count, 1) >= int32(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))))) {
		goto __829
	}
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __831
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + 1 + DIMM2_SIZE + 3
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __832
__831:
	return -43
__832:
	;
	goto __830
__829:
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __833
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = count
	next_new_state += 12
	goto __834
__833:
	return -43
__834:
	;
__830:
	;
__827:
	;
__777:
	;
	goto __89

	//-----------------------------------------------------------------
__186:
__187:
__188:
__189:
	if !(codevalue != Tuint32_t(DOP_EXTUNI_EXTRA+OP_TYPEEXACT)) {
		goto __835
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __836
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 2 + DIMM2_SIZE
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __837
__836:
	return -43
__837:
	;
__835:
	;
	count = (*Tstateblock)(unsafe.Pointer(current_state)).Fcount // Number already matched
	if !(clen > 0) {
		goto __838
	}

	*(*int32)(unsafe.Pointer(bp + 8 /* ncount4 */)) = 0
	if !(codevalue == Tuint32_t(DOP_EXTUNI_EXTRA+OP_TYPEPOSUPTO)) {
		goto __839
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__839:
	;
	nptr = X_pcre2_extuni_8(tls, c, ptr+uintptr(clen), (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_subject, end_subject, utf,
		bp+8)
	if !(nptr >= end_subject && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_PARTIAL_HARD != Tuint32_t(0)) {
		goto __840
	}
	reset_could_continue = DTRUE
__840:
	;
	if !(libc.PreIncInt32(&count, 1) >= int32(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))))) {
		goto __841
	}
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __843
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -(state_offset + 2 + DIMM2_SIZE)
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = *(*int32)(unsafe.Pointer(bp + 8))
	next_new_state += 12
	goto __844
__843:
	return -43
__844:
	;
	goto __842
__841:
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __845
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = count
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = *(*int32)(unsafe.Pointer(bp + 8))
	next_new_state += 12
	goto __846
__845:
	return -43
__846:
	;
__842:
	;
__838:
	;
	goto __89

	//-----------------------------------------------------------------
__190:
__191:
__192:
__193:
	if !(codevalue != Tuint32_t(DOP_ANYNL_EXTRA+OP_TYPEEXACT)) {
		goto __847
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __848
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 2 + DIMM2_SIZE
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __849
__848:
	return -43
__849:
	;
__847:
	;
	count = (*Tstateblock)(unsafe.Pointer(current_state)).Fcount // Number already matched
	if !(clen > 0) {
		goto __850
	}
	ncount5 = 0
	switch c {
	case Tuint32_t('\013'):
		goto __852
	case Tuint32_t('\014'):
		goto __853
	case Tuint32_t(uint8('\x85')):
		goto __854
	case Tuint32_t(0x2028):
		goto __855
	case Tuint32_t(0x2029):
		goto __856

	case Tuint32_t('\015'):
		goto __857
	case Tuint32_t('\012'):
		goto __858

	default:
		goto __859
	}
	goto __851

__852:
__853:
__854:
__855:
__856:
	if !(int32((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fbsr_convention) == DPCRE2_BSR_ANYCRLF) {
		goto __860
	}
	goto __851
__860:
	;
	goto ANYNL03

__857:
	if !(ptr+uintptr(1) < end_subject && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + uintptr(1)))) == '\012') {
		goto __861
	}
	ncount5 = 1
__861:
	;
	// Fall through

ANYNL03:
__858:
	if !(codevalue == Tuint32_t(DOP_ANYNL_EXTRA+OP_TYPEPOSUPTO)) {
		goto __862
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__862:
	;
	if !(libc.PreIncInt32(&count, 1) >= int32(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))))) {
		goto __863
	}
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __865
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -(state_offset + 2 + DIMM2_SIZE)
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = ncount5
	next_new_state += 12
	goto __866
__865:
	return -43
__866:
	;
	goto __864
__863:
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __867
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = count
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = ncount5
	next_new_state += 12
	goto __868
__867:
	return -43
__868:
	;
__864:
	;
	goto __851

__859:
	goto __851
__851:
	;
__850:
	;
	goto __89

	//-----------------------------------------------------------------
__194:
__195:
__196:
__197:
	if !(codevalue != Tuint32_t(DOP_VSPACE_EXTRA+OP_TYPEEXACT)) {
		goto __869
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __870
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 2 + DIMM2_SIZE
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __871
__870:
	return -43
__871:
	;
__869:
	;
	count = (*Tstateblock)(unsafe.Pointer(current_state)).Fcount // Number already matched
	if !(clen > 0) {
		goto __872
	}

	switch c {
	case Tuint32_t('\012'):
		goto __874
	case Tuint32_t('\013'):
		goto __875
	case Tuint32_t('\014'):
		goto __876
	case Tuint32_t('\015'):
		goto __877
	case Tuint32_t(uint8('\x85')):
		goto __878
	case Tuint32_t(0x2028):
		goto __879 /* LINE SEPARATOR */
	case Tuint32_t(0x2029):
		goto __880

	default:
		goto __881
	}
	goto __873

__874:
__875:
__876:
__877:
__878:
__879: /* LINE SEPARATOR */
__880:
	OK8 = DTRUE
	goto __873

__881:
	OK8 = DFALSE
__873:
	;

	if !(OK8 == libc.Bool32(d == OP_VSPACE)) {
		goto __882
	}

	if !(codevalue == Tuint32_t(DOP_VSPACE_EXTRA+OP_TYPEPOSUPTO)) {
		goto __883
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__883:
	;
	if !(libc.PreIncInt32(&count, 1) >= int32(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))))) {
		goto __884
	}
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __886
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -(state_offset + 2 + DIMM2_SIZE)
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = 0
	next_new_state += 12
	goto __887
__886:
	return -43
__887:
	;
	goto __885
__884:
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __888
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = count
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = 0
	next_new_state += 12
	goto __889
__888:
	return -43
__889:
	;
__885:
	;
__882:
	;
__872:
	;
	goto __89

	//-----------------------------------------------------------------
__198:
__199:
__200:
__201:
	if !(codevalue != Tuint32_t(DOP_HSPACE_EXTRA+OP_TYPEEXACT)) {
		goto __890
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __891
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 2 + DIMM2_SIZE
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __892
__891:
	return -43
__892:
	;
__890:
	;
	count = (*Tstateblock)(unsafe.Pointer(current_state)).Fcount // Number already matched
	if !(clen > 0) {
		goto __893
	}

	switch c {
	case Tuint32_t('\011'):
		goto __895
	case Tuint32_t('\040'):
		goto __896
	case Tuint32_t(uint8('\xa0')):
		goto __897
	case Tuint32_t(0x1680):
		goto __898 /* OGHAM SPACE MARK */
	case Tuint32_t(0x180e):
		goto __899 /* MONGOLIAN VOWEL SEPARATOR */
	case Tuint32_t(0x2000):
		goto __900 /* EN QUAD */
	case Tuint32_t(0x2001):
		goto __901 /* EM QUAD */
	case Tuint32_t(0x2002):
		goto __902 /* EN SPACE */
	case Tuint32_t(0x2003):
		goto __903 /* EM SPACE */
	case Tuint32_t(0x2004):
		goto __904 /* THREE-PER-EM SPACE */
	case Tuint32_t(0x2005):
		goto __905 /* FOUR-PER-EM SPACE */
	case Tuint32_t(0x2006):
		goto __906 /* SIX-PER-EM SPACE */
	case Tuint32_t(0x2007):
		goto __907 /* FIGURE SPACE */
	case Tuint32_t(0x2008):
		goto __908 /* PUNCTUATION SPACE */
	case Tuint32_t(0x2009):
		goto __909 /* THIN SPACE */
	case Tuint32_t(0x200A):
		goto __910 /* HAIR SPACE */
	case Tuint32_t(0x202f):
		goto __911 /* NARROW NO-BREAK SPACE */
	case Tuint32_t(0x205f):
		goto __912 /* MEDIUM MATHEMATICAL SPACE */
	case Tuint32_t(0x3000):
		goto __913

	default:
		goto __914
	}
	goto __894

__895:
__896:
__897:
__898: /* OGHAM SPACE MARK */
__899: /* MONGOLIAN VOWEL SEPARATOR */
__900: /* EN QUAD */
__901: /* EM QUAD */
__902: /* EN SPACE */
__903: /* EM SPACE */
__904: /* THREE-PER-EM SPACE */
__905: /* FOUR-PER-EM SPACE */
__906: /* SIX-PER-EM SPACE */
__907: /* FIGURE SPACE */
__908: /* PUNCTUATION SPACE */
__909: /* THIN SPACE */
__910: /* HAIR SPACE */
__911: /* NARROW NO-BREAK SPACE */
__912: /* MEDIUM MATHEMATICAL SPACE */
__913:
	OK9 = DTRUE
	goto __894

__914:
	OK9 = DFALSE
	goto __894
__894:
	;

	if !(OK9 == libc.Bool32(d == OP_HSPACE)) {
		goto __915
	}

	if !(codevalue == Tuint32_t(DOP_HSPACE_EXTRA+OP_TYPEPOSUPTO)) {
		goto __916
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__916:
	;
	if !(libc.PreIncInt32(&count, 1) >= int32(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))))) {
		goto __917
	}
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __919
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -(state_offset + 2 + DIMM2_SIZE)
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = 0
	next_new_state += 12
	goto __920
__919:
	return -43
__920:
	;
	goto __918
__917:
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __921
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = count
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = 0
	next_new_state += 12
	goto __922
__921:
	return -43
__922:
	;
__918:
	;
__915:
	;
__893:
	;
	goto __89

	// ==========================================================================
	// These opcodes are followed by a character that is usually compared
	//       to the current subject character; it is loaded into d. We still get
	//       here even if there is no subject character, because in some cases zero
	//       repetitions are permitted.

	//-----------------------------------------------------------------
__202:
	if !(clen > 0 && c == d) {
		goto __923
	}
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __924
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + dlen + 1
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __925
__924:
	return -43
__925:
	;
__923:
	;
	goto __89

	//-----------------------------------------------------------------
__203:
	if !(clen == 0) {
		goto __926
	}
	goto __89
__926:
	;

	if !(utf_or_ucp != 0) {
		goto __927
	}

	if !(c == d) {
		goto __929
	}
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __931
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + dlen + 1
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __932
__931:
	return -43
__932:
	;
	goto __930
__929:

	if !(c < Tuint32_t(128)) {
		goto __933
	}
	othercase = uint32(*(*Tuint8_t)(unsafe.Pointer(fcc + uintptr(c))))
	goto __934
__933:
	othercase = Tuint32_t(int32(c) + (*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12)).Fother_case)
__934:
	;
	if !(d == othercase) {
		goto __935
	}
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __936
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + dlen + 1
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __937
__936:
	return -43
__937:
	;
__935:
	;
__930:
	;
	goto __928
__927:
	/* Not UTF or UCP mode */

	if !(int32(*(*Tuint8_t)(unsafe.Pointer(lcc + uintptr(c)))) == int32(*(*Tuint8_t)(unsafe.Pointer(lcc + uintptr(d))))) {
		goto __938
	}
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __939
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + 2
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __940
__939:
	return -43
__940:
	;
__938:
	;
__928:
	;
	goto __89

	//-----------------------------------------------------------------
	// This is a tricky one because it can match more than one character.
	//       Find out how many characters to skip, and then set up a negative state
	//       to wait for them to pass before continuing.

__204:
	if !(clen > 0) {
		goto __941
	}

	*(*int32)(unsafe.Pointer(bp + 12 /* ncount6 */)) = 0
	nptr1 = X_pcre2_extuni_8(tls, c, ptr+uintptr(clen), (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_subject,
		end_subject, utf, bp+12)
	if !(nptr1 >= end_subject && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_PARTIAL_HARD != Tuint32_t(0)) {
		goto __942
	}
	reset_could_continue = DTRUE
__942:
	;
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __943
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -(state_offset + 1)
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = *(*int32)(unsafe.Pointer(bp + 12))
	next_new_state += 12
	goto __944
__943:
	return -43
__944:
	;
__941:
	;
	goto __89

	//-----------------------------------------------------------------
	// This is a tricky like EXTUNI because it too can match more than one
	//       character (when CR is followed by LF). In this case, set up a negative
	//       state to wait for one character to pass before continuing.

__205:
	if !(clen > 0) {
		goto __945
	}
	switch c {
	case Tuint32_t('\013'):
		goto __947
	case Tuint32_t('\014'):
		goto __948
	case Tuint32_t(uint8('\x85')):
		goto __949
	case Tuint32_t(0x2028):
		goto __950
	case Tuint32_t(0x2029):
		goto __951
	// Fall through

	case Tuint32_t('\012'):
		goto __952

	case Tuint32_t('\015'):
		goto __953
	}
	goto __946

__947:
__948:
__949:
__950:
__951:
	if !(int32((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fbsr_convention) == DPCRE2_BSR_ANYCRLF) {
		goto __954
	}
	goto __946
__954:
	;
	// Fall through

__952:
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __955
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __956
__955:
	return -43
__956:
	;
	goto __946

__953:
	if !(ptr+uintptr(1) >= end_subject) {
		goto __957
	}

	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __959
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __960
__959:
	return -43
__960:
	;
	if !((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_PARTIAL_HARD != Tuint32_t(0)) {
		goto __961
	}
	reset_could_continue = DTRUE
__961:
	;
	goto __958
__957:
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + uintptr(1)))) == '\012') {
		goto __962
	}

	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __964
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -(state_offset + 1)
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = 1
	next_new_state += 12
	goto __965
__964:
	return -43
__965:
	;
	goto __963
__962:

	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __966
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __967
__966:
	return -43
__967:
	;
__963:
	;
__958:
	;
	goto __946
__946:
	;
__945:
	;
	goto __89

	//-----------------------------------------------------------------
__206:
	if !(clen > 0) {
		goto __968
	}
	switch c {
	case Tuint32_t('\012'):
		goto __970
	case Tuint32_t('\013'):
		goto __971
	case Tuint32_t('\014'):
		goto __972
	case Tuint32_t('\015'):
		goto __973
	case Tuint32_t(uint8('\x85')):
		goto __974
	case Tuint32_t(0x2028):
		goto __975 /* LINE SEPARATOR */
	case Tuint32_t(0x2029):
		goto __976

	default:
		goto __977
	}
	goto __969

__970:
__971:
__972:
__973:
__974:
__975: /* LINE SEPARATOR */
__976:
	goto __969

__977:
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __978
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __979
__978:
	return -43
__979:
	;
	goto __969
__969:
	;
__968:
	;
	goto __89

	//-----------------------------------------------------------------
__207:
	if !(clen > 0) {
		goto __980
	}
	switch c {
	case Tuint32_t('\012'):
		goto __982
	case Tuint32_t('\013'):
		goto __983
	case Tuint32_t('\014'):
		goto __984
	case Tuint32_t('\015'):
		goto __985
	case Tuint32_t(uint8('\x85')):
		goto __986
	case Tuint32_t(0x2028):
		goto __987 /* LINE SEPARATOR */
	case Tuint32_t(0x2029):
		goto __988

	default:
		goto __989
	}
	goto __981

__982:
__983:
__984:
__985:
__986:
__987: /* LINE SEPARATOR */
__988:
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __990
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __991
__990:
	return -43
__991:
	;
	goto __981

__989:
	goto __981
__981:
	;
__980:
	;
	goto __89

	//-----------------------------------------------------------------
__208:
	if !(clen > 0) {
		goto __992
	}
	switch c {
	case Tuint32_t('\011'):
		goto __994
	case Tuint32_t('\040'):
		goto __995
	case Tuint32_t(uint8('\xa0')):
		goto __996
	case Tuint32_t(0x1680):
		goto __997 /* OGHAM SPACE MARK */
	case Tuint32_t(0x180e):
		goto __998 /* MONGOLIAN VOWEL SEPARATOR */
	case Tuint32_t(0x2000):
		goto __999 /* EN QUAD */
	case Tuint32_t(0x2001):
		goto __1000 /* EM QUAD */
	case Tuint32_t(0x2002):
		goto __1001 /* EN SPACE */
	case Tuint32_t(0x2003):
		goto __1002 /* EM SPACE */
	case Tuint32_t(0x2004):
		goto __1003 /* THREE-PER-EM SPACE */
	case Tuint32_t(0x2005):
		goto __1004 /* FOUR-PER-EM SPACE */
	case Tuint32_t(0x2006):
		goto __1005 /* SIX-PER-EM SPACE */
	case Tuint32_t(0x2007):
		goto __1006 /* FIGURE SPACE */
	case Tuint32_t(0x2008):
		goto __1007 /* PUNCTUATION SPACE */
	case Tuint32_t(0x2009):
		goto __1008 /* THIN SPACE */
	case Tuint32_t(0x200A):
		goto __1009 /* HAIR SPACE */
	case Tuint32_t(0x202f):
		goto __1010 /* NARROW NO-BREAK SPACE */
	case Tuint32_t(0x205f):
		goto __1011 /* MEDIUM MATHEMATICAL SPACE */
	case Tuint32_t(0x3000):
		goto __1012

	default:
		goto __1013
	}
	goto __993

__994:
__995:
__996:
__997: /* OGHAM SPACE MARK */
__998: /* MONGOLIAN VOWEL SEPARATOR */
__999: /* EN QUAD */
__1000: /* EM QUAD */
__1001: /* EN SPACE */
__1002: /* EM SPACE */
__1003: /* THREE-PER-EM SPACE */
__1004: /* FOUR-PER-EM SPACE */
__1005: /* SIX-PER-EM SPACE */
__1006: /* FIGURE SPACE */
__1007: /* PUNCTUATION SPACE */
__1008: /* THIN SPACE */
__1009: /* HAIR SPACE */
__1010: /* NARROW NO-BREAK SPACE */
__1011: /* MEDIUM MATHEMATICAL SPACE */
__1012:
	goto __993

__1013:
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1014
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __1015
__1014:
	return -43
__1015:
	;
	goto __993
__993:
	;
__992:
	;
	goto __89

	//-----------------------------------------------------------------
__209:
	if !(clen > 0) {
		goto __1016
	}
	switch c {
	case Tuint32_t('\011'):
		goto __1018
	case Tuint32_t('\040'):
		goto __1019
	case Tuint32_t(uint8('\xa0')):
		goto __1020
	case Tuint32_t(0x1680):
		goto __1021 /* OGHAM SPACE MARK */
	case Tuint32_t(0x180e):
		goto __1022 /* MONGOLIAN VOWEL SEPARATOR */
	case Tuint32_t(0x2000):
		goto __1023 /* EN QUAD */
	case Tuint32_t(0x2001):
		goto __1024 /* EM QUAD */
	case Tuint32_t(0x2002):
		goto __1025 /* EN SPACE */
	case Tuint32_t(0x2003):
		goto __1026 /* EM SPACE */
	case Tuint32_t(0x2004):
		goto __1027 /* THREE-PER-EM SPACE */
	case Tuint32_t(0x2005):
		goto __1028 /* FOUR-PER-EM SPACE */
	case Tuint32_t(0x2006):
		goto __1029 /* SIX-PER-EM SPACE */
	case Tuint32_t(0x2007):
		goto __1030 /* FIGURE SPACE */
	case Tuint32_t(0x2008):
		goto __1031 /* PUNCTUATION SPACE */
	case Tuint32_t(0x2009):
		goto __1032 /* THIN SPACE */
	case Tuint32_t(0x200A):
		goto __1033 /* HAIR SPACE */
	case Tuint32_t(0x202f):
		goto __1034 /* NARROW NO-BREAK SPACE */
	case Tuint32_t(0x205f):
		goto __1035 /* MEDIUM MATHEMATICAL SPACE */
	case Tuint32_t(0x3000):
		goto __1036

	default:
		goto __1037
	}
	goto __1017

__1018:
__1019:
__1020:
__1021: /* OGHAM SPACE MARK */
__1022: /* MONGOLIAN VOWEL SEPARATOR */
__1023: /* EN QUAD */
__1024: /* EM QUAD */
__1025: /* EN SPACE */
__1026: /* EM SPACE */
__1027: /* THREE-PER-EM SPACE */
__1028: /* FOUR-PER-EM SPACE */
__1029: /* SIX-PER-EM SPACE */
__1030: /* FIGURE SPACE */
__1031: /* PUNCTUATION SPACE */
__1032: /* THIN SPACE */
__1033: /* HAIR SPACE */
__1034: /* NARROW NO-BREAK SPACE */
__1035: /* MEDIUM MATHEMATICAL SPACE */
__1036:
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1038
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __1039
__1038:
	return -43
__1039:
	;
	goto __1017

__1037:
	goto __1017
__1017:
	;
__1016:
	;
	goto __89

	//-----------------------------------------------------------------
	// Match a negated single character casefully.

__210:
	if !(clen > 0 && c != d) {
		goto __1040
	}
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1041
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + dlen + 1
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __1042
__1041:
	return -43
__1042:
	;
__1040:
	;
	goto __89

	//-----------------------------------------------------------------
	// Match a negated single character caselessly.

__211:
	if !(clen > 0) {
		goto __1043
	}

	if !(utf_or_ucp != 0 && d >= Tuint32_t(128)) {
		goto __1044
	}
	otherd = Tuint32_t(int32(d) + (*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(d)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(d)%DUCD_BLOCK_SIZE])*12)).Fother_case)
	goto __1045
__1044:
	otherd = Tuint32_t(*(*Tuint8_t)(unsafe.Pointer(fcc + uintptr(d))))
__1045:
	;
	if !(c != d && c != otherd) {
		goto __1046
	}
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1047
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + dlen + 1
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __1048
__1047:
	return -43
__1048:
	;
__1046:
	;
__1043:
	;
	goto __89

	//-----------------------------------------------------------------
__212:
__213:
__214:
__215:
__216:
__217:
	caseless = DTRUE
	codevalue = codevalue - Tuint32_t(OP_STARI-OP_STAR)

	// Fall through
__218:
__219:
__220:
__221:
__222:
__223:
	count = (*Tstateblock)(unsafe.Pointer(current_state)).Fcount // Already matched
	if !(count > 0) {
		goto __1049
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __1050
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + dlen + 1
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __1051
__1050:
	return -43
__1051:
	;
__1049:
	;
	if !(clen > 0) {
		goto __1052
	}

	otherd1 = DNOTACHAR
	if !(caseless != 0) {
		goto __1053
	}

	if !(utf_or_ucp != 0 && d >= Tuint32_t(128)) {
		goto __1054
	}
	otherd1 = Tuint32_t(int32(d) + (*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(d)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(d)%DUCD_BLOCK_SIZE])*12)).Fother_case)
	goto __1055
__1054:
	otherd1 = Tuint32_t(*(*Tuint8_t)(unsafe.Pointer(fcc + uintptr(d))))
__1055:
	;
__1053:
	;
	if !(libc.Bool32(c == d || c == otherd1) == libc.Bool32(codevalue < OP_NOTSTAR)) {
		goto __1056
	}

	if !(count > 0 && (codevalue == OP_POSPLUS || codevalue == OP_NOTPOSPLUS)) {
		goto __1057
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__1057:
	;
	count++
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1058
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = count
	next_new_state += 12
	goto __1059
__1058:
	return -43
__1059:
	;
__1056:
	;
__1052:
	;
	goto __89

	//-----------------------------------------------------------------
__224:
__225:
__226:
__227:
__228:
__229:
	caseless = DTRUE
	codevalue = codevalue - Tuint32_t(OP_STARI-OP_STAR)
	// Fall through
__230:
__231:
__232:
__233:
__234:
__235:
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __1060
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + dlen + 1
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __1061
__1060:
	return -43
__1061:
	;
	if !(clen > 0) {
		goto __1062
	}

	otherd2 = DNOTACHAR
	if !(caseless != 0) {
		goto __1063
	}

	if !(utf_or_ucp != 0 && d >= Tuint32_t(128)) {
		goto __1064
	}
	otherd2 = Tuint32_t(int32(d) + (*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(d)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(d)%DUCD_BLOCK_SIZE])*12)).Fother_case)
	goto __1065
__1064:
	otherd2 = Tuint32_t(*(*Tuint8_t)(unsafe.Pointer(fcc + uintptr(d))))
__1065:
	;
__1063:
	;
	if !(libc.Bool32(c == d || c == otherd2) == libc.Bool32(codevalue < OP_NOTSTAR)) {
		goto __1066
	}

	if !(codevalue == OP_POSQUERY || codevalue == OP_NOTPOSQUERY) {
		goto __1067
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__1067:
	;
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1068
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + dlen + 1
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __1069
__1068:
	return -43
__1069:
	;
__1066:
	;
__1062:
	;
	goto __89

	//-----------------------------------------------------------------
__236:
__237:
__238:
__239:
__240:
__241:
	caseless = DTRUE
	codevalue = codevalue - Tuint32_t(OP_STARI-OP_STAR)
	// Fall through
__242:
__243:
__244:
__245:
__246:
__247:
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __1070
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + dlen + 1
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __1071
__1070:
	return -43
__1071:
	;
	if !(clen > 0) {
		goto __1072
	}

	otherd3 = DNOTACHAR
	if !(caseless != 0) {
		goto __1073
	}

	if !(utf_or_ucp != 0 && d >= Tuint32_t(128)) {
		goto __1074
	}
	otherd3 = Tuint32_t(int32(d) + (*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(d)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(d)%DUCD_BLOCK_SIZE])*12)).Fother_case)
	goto __1075
__1074:
	otherd3 = Tuint32_t(*(*Tuint8_t)(unsafe.Pointer(fcc + uintptr(d))))
__1075:
	;
__1073:
	;
	if !(libc.Bool32(c == d || c == otherd3) == libc.Bool32(codevalue < OP_NOTSTAR)) {
		goto __1076
	}

	if !(codevalue == OP_POSSTAR || codevalue == OP_NOTPOSSTAR) {
		goto __1077
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__1077:
	;
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1078
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __1079
__1078:
	return -43
__1079:
	;
__1076:
	;
__1072:
	;
	goto __89

	//-----------------------------------------------------------------
__248:
__249:
	caseless = DTRUE
	codevalue = codevalue - Tuint32_t(OP_STARI-OP_STAR)
	// Fall through
__250:
__251:
	count = (*Tstateblock)(unsafe.Pointer(current_state)).Fcount // Number already matched
	if !(clen > 0) {
		goto __1080
	}

	otherd4 = DNOTACHAR
	if !(caseless != 0) {
		goto __1081
	}

	if !(utf_or_ucp != 0 && d >= Tuint32_t(128)) {
		goto __1082
	}
	otherd4 = Tuint32_t(int32(d) + (*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(d)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(d)%DUCD_BLOCK_SIZE])*12)).Fother_case)
	goto __1083
__1082:
	otherd4 = Tuint32_t(*(*Tuint8_t)(unsafe.Pointer(fcc + uintptr(d))))
__1083:
	;
__1081:
	;
	if !(libc.Bool32(c == d || c == otherd4) == libc.Bool32(codevalue < OP_NOTSTAR)) {
		goto __1084
	}

	if !(libc.PreIncInt32(&count, 1) >= int32(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))))) {
		goto __1085
	}
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1087
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + dlen + 1 + DIMM2_SIZE
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __1088
__1087:
	return -43
__1088:
	;
	goto __1086
__1085:
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1089
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = count
	next_new_state += 12
	goto __1090
__1089:
	return -43
__1090:
	;
__1086:
	;
__1084:
	;
__1080:
	;
	goto __89

	//-----------------------------------------------------------------
__252:
__253:
__254:
__255:
__256:
__257:
	caseless = DTRUE
	codevalue = codevalue - Tuint32_t(OP_STARI-OP_STAR)
	// Fall through
__258:
__259:
__260:
__261:
__262:
__263:
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __1091
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + dlen + 1 + DIMM2_SIZE
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __1092
__1091:
	return -43
__1092:
	;
	count = (*Tstateblock)(unsafe.Pointer(current_state)).Fcount // Number already matched
	if !(clen > 0) {
		goto __1093
	}

	otherd5 = DNOTACHAR
	if !(caseless != 0) {
		goto __1094
	}

	if !(utf_or_ucp != 0 && d >= Tuint32_t(128)) {
		goto __1095
	}
	otherd5 = Tuint32_t(int32(d) + (*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(d)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(d)%DUCD_BLOCK_SIZE])*12)).Fother_case)
	goto __1096
__1095:
	otherd5 = Tuint32_t(*(*Tuint8_t)(unsafe.Pointer(fcc + uintptr(d))))
__1096:
	;
__1094:
	;
	if !(libc.Bool32(c == d || c == otherd5) == libc.Bool32(codevalue < OP_NOTSTAR)) {
		goto __1097
	}

	if !(codevalue == OP_POSUPTO || codevalue == OP_NOTPOSUPTO) {
		goto __1098
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__1098:
	;
	if !(libc.PreIncInt32(&count, 1) >= int32(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))))) {
		goto __1099
	}
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1101
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + dlen + 1 + DIMM2_SIZE
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __1102
__1101:
	return -43
__1102:
	;
	goto __1100
__1099:
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1103
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = count
	next_new_state += 12
	goto __1104
__1103:
	return -43
__1104:
	;
__1100:
	;
__1097:
	;
__1093:
	;
	goto __89

	// ==========================================================================
	// These are the class-handling opcodes

__264:
__265:
__266:

	isinclass = DFALSE

	// For a simple class, there is always just a 32-byte table, and we
	//         can set isinclass from it.

	if !(codevalue != OP_XCLASS) {
		goto __1105
	}

	ecode = code + uintptr(1) + uintptr(uint64(32)/uint64(unsafe.Sizeof(TPCRE2_UCHAR8(0))))
	if !(clen > 0) {
		goto __1107
	}

	if c > Tuint32_t(255) {
		isinclass = libc.Bool32(codevalue == OP_NCLASS)
	} else {
		isinclass = libc.Bool32(uint32(*(*Tuint8_t)(unsafe.Pointer(code + uintptr(1) + uintptr(c/Tuint32_t(8)))))&(uint32(1)<<(c&Tuint32_t(7))) != uint32(0))
	}
__1107:
	;
	goto __1106
__1105:

	ecode = code + uintptr(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))))
	if !(clen > 0) {
		goto __1108
	}
	isinclass = X_pcre2_xclass_8(tls, c, code+uintptr(1)+uintptr(DLINK_SIZE), utf)
__1108:
	;
__1106:
	;

	// At this point, isinclass is set for all kinds of class, and ecode
	//         points to the byte after the end of the class. If there is a
	//         quantifier, this is where it will be.

	next_state_offset = int32((int64(ecode) - int64(start_code)) / 1)

	switch int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ecode))) {
	case OP_CRSTAR:
		goto __1110
	case OP_CRMINSTAR:
		goto __1111
	case OP_CRPOSSTAR:
		goto __1112

	case OP_CRPLUS:
		goto __1113
	case OP_CRMINPLUS:
		goto __1114
	case OP_CRPOSPLUS:
		goto __1115

	case OP_CRQUERY:
		goto __1116
	case OP_CRMINQUERY:
		goto __1117
	case OP_CRPOSQUERY:
		goto __1118

	case OP_CRRANGE:
		goto __1119
	case OP_CRMINRANGE:
		goto __1120
	case OP_CRPOSRANGE:
		goto __1121

	default:
		goto __1122
	}
	goto __1109

__1110:
__1111:
__1112:
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __1123
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = next_state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __1124
__1123:
	return -43
__1124:
	;
	if !(isinclass != 0) {
		goto __1125
	}

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ecode))) == OP_CRPOSSTAR) {
		goto __1126
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__1126:
	;
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1127
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __1128
__1127:
	return -43
__1128:
	;
__1125:
	;
	goto __1109

__1113:
__1114:
__1115:
	count = (*Tstateblock)(unsafe.Pointer(current_state)).Fcount // Already matched
	if !(count > 0) {
		goto __1129
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __1130
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = next_state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __1131
__1130:
	return -43
__1131:
	;
__1129:
	;
	if !(isinclass != 0) {
		goto __1132
	}

	if !(count > 0 && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ecode))) == OP_CRPOSPLUS) {
		goto __1133
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__1133:
	;
	count++
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1134
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = count
	next_new_state += 12
	goto __1135
__1134:
	return -43
__1135:
	;
__1132:
	;
	goto __1109

__1116:
__1117:
__1118:
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __1136
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = next_state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __1137
__1136:
	return -43
__1137:
	;
	if !(isinclass != 0) {
		goto __1138
	}

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ecode))) == OP_CRPOSQUERY) {
		goto __1139
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__1139:
	;
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1140
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = next_state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __1141
__1140:
	return -43
__1141:
	;
__1138:
	;
	goto __1109

__1119:
__1120:
__1121:
	count = (*Tstateblock)(unsafe.Pointer(current_state)).Fcount // Already matched
	if !(count >= int32(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ecode + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ecode + 2)))))) {
		goto __1142
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __1143
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = next_state_offset + 1 + 2*DIMM2_SIZE
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __1144
__1143:
	return -43
__1144:
	;
__1142:
	;
	if !(isinclass != 0) {
		goto __1145
	}

	max = int32(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ecode + 3)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ecode + 4)))))

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ecode))) == OP_CRPOSRANGE && count >= int32(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ecode + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ecode + 2)))))) {
		goto __1146
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__1146:
	;

	if !(libc.PreIncInt32(&count, 1) >= max && max != 0) {
		goto __1147
	} /* Max 0 => no limit */
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1149
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = next_state_offset + 1 + 2*DIMM2_SIZE
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __1150
__1149:
	return -43
__1150:
	;
	goto __1148
__1147:
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1151
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = count
	next_new_state += 12
	goto __1152
__1151:
	return -43
__1152:
	;
__1148:
	;
__1145:
	;
	goto __1109

__1122:
	if !(isinclass != 0) {
		goto __1153
	}
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1154
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = next_state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __1155
__1154:
	return -43
__1155:
	;
__1153:
	;
	goto __1109
__1109:
	;

	goto __89

	// ==========================================================================
	// These are the opcodes for fancy brackets of various kinds. We have
	//       to use recursion in order to handle them. The "always failing" assertion
	//       (?!) is optimised to OP_FAIL when compiling, so we have to support that,
	//       though the other "backtracking verbs" are not supported.

__267:
	forced_fail++ // Count FAILs for multiple states
	goto __89

__268:
__269:
__270:
__271:

	endasscode = code + uintptr(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))))
	*(*uintptr)(unsafe.Pointer(bp + 16 /* rws */)) = RWS

	if !(uint64((*TRWS_anchor)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16)))).Ffree) < uint64(DRWS_RSIZE)+uint64(2)*(uint64(unsafe.Sizeof(Tsize_t(0)))/uint64(unsafe.Sizeof(int32(0))))) {
		goto __1156
	}

	rc = more_workspace(tls, bp+16, uint32(uint64(2)*(uint64(unsafe.Sizeof(Tsize_t(0)))/uint64(unsafe.Sizeof(int32(0))))), mb)
	if !(rc != 0) {
		goto __1157
	}
	return rc
__1157:
	;
	RWS = *(*uintptr)(unsafe.Pointer(bp + 16 /* rws */))
__1156:
	;

	local_offsets = RWS + uintptr((*TRWS_anchor)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16)))).Fsize)*4 - uintptr((*TRWS_anchor)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16)))).Ffree)*4
	local_workspace = local_offsets + uintptr(uint64(2)*(uint64(unsafe.Sizeof(Tsize_t(0)))/uint64(unsafe.Sizeof(int32(0)))))*4
	*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16)) + 12)) -= uint32(uint64(DRWS_RSIZE) + uint64(2)*(uint64(unsafe.Sizeof(Tsize_t(0)))/uint64(unsafe.Sizeof(int32(0)))))

__1158:
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(endasscode))) == OP_ALT) {
		goto __1159
	}
	endasscode += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(endasscode + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(endasscode + 2)))))
	goto __1158
__1159:
	;

	rc = internal_dfa_match(tls,
		mb,   // static match data
		code, // this subexpression's code
		ptr,  // where we currently are
		Tsize_t((int64(ptr)-int64(start_subject))/1),
		local_offsets, // offset vector
		uint32(uint64(2)*(uint64(unsafe.Sizeof(Tsize_t(0)))/uint64(unsafe.Sizeof(int32(0))))/(uint64(unsafe.Sizeof(Tsize_t(0)))/uint64(unsafe.Sizeof(int32(0))))),
		local_workspace, // workspace vector
		DRWS_RSIZE,      // size of same
		rlevel,          // function recursion level
		RWS)             // recursion workspace

	*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16)) + 12)) += uint32(uint64(DRWS_RSIZE) + uint64(2)*(uint64(unsafe.Sizeof(Tsize_t(0)))/uint64(unsafe.Sizeof(int32(0)))))

	if !(rc < 0 && rc != -1) {
		goto __1160
	}
	return rc
__1160:
	;
	if !(libc.Bool32(rc >= 0) == libc.Bool32(codevalue == OP_ASSERT || codevalue == OP_ASSERTBACK)) {
		goto __1161
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __1162
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = int32((int64(endasscode+uintptr(DLINK_SIZE)+uintptr(1)) - int64(start_code)) / 1)
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __1163
__1162:
	return -43
__1163:
	;
__1161:
	;

	goto __89

	//-----------------------------------------------------------------
__272:
__273:

	codelink = int32(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))))

	// Because of the way auto-callout works during compile, a callout item
	//         is inserted between OP_COND and an assertion condition. This does not
	//         happen for the other conditions.

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3))) == OP_CALLOUT ||
		int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3))) == OP_CALLOUT_STR) {
		goto __1164
	}

	rrc = do_callout(tls, code, offsets, current_subject, ptr, mb,
		uint64(1+DLINK_SIZE), bp+24)
	if !(rrc < 0) {
		goto __1165
	}
	return rrc
__1165:
	; // Abandon
	if !(rrc > 0) {
		goto __1166
	}
	goto __89
__1166:
	;                                                                               // Fail this thread
	code += TPCRE2_SPTR8(*(*Tsize_t)(unsafe.Pointer(bp + 24 /* callout_length */))) // Skip callout data
__1164:
	;

	condcode = *(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3))

	// Back reference conditions and duplicate named recursion conditions
	//         are not supported

	if !(int32(condcode) == OP_CREF || int32(condcode) == OP_DNCREF || int32(condcode) == OP_DNRREF) {
		goto __1167
	}
	return -40
__1167:
	;

	// The DEFINE condition is always false, and the assertion (?!) is
	//         converted to OP_FAIL.

	if !(int32(condcode) == OP_FALSE || int32(condcode) == OP_FAIL) {
		goto __1168
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __1170
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + codelink + DLINK_SIZE + 1
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __1171
__1170:
	return -43
__1171:
	;
	goto __1169
__1168:
	if !(int32(condcode) == OP_TRUE) {
		goto __1172
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __1174
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + DLINK_SIZE + 2
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __1175
__1174:
	return -43
__1175:
	;
	goto __1173
__1172:
	if !(int32(condcode) == OP_RREF) {
		goto __1176
	}

	value = uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 4)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 5))))
	if !(value != uint32(DRREF_ANY)) {
		goto __1178
	}
	return -40
__1178:
	;
	if !((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Frecursive != uintptr(0)) {
		goto __1179
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __1181
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + DLINK_SIZE + 2 + DIMM2_SIZE
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __1182
__1181:
	return -43
__1182:
	;
	goto __1180
__1179:
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __1183
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + codelink + DLINK_SIZE + 1
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __1184
__1183:
	return -43
__1184:
	;
__1180:
	;
	goto __1177
__1176:

	asscode = code + uintptr(DLINK_SIZE) + uintptr(1)
	endasscode1 = asscode + uintptr(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(asscode + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(asscode + 2)))))
	*(*uintptr)(unsafe.Pointer(bp + 32 /* rws1 */)) = RWS

	if !(uint64((*TRWS_anchor)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32)))).Ffree) < uint64(DRWS_RSIZE)+uint64(2)*(uint64(unsafe.Sizeof(Tsize_t(0)))/uint64(unsafe.Sizeof(int32(0))))) {
		goto __1185
	}

	rc1 = more_workspace(tls, bp+32, uint32(uint64(2)*(uint64(unsafe.Sizeof(Tsize_t(0)))/uint64(unsafe.Sizeof(int32(0))))), mb)
	if !(rc1 != 0) {
		goto __1186
	}
	return rc1
__1186:
	;
	RWS = *(*uintptr)(unsafe.Pointer(bp + 32 /* rws1 */))
__1185:
	;

	local_offsets1 = RWS + uintptr((*TRWS_anchor)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32)))).Fsize)*4 - uintptr((*TRWS_anchor)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32)))).Ffree)*4
	local_workspace1 = local_offsets1 + uintptr(uint64(2)*(uint64(unsafe.Sizeof(Tsize_t(0)))/uint64(unsafe.Sizeof(int32(0)))))*4
	*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32)) + 12)) -= uint32(uint64(DRWS_RSIZE) + uint64(2)*(uint64(unsafe.Sizeof(Tsize_t(0)))/uint64(unsafe.Sizeof(int32(0)))))

__1187:
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(endasscode1))) == OP_ALT) {
		goto __1188
	}
	endasscode1 += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(endasscode1 + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(endasscode1 + 2)))))
	goto __1187
__1188:
	;

	rc1 = internal_dfa_match(tls,
		mb,      // fixed match data
		asscode, // this subexpression's code
		ptr,     // where we currently are
		Tsize_t((int64(ptr)-int64(start_subject))/1),
		local_offsets1, // offset vector
		uint32(uint64(2)*(uint64(unsafe.Sizeof(Tsize_t(0)))/uint64(unsafe.Sizeof(int32(0))))/(uint64(unsafe.Sizeof(Tsize_t(0)))/uint64(unsafe.Sizeof(int32(0))))),
		local_workspace1, // workspace vector
		DRWS_RSIZE,       // size of same
		rlevel,           // function recursion level
		RWS)              // recursion workspace

	*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32)) + 12)) += uint32(uint64(DRWS_RSIZE) + uint64(2)*(uint64(unsafe.Sizeof(Tsize_t(0)))/uint64(unsafe.Sizeof(int32(0)))))

	if !(rc1 < 0 && rc1 != -1) {
		goto __1189
	}
	return rc1
__1189:
	;
	if !(libc.Bool32(rc1 >= 0) == libc.Bool32(int32(condcode) == OP_ASSERT || int32(condcode) == OP_ASSERTBACK)) {
		goto __1190
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __1192
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = int32((int64(endasscode1+uintptr(DLINK_SIZE)+uintptr(1)) - int64(start_code)) / 1)
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __1193
__1192:
	return -43
__1193:
	;
	goto __1191
__1190:
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __1194
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + codelink + DLINK_SIZE + 1
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __1195
__1194:
	return -43
__1195:
	;
__1191:
	;
__1177:
	;
__1173:
	;
__1169:
	;

	goto __89

	//-----------------------------------------------------------------
__274:

	*(*uintptr)(unsafe.Pointer(bp + 40 /* rws2 */)) = RWS
	callpat = start_code + uintptr(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))))
	if callpat == (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_code {
		recno = uint32(0)
	} else {
		recno = uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(callpat + 3)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(callpat + 4))))
	}

	if !(uint64((*TRWS_anchor)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 40)))).Ffree) < uint64(DRWS_RSIZE)+uint64(1000)*(uint64(unsafe.Sizeof(Tsize_t(0)))/uint64(unsafe.Sizeof(int32(0))))) {
		goto __1196
	}

	rc2 = more_workspace(tls, bp+40, uint32(uint64(1000)*(uint64(unsafe.Sizeof(Tsize_t(0)))/uint64(unsafe.Sizeof(int32(0))))), mb)
	if !(rc2 != 0) {
		goto __1197
	}
	return rc2
__1197:
	;
	RWS = *(*uintptr)(unsafe.Pointer(bp + 40 /* rws2 */))
__1196:
	;

	local_offsets2 = RWS + uintptr((*TRWS_anchor)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 40)))).Fsize)*4 - uintptr((*TRWS_anchor)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 40)))).Ffree)*4
	local_workspace2 = local_offsets2 + uintptr(uint64(1000)*(uint64(unsafe.Sizeof(Tsize_t(0)))/uint64(unsafe.Sizeof(int32(0)))))*4
	*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 40)) + 12)) -= uint32(uint64(DRWS_RSIZE) + uint64(1000)*(uint64(unsafe.Sizeof(Tsize_t(0)))/uint64(unsafe.Sizeof(int32(0)))))

	// Check for repeating a recursion without advancing the subject
	//         pointer. This should catch convoluted mutual recursions. (Some simple
	//         cases are caught at compile time.)

	ri = (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Frecursive
__1198:
	if !(ri != uintptr(0)) {
		goto __1200
	}
	if !(recno == (*Tdfa_recursion_info)(unsafe.Pointer(ri)).Fgroup_num && ptr == (*Tdfa_recursion_info)(unsafe.Pointer(ri)).Fsubject_position) {
		goto __1201
	}
	return -52
__1201:
	;
	goto __1199
__1199:
	ri = (*Tdfa_recursion_info)(unsafe.Pointer(ri)).Fprevrec
	goto __1198
	goto __1200
__1200:
	;

	// Remember this recursion and where we started it so as to
	//         catch infinite loops.

	(*Tdfa_recursion_info)(unsafe.Pointer(bp + 48 /* &new_recursive */)).Fgroup_num = recno
	(*Tdfa_recursion_info)(unsafe.Pointer(bp + 48 /* &new_recursive */)).Fsubject_position = ptr
	(*Tdfa_recursion_info)(unsafe.Pointer(bp + 48 /* &new_recursive */)).Fprevrec = (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Frecursive
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Frecursive = bp + 48 /* &new_recursive */

	rc2 = internal_dfa_match(tls,
		mb,      // fixed match data
		callpat, // this subexpression's code
		ptr,     // where we currently are
		Tsize_t((int64(ptr)-int64(start_subject))/1),
		local_offsets2, // offset vector
		uint32(uint64(1000)*(uint64(unsafe.Sizeof(Tsize_t(0)))/uint64(unsafe.Sizeof(int32(0))))/(uint64(unsafe.Sizeof(Tsize_t(0)))/uint64(unsafe.Sizeof(int32(0))))),
		local_workspace2, // workspace vector
		DRWS_RSIZE,       // size of same
		rlevel,           // function recursion level
		RWS)              // recursion workspace

	*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 40)) + 12)) += uint32(uint64(DRWS_RSIZE) + uint64(1000)*(uint64(unsafe.Sizeof(Tsize_t(0)))/uint64(unsafe.Sizeof(int32(0)))))
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Frecursive = (*Tdfa_recursion_info)(unsafe.Pointer(bp + 48 /* &new_recursive */)).Fprevrec // Done this recursion

	// Ran out of internal offsets

	if !(rc2 == 0) {
		goto __1202
	}
	return -39
__1202:
	;

	// For each successful matched substring, set up the next state with a
	//         count of characters to skip before trying it. Note that the count is in
	//         characters, not bytes.

	if !(rc2 > 0) {
		goto __1203
	}

	rc2 = rc2*2 - 2
__1205:
	if !(rc2 >= 0) {
		goto __1207
	}

	charcount = *(*Tsize_t)(unsafe.Pointer(local_offsets2 + uintptr(rc2+1)*8)) - *(*Tsize_t)(unsafe.Pointer(local_offsets2 + uintptr(rc2)*8))
	if !(utf != 0) {
		goto __1208
	}

	p = start_subject + uintptr(*(*Tsize_t)(unsafe.Pointer(local_offsets2 + uintptr(rc2)*8)))
	pp = start_subject + uintptr(*(*Tsize_t)(unsafe.Pointer(local_offsets2 + uintptr(rc2+1)*8)))
__1209:
	if !(p < pp) {
		goto __1210
	}
	if !(uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))))&0xc0 == 0x80) {
		goto __1211
	}
	charcount--
__1211:
	;
	goto __1209
__1210:
	;
__1208:
	;
	if !(charcount > uint64(0)) {
		goto __1212
	}

	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1214
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -(state_offset + DLINK_SIZE + 1)
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = int32(charcount - uint64(1))
	next_new_state += 12
	goto __1215
__1214:
	return -43
__1215:
	;
	goto __1213
__1212:

	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __1216
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + DLINK_SIZE + 1
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __1217
__1216:
	return -43
__1217:
	;
__1213:
	;
	goto __1206
__1206:
	rc2 = rc2 - 2
	goto __1205
	goto __1207
__1207:
	;
	goto __1204
__1203:
	if !(rc2 != -1) {
		goto __1218
	}
	return rc2
__1218:
	;
__1204:
	;

	goto __89

	//-----------------------------------------------------------------
__275:
__276:
__277:
__278:
__279:

	local_ptr = ptr
	*(*uintptr)(unsafe.Pointer(bp + 72 /* rws3 */)) = RWS

	if !(uint64((*TRWS_anchor)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 72)))).Ffree) < uint64(DRWS_RSIZE)+uint64(2)*(uint64(unsafe.Sizeof(Tsize_t(0)))/uint64(unsafe.Sizeof(int32(0))))) {
		goto __1219
	}

	rc3 = more_workspace(tls, bp+72, uint32(uint64(2)*(uint64(unsafe.Sizeof(Tsize_t(0)))/uint64(unsafe.Sizeof(int32(0))))), mb)
	if !(rc3 != 0) {
		goto __1220
	}
	return rc3
__1220:
	;
	RWS = *(*uintptr)(unsafe.Pointer(bp + 72 /* rws3 */))
__1219:
	;

	local_offsets3 = RWS + uintptr((*TRWS_anchor)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 72)))).Fsize)*4 - uintptr((*TRWS_anchor)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 72)))).Ffree)*4
	local_workspace3 = local_offsets3 + uintptr(uint64(2)*(uint64(unsafe.Sizeof(Tsize_t(0)))/uint64(unsafe.Sizeof(int32(0)))))*4
	*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 72)) + 12)) -= uint32(uint64(DRWS_RSIZE) + uint64(2)*(uint64(unsafe.Sizeof(Tsize_t(0)))/uint64(unsafe.Sizeof(int32(0)))))

	if !(codevalue == OP_BRAPOSZERO) {
		goto __1221
	}

	allow_zero = DTRUE
	codevalue = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PreIncUintptr(&code, 1)))) // Codevalue will be one of above BRAs
	goto __1222
__1221:
	allow_zero = DFALSE
__1222:
	;

	// Loop to match the subpattern as many times as possible as if it were
	//         a complete pattern.

	matched_count = uint64(0)
__1223:
	;

	rc3 = internal_dfa_match(tls,
		mb,        // fixed match data
		code,      // this subexpression's code
		local_ptr, // where we currently are
		Tsize_t((int64(ptr)-int64(start_subject))/1),
		local_offsets3, // offset vector
		uint32(uint64(2)*(uint64(unsafe.Sizeof(Tsize_t(0)))/uint64(unsafe.Sizeof(int32(0))))/(uint64(unsafe.Sizeof(Tsize_t(0)))/uint64(unsafe.Sizeof(int32(0))))),
		local_workspace3, // workspace vector
		DRWS_RSIZE,       // size of same
		rlevel,           // function recursion level
		RWS)              // recursion workspace

	// Failed to match

	if !(rc3 < 0) {
		goto __1226
	}

	if !(rc3 != -1) {
		goto __1227
	}
	return rc3
__1227:
	;
	goto __1225
__1226:
	;

	// Matched: break the loop if zero characters matched.

	charcount1 = *(*Tsize_t)(unsafe.Pointer(local_offsets3 + 1*8)) - *(*Tsize_t)(unsafe.Pointer(local_offsets3))
	if !(charcount1 == uint64(0)) {
		goto __1228
	}
	goto __1225
__1228:
	;
	local_ptr += TPCRE2_SPTR8(charcount1) // Advance temporary position ptr
	goto __1224
__1224:
	matched_count++
	goto __1223
	goto __1225
__1225:
	;

	*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 72)) + 12)) += uint32(uint64(DRWS_RSIZE) + uint64(2)*(uint64(unsafe.Sizeof(Tsize_t(0)))/uint64(unsafe.Sizeof(int32(0)))))

	// At this point we have matched the subpattern matched_count
	//         times, and local_ptr is pointing to the character after the end of the
	//         last match.

	if !(matched_count > uint64(0) || allow_zero != 0) {
		goto __1229
	}

	end_subpattern = code

__1230:
	end_subpattern += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(end_subpattern + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(end_subpattern + 2)))))
	goto __1231
__1231:
	if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(end_subpattern))) == OP_ALT {
		goto __1230
	}
	goto __1232
__1232:
	;
	next_state_offset1 = int32((int64(end_subpattern)-int64(start_code))/1 + int64(DLINK_SIZE) + int64(1))

	// Optimization: if there are no more active states, and there
	//           are no new states yet set up, then skip over the subject string
	//           right here, to save looping. Otherwise, set up the new state to swing
	//           into action when the end of the matched substring is reached.

	if !(i+1 >= active_count && new_count == 0) {
		goto __1233
	}

	ptr = local_ptr
	clen = 0
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1235
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = next_state_offset1
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __1236
__1235:
	return -43
__1236:
	;
	goto __1234
__1233:

	p1 = ptr
	pp1 = local_ptr
	charcount1 = Tsize_t((int64(pp1) - int64(p1)) / 1)
	if !(utf != 0) {
		goto __1237
	}
__1238:
	if !(p1 < pp1) {
		goto __1239
	}
	if !(uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&p1, 1))))&0xc0 == 0x80) {
		goto __1240
	}
	charcount1--
__1240:
	;
	goto __1238
__1239:
	;
__1237:
	;
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1241
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -next_state_offset1
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = int32(charcount1 - uint64(1))
	next_new_state += 12
	goto __1242
__1241:
	return -43
__1242:
	;
__1234:
	;
__1229:
	;

	goto __89

	//-----------------------------------------------------------------
__280:

	*(*uintptr)(unsafe.Pointer(bp + 80 /* rws4 */)) = RWS

	if !(uint64((*TRWS_anchor)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 80)))).Ffree) < uint64(DRWS_RSIZE)+uint64(2)*(uint64(unsafe.Sizeof(Tsize_t(0)))/uint64(unsafe.Sizeof(int32(0))))) {
		goto __1243
	}

	rc4 = more_workspace(tls, bp+80, uint32(uint64(2)*(uint64(unsafe.Sizeof(Tsize_t(0)))/uint64(unsafe.Sizeof(int32(0))))), mb)
	if !(rc4 != 0) {
		goto __1244
	}
	return rc4
__1244:
	;
	RWS = *(*uintptr)(unsafe.Pointer(bp + 80 /* rws4 */))
__1243:
	;

	local_offsets4 = RWS + uintptr((*TRWS_anchor)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 80)))).Fsize)*4 - uintptr((*TRWS_anchor)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 80)))).Ffree)*4
	local_workspace4 = local_offsets4 + uintptr(uint64(2)*(uint64(unsafe.Sizeof(Tsize_t(0)))/uint64(unsafe.Sizeof(int32(0)))))*4
	*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 80)) + 12)) -= uint32(uint64(DRWS_RSIZE) + uint64(2)*(uint64(unsafe.Sizeof(Tsize_t(0)))/uint64(unsafe.Sizeof(int32(0)))))

	rc4 = internal_dfa_match(tls,
		mb,   // fixed match data
		code, // this subexpression's code
		ptr,  // where we currently are
		Tsize_t((int64(ptr)-int64(start_subject))/1),
		local_offsets4, // offset vector
		uint32(uint64(2)*(uint64(unsafe.Sizeof(Tsize_t(0)))/uint64(unsafe.Sizeof(int32(0))))/(uint64(unsafe.Sizeof(Tsize_t(0)))/uint64(unsafe.Sizeof(int32(0))))),
		local_workspace4, // workspace vector
		DRWS_RSIZE,       // size of same
		rlevel,           // function recursion level
		RWS)              // recursion workspace

	*(*Tuint32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 80)) + 12)) += uint32(uint64(DRWS_RSIZE) + uint64(2)*(uint64(unsafe.Sizeof(Tsize_t(0)))/uint64(unsafe.Sizeof(int32(0)))))

	if !(rc4 >= 0) {
		goto __1245
	}

	end_subpattern1 = code
	charcount2 = *(*Tsize_t)(unsafe.Pointer(local_offsets4 + 1*8)) - *(*Tsize_t)(unsafe.Pointer(local_offsets4))

__1247:
	end_subpattern1 += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(end_subpattern1 + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(end_subpattern1 + 2)))))
	goto __1248
__1248:
	if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(end_subpattern1))) == OP_ALT {
		goto __1247
	}
	goto __1249
__1249:
	;
	next_state_offset2 = int32((int64(end_subpattern1)-int64(start_code))/1 + int64(DLINK_SIZE) + int64(1))

	// If the end of this subpattern is KETRMAX or KETRMIN, we must
	//           arrange for the repeat state also to be added to the relevant list.
	//           Calculate the offset, or set -1 for no repeat.

	if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(end_subpattern1))) == OP_KETRMAX || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(end_subpattern1))) == OP_KETRMIN {
		repeat_state_offset = int32((int64(end_subpattern1)-int64(start_code))/1 - int64(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(end_subpattern1 + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(end_subpattern1 + 2))))))
	} else {
		repeat_state_offset = -1
	}

	// If we have matched an empty string, add the next state at the
	//           current character pointer. This is important so that the duplicate
	//           checking kicks in, which is what breaks infinite loops that match an
	//           empty string.

	if !(charcount2 == uint64(0)) {
		goto __1250
	}

	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __1252
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = next_state_offset2
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __1253
__1252:
	return -43
__1253:
	;
	goto __1251
__1250:
	if !(i+1 >= active_count && new_count == 0) {
		goto __1254
	}

	ptr += TPCRE2_SPTR8(charcount2)
	clen = 0
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1256
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = next_state_offset2
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __1257
__1256:
	return -43
__1257:
	;

	// If we are adding a repeat state at the new character position,
	//             we must fudge things so that it is the only current state.
	//             Otherwise, it might be a duplicate of one we processed before, and
	//             that would cause it to be skipped.

	if !(repeat_state_offset >= 0) {
		goto __1258
	}

	next_active_state = active_states
	active_count = 0
	i = -1
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __1259
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = repeat_state_offset
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __1260
__1259:
	return -43
__1260:
	;
__1258:
	;
	goto __1255
__1254:

	if !(utf != 0) {
		goto __1261
	}

	p2 = start_subject + uintptr(*(*Tsize_t)(unsafe.Pointer(local_offsets4)))
	pp2 = start_subject + uintptr(*(*Tsize_t)(unsafe.Pointer(local_offsets4 + 1*8)))
__1262:
	if !(p2 < pp2) {
		goto __1263
	}
	if !(uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&p2, 1))))&0xc0 == 0x80) {
		goto __1264
	}
	charcount2--
__1264:
	;
	goto __1262
__1263:
	;
__1261:
	;
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1265
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -next_state_offset2
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = int32(charcount2 - uint64(1))
	next_new_state += 12
	goto __1266
__1265:
	return -43
__1266:
	;
	if !(repeat_state_offset >= 0) {
		goto __1267
	}
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1268
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -repeat_state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = int32(charcount2 - uint64(1))
	next_new_state += 12
	goto __1269
__1268:
	return -43
__1269:
	;
__1267:
	;
__1255:
	;
__1251:
	;
	goto __1246
__1245:
	if !(rc4 != -1) {
		goto __1270
	}
	return rc4
__1270:
	;
__1246:
	;

	goto __89

	// ==========================================================================
	// Handle callouts

__281:
__282:

	rrc = do_callout(tls, code, offsets, current_subject, ptr, mb, uint64(0),
		bp+88)
	if !(rrc < 0) {
		goto __1271
	}
	return rrc
__1271:
	; // Abandon
	if !(rrc == 0) {
		goto __1272
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __1273
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + int32(*(*Tsize_t)(unsafe.Pointer(bp + 88)))
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __1274
__1273:
	return -43
__1274:
	;
__1272:
	;

	goto __89

	// ==========================================================================
__283: // Unsupported opcode
	return -42
__89:
	;

NEXT_ACTIVE_STATE:
	goto __51

	goto __51
__51:
	i++
	goto __50
	goto __52
__52:
	; // End of loop scanning active states

	// We have finished the processing at the current subject character. If no
	//   new states have been set for the next character, we have found all the
	//   matches that we are going to find. If partial matching has been requested,
	//   check for appropriate conditions.
	//
	//   The "forced_ fail" variable counts the number of (*F) encountered for the
	//   character. If it is equal to the original active_count (saved in
	//   workspace[1]) it means that (*F) was found on every active state. In this
	//   case we don't want to give a partial match.
	//
	//   The "could_continue" variable is true if a state could have continued but
	//   for the fact that the end of the subject was reached.

	if !(new_count <= 0) {
		goto __1275
	}

	if !(could_continue != 0 && forced_fail != *(*int32)(unsafe.Pointer(workspace + 1*4)) && ((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_PARTIAL_HARD != Tuint32_t(0) ||
		(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_PARTIAL_SOFT != Tuint32_t(0) && match_count < 0) && (partial_newline != 0 || ptr >= end_subject && (ptr > (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0))) {
		goto __1276
	}
	match_count = -2
__1276:
	;
	goto __37 // Exit from loop along the subject string
__1275:
	;

	// One or more states are active for the next character.

	ptr += TPCRE2_SPTR8(clen) // Advance to next subject character
	goto __36
__36:
	goto __35
	goto __37
__37:
	; // Loop to move along the subject string

	// Control gets here from "break" a few lines above. If we have a match and
	// PCRE2_ENDANCHORED is set, the match fails.

	if !(match_count >= 0 && ((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions|(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fpoptions)&DPCRE2_ENDANCHORED != Tuint32_t(0) && ptr < end_subject) {
		goto __1277
	}
	match_count = -1
__1277:
	;

	return match_count
}

// ************************************************
//
//     Match a pattern using the DFA algorithm    *
//

// This function matches a compiled pattern to a subject string, using the
// alternate matching algorithm that finds all matches at once.
//
// Arguments:
//   code          points to the compiled pattern
//   subject       subject string
//   length        length of subject string
//   startoffset   where to start matching in the subject
//   options       option bits
//   match_data    points to a match data structure
//   gcontext      points to a match context
//   workspace     pointer to workspace
//   wscount       size of workspace
//
// Returns:        > 0 => number of match offset pairs placed in offsets
//                 = 0 => offsets overflowed; longest matches are present
//                  -1 => failed to match
//                < -1 => some kind of unexpected problem

func Xpcre2_dfa_match_8(tls *libc.TLS, code uintptr, subject TPCRE2_SPTR8, length Tsize_t, start_offset Tsize_t, options Tuint32_t, match_data uintptr, mcontext uintptr, workspace uintptr, wscount Tsize_t) int32 { /* pcre2_dfa_match.c:3297:1: */
	bp := tls.Alloc(31000)
	defer tls.Free(31000)

	var rc int32
	var was_zero_terminated int32
	var re uintptr
	var start_match TPCRE2_SPTR8
	var end_subject TPCRE2_SPTR8
	var bumpalong_limit TPCRE2_SPTR8
	var req_cu_ptr TPCRE2_SPTR8
	var utf TBOOL
	var anchored TBOOL
	var startline TBOOL
	var firstline TBOOL
	var has_first_cu TBOOL
	var has_req_cu TBOOL
	var memchr_found_first_cu TPCRE2_SPTR8
	var memchr_found_first_cu2 TPCRE2_SPTR8
	var first_cu TPCRE2_UCHAR8
	var first_cu2 TPCRE2_UCHAR8
	var req_cu TPCRE2_UCHAR8
	var req_cu2 TPCRE2_UCHAR8
	var start_bits uintptr

	// We need to have mb pointing to a match block, because the IS_NEWLINE macro
	// is used below, and it expects NLBLOCK to be defined as a pointer.

	// var cb Tpcre2_callout_block_8 at bp+30888, 112

	// var actual_match_block Tdfa_match_block_8 at bp, 168

	var mb uintptr

	// Set up a starting block of memory for use during recursive calls to
	// internal_dfa_match(). By putting this on the stack, it minimizes resource use
	// in the case when it is not needed. If this is too small, more memory is
	// obtained from the heap. At the start of each block is an anchor structure.

	// var base_recursion_workspace [7680]int32 at bp+168, 30720

	var rws uintptr
	var i uint32
	var check_subject TPCRE2_SPTR8
	var t TPCRE2_SPTR8
	var c TPCRE2_UCHAR8
	var ok TBOOL
	// In 16-bit and 32_bit modes we have to do our own search, so can
	//           look for both cases at once.

	// In 8-bit mode, the use of memchr() gives a big speed up, even
	//           though we have to call it twice in order to find the earliest
	//           occurrence of the code unit in either of its cases. Caching is used
	//           to remember the positions of previously found code units. This can
	//           make a huge difference when the strings are very long and only one
	//           case is actually present.

	var pp1 TPCRE2_SPTR8
	var pp2 TPCRE2_SPTR8
	var searchlength Tsize_t
	var c1 Tuint32_t
	var pp TPCRE2_SPTR8
	var check_length Tsize_t
	var p TPCRE2_SPTR8
	var next uintptr
	was_zero_terminated = 0
	re = code
	has_first_cu = DFALSE
	has_req_cu = DFALSE
	memchr_found_first_cu = uintptr(0)
	memchr_found_first_cu2 = uintptr(0)
	first_cu = TPCRE2_UCHAR8(0)
	first_cu2 = TPCRE2_UCHAR8(0)
	req_cu = TPCRE2_UCHAR8(0)
	req_cu2 = TPCRE2_UCHAR8(0)
	start_bits = uintptr(0)
	mb = bp        /* &actual_match_block */
	rws = bp + 168 /* base_recursion_workspace */
	(*TRWS_anchor)(unsafe.Pointer(rws)).Fnext = uintptr(0)
	(*TRWS_anchor)(unsafe.Pointer(rws)).Fsize = uint32(uint64(DDFA_START_RWS_SIZE) / uint64(unsafe.Sizeof(int32(0))))
	(*TRWS_anchor)(unsafe.Pointer(rws)).Ffree = uint32(uint64(DDFA_START_RWS_SIZE)/uint64(unsafe.Sizeof(int32(0))) - uint64(unsafe.Sizeof(TRWS_anchor{}))/uint64(unsafe.Sizeof(int32(0))))

	// Recognize NULL, length 0 as an empty string.

	if !(subject == uintptr(0) && length == uint64(0)) {
		goto __1
	}
	subject = ts + 797 /* "" */
__1:
	;

	// Plausibility checks

	if !(options&libc.CplUint32(DPCRE2_ANCHORED|DPCRE2_ENDANCHORED|DPCRE2_NOTBOL|DPCRE2_NOTEOL|DPCRE2_NOTEMPTY|DPCRE2_NOTEMPTY_ATSTART|DPCRE2_NO_UTF_CHECK|DPCRE2_PARTIAL_HARD|DPCRE2_PARTIAL_SOFT|DPCRE2_DFA_SHORTEST|DPCRE2_DFA_RESTART|DPCRE2_COPY_MATCHED_SUBJECT) != Tuint32_t(0)) {
		goto __2
	}
	return -34
__2:
	;
	if !(re == uintptr(0) || subject == uintptr(0) || workspace == uintptr(0) || match_data == uintptr(0)) {
		goto __3
	}
	return -51
__3:
	;

	if !(length == libc.CplUint64(uint64(0))) {
		goto __4
	}

	length = X_pcre2_strlen_8(tls, subject)
	was_zero_terminated = 1
__4:
	;

	if !(wscount < uint64(20)) {
		goto __5
	}
	return -43
__5:
	;
	if !(start_offset > length) {
		goto __6
	}
	return -33
__6:
	;

	// Partial matching and PCRE2_ENDANCHORED are currently not allowed at the same
	// time.

	if !(options&(DPCRE2_PARTIAL_HARD|DPCRE2_PARTIAL_SOFT) != Tuint32_t(0) && ((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options|options)&DPCRE2_ENDANCHORED != Tuint32_t(0)) {
		goto __7
	}
	return -34
__7:
	;

	// Invalid UTF support is not available for DFA matching.

	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_MATCH_INVALID_UTF != Tuint32_t(0)) {
		goto __8
	}
	return -66
__8:
	;

	// Check that the first field in the block is the magic number. If it is not,
	// return with PCRE2_ERROR_BADMAGIC.

	if !(uint64((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fmagic_number) != DMAGIC_NUMBER) {
		goto __9
	}
	return -31
__9:
	;

	// Check the code unit width.

	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&Tuint32_t(DPCRE2_MODE8|DPCRE2_MODE16|DPCRE2_MODE32) != Tuint32_t(DPCRE2_CODE_UNIT_WIDTH/8)) {
		goto __10
	}
	return -32
__10:
	;

	// PCRE2_NOTEMPTY and PCRE2_NOTEMPTY_ATSTART are match-time flags in the
	// options variable for this function. Users of PCRE2 who are not calling the
	// function directly would like to have a way of setting these flags, in the same
	// way that they can set pcre2_compile() flags like PCRE2_NO_AUTOPOSSESS with
	// constructions like (*NO_AUTOPOSSESS). To enable this, (*NOTEMPTY) and
	// (*NOTEMPTY_ATSTART) set bits in the pattern's "flag" function which can now be
	// transferred to the options for this function. The bits are guaranteed to be
	// adjacent, but do not have the same values. This bit of Boolean trickery assumes
	// that the match-time bits are not more significant than the flag bits. If by
	// accident this is not the case, a compile-time division by zero error will
	// occur.

	options = options | (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&Tuint32_t(DPCRE2_NOTEMPTY_SET|DPCRE2_NE_ATST_SET)/(uint32((DPCRE2_NOTEMPTY_SET|DPCRE2_NE_ATST_SET)&(libc.CplInt32(DPCRE2_NOTEMPTY_SET|DPCRE2_NE_ATST_SET)+1))/((DPCRE2_NOTEMPTY|DPCRE2_NOTEMPTY_ATSTART)&(libc.CplUint32(DPCRE2_NOTEMPTY|DPCRE2_NOTEMPTY_ATSTART)+uint32(1))))

	// If restarting after a partial match, do some sanity checks on the contents
	// of the workspace.

	if !(options&DPCRE2_DFA_RESTART != Tuint32_t(0)) {
		goto __11
	}

	if !(*(*int32)(unsafe.Pointer(workspace))&-2 != 0 || *(*int32)(unsafe.Pointer(workspace + 1*4)) < 1 || *(*int32)(unsafe.Pointer(workspace + 1*4)) > int32((wscount-uint64(2))/Tsize_t(int32(uint64(unsafe.Sizeof(Tstateblock{}))/uint64(unsafe.Sizeof(int32(0))))))) {
		goto __12
	}
	return -38
__12:
	;
__11:
	;

	// Set some local values

	utf = libc.Bool32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_UTF != Tuint32_t(0))
	start_match = subject + uintptr(start_offset)
	end_subject = subject + uintptr(length)
	req_cu_ptr = start_match - uintptr(1)
	anchored = libc.Bool32(options&(DPCRE2_ANCHORED|DPCRE2_DFA_RESTART) != Tuint32_t(0) || (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_ANCHORED != Tuint32_t(0))

	// The "must be at the start of a line" flags are used in a loop when finding
	// where to start.

	startline = libc.Bool32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&Tuint32_t(DPCRE2_STARTLINE) != Tuint32_t(0))
	firstline = libc.Bool32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_FIRSTLINE != Tuint32_t(0))
	bumpalong_limit = end_subject

	// Initialize and set up the fixed fields in the callout block, with a pointer
	// in the match block.

	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fcb = bp + 30888 /* &cb */
	(*Tpcre2_callout_block_8)(unsafe.Pointer(bp + 30888 /* &cb */)).Fversion = Tuint32_t(2)
	(*Tpcre2_callout_block_8)(unsafe.Pointer(bp + 30888 /* &cb */)).Fsubject = subject
	(*Tpcre2_callout_block_8)(unsafe.Pointer(bp + 30888 /* &cb */)).Fsubject_length = Tsize_t((int64(end_subject) - int64(subject)) / 1)
	(*Tpcre2_callout_block_8)(unsafe.Pointer(bp + 30888 /* &cb */)).Fcallout_flags = Tuint32_t(0)
	(*Tpcre2_callout_block_8)(unsafe.Pointer(bp + 30888 /* &cb */)).Fcapture_top = Tuint32_t(1) // No capture support
	(*Tpcre2_callout_block_8)(unsafe.Pointer(bp + 30888 /* &cb */)).Fcapture_last = Tuint32_t(0)
	(*Tpcre2_callout_block_8)(unsafe.Pointer(bp + 30888 /* &cb */)).Fmark = uintptr(0) // No (*MARK) support

	// Get data from the match context, if present, and fill in the remaining
	// fields in the match block. It is an error to set an offset limit without
	// setting the flag at compile time.

	if !(mcontext == uintptr(0)) {
		goto __13
	}

	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fcallout = uintptr(0)
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmemctl = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fmemctl
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmatch_limit = X_pcre2_default_match_context_8.Fmatch_limit
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmatch_limit_depth = X_pcre2_default_match_context_8.Fdepth_limit
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fheap_limit = Tsize_t(X_pcre2_default_match_context_8.Fheap_limit)
	goto __14
__13:

	if !((*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Foffset_limit != libc.CplUint64(uint64(0))) {
		goto __15
	}

	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_USE_OFFSET_LIMIT == Tuint32_t(0)) {
		goto __16
	}
	return -56
__16:
	;
	bumpalong_limit = subject + uintptr((*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Foffset_limit)
__15:
	;
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fcallout = (*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fcallout
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fcallout_data = (*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fcallout_data
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmemctl = (*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fmemctl
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmatch_limit = (*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fmatch_limit
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmatch_limit_depth = (*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fdepth_limit
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fheap_limit = Tsize_t((*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fheap_limit)
__14:
	;

	if !((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmatch_limit > (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flimit_match) {
		goto __17
	}
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmatch_limit = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flimit_match
__17:
	;

	if !((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmatch_limit_depth > (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flimit_depth) {
		goto __18
	}
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmatch_limit_depth = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flimit_depth
__18:
	;

	if !((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fheap_limit > Tsize_t((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flimit_heap)) {
		goto __19
	}
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fheap_limit = Tsize_t((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flimit_heap)
__19:
	;

	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_code = re + uintptr(uint64(unsafe.Sizeof(Tpcre2_real_code_8{}))) + uintptr(int32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fname_count)*int32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fname_entry_size))
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Ftables = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftables
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_subject = subject
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject = end_subject
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_offset = start_offset
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fallowemptypartial = libc.Bool32(int32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fmax_lookbehind) > 0 || (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&Tuint32_t(DPCRE2_MATCH_EMPTY) != Tuint32_t(0))
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions = options
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fpoptions = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmatch_call_count = Tuint32_t(0)
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fheap_used = uint64(0)

	// Process the \R and newline settings.

	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fbsr_convention = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fbsr_convention
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype = Tuint32_t(DNLTYPE_FIXED)
	switch int32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fnewline_convention) {
	case DPCRE2_NEWLINE_CR:
		goto __21

	case DPCRE2_NEWLINE_LF:
		goto __22

	case DPCRE2_NEWLINE_NUL:
		goto __23

	case DPCRE2_NEWLINE_CRLF:
		goto __24

	case DPCRE2_NEWLINE_ANY:
		goto __25

	case DPCRE2_NEWLINE_ANYCRLF:
		goto __26

	default:
		goto __27
	}
	goto __20

__21:
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen = Tuint32_t(1)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128)) = TPCRE2_UCHAR8('\015')
	goto __20

__22:
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen = Tuint32_t(1)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128)) = TPCRE2_UCHAR8('\012')
	goto __20

__23:
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen = Tuint32_t(1)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128)) = TPCRE2_UCHAR8(0)
	goto __20

__24:
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen = Tuint32_t(2)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128)) = TPCRE2_UCHAR8('\015')
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128 + 1)) = TPCRE2_UCHAR8('\012')
	goto __20

__25:
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype = Tuint32_t(DNLTYPE_ANY)
	goto __20

__26:
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype = Tuint32_t(DNLTYPE_ANYCRLF)
	goto __20

__27:
	return -44
__20:
	;

	// Check a UTF string for validity if required. For 8-bit and 16-bit strings,
	// we must also check that a starting offset does not point into the middle of a
	// multiunit character. We check only the portion of the subject that is going to
	// be inspected during matching - from the offset minus the maximum back reference
	// to the given length. This saves time when a small part of a large subject is
	// being matched by the use of a starting offset. Note that the maximum lookbehind
	// is a number of characters, not code units.

	if !(utf != 0 && options&DPCRE2_NO_UTF_CHECK == Tuint32_t(0)) {
		goto __28
	}

	check_subject = start_match // start_match includes offset

	if !(start_offset > uint64(0)) {
		goto __29
	}

	if !(start_match < end_subject && uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(start_match)))&0xc0 == 0x80) {
		goto __30
	}
	return -36
__30:
	;
	i = uint32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fmax_lookbehind)
__31:
	if !(i > uint32(0) && check_subject > subject) {
		goto __33
	}

	check_subject--
__34:
	if !(check_subject > subject && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(check_subject)))&0xc0 == 0x80) {
		goto __35
	}
	check_subject--
	goto __34
__35:
	;
	goto __32
__32:
	i--
	goto __31
	goto __33
__33:
	;
__29:
	;

	// Validate the relevant portion of the subject. After an error, adjust the
	//   offset to be an absolute offset in the whole string.

	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Frc = X_pcre2_valid_utf_8(tls, check_subject,
		length-Tsize_t((int64(check_subject)-int64(subject))/1), match_data+64)
	if !((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Frc != 0) {
		goto __36
	}

	*(*Tsize_t)(unsafe.Pointer(match_data + 64)) += Tsize_t((int64(check_subject) - int64(subject)) / 1)
	return (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Frc
__36:
	;
__28:
	;

	// Set up the first code unit to match, if available. If there's no first code
	// unit there may be a bitmap of possible first characters.

	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&Tuint32_t(DPCRE2_FIRSTSET) != Tuint32_t(0)) {
		goto __37
	}

	has_first_cu = DTRUE
	first_cu = libc.AssignUint8(&first_cu2, TPCRE2_UCHAR8((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ffirst_codeunit))
	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&Tuint32_t(DPCRE2_FIRSTCASELESS) != Tuint32_t(0)) {
		goto __39
	}

	first_cu2 = *(*Tuint8_t)(unsafe.Pointer((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Ftables + uintptr(Dfcc_offset) + uintptr(first_cu)))
	if !(int32(first_cu) > 127 && !(utf != 0) && (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_UCP != Tuint32_t(0)) {
		goto __40
	}
	first_cu2 = TPCRE2_UCHAR8(Tuint32_t(int32(first_cu) + (*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(first_cu)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(first_cu)%DUCD_BLOCK_SIZE])*12)).Fother_case))
__40:
	;
__39:
	;
	goto __38
__37:
	if !(!(startline != 0) && (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&Tuint32_t(DPCRE2_FIRSTMAPSET) != Tuint32_t(0)) {
		goto __41
	}
	start_bits = re + 40 /* &.start_bitmap */
__41:
	;
__38:
	;

	// There may be a "last known required code unit" set.

	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&Tuint32_t(DPCRE2_LASTSET) != Tuint32_t(0)) {
		goto __42
	}

	has_req_cu = DTRUE
	req_cu = libc.AssignUint8(&req_cu2, TPCRE2_UCHAR8((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flast_codeunit))
	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&Tuint32_t(DPCRE2_LASTCASELESS) != Tuint32_t(0)) {
		goto __43
	}

	req_cu2 = *(*Tuint8_t)(unsafe.Pointer((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Ftables + uintptr(Dfcc_offset) + uintptr(req_cu)))
	if !(int32(req_cu) > 127 && !(utf != 0) && (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_UCP != Tuint32_t(0)) {
		goto __44
	}
	req_cu2 = TPCRE2_UCHAR8(Tuint32_t(int32(req_cu) + (*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(req_cu)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(req_cu)%DUCD_BLOCK_SIZE])*12)).Fother_case))
__44:
	;
__43:
	;
__42:
	;

	// If the match data block was previously used with PCRE2_COPY_MATCHED_SUBJECT,
	// free the memory that was obtained.

	if !(uint32((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fflags)&DPCRE2_MD_COPIED_SUBJECT != uint32(0)) {
		goto __45
	}

	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmemctl.Ffree})).f(tls, (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fsubject,
		(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmemctl.Fmemory_data)
	*(*Tuint8_t)(unsafe.Pointer(match_data + 73)) &= libc.Uint8FromUint32(libc.CplUint32(DPCRE2_MD_COPIED_SUBJECT))
__45:
	;

	// Fill in fields that are always returned in the match data.

	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fcode = re
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fsubject = uintptr(0) // Default for no match
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmark = uintptr(0)
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmatchedby = PCRE2_MATCHEDBY_DFA_INTERPRETER

	// Call the main matching function, looping for a non-anchored regex after a
	// failed match. If not restarting, perform certain optimizations at the start of
	// a match.

__46:

	// ----------------- Start of match optimizations ----------------

	// There are some optimizations that avoid running the match if a known
	//   starting point is not found, or if a known later code unit is not present.
	//   However, there is an option (settable at compile time) that disables
	//   these, for testing and for ensuring that all callouts do actually occur.
	//   The optimizations must also be avoided when restarting a DFA match.

	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_NO_START_OPTIMIZE == Tuint32_t(0) && options&DPCRE2_DFA_RESTART == Tuint32_t(0)) {
		goto __49
	}

	// If firstline is TRUE, the start of the match is constrained to the first
	//     line of a multiline string. That is, the match must be before or at the
	//     first newline following the start of matching. Temporarily adjust
	//     end_subject so that we stop the optimization scans for a first code unit
	//     immediately after the first character of a newline (the first code unit can
	//     legitimately be a newline). If the match fails at the newline, later code
	//     breaks this loop.

	if !(firstline != 0) {
		goto __50
	}

	t = start_match
	if !(utf != 0) {
		goto __51
	}

__53:
	if !(t < end_subject && !(func() int32 {
		if (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype != Tuint32_t(DNLTYPE_FIXED) {
			return libc.Bool32(t < (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, t, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+120, utf) != 0)
		}
		return libc.Bool32(t <= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(t))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128))) && ((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(1) || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(t + uintptr(1)))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128 + 1)))))
	}() != 0)) {
		goto __54
	}

	t++
__55:
	if !(t < end_subject && uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(t)))&0xc0 == 0x80) {
		goto __56
	}
	t++
	goto __55
__56:
	;
	goto __53
__54:
	;
	goto __52
__51:
__57:
	if !(t < end_subject && !(func() int32 {
		if (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype != Tuint32_t(DNLTYPE_FIXED) {
			return libc.Bool32(t < (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, t, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+120, utf) != 0)
		}
		return libc.Bool32(t <= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(t))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128))) && ((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(1) || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(t + uintptr(1)))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128 + 1)))))
	}() != 0)) {
		goto __58
	}
	t++
	goto __57
__58:
	;
__52:
	;
	end_subject = t
__50:
	;

	// Anchored: check the first code unit if one is recorded. This may seem
	//     pointless but it can help in detecting a no match case without scanning for
	//     the required code unit.

	if !(anchored != 0) {
		goto __59
	}

	if !(has_first_cu != 0 || start_bits != uintptr(0)) {
		goto __61
	}

	ok = libc.Bool32(start_match < end_subject)
	if !(ok != 0) {
		goto __62
	}

	c = *(*TPCRE2_UCHAR8)(unsafe.Pointer(start_match))
	ok = libc.Bool32(has_first_cu != 0 && (int32(c) == int32(first_cu) || int32(c) == int32(first_cu2)))
	if !(!(ok != 0) && start_bits != uintptr(0)) {
		goto __63
	}

	ok = libc.Bool32(uint32(*(*Tuint8_t)(unsafe.Pointer(start_bits + uintptr(int32(c)/8))))&(uint32(1)<<(int32(c)&7)) != uint32(0))
__63:
	;
__62:
	;
	if !!(ok != 0) {
		goto __64
	}
	goto __48
__64:
	;
__61:
	;
	goto __60
__59:

	if !(has_first_cu != 0) {
		goto __65
	}

	if !(int32(first_cu) != int32(first_cu2)) {
		goto __67
	} /* Caseless */

	// In 16-bit and 32_bit modes we have to do our own search, so can
	//           look for both cases at once.

	// In 8-bit mode, the use of memchr() gives a big speed up, even
	//           though we have to call it twice in order to find the earliest
	//           occurrence of the code unit in either of its cases. Caching is used
	//           to remember the positions of previously found code units. This can
	//           make a huge difference when the strings are very long and only one
	//           case is actually present.

	pp1 = uintptr(0)
	pp2 = uintptr(0)
	searchlength = Tsize_t((int64(end_subject) - int64(start_match)) / 1)

	// If we haven't got a previously found position for first_cu, or if
	//           the current starting position is later, we need to do a search. If
	//           the code unit is not found, set it to the end.

	if !(memchr_found_first_cu == uintptr(0) || start_match > memchr_found_first_cu) {
		goto __69
	}

	pp1 = libc.Xmemchr(tls, start_match, int32(first_cu), searchlength)
	if pp1 == uintptr(0) {
		memchr_found_first_cu = end_subject
	} else {
		memchr_found_first_cu = pp1
	}
	goto __70
__69:
	if memchr_found_first_cu == end_subject {
		pp1 = uintptr(0)
	} else {
		pp1 = memchr_found_first_cu
	}
__70:
	;

	// Do the same thing for the other case.

	if !(memchr_found_first_cu2 == uintptr(0) || start_match > memchr_found_first_cu2) {
		goto __71
	}

	pp2 = libc.Xmemchr(tls, start_match, int32(first_cu2), searchlength)
	if pp2 == uintptr(0) {
		memchr_found_first_cu2 = end_subject
	} else {
		memchr_found_first_cu2 = pp2
	}
	goto __72
__71:
	if memchr_found_first_cu2 == end_subject {
		pp2 = uintptr(0)
	} else {
		pp2 = memchr_found_first_cu2
	}
__72:
	;

	// Set the start to the end of the subject if neither case was found.
	//           Otherwise, use the earlier found point.

	if !(pp1 == uintptr(0)) {
		goto __73
	}
	if pp2 == uintptr(0) {
		start_match = end_subject
	} else {
		start_match = pp2
	}
	goto __74
__73:
	if pp2 == uintptr(0) || pp1 < pp2 {
		start_match = pp1
	} else {
		start_match = pp2
	}
__74:
	;

	goto __68
__67:

	start_match = libc.Xmemchr(tls, start_match, int32(first_cu), uint64((int64(end_subject)-int64(start_match))/1))
	if !(start_match == uintptr(0)) {
		goto __75
	}
	start_match = end_subject
__75:
	;
__68:
	;

	// If we can't find the required code unit, having reached the true end
	//         of the subject, break the bumpalong loop, to force a match failure,
	//         except when doing partial matching, when we let the next cycle run at
	//         the end of the subject. To see why, consider the pattern /(?<=abc)def/,
	//         which partially matches "abc", even though the string does not contain
	//         the starting character "d". If we have not reached the true end of the
	//         subject (PCRE2_FIRSTLINE caused end_subject to be temporarily modified)
	//         we also let the cycle run, because the matching string is legitimately
	//         allowed to start with the first code unit of a newline.

	if !((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&(DPCRE2_PARTIAL_HARD|DPCRE2_PARTIAL_SOFT) == Tuint32_t(0) && start_match >= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __76
	}
	goto __48
__76:
	;
	goto __66
__65:
	if !(startline != 0) {
		goto __77
	}

	if !(start_match > (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_subject+uintptr(start_offset)) {
		goto __79
	}

	if !(utf != 0) {
		goto __80
	}

__82:
	if !(start_match < end_subject && !(func() int32 {
		if (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype != Tuint32_t(DNLTYPE_FIXED) {
			return libc.Bool32(start_match > (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_subject && X_pcre2_was_newline_8(tls, start_match, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_subject, mb+120, utf) != 0)
		}
		return libc.Bool32(start_match >= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_subject+uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(start_match - uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen)))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128))) && ((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(1) || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(start_match - uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen) + uintptr(1)))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128 + 1)))))
	}() != 0)) {
		goto __83
	}

	start_match++
__84:
	if !(start_match < end_subject && uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(start_match)))&0xc0 == 0x80) {
		goto __85
	}
	start_match++
	goto __84
__85:
	;
	goto __82
__83:
	;
	goto __81
__80:
__86:
	if !(start_match < end_subject && !(func() int32 {
		if (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype != Tuint32_t(DNLTYPE_FIXED) {
			return libc.Bool32(start_match > (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_subject && X_pcre2_was_newline_8(tls, start_match, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_subject, mb+120, utf) != 0)
		}
		return libc.Bool32(start_match >= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_subject+uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(start_match - uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen)))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128))) && ((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(1) || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(start_match - uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen) + uintptr(1)))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128 + 1)))))
	}() != 0)) {
		goto __87
	}
	start_match++
	goto __86
__87:
	;
__81:
	;

	// If we have just passed a CR and the newline option is ANY or
	//           ANYCRLF, and we are now at a LF, advance the match position by one
	//           more code unit.

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(start_match + libc.UintptrFromInt32(-1)))) == '\015' && ((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype == Tuint32_t(DNLTYPE_ANY) || (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype == Tuint32_t(DNLTYPE_ANYCRLF)) && start_match < end_subject && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(start_match))) == '\012') {
		goto __88
	}
	start_match++
__88:
	;
__79:
	;
	goto __78
__77:
	if !(start_bits != uintptr(0)) {
		goto __89
	}

__90:
	if !(start_match < end_subject) {
		goto __91
	}

	c1 = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(start_match)))
	if !(uint32(*(*Tuint8_t)(unsafe.Pointer(start_bits + uintptr(c1/Tuint32_t(8)))))&(uint32(1)<<(c1&Tuint32_t(7))) != uint32(0)) {
		goto __92
	}
	goto __91
__92:
	;
	start_match++
	goto __90
__91:
	;

	// See comment above in first_cu checking about the next line.

	if !((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&(DPCRE2_PARTIAL_HARD|DPCRE2_PARTIAL_SOFT) == Tuint32_t(0) && start_match >= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __93
	}
	goto __48
__93:
	;
__89:
	;
__78:
	;
__66:
	;
__60:
	; // End of first code unit handling

	// Restore fudged end_subject

	end_subject = (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject

	// The following two optimizations are disabled for partial matching.

	if !((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&(DPCRE2_PARTIAL_HARD|DPCRE2_PARTIAL_SOFT) == Tuint32_t(0)) {
		goto __94
	}

	// The minimum matching length is a lower bound; no actual string of that
	//       length may actually match the pattern. Although the value is, strictly,
	//       in characters, we treat it as code units to avoid spending too much time
	//       in this optimization.

	if !((int64(end_subject)-int64(start_match))/1 < int64((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fminlength)) {
		goto __95
	}
	goto NOMATCH_EXIT
__95:
	;

	// If req_cu is set, we know that that code unit must appear in the
	//       subject for the match to succeed. If the first code unit is set, req_cu
	//       must be later in the subject; otherwise the test starts at the match
	//       point. This optimization can save a huge amount of backtracking in
	//       patterns with nested unlimited repeats that aren't going to match.
	//       Writing separate code for cased/caseless versions makes it go faster, as
	//       does using an autoincrement and backing off on a match. As in the case of
	//       the first code unit, using memchr() in the 8-bit library gives a big
	//       speed up. Unlike the first_cu check above, we do not need to call
	//       memchr() twice in the caseless case because we only need to check for the
	//       presence of the character in either case, not find the first occurrence.
	//
	//       The search can be skipped if the code unit was found later than the
	//       current starting point in a previous iteration of the bumpalong loop.
	//
	//       HOWEVER: when the subject string is very, very long, searching to its end
	//       can take a long time, and give bad performance on quite ordinary
	//       patterns. This showed up when somebody was matching something like
	//       /^\d+C/ on a 32-megabyte string... so we don't do this when the string is
	//       sufficiently long, but it's worth searching a lot more for unanchored
	//       patterns.

	p = start_match + uintptr(func() int32 {
		if has_first_cu != 0 {
			return 1
		}
		return 0
	}())
	if !(has_req_cu != 0 && p > req_cu_ptr) {
		goto __96
	}

	check_length = Tsize_t((int64(end_subject) - int64(start_match)) / 1)

	if !(check_length < uint64(DREQ_CU_MAX) || !(anchored != 0) && check_length < uint64(DREQ_CU_MAX*1000)) {
		goto __97
	}

	if !(int32(req_cu) != int32(req_cu2)) {
		goto __98
	} /* Caseless */

	pp = p
	p = libc.Xmemchr(tls, pp, int32(req_cu), uint64((int64(end_subject)-int64(pp))/1))
	if !(p == uintptr(0)) {
		goto __100
	}

	p = libc.Xmemchr(tls, pp, int32(req_cu2), uint64((int64(end_subject)-int64(pp))/1))
	if !(p == uintptr(0)) {
		goto __101
	}
	p = end_subject
__101:
	;
__100:
	;
	goto __99
__98:

	p = libc.Xmemchr(tls, p, int32(req_cu), uint64((int64(end_subject)-int64(p))/1))
	if !(p == uintptr(0)) {
		goto __102
	}
	p = end_subject
__102:
	;
__99:
	;

	// If we can't find the required code unit, break the matching loop,
	//           forcing a match failure.

	if !(p >= end_subject) {
		goto __103
	}
	goto __48
__103:
	;

	// If we have found the required code unit, save the point where we
	//           found it, so that we don't search again next time round the loop if
	//           the start hasn't passed this code unit yet.

	req_cu_ptr = p
__97:
	;
__96:
	;
__94:
	;
__49:
	;

	// ------------ End of start of match optimizations ------------

	// Give no match if we have passed the bumpalong limit.

	if !(start_match > bumpalong_limit) {
		goto __104
	}
	goto __48
__104:
	;

	// OK, now we can do the business

	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr = start_match
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Flast_used_ptr = start_match
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Frecursive = uintptr(0)

	rc = internal_dfa_match(tls,
		mb, // fixed match data
		(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_code, // this subexpression's code
		start_match,  // where we currently are
		start_offset, // start offset in subject
		match_data+80,
		Tuint32_t((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Foveccount)*Tuint32_t(2),
		workspace,      // workspace vector
		int32(wscount), // size of same
		uint32(0),      // function recurse level
		bp+168)         // initial workspace for recursion

	// Anything other than "no match" means we are done, always; otherwise, carry
	//   on only if not anchored.

	if !(rc != -1 || anchored != 0) {
		goto __105
	}

	if !(rc == -2 && int32((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Foveccount) > 0) {
		goto __106
	}

	*(*Tsize_t)(unsafe.Pointer(match_data + 80)) = Tsize_t((int64(start_match) - int64(subject)) / 1)
	*(*Tsize_t)(unsafe.Pointer(match_data + 80 + 1*8)) = Tsize_t((int64(end_subject) - int64(subject)) / 1)
__106:
	;
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fleftchar = Tsize_t((int64((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr) - int64(subject)) / 1)
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Frightchar = Tsize_t((int64((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Flast_used_ptr) - int64(subject)) / 1)
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fstartchar = Tsize_t((int64(start_match) - int64(subject)) / 1)
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Frc = rc

	if !(rc >= 0 && options&DPCRE2_COPY_MATCHED_SUBJECT != Tuint32_t(0)) {
		goto __107
	}

	length = (length + Tsize_t(was_zero_terminated)) * uint64(DPCRE2_CODE_UNIT_WIDTH/8)
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fsubject = (*struct {
		f func(*libc.TLS, Tsize_t, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmemctl.Fmalloc})).f(tls, length,
		(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmemctl.Fmemory_data)
	if !((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fsubject == uintptr(0)) {
		goto __109
	}
	return -48
__109:
	;
	libc.Xmemcpy(tls, (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fsubject, subject, length)
	*(*Tuint8_t)(unsafe.Pointer(match_data + 73)) |= uint8(DPCRE2_MD_COPIED_SUBJECT)
	goto __108
__107:

	if !(rc >= 0 || rc == -2) {
		goto __110
	}
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fsubject = subject
__110:
	;
__108:
	;
	goto EXIT
__105:
	;

	// Advance to the next subject character unless we are at the end of a line
	//   and firstline is set.

	if !(firstline != 0 && func() int32 {
		if (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype != Tuint32_t(DNLTYPE_FIXED) {
			return libc.Bool32(start_match < (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, start_match, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+120, utf) != 0)
		}
		return libc.Bool32(start_match <= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(start_match))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128))) && ((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(1) || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(start_match + uintptr(1)))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 128 + 1)))))
	}() != 0) {
		goto __111
	}
	goto __48
__111:
	;
	start_match++
	if !(utf != 0) {
		goto __112
	}

__113:
	if !(start_match < end_subject && uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(start_match)))&0xc0 == 0x80) {
		goto __114
	}
	start_match++
	goto __113
__114:
	;
__112:
	;
	if !(start_match > end_subject) {
		goto __115
	}
	goto __48
__115:
	;

	// If we have just passed a CR and we are now at a LF, and the pattern does
	//   not contain any explicit matches for \r or \n, and the newline option is CRLF
	//   or ANY or ANYCRLF, advance the match position by one more character.

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(start_match - uintptr(1)))) == '\015' && start_match < end_subject && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(start_match))) == '\012' && (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&Tuint32_t(DPCRE2_HASCRORLF) == Tuint32_t(0) && ((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype == Tuint32_t(DNLTYPE_ANY) || (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype == Tuint32_t(DNLTYPE_ANYCRLF) || (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(2))) {
		goto __116
	}
	start_match++
__116:
	;

	goto __47
__47:
	goto __46
	goto __48
__48:
	; // "Bumpalong" loop

NOMATCH_EXIT:
	rc = -1

EXIT:
__117:
	if !((*TRWS_anchor)(unsafe.Pointer(rws)).Fnext != uintptr(0)) {
		goto __118
	}

	next = (*TRWS_anchor)(unsafe.Pointer(rws)).Fnext
	(*TRWS_anchor)(unsafe.Pointer(rws)).Fnext = (*TRWS_anchor)(unsafe.Pointer(next)).Fnext
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmemctl.Ffree})).f(tls, next, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmemctl.Fmemory_data)
	goto __117
__118:
	;

	return rc
}

// End of pcre2_dfa_match.c

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// The texts of compile-time error messages. Compile-time error numbers start
// at COMPILE_ERROR_BASE (100).
//
// This used to be a table of strings, but in order to reduce the number of
// relocations needed when a shared library is loaded dynamically, it is now one
// long string. We cannot use a table of offsets, because the lengths of inserts
// such as XSTRING(MAX_NAME_SIZE) are not known. Instead,
// pcre2_get_error_message() counts through to the one it wants - this isn't a
// performance issue because these strings are used only when there is an error.
//
// Each substring ends with \0 to insert a null character. This includes the final
// substring, so that the whole string ends with \0\0, which can be detected when
// counting through.

var compile_error_texts =

// 5

// 10

// 15

// 20

// 25

// 30

// 35

// 40

// 45

// 50

// 55

// "an argument is not allowed for (*ACCEPT), (*FAIL), or (*COMMIT)\0"
// Was the above
// 60

// 65

// 70

// 75

// 80

// 85

// 90

// 95

*(*[4381]uint8)(unsafe.Pointer(ts + 798)) /* pcre2_error.c:65:28 */

// Match-time and UTF error texts are in the same format.

var match_error_texts =

// 5

// 10

// 15

// 20

// 25

// 30

// 35

// Never returned by PCRE2 itself

// 40

// 45

// 50

// 55

// 60

// 65

*(*[2476]uint8)(unsafe.Pointer(ts + 5179)) /* pcre2_error.c:194:28 */

// ************************************************
//
//            Return error message                *
//

// This function copies an error message into a buffer whose units are of an
// appropriate width. Error numbers are positive for compile-time errors, and
// negative for match-time errors (except for UTF errors), but the numbers are all
// distinct.
//
// Arguments:
//   enumber       error number
//   buffer        where to put the message (zero terminated)
//   size          size of the buffer in code units
//
// Returns:        length of message if all is well
//                 negative on error

func Xpcre2_get_error_message_8(tls *libc.TLS, enumber int32, buffer uintptr, size Tsize_t) int32 { /* pcre2_error.c:297:1: */
	var message uintptr
	var i Tsize_t
	var n int32

	if size == uint64(0) {
		return -48
	}

	if enumber >= DCOMPILE_ERROR_BASE {
		message = uintptr(unsafe.Pointer(&compile_error_texts))
		n = enumber - DCOMPILE_ERROR_BASE
	} else if enumber < 0 {
		message = uintptr(unsafe.Pointer(&match_error_texts))
		n = -enumber
	} else {
		message = ts + 7655 /* "\x00" */ // Empty message list
		n = 1
	}

	for ; n > 0; n-- {
		for int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&message, 1)))) != 0 {
		}

		if int32(*(*uint8)(unsafe.Pointer(message))) == 0 {
			return -29
		}
	}

	for i = uint64(0); int32(*(*uint8)(unsafe.Pointer(message))) != 0; i++ {
		if i >= size-uint64(1) {
			*(*TPCRE2_UCHAR8)(unsafe.Pointer(buffer + uintptr(i))) = TPCRE2_UCHAR8(0) // Terminate partial message
			return -48
		}
		*(*TPCRE2_UCHAR8)(unsafe.Pointer(buffer + uintptr(i))) = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&message, 1)))
	}

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(buffer + uintptr(i))) = TPCRE2_UCHAR8(0)
	return int32(i)
}

// End of pcre2_error.c

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// Dummy function

// ************************************************
//
//      Match an extended grapheme sequence       *
//

//
// Arguments:
//   c              the first character
//   eptr           pointer to next character
//   start_subject  pointer to start of subject
//   end_subject    pointer to end of subject
//   utf            TRUE if in UTF mode
//   xcount         pointer to count of additional characters,
//                    or NULL if count not needed
//
// Returns:         pointer after the end of the sequence

func X_pcre2_extuni_8(tls *libc.TLS, c Tuint32_t, eptr TPCRE2_SPTR8, start_subject TPCRE2_SPTR8, end_subject TPCRE2_SPTR8, utf TBOOL, xcount uintptr) TPCRE2_SPTR8 { /* pcre2_extuni.c:92:1: */
	var lgb int32 = int32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12)).Fgbprop)

	for eptr < end_subject {
		var rgb int32
		var len int32 = 1
		if !(utf != 0) {
			c = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(eptr)))
		} else {
			c = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(eptr)))
			if c >= 0xc0 {
				if c&0x20 == Tuint32_t(0) {
					c = c&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(eptr + 1)))&0x3f
					len++
				} else if c&0x10 == Tuint32_t(0) {
					c = c&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(eptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(eptr + 2)))&0x3f
					len = len + 2
				} else if c&0x08 == Tuint32_t(0) {
					c = c&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(eptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(eptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(eptr + 3)))&0x3f
					len = len + 3
				} else if c&0x04 == Tuint32_t(0) {
					c = c&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(eptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(eptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(eptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(eptr + 4)))&0x3f
					len = len + 4
				} else {
					c = c&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(eptr + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(eptr + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(eptr + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(eptr + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(eptr + 5)))&0x3f
					len = len + 5
				}
			}

		}
		rgb = int32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12)).Fgbprop)
		if X_pcre2_ucp_gbtable_8[lgb]&(uint32(1)<<rgb) == Tuint32_t(0) {
			break
		}

		// Not breaking between Regional Indicators is allowed only if there
		//   are an even number of preceding RIs.

		if lgb == ucp_gbRegional_Indicator && rgb == ucp_gbRegional_Indicator {
			var ricount int32 = 0
			var bptr TPCRE2_SPTR8 = eptr - uintptr(1)
			if utf != 0 {
				for uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bptr)))&0xc0 == 0x80 {
					bptr--
				}
			}

			// bptr is pointing to the left-hand character

			for bptr > start_subject {
				bptr--
				if utf != 0 {
					for uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bptr)))&0xc0 == 0x80 {
						bptr--
					}
					c = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bptr)))
					if c >= 0xc0 {
						if c&0x20 == Tuint32_t(0) {
							c = c&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bptr + 1)))&0x3f
						} else if c&0x10 == Tuint32_t(0) {
							c = c&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bptr + 2)))&0x3f
						} else if c&0x08 == Tuint32_t(0) {
							c = c&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bptr + 3)))&0x3f
						} else if c&0x04 == Tuint32_t(0) {
							c = c&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bptr + 4)))&0x3f
						} else {
							c = c&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bptr + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bptr + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bptr + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bptr + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bptr + 5)))&0x3f
						}
					}

				} else {
					c = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bptr)))
				}
				if int32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12)).Fgbprop) != ucp_gbRegional_Indicator {
					break
				}
				ricount++
			}
			if ricount&1 != 0 {
				break
			} // Grapheme break required
		}

		// If Extend or ZWJ follows Extended_Pictographic, do not update lgb; this
		//   allows any number of them before a following Extended_Pictographic.

		if rgb != ucp_gbExtend && rgb != ucp_gbZWJ || lgb != ucp_gbExtended_Pictographic {
			lgb = rgb
		}

		eptr += TPCRE2_SPTR8(len)
		if xcount != uintptr(0) {
			*(*int32)(unsafe.Pointer(xcount)) += 1
		}
	}

	return eptr
}

// End of pcre2_extuni.c

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// ************************************************
//
//    Scan compiled regex for specific bracket    *
//

//
// Arguments:
//   code        points to start of expression
//   utf         TRUE in UTF mode
//   number      the required bracket number or negative to find a lookbehind
//
// Returns:      pointer to the opcode for the bracket, or NULL if not found

func X_pcre2_find_bracket_8(tls *libc.TLS, code TPCRE2_SPTR8, utf TBOOL, number int32) TPCRE2_SPTR8 { /* pcre2_find_bracket.c:70:1: */
	for {
		var c TPCRE2_UCHAR8 = *(*TPCRE2_UCHAR8)(unsafe.Pointer(code))

		if int32(c) == OP_END {
			return uintptr(0)
		}

		// XCLASS is used for classes that cannot be represented just by a bit map.
		//   This includes negated single high-valued characters. CALLOUT_STR is used for
		//   callouts with string arguments. In both cases the length in the table is
		//   zero; the actual length is stored in the compiled code.

		if int32(c) == OP_XCLASS {
			code += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))))
		} else if int32(c) == OP_CALLOUT_STR {
			code += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 5)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 6)))))
		} else if int32(c) == OP_REVERSE {
			if number < 0 {
				return code
			}
			code += TPCRE2_SPTR8(X_pcre2_OP_lengths_8[c])
		} else if int32(c) == OP_CBRA || int32(c) == OP_SCBRA || int32(c) == OP_CBRAPOS || int32(c) == OP_SCBRAPOS {
			var n int32 = int32(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 4)))))
			if n == number {
				return code
			}
			code += TPCRE2_SPTR8(X_pcre2_OP_lengths_8[c])
		} else {
			switch int32(c) {
			case OP_TYPESTAR:
				fallthrough
			case OP_TYPEMINSTAR:
				fallthrough
			case OP_TYPEPLUS:
				fallthrough
			case OP_TYPEMINPLUS:
				fallthrough
			case OP_TYPEQUERY:
				fallthrough
			case OP_TYPEMINQUERY:
				fallthrough
			case OP_TYPEPOSSTAR:
				fallthrough
			case OP_TYPEPOSPLUS:
				fallthrough
			case OP_TYPEPOSQUERY:
				if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1))) == OP_PROP || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1))) == OP_NOTPROP {
					code += uintptr(2)
				}
				break
				fallthrough

			case OP_TYPEUPTO:
				fallthrough
			case OP_TYPEMINUPTO:
				fallthrough
			case OP_TYPEEXACT:
				fallthrough
			case OP_TYPEPOSUPTO:
				if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3))) == OP_PROP || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 3))) == OP_NOTPROP {
					code += uintptr(2)
				}
				break
				fallthrough

			case OP_MARK:
				fallthrough
			case OP_COMMIT_ARG:
				fallthrough
			case OP_PRUNE_ARG:
				fallthrough
			case OP_SKIP_ARG:
				fallthrough
			case OP_THEN_ARG:
				code += TPCRE2_SPTR8(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))
				break
			}

			// Add in the fixed length from the table

			code += TPCRE2_SPTR8(X_pcre2_OP_lengths_8[c])

			// In UTF-8 and UTF-16 modes, opcodes that are followed by a character may be
			//   followed by a multi-byte character. The length in the table is a minimum, so
			//   we have to arrange to skip the extra bytes.

			if utf != 0 {
				switch int32(c) {
				case OP_CHAR:
					fallthrough
				case OP_CHARI:
					fallthrough
				case OP_NOT:
					fallthrough
				case OP_NOTI:
					fallthrough
				case OP_EXACT:
					fallthrough
				case OP_EXACTI:
					fallthrough
				case OP_NOTEXACT:
					fallthrough
				case OP_NOTEXACTI:
					fallthrough
				case OP_UPTO:
					fallthrough
				case OP_UPTOI:
					fallthrough
				case OP_NOTUPTO:
					fallthrough
				case OP_NOTUPTOI:
					fallthrough
				case OP_MINUPTO:
					fallthrough
				case OP_MINUPTOI:
					fallthrough
				case OP_NOTMINUPTO:
					fallthrough
				case OP_NOTMINUPTOI:
					fallthrough
				case OP_POSUPTO:
					fallthrough
				case OP_POSUPTOI:
					fallthrough
				case OP_NOTPOSUPTO:
					fallthrough
				case OP_NOTPOSUPTOI:
					fallthrough
				case OP_STAR:
					fallthrough
				case OP_STARI:
					fallthrough
				case OP_NOTSTAR:
					fallthrough
				case OP_NOTSTARI:
					fallthrough
				case OP_MINSTAR:
					fallthrough
				case OP_MINSTARI:
					fallthrough
				case OP_NOTMINSTAR:
					fallthrough
				case OP_NOTMINSTARI:
					fallthrough
				case OP_POSSTAR:
					fallthrough
				case OP_POSSTARI:
					fallthrough
				case OP_NOTPOSSTAR:
					fallthrough
				case OP_NOTPOSSTARI:
					fallthrough
				case OP_PLUS:
					fallthrough
				case OP_PLUSI:
					fallthrough
				case OP_NOTPLUS:
					fallthrough
				case OP_NOTPLUSI:
					fallthrough
				case OP_MINPLUS:
					fallthrough
				case OP_MINPLUSI:
					fallthrough
				case OP_NOTMINPLUS:
					fallthrough
				case OP_NOTMINPLUSI:
					fallthrough
				case OP_POSPLUS:
					fallthrough
				case OP_POSPLUSI:
					fallthrough
				case OP_NOTPOSPLUS:
					fallthrough
				case OP_NOTPOSPLUSI:
					fallthrough
				case OP_QUERY:
					fallthrough
				case OP_QUERYI:
					fallthrough
				case OP_NOTQUERY:
					fallthrough
				case OP_NOTQUERYI:
					fallthrough
				case OP_MINQUERY:
					fallthrough
				case OP_MINQUERYI:
					fallthrough
				case OP_NOTMINQUERY:
					fallthrough
				case OP_NOTMINQUERYI:
					fallthrough
				case OP_POSQUERY:
					fallthrough
				case OP_POSQUERYI:
					fallthrough
				case OP_NOTPOSQUERY:
					fallthrough
				case OP_NOTPOSQUERYI:
					if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + libc.UintptrFromInt32(-1)))) >= 0xc0 {
						code += TPCRE2_SPTR8(X_pcre2_utf8_table4[uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + libc.UintptrFromInt32(-1))))&0x3f])
					}
					break
				}
			}
		}
	}
	return TPCRE2_SPTR8(0)
}

// End of pcre2_find_bracket.c

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// ************************************************
//
//        JIT compile a Regular Expression        *
//

// This function used JIT to convert a previously-compiled pattern into machine
// code.
//
// Arguments:
//   code          a compiled pattern
//   options       JIT option bits
//
// Returns:        0: success or (*NOJIT) was used
//                <0: an error code

func Xpcre2_jit_compile_8(tls *libc.TLS, code uintptr, options Tuint32_t) int32 { /* pcre2_jit_compile.c:14382:1: */
	var re uintptr = code

	if code == uintptr(0) {
		return -51
	}

	if options&libc.CplUint32(DPCRE2_JIT_COMPLETE|DPCRE2_JIT_PARTIAL_SOFT|DPCRE2_JIT_PARTIAL_HARD|DPCRE2_JIT_INVALID_UTF) != Tuint32_t(0) {
		return -45
	}

	// Support for invalid UTF was first introduced in JIT, with the option
	// PCRE2_JIT_INVALID_UTF. Later, support was added to the interpreter, and the
	// compile-time option PCRE2_MATCH_INVALID_UTF was created. This is now the
	// preferred feature, with the earlier option deprecated. However, for backward
	// compatibility, if the earlier option is set, it forces the new option so that
	// if JIT matching falls back to the interpreter, there is still support for
	// invalid UTF. However, if this function has already been successfully called
	// without PCRE2_JIT_INVALID_UTF and without PCRE2_MATCH_INVALID_UTF (meaning that
	// non-invalid-supporting JIT code was compiled), give an error.
	//
	// If in the future support for PCRE2_JIT_INVALID_UTF is withdrawn, the following
	// actions are needed:
	//
	//   1. Remove the definition from pcre2.h.in and from the list in
	//      PUBLIC_JIT_COMPILE_OPTIONS above.
	//
	//   2. Replace PCRE2_JIT_INVALID_UTF with a local flag in this module.
	//
	//   3. Replace PCRE2_JIT_INVALID_UTF in pcre2_jit_test.c.
	//
	//   4. Delete the following short block of code. The setting of "re" and
	//      "functions" can be moved into the JIT-only block below, but if that is
	//      done, (void)re and (void)functions will be needed in the non-JIT case, to
	//      avoid compiler warnings.

	if options&DPCRE2_JIT_INVALID_UTF != Tuint32_t(0) {
		if (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_MATCH_INVALID_UTF == Tuint32_t(0) {
			*(*Tuint32_t)(unsafe.Pointer(re + 88)) |= DPCRE2_MATCH_INVALID_UTF
		}
	}

	// The above tests are run with and without JIT support. This means that
	// PCRE2_JIT_INVALID_UTF propagates back into the regex options (ensuring
	// interpreter support) even in the absence of JIT. But now, if there is no JIT
	// support, give an error return.

	return -45
}

// JIT compiler uses an all-in-one approach. This improves security,
//    since the code generator functions are not exported.

// ************************************************
//
//      Perl-Compatible Regular Expressions       *
//

// PCRE is a library of functions to support regular expressions whose syntax
// and semantics are as close as possible to those of the Perl 5 language.
//
//                        Written by Philip Hazel
//      Original API code Copyright (c) 1997-2012 University of Cambridge
//           New API code Copyright (c) 2016-2018 University of Cambridge
//
// -----------------------------------------------------------------------------
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//
//     * Neither the name of the University of Cambridge nor the names of its
//       contributors may be used to endorse or promote products derived from
//       this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
// -----------------------------------------------------------------------------

// ************************************************
//
//              Do a JIT pattern match            *
//

// This function runs a JIT pattern match.
//
// Arguments:
//   code            points to the compiled expression
//   subject         points to the subject string
//   length          length of subject string (may contain binary zeros)
//   start_offset    where to start in the subject string
//   options         option bits
//   match_data      points to a match_data block
//   mcontext        points to a match context
//
// Returns:          > 0 => success; value is the number of ovector pairs filled
//                   = 0 => success, but ovector is not big enough
//                    -1 => failed to match (PCRE_ERROR_NOMATCH)
//                  < -1 => some kind of unexpected problem

func Xpcre2_jit_match_8(tls *libc.TLS, code uintptr, subject TPCRE2_SPTR8, length Tsize_t, start_offset Tsize_t, options Tuint32_t, match_data uintptr, mcontext uintptr) int32 { /* pcre2_jit_match.c:85:1: */

	_ = code
	_ = subject
	_ = length
	_ = start_offset
	_ = options
	_ = match_data
	_ = mcontext
	return -45

}

// End of pcre2_jit_match.c
// ************************************************
//
//      Perl-Compatible Regular Expressions       *
//

// PCRE is a library of functions to support regular expressions whose syntax
// and semantics are as close as possible to those of the Perl 5 language.
//
//                        Written by Philip Hazel
//      Original API code Copyright (c) 1997-2012 University of Cambridge
//          New API code Copyright (c) 2016 University of Cambridge
//
// -----------------------------------------------------------------------------
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//
//     * Neither the name of the University of Cambridge nor the names of its
//       contributors may be used to endorse or promote products derived from
//       this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
// -----------------------------------------------------------------------------

// ************************************************
//
//           Free JIT read-only data              *
//

func X_pcre2_jit_free_rodata_8(tls *libc.TLS, current uintptr, allocator_data uintptr) { /* pcre2_jit_misc.c:53:1: */
	_ = current
	_ = allocator_data
}

// ************************************************
//
//           Free JIT compiled code               *
//

func X_pcre2_jit_free_8(tls *libc.TLS, executable_jit uintptr, memctl uintptr) { /* pcre2_jit_misc.c:78:1: */
	_ = executable_jit
	_ = memctl
}

// ************************************************
//
//            Free unused JIT memory              *
//

func Xpcre2_jit_free_unused_memory_8(tls *libc.TLS, gcontext uintptr) { /* pcre2_jit_misc.c:107:1: */
	_ = gcontext // Suppress warning
}

// ************************************************
//
//            Allocate a JIT stack                *
//

func Xpcre2_jit_stack_create_8(tls *libc.TLS, startsize Tsize_t, maxsize Tsize_t, gcontext uintptr) uintptr { /* pcre2_jit_misc.c:123:32: */

	_ = gcontext
	_ = startsize
	_ = maxsize
	return uintptr(0)

}

// ************************************************
//
//         Assign a JIT stack to a pattern        *
//

func Xpcre2_jit_stack_assign_8(tls *libc.TLS, mcontext uintptr, callback Tpcre2_jit_callback_8, callback_data uintptr) { /* pcre2_jit_misc.c:164:1: */
	_ = mcontext
	_ = callback
	_ = callback_data
}

// ************************************************
//
//               Free a JIT stack                 *
//

func Xpcre2_jit_stack_free_8(tls *libc.TLS, jit_stack uintptr) { /* pcre2_jit_misc.c:186:1: */
	_ = jit_stack
}

// ************************************************
//
//               Get target CPU type              *
//

func X_pcre2_jit_get_target_8(tls *libc.TLS) uintptr { /* pcre2_jit_misc.c:204:11: */
	return ts + 7657 /* "JIT is not suppo..." */
}

// ************************************************
//
//              Get size of JIT code              *
//

func X_pcre2_jit_get_size_8(tls *libc.TLS, executable_jit uintptr) Tsize_t { /* pcre2_jit_misc.c:220:1: */
	_ = executable_jit
	return uint64(0)
}

// End of pcre2_jit_misc.c

// End of pcre2_jit_compile.c

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// ************************************************
//
//           Create PCRE2 character tables        *
//

// This function builds a set of character tables for use by PCRE2 and returns
// a pointer to them. They are build using the ctype functions, and consequently
// their contents will depend upon the current locale setting. When compiled as
// part of the library, the store is obtained via a general context malloc, if
// supplied, but when PCRE2_DFTABLES is defined (when compiling the pcre2_dftables
// freestanding auxiliary program) malloc() is used, and the function has a
// different name so as not to clash with the prototype in pcre2.h.
//
// Arguments:   none when PCRE2_DFTABLES is defined
//                else a PCRE2 general context or NULL
// Returns:     pointer to the contiguous block of data
//                else NULL if memory allocation failed

func Xpcre2_maketables_8(tls *libc.TLS, gcontext uintptr) uintptr { /* pcre2_maketables.c:81:30: */
	var yield uintptr = func() uintptr {
		if gcontext != uintptr(0) {
			return (*struct {
				f func(*libc.TLS, Tsize_t, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_general_context_8)(unsafe.Pointer(gcontext)).Fmemctl.Fmalloc})).f(tls, uint64(Dcbits_offset+Dcbit_length+256), (*Tpcre2_general_context_8)(unsafe.Pointer(gcontext)).Fmemctl.Fmemory_data)
		}
		return libc.Xmalloc(tls, uint64(Dcbits_offset+Dcbit_length+256))
	}()
	var i int32
	var p uintptr

	if yield == uintptr(0) {
		return uintptr(0)
	}
	p = yield

	// First comes the lower casing table

	for i = 0; i < 256; i++ {
		*(*Tuint8_t)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))) = Tuint8_t(libc.Xtolower(tls, i))
	}

	// Next the case-flipping table

	for i = 0; i < 256; i++ {
		*(*Tuint8_t)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))) = func() uint8 {
			if int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(i)*2)))&int32(_ISlower) != 0 {
				return uint8(libc.Xtoupper(tls, i))
			}
			return uint8(libc.Xtolower(tls, i))
		}()
	}

	// Then the character class tables. Don't try to be clever and save effort on
	// exclusive ones - in some locales things may be different.
	//
	// Note that the table for "space" includes everything "isspace" gives, including
	// VT in the default locale. This makes it work for the POSIX class [:space:].
	// From PCRE1 release 8.34 and for all PCRE2 releases it is also correct for Perl
	// space, because Perl added VT at release 5.18.
	//
	// Note also that it is possible for a character to be alnum or alpha without
	// being lower or upper, such as "male and female ordinals" (\xAA and \xBA) in the
	// fr_FR locale (at least under Debian Linux's locales as of 12/2005). So we must
	// test for alnum specially.

	libc.Xmemset(tls, p, 0, uint64(Dcbit_length))
	for i = 0; i < 256; i++ {
		if int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(i)*2)))&int32(_ISdigit) != 0 {
			*(*Tuint8_t)(unsafe.Pointer(p + uintptr(Dcbit_digit+i/8))) |= Tuint8_t(uint32(1) << (i & 7))
		}
		if int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(i)*2)))&int32(_ISupper) != 0 {
			*(*Tuint8_t)(unsafe.Pointer(p + uintptr(Dcbit_upper+i/8))) |= Tuint8_t(uint32(1) << (i & 7))
		}
		if int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(i)*2)))&int32(_ISlower) != 0 {
			*(*Tuint8_t)(unsafe.Pointer(p + uintptr(Dcbit_lower+i/8))) |= Tuint8_t(uint32(1) << (i & 7))
		}
		if int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(i)*2)))&int32(_ISalnum) != 0 {
			*(*Tuint8_t)(unsafe.Pointer(p + uintptr(Dcbit_word+i/8))) |= Tuint8_t(uint32(1) << (i & 7))
		}
		if i == '_' {
			*(*Tuint8_t)(unsafe.Pointer(p + uintptr(Dcbit_word+i/8))) |= Tuint8_t(uint32(1) << (i & 7))
		}
		if int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(i)*2)))&int32(_ISspace) != 0 {
			*(*Tuint8_t)(unsafe.Pointer(p + uintptr(Dcbit_space+i/8))) |= Tuint8_t(uint32(1) << (i & 7))
		}
		if int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(i)*2)))&int32(_ISxdigit) != 0 {
			*(*Tuint8_t)(unsafe.Pointer(p + uintptr(Dcbit_xdigit+i/8))) |= Tuint8_t(uint32(1) << (i & 7))
		}
		if int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(i)*2)))&int32(_ISgraph) != 0 {
			*(*Tuint8_t)(unsafe.Pointer(p + uintptr(Dcbit_graph+i/8))) |= Tuint8_t(uint32(1) << (i & 7))
		}
		if int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(i)*2)))&int32(_ISprint) != 0 {
			*(*Tuint8_t)(unsafe.Pointer(p + uintptr(Dcbit_print+i/8))) |= Tuint8_t(uint32(1) << (i & 7))
		}
		if int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(i)*2)))&int32(_ISpunct) != 0 {
			*(*Tuint8_t)(unsafe.Pointer(p + uintptr(Dcbit_punct+i/8))) |= Tuint8_t(uint32(1) << (i & 7))
		}
		if int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(i)*2)))&int32(_IScntrl) != 0 {
			*(*Tuint8_t)(unsafe.Pointer(p + uintptr(Dcbit_cntrl+i/8))) |= Tuint8_t(uint32(1) << (i & 7))
		}
	}
	p += uintptr(Dcbit_length)

	// Finally, the character type table. In this, we used to exclude VT from the
	// white space chars, because Perl didn't recognize it as such for \s and for
	// comments within regexes. However, Perl changed at release 5.18, so PCRE1
	// changed at release 8.34 and it's always been this way for PCRE2.

	for i = 0; i < 256; i++ {
		var x int32 = 0
		if int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(i)*2)))&int32(_ISspace) != 0 {
			x = x + Dctype_space
		}
		if int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(i)*2)))&int32(_ISalpha) != 0 {
			x = x + Dctype_letter
		}
		if int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(i)*2)))&int32(_ISlower) != 0 {
			x = x + Dctype_lcletter
		}
		if int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(i)*2)))&int32(_ISdigit) != 0 {
			x = x + Dctype_digit
		}
		if int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(i)*2)))&int32(_ISalnum) != 0 || i == '_' {
			x = x + Dctype_word
		}
		*(*Tuint8_t)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))) = Tuint8_t(x)
	}

	return yield
}

func Xpcre2_maketables_free_8(tls *libc.TLS, gcontext uintptr, tables uintptr) { /* pcre2_maketables.c:154:1: */
	if gcontext != 0 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_general_context_8)(unsafe.Pointer(gcontext)).Fmemctl.Ffree})).f(tls, tables, (*Tpcre2_general_context_8)(unsafe.Pointer(gcontext)).Fmemctl.Fmemory_data)
	} else {
		libc.Xfree(tls, tables)
	}
}

// End of pcre2_maketables.c

// Min and max values for the common repeats; a maximum of UINT32_MAX =>
// infinity.

var rep_min = [11]Tuint32_t{
	Tuint32_t(0), Tuint32_t(0), // * and *?
	Tuint32_t(1), Tuint32_t(1), // + and +?
	Tuint32_t(0), Tuint32_t(0), // ? and ??
	Tuint32_t(0), Tuint32_t(0), // dummy placefillers for OP_CR[MIN]RANGE
	Tuint32_t(0), Tuint32_t(1), Tuint32_t(0)} /* pcre2_match.c:123:23 */ // OP_CRPOS{STAR, PLUS, QUERY}

var rep_max = [11]Tuint32_t{
	4294967295, 4294967295,
	4294967295, 4294967295,
	Tuint32_t(1), Tuint32_t(1), // ? and ??
	Tuint32_t(0), Tuint32_t(0), // dummy placefillers for OP_CR[MIN]RANGE
	4294967295, 4294967295, Tuint32_t(1)} /* pcre2_match.c:130:23 */ // OP_CRPOS{STAR, PLUS, QUERY}

// Repetition types - must include OP_CRPOSRANGE (not needed above)

var rep_typ = [12]Tuint32_t{
	REPTYPE_MAX, REPTYPE_MIN, // * and *?
	REPTYPE_MAX, REPTYPE_MIN, // + and +?
	REPTYPE_MAX, REPTYPE_MIN, // ? and ??
	REPTYPE_MAX, REPTYPE_MIN, // OP_CRRANGE and OP_CRMINRANGE
	REPTYPE_POS, REPTYPE_POS, // OP_CRPOSSTAR, OP_CRPOSPLUS
	REPTYPE_POS, REPTYPE_POS} /* pcre2_match.c:139:23 */

// Define short names for general fields in the current backtrack frame, which
// is always pointed to by the F variable. Occasional references to fields in
// other frames are written out explicitly. There are also some fields in the
// current frame whose names start with "temp" that are used for short-term,
// localised backtracking memory. These are #defined with Lxxx names at the point
// of use and undefined afterwards.

// ************************************************
//
//                Process a callout               *
//

// This function is called for all callouts, whether "standalone" or at the
// start of a conditional group. Feptr will be pointing to either OP_CALLOUT or
// OP_CALLOUT_STR. A callout block is allocated in pcre2_match() and initialized
// with fixed values.
//
// Arguments:
//   F          points to the current backtracking frame
//   mb         points to the match block
//   lengthptr  where to return the length of the callout item
//
// Returns:     the return from the callout
//              or 0 if no callout function exists

func do_callout1(tls *libc.TLS, F uintptr, mb uintptr, lengthptr uintptr) int32 { /* pcre2_match.c:267:1: */
	var rc int32
	var save0 Tsize_t
	var save1 Tsize_t
	var callout_ovector uintptr
	var cb uintptr

	*(*Tsize_t)(unsafe.Pointer(lengthptr)) = func() uint64 {
		if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) == OP_CALLOUT {
			return uint64(X_pcre2_OP_lengths_8[OP_CALLOUT])
		}
		return uint64(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 5)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 6)))))
	}()

	if (*Tmatch_block_8)(unsafe.Pointer(mb)).Fcallout == uintptr(0) {
		return 0
	} // No callout function provided

	// The original matching code (pre 10.30) worked directly with the ovector
	// passed by the user, and this was passed to callouts. Now that the working
	// ovector is in the backtracking frame, it no longer needs to reserve space for
	// the overall match offsets (which would waste space in the frame). For backward
	// compatibility, however, we pass capture_top and offset_vector to the callout as
	// if for the extended ovector, and we ensure that the first two slots are unset
	// by preserving and restoring their current contents. Picky compilers complain if
	// references such as Fovector[-2] are use directly, so we set up a separate
	// pointer.

	callout_ovector = F + 128 - uintptr(2)*8

	// The cb->version, cb->subject, cb->subject_length, and cb->start_match fields
	// are set externally. The first 3 never change; the last is updated for each
	// bumpalong.

	cb = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fcb
	(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fcapture_top = Tuint32_t((*Theapframe)(unsafe.Pointer(F)).Foffset_top)/Tuint32_t(2) + Tuint32_t(1)
	(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fcapture_last = (*Theapframe)(unsafe.Pointer(F)).Fcapture_last
	(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Foffset_vector = callout_ovector
	(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fmark = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnomatch_mark
	(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fcurrent_position = Tsize_t((int64((*Theapframe)(unsafe.Pointer(F)).Feptr) - int64((*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject)) / 1)
	(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fpattern_position = Tsize_t(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))))
	(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fnext_item_length = Tsize_t(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 4)))))

	if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) == OP_CALLOUT {
		(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fcallout_number = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 5)))
		(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fcallout_string_offset = uint64(0)
		(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fcallout_string = uintptr(0)
		(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fcallout_string_length = uint64(0)
	} else {
		(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fcallout_number = Tuint32_t(0)
		(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fcallout_string_offset = Tsize_t(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 7)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 8)))))
		(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fcallout_string = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(1+4*DLINK_SIZE) + uintptr(1)
		(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fcallout_string_length = *(*Tsize_t)(unsafe.Pointer(lengthptr)) - uint64(1+4*DLINK_SIZE) - uint64(2)
	}

	save0 = *(*Tsize_t)(unsafe.Pointer(callout_ovector))
	save1 = *(*Tsize_t)(unsafe.Pointer(callout_ovector + 1*8))
	*(*Tsize_t)(unsafe.Pointer(callout_ovector)) = libc.AssignPtrUint64(callout_ovector+1*8, libc.CplUint64(uint64(0)))
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*Tmatch_block_8)(unsafe.Pointer(mb)).Fcallout})).f(tls, cb, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fcallout_data)
	*(*Tsize_t)(unsafe.Pointer(callout_ovector)) = save0
	*(*Tsize_t)(unsafe.Pointer(callout_ovector + 1*8)) = save1
	(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fcallout_flags = Tuint32_t(0)
	return rc
}

// ************************************************
//
//          Match a back-reference                *
//

// This function is called only when it is known that the offset lies within
// the offsets that have so far been used in the match. Note that in caseless
// UTF-8 mode, the number of subject bytes matched may be different to the number
// of reference bytes. (In theory this could also happen in UTF-16 mode, but it
// seems unlikely.)
//
// Arguments:
//   offset      index into the offset vector
//   caseless    TRUE if caseless
//   F           the current backtracking frame pointer
//   mb          points to match block
//   lengthptr   pointer for returning the length matched
//
// Returns:      = 0 sucessful match; number of code units matched is set
//               < 0 no match
//               > 0 partial match

func match_ref(tls *libc.TLS, offset Tsize_t, caseless TBOOL, F uintptr, mb uintptr, lengthptr uintptr) int32 { /* pcre2_match.c:355:1: */
	var p TPCRE2_SPTR8
	var length Tsize_t
	var eptr TPCRE2_SPTR8
	var eptr_start TPCRE2_SPTR8

	// Deal with an unset group. The default is no match, but there is an option to
	// match an empty string.

	if offset >= (*Theapframe)(unsafe.Pointer(F)).Foffset_top || *(*Tsize_t)(unsafe.Pointer(F + 128 + uintptr(offset)*8)) == libc.CplUint64(uint64(0)) {
		if (*Tmatch_block_8)(unsafe.Pointer(mb)).Fpoptions&DPCRE2_MATCH_UNSET_BACKREF != Tuint32_t(0) {
			*(*Tsize_t)(unsafe.Pointer(lengthptr)) = uint64(0)
			return 0 // Match
		} else {
			return -1
		} // No match
	}

	// Separate the caseless and UTF cases for speed.

	eptr = libc.AssignUintptr(&eptr_start, (*Theapframe)(unsafe.Pointer(F)).Feptr)
	p = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject + uintptr(*(*Tsize_t)(unsafe.Pointer(F + 128 + uintptr(offset)*8)))
	length = *(*Tsize_t)(unsafe.Pointer(F + 128 + uintptr(offset+uint64(1))*8)) - *(*Tsize_t)(unsafe.Pointer(F + 128 + uintptr(offset)*8))

	if caseless != 0 {
		var utf TBOOL = libc.Bool32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpoptions&DPCRE2_UTF != Tuint32_t(0))

		if utf != 0 || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fpoptions&DPCRE2_UCP != Tuint32_t(0) {
			var endptr TPCRE2_SPTR8 = p + uintptr(length)

			// Match characters up to the end of the reference. NOTE: the number of
			//     code units matched may differ, because in UTF-8 there are some characters
			//     whose upper and lower case codes have different numbers of bytes. For
			//     example, U+023A (2 bytes in UTF-8) is the upper case version of U+2C65 (3
			//     bytes in UTF-8); a sequence of 3 of the former uses 6 bytes, as does a
			//     sequence of two of the latter. It is important, therefore, to check the
			//     length along the reference, not along the subject (earlier code did this
			//     wrong). UCP without uses Unicode properties but without UTF encoding.

			for p < endptr {
				var c Tuint32_t
				var d Tuint32_t
				var ur uintptr
				if eptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject {
					return 1
				} // Partial match

				if utf != 0 {
					c = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&eptr, 1))))
					if c >= 0xc0 {
						if c&0x20 == Tuint32_t(0) {
							c = c&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&eptr, 1))))&0x3f
						} else if c&0x10 == Tuint32_t(0) {
							c = c&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(eptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(eptr + 1)))&0x3f
							eptr += uintptr(2)
						} else if c&0x08 == Tuint32_t(0) {
							c = c&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(eptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(eptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(eptr + 2)))&0x3f
							eptr += uintptr(3)
						} else if c&0x04 == Tuint32_t(0) {
							c = c&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(eptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(eptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(eptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(eptr + 3)))&0x3f
							eptr += uintptr(4)
						} else {
							c = c&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(eptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(eptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(eptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(eptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(eptr + 4)))&0x3f
							eptr += uintptr(5)
						}
					}

					d = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))))
					if d >= 0xc0 {
						if d&0x20 == Tuint32_t(0) {
							d = d&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))))&0x3f
						} else if d&0x10 == Tuint32_t(0) {
							d = d&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(p)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(p + 1)))&0x3f
							p += uintptr(2)
						} else if d&0x08 == Tuint32_t(0) {
							d = d&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(p)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(p + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(p + 2)))&0x3f
							p += uintptr(3)
						} else if d&0x04 == Tuint32_t(0) {
							d = d&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(p)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(p + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(p + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(p + 3)))&0x3f
							p += uintptr(4)
						} else {
							d = d&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(p)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(p + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(p + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(p + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(p + 4)))&0x3f
							p += uintptr(5)
						}
					}

				} else {
					c = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&eptr, 1))))
					d = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))))
				}

				ur = uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(d)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(d)%DUCD_BLOCK_SIZE])*12
				if c != d && c != Tuint32_t(int32(d)+(*Tucd_record)(unsafe.Pointer(ur)).Fother_case) {
					var pp uintptr = uintptr(unsafe.Pointer(&X_pcre2_ucd_caseless_sets_8)) + uintptr((*Tucd_record)(unsafe.Pointer(ur)).Fcaseset)*4
					for {
						if c < *(*Tuint32_t)(unsafe.Pointer(pp)) {
							return -1
						} // No match
						if c == *(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&pp, 4))) {
							break
						}
					}
				}
			}
		} else {
			for ; length > uint64(0); length-- {
				var cc Tuint32_t
				var cp Tuint32_t
				if eptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject {
					return 1
				} // Partial match
				cc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(eptr)))
				cp = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(p)))
				if int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Flcc + uintptr(cp)))) != int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Flcc + uintptr(cc)))) {
					return -1
				} // No match
				p++
				eptr++
			}
		}
	} else {
		if int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 {
			for ; length > uint64(0); length-- {
				if eptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject {
					return 1
				} // Partial match
				if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1)))) != int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&eptr, 1)))) {
					return -1
				} // No match
			}
		} else {
			if Tsize_t((int64((*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject)-int64(eptr))/1) < length {
				return 1
			} // Partial
			if libc.Xmemcmp(tls, p, eptr, length*uint64(DPCRE2_CODE_UNIT_WIDTH/8)) != 0 {
				return -1
			} // No match
			eptr += TPCRE2_SPTR8(length)
		}
	}

	*(*Tsize_t)(unsafe.Pointer(lengthptr)) = Tsize_t((int64(eptr) - int64(eptr_start)) / 1)
	return 0 // Match
}

//*****************************************************************************
//
//                    "Recursion" in the match() function
//
// The original match() function was highly recursive, but this proved to be the
// source of a number of problems over the years, mostly because of the relatively
// small system stacks that are commonly found. As new features were added to
// patterns, various kludges were invented to reduce the amount of stack used,
// making the code hard to understand in places.
//
// A version did exist that used individual frames on the heap instead of calling
// match() recursively, but this ran substantially slower. The current version is
// a refactoring that uses a vector of frames to remember backtracking points.
// This runs no slower, and possibly even a bit faster than the original recursive
// implementation. An initial vector of size START_FRAMES_SIZE (enough for maybe
// 50 frames) is allocated on the system stack. If this is not big enough, the
// heap is used for a larger vector.
//
// *******************************************************************************
// *****************************************************************************

// ************************************************
//
//       Macros for the match() function          *
//

// These macros pack up tests that are used for partial matching several times
// in the code. The second one is used when we already know we are past the end of
// the subject. We set the "hit end" flag if the pointer is at the end of the
// subject and either (a) the pointer is past the earliest inspected character
// (i.e. something has been matched, even if not part of the actual matched
// string), or (b) the pattern contains a lookbehind. These are the conditions for
// which adding more characters may allow the current match to continue.
//
// For hard partial matching, we immediately return a partial match. Otherwise,
// carrying on means that a complete match on the current subject will be sought.
// A partial match is returned only if no complete match can be found.

// These macros are used to implement backtracking. They simulate a recursive
// call to the match() function by means of a local vector of frames which
// remember the backtracking points.

// ************************************************
//
//         Match from current position            *
//

// This function is called to run one match attempt at a single starting point
// in the subject.
//
// Performance note: It might be tempting to extract commonly used fields from the
// mb structure (e.g. end_subject) into individual variables to improve
// performance. Tests using gcc on a SPARC disproved this; in the first case, it
// made performance worse.
//
// Arguments:
//    start_eptr   starting character in subject
//    start_ecode  starting position in compiled code
//    ovector      pointer to the final output vector
//    oveccount    number of pairs in ovector
//    top_bracket  number of capturing parentheses in the pattern
//    frame_size   size of each backtracking frame
//    mb           pointer to "static" variables block
//
// Returns:        MATCH_MATCH if matched            )  these values are >= 0
//                 MATCH_NOMATCH if failed to match  )
//                 negative MATCH_xxx value for PRUNE, SKIP, etc
//                 negative PCRE2_ERROR_xxx value if aborted by an error condition
//                 (e.g. stopped by repeated call or depth limit)

func match(tls *libc.TLS, start_eptr TPCRE2_SPTR8, start_ecode TPCRE2_SPTR8, ovector uintptr, oveccount Tuint16_t, top_bracket Tuint16_t, frame_size Tsize_t, mb uintptr) int32 { /* pcre2_match.c:583:1: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// Frame-handling variables

	var F uintptr // Current frame pointer
	var N uintptr // Temporary frame pointers
	var P uintptr
	var assert_accept_frame uintptr // For passing back a frame with captures
	var frame_copy_size Tsize_t     // Amount to copy when creating a new frame

	// Local variables that do not need to be preserved over calls to RRMATCH().

	var bracode TPCRE2_SPTR8 // Temp pointer to start of group
	var offset Tsize_t       // Used for group offsets
	// var length Tsize_t at bp, 8
	// Used for various length calculations

	var rrc int32      // Return from functions & backtracking "recursions"
	var proptype int32 // Type of character property

	var i Tuint32_t                // Used for local loops
	var fc Tuint32_t               // Character values
	var number Tuint32_t           // Used for group and other numbers
	var reptype Tuint32_t          // Type of repetition (0 to avoid compiler warning)
	var group_frame_type Tuint32_t // Specifies type for new group frames

	var condition TBOOL    // Used in conditional groups
	var cur_is_word TBOOL  // Used in "word" tests
	var prev_is_word TBOOL // Used in "word" tests

	// UTF and UCP flags

	var utf TBOOL
	var ucp TBOOL
	var maxsize Tsize_t
	var newsize Tsize_t
	var new uintptr
	var cc Tuint32_t
	var dc Tuint32_t
	var cc1 Tuint32_t
	var ch Tuint32_t
	var ch1 Tuint32_t
	var ch2 Tuint32_t
	var othercase Tuint32_t
	var cc2 Tuint32_t
	var cc3 Tuint32_t
	var cc4 Tuint32_t
	var d Tuint32_t
	var d1 Tuint32_t
	var len int32
	var d2 Tuint32_t
	var d3 Tuint32_t
	var d4 Tuint32_t
	var len1 int32
	var d5 Tuint32_t
	var len2 int32
	var len3 int32
	var ok TBOOL
	var ok1 TBOOL
	var cp uintptr
	var prop uintptr
	var notmatch TBOOL
	var chartype int32
	var ok2 TBOOL
	var prop1 uintptr
	var category int32
	var category1 int32
	var cp1 uintptr
	var ok3 TBOOL
	var prop2 uintptr
	var notmatch1 TBOOL
	var cc5 Tuint32_t
	var cc6 Tuint32_t
	var cc7 Tuint32_t
	var cc8 Tuint32_t
	var cc9 Tuint32_t
	var chartype1 int32
	var ok4 TBOOL
	var prop3 uintptr
	var category2 int32
	var category3 int32
	var cp2 uintptr
	var ok5 TBOOL
	var prop4 uintptr
	var len4 int32
	var chartype2 int32
	var len5 int32
	var len6 int32
	var len7 int32
	var len8 int32
	var ok6 TBOOL
	var prop5 uintptr
	var len9 int32
	var category4 int32
	var len10 int32
	var len11 int32
	var category5 int32
	var len12 int32
	var cp3 uintptr
	var len13 int32
	var len14 int32
	var len15 int32
	var ok7 TBOOL
	var prop6 uintptr
	var len16 int32
	var notmatch2 TBOOL
	var lgb int32
	var rgb int32
	var fptr TPCRE2_SPTR8
	var len17 int32
	var gotspace TBOOL
	var len18 int32
	var gotspace1 TBOOL
	var len19 int32
	var len20 int32
	var len21 int32
	var len22 int32
	var len23 int32
	var len24 int32
	var len25 int32
	var count int32
	var slot TPCRE2_SPTR8
	// var slength Tsize_t at bp+8, 8

	// var slength1 Tsize_t at bp+16, 8

	// var slength2 Tsize_t at bp+24, 8

	// var slength3 Tsize_t at bp+32, 8

	var samelengths TBOOL
	var next_ecode TPCRE2_SPTR8
	var next_ecode1 TPCRE2_SPTR8
	var next_ecode2 TPCRE2_SPTR8
	var count1 int32
	var slot1 TPCRE2_SPTR8
	var count2 int32
	var slot2 TPCRE2_SPTR8
	var y Tuint32_t
	var cat int32
	var lastptr TPCRE2_SPTR8
	var cat1 int32
	var nextptr TPCRE2_SPTR8
	N = uintptr(0)
	P = uintptr(0)
	assert_accept_frame = uintptr(0)
	reptype = Tuint32_t(0)
	utf = libc.Bool32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpoptions&DPCRE2_UTF != Tuint32_t(0))
	ucp = libc.Bool32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpoptions&DPCRE2_UCP != Tuint32_t(0))

	// This is the length of the last part of a backtracking frame that must be
	// copied when a new frame is created.

	frame_copy_size = frame_size - Tsize_t(uintptr(0)+80)

	// Set up the first current frame at the start of the vector, and initialize
	// fields that are not reset for new frames.

	F = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fmatch_frames
	(*Theapframe)(unsafe.Pointer(F)).Frdepth = Tuint32_t(0)                                 // "Recursion" depth
	(*Theapframe)(unsafe.Pointer(F)).Fcapture_last = Tuint32_t(0)                           // Number of most recent capture
	(*Theapframe)(unsafe.Pointer(F)).Fcurrent_recurse = DRECURSE_UNSET                      // Not pattern recursing.
	(*Theapframe)(unsafe.Pointer(F)).Fstart_match = libc.AssignPtrUintptr(F+80, start_eptr) // Current data pointer and start match
	(*Theapframe)(unsafe.Pointer(F)).Fmark = uintptr(0)                                     // Most recent mark
	(*Theapframe)(unsafe.Pointer(F)).Foffset_top = uint64(0)                                // End of captures within the frame
	(*Theapframe)(unsafe.Pointer(F)).Flast_group_offset = libc.CplUint64(uint64(0))         // Saved frame of most recent group
	group_frame_type = Tuint32_t(0)                                                         // Not a start of group frame
	goto NEW_FRAME                                                                          // Start processing with this frame

	// Come back here when we want to create a new frame for remembering a
	// backtracking point.

MATCH_RECURSE:

	// Set up a new backtracking frame. If the vector is full, get a new one
	// on the heap, doubling the size, but constrained by the heap limit.

	N = F + uintptr(frame_size)
	if !(N >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fmatch_frames_top) {
		goto __1
	}

	newsize = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fframe_vector_size * uint64(2)

	if !(newsize/uint64(1024) > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fheap_limit) {
		goto __2
	}

	maxsize = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fheap_limit * uint64(1024) / frame_size * frame_size
	if !((*Tmatch_block_8)(unsafe.Pointer(mb)).Fframe_vector_size >= maxsize) {
		goto __3
	}
	return -63
__3:
	;
	newsize = maxsize
__2:
	;

	new = (*struct {
		f func(*libc.TLS, Tsize_t, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*Tmatch_block_8)(unsafe.Pointer(mb)).Fmemctl.Fmalloc})).f(tls, newsize, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fmemctl.Fmemory_data)
	if !(new == uintptr(0)) {
		goto __4
	}
	return -48
__4:
	;
	libc.Xmemcpy(tls, new, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fmatch_frames, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fframe_vector_size)

	F = new + uintptr((int64(F)-int64((*Tmatch_block_8)(unsafe.Pointer(mb)).Fmatch_frames))/1)
	N = F + uintptr(frame_size)

	if !((*Tmatch_block_8)(unsafe.Pointer(mb)).Fmatch_frames != (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstack_frames) {
		goto __5
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*Tmatch_block_8)(unsafe.Pointer(mb)).Fmemctl.Ffree})).f(tls, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fmatch_frames, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fmemctl.Fmemory_data)
__5:
	;
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fmatch_frames = new
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fmatch_frames_top = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fmatch_frames + uintptr(newsize)
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fframe_vector_size = newsize
__1:
	;

	// Copy those fields that must be copied into the new frame, increase the
	// "recursion" depth (i.e. the new frame's index) and then make the new frame
	// current.

	libc.Xmemcpy(tls, N+uintptr(uint64(uintptr(0)+80)),
		F+uintptr(uint64(uintptr(0)+80)),
		frame_copy_size)

	(*Theapframe)(unsafe.Pointer(N)).Frdepth = (*Theapframe)(unsafe.Pointer(F)).Frdepth + Tuint32_t(1)
	F = N

	// Carry on processing with a new frame.

NEW_FRAME:
	(*Theapframe)(unsafe.Pointer(F)).Fgroup_frame_type = group_frame_type
	(*Theapframe)(unsafe.Pointer(F)).Fecode = start_ecode     // Starting code pointer
	(*Theapframe)(unsafe.Pointer(F)).Fback_frame = frame_size // Default is go back one frame

	// If this is a special type of group frame, remember its offset for quick
	// access at the end of the group. If this is a recursion, set a new current
	// recursion value.

	if !(group_frame_type != Tuint32_t(0)) {
		goto __6
	}

	(*Theapframe)(unsafe.Pointer(F)).Flast_group_offset = Tsize_t((int64(F) - int64((*Tmatch_block_8)(unsafe.Pointer(mb)).Fmatch_frames)) / 1)
	if !(group_frame_type&0xffff0000 == DGF_RECURSE) {
		goto __7
	}
	(*Theapframe)(unsafe.Pointer(F)).Fcurrent_recurse = group_frame_type & 0x0000ffff
__7:
	;
	group_frame_type = Tuint32_t(0)
__6:
	;

	// =========================================================================
	// This is the main processing loop. First check that we haven't recorded too
	// many backtracks (search tree is too large), or that we haven't exceeded the
	// recursive depth limit (used too many backtracking frames). If not, process the
	// opcodes.

	if !(libc.PostIncUint32(&(*Tmatch_block_8)(unsafe.Pointer(mb)).Fmatch_call_count, 1) >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fmatch_limit) {
		goto __8
	}
	return -47
__8:
	;
	if !((*Theapframe)(unsafe.Pointer(F)).Frdepth >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fmatch_limit_depth) {
		goto __9
	}
	return -53
__9:
	;

__10:

	(*Theapframe)(unsafe.Pointer(F)).Fop = *(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode)) // Cast needed for 16-bit and 32-bit modes
	switch int32((*Theapframe)(unsafe.Pointer(F)).Fop) {
	// =====================================================================
	// Before OP_ACCEPT there may be any number of OP_CLOSE opcodes, to close
	//     any currently open capturing brackets. Unlike reaching the end of a group,
	//     where we know the starting frame is at the top of the chained frames, in
	//     this case we have to search back for the relevant frame in case other types
	//     of group that use chained frames have intervened. Multiple OP_CLOSEs always
	//     come innermost first, which matches the chain order. We can ignore this in
	//     a recursion, because captures are not passed out of recursions.

	case OP_CLOSE:
		goto __14

	// =====================================================================
	// Real or forced end of the pattern, assertion, or recursion. In an
	//     assertion ACCEPT, update the last used pointer and remember the current
	//     frame so that the captures and mark can be fished out of it.

	case OP_ASSERT_ACCEPT:
		goto __15

	// If recursing, we have to find the most recent recursion.

	case OP_ACCEPT:
		goto __16
	case OP_END:
		goto __17 // Note: NOT RRETURN

	//=====================================================================
	// Match any single character type except newline; have to take care with
	//     CRLF newlines and partial matching.

	case OP_ANY:
		goto __18
	// Fall through

	// Match any single character whatsoever.

	case OP_ALLANY:
		goto __19

	// =====================================================================
	// Match a single code unit, even in UTF mode. This opcode really does
	//     match any code unit, even newline. (It really should be called ANYCODEUNIT,
	//     of course - the byte name is from pre-16 bit days.)

	case OP_ANYBYTE:
		goto __20

	// =====================================================================
	// Match a single character, casefully

	case OP_CHAR:
		goto __21

	// =====================================================================
	// Match a single character, caselessly. If we are at the end of the
	//     subject, give up immediately. We get here only when the pattern character
	//     has at most one other case. Characters with more than two cases are coded
	//     as OP_PROP with the pseudo-property PT_CLIST.

	case OP_CHARI:
		goto __22

	// =====================================================================
	// Match not a single character.

	case OP_NOT:
		goto __23
	case OP_NOTI:
		goto __24

	// =====================================================================
	// Match a single character repeatedly.

	case OP_EXACT:
		goto __25
	case OP_EXACTI:
		goto __26

	case OP_POSUPTO:
		goto __27
	case OP_POSUPTOI:
		goto __28

	case OP_UPTO:
		goto __29
	case OP_UPTOI:
		goto __30

	case OP_MINUPTO:
		goto __31
	case OP_MINUPTOI:
		goto __32

	case OP_POSSTAR:
		goto __33
	case OP_POSSTARI:
		goto __34

	case OP_POSPLUS:
		goto __35
	case OP_POSPLUSI:
		goto __36

	case OP_POSQUERY:
		goto __37
	case OP_POSQUERYI:
		goto __38

	case OP_STAR:
		goto __39
	case OP_STARI:
		goto __40
	case OP_MINSTAR:
		goto __41
	case OP_MINSTARI:
		goto __42
	case OP_PLUS:
		goto __43
	case OP_PLUSI:
		goto __44
	case OP_MINPLUS:
		goto __45
	case OP_MINPLUSI:
		goto __46
	case OP_QUERY:
		goto __47
	case OP_QUERYI:
		goto __48
	case OP_MINQUERY:
		goto __49
	case OP_MINQUERYI:
		goto __50

	// =====================================================================
	// Match a negated single one-byte character repeatedly. This is almost a
	//     repeat of the code for a repeated single character, but I haven't found a
	//     nice way of commoning these up that doesn't require a test of the
	//     positive/negative option for each character match. Maybe that wouldn't add
	//     very much to the time taken, but character matching *is* what this is all
	//     about...

	case OP_NOTEXACT:
		goto __51
	case OP_NOTEXACTI:
		goto __52

	case OP_NOTUPTO:
		goto __53
	case OP_NOTUPTOI:
		goto __54

	case OP_NOTMINUPTO:
		goto __55
	case OP_NOTMINUPTOI:
		goto __56

	case OP_NOTPOSSTAR:
		goto __57
	case OP_NOTPOSSTARI:
		goto __58

	case OP_NOTPOSPLUS:
		goto __59
	case OP_NOTPOSPLUSI:
		goto __60

	case OP_NOTPOSQUERY:
		goto __61
	case OP_NOTPOSQUERYI:
		goto __62

	case OP_NOTPOSUPTO:
		goto __63
	case OP_NOTPOSUPTOI:
		goto __64

	case OP_NOTSTAR:
		goto __65
	case OP_NOTSTARI:
		goto __66
	case OP_NOTMINSTAR:
		goto __67
	case OP_NOTMINSTARI:
		goto __68
	case OP_NOTPLUS:
		goto __69
	case OP_NOTPLUSI:
		goto __70
	case OP_NOTMINPLUS:
		goto __71
	case OP_NOTMINPLUSI:
		goto __72
	case OP_NOTQUERY:
		goto __73
	case OP_NOTQUERYI:
		goto __74
	case OP_NOTMINQUERY:
		goto __75
	case OP_NOTMINQUERYI:
		goto __76

	// =====================================================================
	// Match a bit-mapped character class, possibly repeatedly. These opcodes
	//     are used when all the characters in the class have values in the range
	//     0-255, and either the matching is caseful, or the characters are in the
	//     range 0-127 when UTF processing is enabled. The only difference between
	//     OP_CLASS and OP_NCLASS occurs when a data character outside the range is
	//     encountered.

	case OP_NCLASS:
		goto __77
	case OP_CLASS:
		goto __78
	// Control never gets here

	// =====================================================================
	// Match an extended character class. In the 8-bit library, this opcode is
	//     encountered only when UTF-8 mode mode is supported. In the 16-bit and
	//     32-bit libraries, codepoints greater than 255 may be encountered even when
	//     UTF is not supported.

	case OP_XCLASS:
		goto __79

	// =====================================================================
	// Match various character types when PCRE2_UCP is not set. These opcodes
	//     are not generated when PCRE2_UCP is set - instead appropriate property
	//     tests are compiled.

	case OP_NOT_DIGIT:
		goto __80

	case OP_DIGIT:
		goto __81

	case OP_NOT_WHITESPACE:
		goto __82

	case OP_WHITESPACE:
		goto __83

	case OP_NOT_WORDCHAR:
		goto __84

	case OP_WORDCHAR:
		goto __85

	case OP_ANYNL:
		goto __86

	case OP_NOT_HSPACE:
		goto __87

	case OP_HSPACE:
		goto __88

	case OP_NOT_VSPACE:
		goto __89

	case OP_VSPACE:
		goto __90

	// =====================================================================
	// Check the next character by Unicode property. We will get here only
	//     if the support is in the binary; otherwise a compile-time error occurs.

	case OP_PROP:
		goto __91
	case OP_NOTPROP:
		goto __92

	// =====================================================================
	// Match an extended Unicode sequence. We will get here only if the support
	//     is in the binary; otherwise a compile-time error occurs.

	case OP_EXTUNI:
		goto __93

	// =====================================================================
	// Match a single character type repeatedly. Note that the property type
	//     does not need to be in a stack frame as it is not used within an RMATCH()
	//     loop.

	case OP_TYPEEXACT:
		goto __94

	case OP_TYPEUPTO:
		goto __95
	case OP_TYPEMINUPTO:
		goto __96

	case OP_TYPEPOSSTAR:
		goto __97

	case OP_TYPEPOSPLUS:
		goto __98

	case OP_TYPEPOSQUERY:
		goto __99

	case OP_TYPEPOSUPTO:
		goto __100

	case OP_TYPESTAR:
		goto __101
	case OP_TYPEMINSTAR:
		goto __102
	case OP_TYPEPLUS:
		goto __103
	case OP_TYPEMINPLUS:
		goto __104
	case OP_TYPEQUERY:
		goto __105
	case OP_TYPEMINQUERY:
		goto __106 // End of repeat character type processing

	// =====================================================================
	// Match a back reference, possibly repeatedly. Look past the end of the
	//     item to see if there is repeat information following. The OP_REF and
	//     OP_REFI opcodes are used for a reference to a numbered group or to a
	//     non-duplicated named group. For a duplicated named group, OP_DNREF and
	//     OP_DNREFI are used. In this case we must scan the list of groups to which
	//     the name refers, and use the first one that is set.

	case OP_DNREF:
		goto __107
	case OP_DNREFI:
		goto __108

	case OP_REF:
		goto __109
	case OP_REFI:
		goto __110
	// Control never gets here

	// =========================================================================
	//           Opcodes for the start of various parenthesized items
	// =========================================================================

	// In all cases, if the result of RMATCH() is MATCH_THEN, check whether the
	//     (*THEN) is within the current branch by comparing the address of OP_THEN
	//     that is passed back with the end of the branch. If (*THEN) is within the
	//     current branch, and the branch is one of two or more alternatives (it
	//     either starts or ends with OP_ALT), we have reached the limit of THEN's
	//     action, so convert the return code to NOMATCH, which will cause normal
	//     backtracking to happen from now on. Otherwise, THEN is passed back to an
	//     outer alternative. This implements Perl's treatment of parenthesized
	//     groups, where a group not containing | does not affect the current
	//     alternative, that is, (X) is NOT the same as (X|(*F)).

	// =====================================================================
	// BRAZERO, BRAMINZERO and SKIPZERO occur just before a non-possessive
	//     bracket group, indicating that it may occur zero times. It may repeat
	//     infinitely, or not at all - i.e. it could be ()* or ()? or even (){0} in
	//     the pattern. Brackets with fixed upper repeat limits are compiled as a
	//     number of copies, with the optional ones preceded by BRAZERO or BRAMINZERO.
	//     Possessive groups with possible zero repeats are preceded by BRAPOSZERO.

	case OP_BRAZERO:
		goto __111

	case OP_BRAMINZERO:
		goto __112

	case OP_SKIPZERO:
		goto __113

	// =====================================================================
	// Handle possessive brackets with an unlimited repeat. The end of these
	//     brackets will always be OP_KETRPOS, which returns MATCH_KETRPOS without
	//     going further in the pattern.

	case OP_BRAPOSZERO:
		goto __114

	case OP_BRAPOS:
		goto __115
	case OP_SBRAPOS:
		goto __116

	case OP_CBRAPOS:
		goto __117
	case OP_SCBRAPOS:
		goto __118

	// =====================================================================
	// Handle non-capturing brackets that cannot match an empty string. When we
	//     get to the final alternative within the brackets, as long as there are no
	//     THEN's in the pattern, we can optimize by not recording a new backtracking
	//     point. (Ideally we should test for a THEN within this group, but we don't
	//     have that information.) Don't do this if we are at the very top level,
	//     however, because that would make handling assertions and once-only brackets
	//     messier when there is nothing to go back to.

	case OP_BRA:
		goto __119

	// =====================================================================
	// Handle a capturing bracket, other than those that are possessive with an
	//     unlimited repeat.

	case OP_CBRA:
		goto __120
	case OP_SCBRA:
		goto __121

	// =====================================================================
	// Atomic groups and non-capturing brackets that can match an empty string
	//     must record a backtracking point and also set up a chained frame.

	case OP_ONCE:
		goto __122
	case OP_SCRIPT_RUN:
		goto __123
	case OP_SBRA:
		goto __124
	// Control never reaches here.

	// =====================================================================
	// Recursion either matches the current regex, or some subexpression. The
	//     offset data is the offset to the starting bracket from the start of the
	//     whole pattern. (This is so that it works from duplicated subpatterns.)

	case OP_RECURSE:
		goto __125
	// Control never reaches here.

	// =====================================================================
	// Positive assertions are like other groups except that PCRE doesn't allow
	//     the effect of (*THEN) to escape beyond an assertion; it is therefore
	//     treated as NOMATCH. (*ACCEPT) is treated as successful assertion, with its
	//     captures and mark retained. Any other return is an error.

	case OP_ASSERT:
		goto __126
	case OP_ASSERTBACK:
		goto __127
	case OP_ASSERT_NA:
		goto __128
	case OP_ASSERTBACK_NA:
		goto __129

	// =====================================================================
	// Handle negative assertions. Loop for each non-matching branch as for
	//     positive assertions.

	case OP_ASSERT_NOT:
		goto __130
	case OP_ASSERTBACK_NOT:
		goto __131

	// =====================================================================
	// The callout item calls an external function, if one is provided, passing
	//     details of the match so far. This is mainly for debugging, though the
	//     function is able to force a failure.

	case OP_CALLOUT:
		goto __132
	case OP_CALLOUT_STR:
		goto __133

	// =====================================================================
	// Conditional group: compilation checked that there are no more than two
	//     branches. If the condition is false, skipping the first branch takes us
	//     past the end of the item if there is only one branch, but that's exactly
	//     what we want.

	case OP_COND:
		goto __134
	case OP_SCOND:
		goto __135

		// =========================================================================
		//                  End of start of parenthesis opcodes
		// =========================================================================

	// =====================================================================
	// Move the subject pointer back. This occurs only at the start of each
	//     branch of a lookbehind assertion. If we are too close to the start to move
	//     back, fail. When working with UTF-8 we move back a number of characters,
	//     not bytes.

	case OP_REVERSE:
		goto __136

	// =====================================================================
	// An alternation is the end of a branch; scan along to find the end of the
	//     bracketed group.

	case OP_ALT:
		goto __137

	// =====================================================================
	// The end of a parenthesized group. For all but OP_BRA and OP_COND, the
	//     starting frame was added to the chained frames in order to remember the
	//     starting subject position for the group.

	case OP_KET:
		goto __138
	case OP_KETRMIN:
		goto __139
	case OP_KETRMAX:
		goto __140
	case OP_KETRPOS:
		goto __141

	// =====================================================================
	// Start and end of line assertions, not multiline mode.

	case OP_CIRC:
		goto __142

	case OP_SOD:
		goto __143

	// When PCRE2_NOTEOL is unset, assert before the subject end, or a
	//     terminating newline unless PCRE2_DOLLAR_ENDONLY is set.

	case OP_DOLL:
		goto __144

	// Fall through
	// Unconditional end of subject assertion (\z)

	case OP_EOD:
		goto __145

	// End of subject or ending \n assertion (\Z)

	case OP_EODN:
		goto __146

	// =====================================================================
	// Start and end of line assertions, multiline mode.

	// Start of subject unless notbol, or after any newline except for one at
	//     the very end, unless PCRE2_ALT_CIRCUMFLEX is set.

	case OP_CIRCM:
		goto __147

	// Assert before any newline, or before end of subject unless noteol is
	//     set.

	case OP_DOLLM:
		goto __148

	// =====================================================================
	// Start of match assertion

	case OP_SOM:
		goto __149

	// =====================================================================
	// Reset the start of match point

	case OP_SET_SOM:
		goto __150

	// =====================================================================
	// Word boundary assertions. Find out if the previous and current
	//     characters are "word" characters. It takes a bit more work in UTF mode.
	//     Characters > 255 are assumed to be "non-word" characters when PCRE2_UCP is
	//     not set. When it is set, use Unicode properties if available, even when not
	//     in UTF mode. Remember the earliest and latest consulted characters.

	case OP_NOT_WORD_BOUNDARY:
		goto __151
	case OP_WORD_BOUNDARY:
		goto __152

	// =====================================================================
	// Backtracking (*VERB)s, with and without arguments. Note that if the
	//     pattern is successfully matched, we do not come back from RMATCH.

	case OP_MARK:
		goto __153

	case OP_FAIL:
		goto __154

	// Record the current recursing group number in mb->verb_current_recurse
	//     when a backtracking return such as MATCH_COMMIT is given. This enables the
	//     recurse processing to catch verbs from within the recursion.

	case OP_COMMIT:
		goto __155

	case OP_COMMIT_ARG:
		goto __156

	case OP_PRUNE:
		goto __157

	case OP_PRUNE_ARG:
		goto __158

	case OP_SKIP:
		goto __159

	// Note that, for Perl compatibility, SKIP with an argument does NOT set
	//     nomatch_mark. When a pattern match ends with a SKIP_ARG for which there was
	//     not a matching mark, we have to re-run the match, ignoring the SKIP_ARG
	//     that failed and any that precede it (either they also failed, or were not
	//     triggered). To do this, we maintain a count of executed SKIP_ARGs. If a
	//     SKIP_ARG gets to top level, the match is re-run with mb->ignore_skip_arg
	//     set to the count of the one that failed.

	case OP_SKIP_ARG:
		goto __160

	// For THEN (and THEN_ARG) we pass back the address of the opcode, so that
	//     the branch in which it occurs can be determined.

	case OP_THEN:
		goto __161

	case OP_THEN_ARG:
		goto __162

	// =====================================================================
	// There's been some horrible disaster. Arrival here can only mean there is
	//     something seriously wrong in the code above or the OP_xxx definitions.

	default:
		goto __163
	}
	goto __13

	// =====================================================================
	// Before OP_ACCEPT there may be any number of OP_CLOSE opcodes, to close
	//     any currently open capturing brackets. Unlike reaching the end of a group,
	//     where we know the starting frame is at the top of the chained frames, in
	//     this case we have to search back for the relevant frame in case other types
	//     of group that use chained frames have intervened. Multiple OP_CLOSEs always
	//     come innermost first, which matches the chain order. We can ignore this in
	//     a recursion, because captures are not passed out of recursions.

__14:
	if !((*Theapframe)(unsafe.Pointer(F)).Fcurrent_recurse == DRECURSE_UNSET) {
		goto __164
	}

	number = uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))))
	offset = (*Theapframe)(unsafe.Pointer(F)).Flast_group_offset
__165:

	if !(offset == libc.CplUint64(uint64(0))) {
		goto __168
	}
	return -44
__168:
	;
	N = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fmatch_frames + uintptr(offset)
	P = N - uintptr(frame_size)
	if !((*Theapframe)(unsafe.Pointer(N)).Fgroup_frame_type == DGF_CAPTURE|number) {
		goto __169
	}
	goto __167
__169:
	;
	offset = (*Theapframe)(unsafe.Pointer(P)).Flast_group_offset
	goto __166
__166:
	goto __165
	goto __167
__167:
	;
	offset = Tsize_t(number<<1 - Tuint32_t(2))
	(*Theapframe)(unsafe.Pointer(F)).Fcapture_last = number
	*(*Tsize_t)(unsafe.Pointer(F + 128 + uintptr(offset)*8)) = Tsize_t((int64((*Theapframe)(unsafe.Pointer(P)).Feptr) - int64((*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject)) / 1)
	*(*Tsize_t)(unsafe.Pointer(F + 128 + uintptr(offset+uint64(1))*8)) = Tsize_t((int64((*Theapframe)(unsafe.Pointer(F)).Feptr) - int64((*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject)) / 1)
	if !(offset >= (*Theapframe)(unsafe.Pointer(F)).Foffset_top) {
		goto __170
	}
	(*Theapframe)(unsafe.Pointer(F)).Foffset_top = offset + uint64(2)
__170:
	;
__164:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8(X_pcre2_OP_lengths_8[*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))])
	goto __13

	// =====================================================================
	// Real or forced end of the pattern, assertion, or recursion. In an
	//     assertion ACCEPT, update the last used pointer and remember the current
	//     frame so that the captures and mark can be fished out of it.

__15:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Flast_used_ptr) {
		goto __171
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Flast_used_ptr = (*Theapframe)(unsafe.Pointer(F)).Feptr
__171:
	;
	assert_accept_frame = F
	rrc = -999
	goto RETURN_SWITCH

	// If recursing, we have to find the most recent recursion.

__16:
__17:

	// Handle end of a recursion.

	if !((*Theapframe)(unsafe.Pointer(F)).Fcurrent_recurse != DRECURSE_UNSET) {
		goto __172
	}

	offset = (*Theapframe)(unsafe.Pointer(F)).Flast_group_offset
__173:

	if !(offset == libc.CplUint64(uint64(0))) {
		goto __176
	}
	return -44
__176:
	;
	N = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fmatch_frames + uintptr(offset)
	P = N - uintptr(frame_size)
	if !((*Theapframe)(unsafe.Pointer(N)).Fgroup_frame_type&0xffff0000 == DGF_RECURSE) {
		goto __177
	}
	goto __175
__177:
	;
	offset = (*Theapframe)(unsafe.Pointer(P)).Flast_group_offset
	goto __174
__174:
	goto __173
	goto __175
__175:
	;

	// N is now the frame of the recursion; the previous frame is at the
	//       OP_RECURSE position. Go back there, copying the current subject position
	//       and mark, and the start_match position (\K might have changed it), and
	//       then move on past the OP_RECURSE.

	(*Theapframe)(unsafe.Pointer(P)).Feptr = (*Theapframe)(unsafe.Pointer(F)).Feptr
	(*Theapframe)(unsafe.Pointer(P)).Fmark = (*Theapframe)(unsafe.Pointer(F)).Fmark
	(*Theapframe)(unsafe.Pointer(P)).Fstart_match = (*Theapframe)(unsafe.Pointer(F)).Fstart_match
	F = P
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8(1 + DLINK_SIZE)
	goto __11
__172:
	;

	// Not a recursion. Fail for an empty string match if either PCRE2_NOTEMPTY
	//     is set, or if PCRE2_NOTEMPTY_ATSTART is set and we have matched at the
	//     start of the subject. In both cases, backtracking will then try other
	//     alternatives, if any.

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr == (*Theapframe)(unsafe.Pointer(F)).Fstart_match && ((*Tmatch_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_NOTEMPTY != Tuint32_t(0) || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_NOTEMPTY_ATSTART != Tuint32_t(0) && (*Theapframe)(unsafe.Pointer(F)).Fstart_match == (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject+uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_offset))) {
		goto __178
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__178:
	;

	// Also fail if PCRE2_ENDANCHORED is set and the end of the match is not
	//     the end of the subject. After (*ACCEPT) we fail the entire match (at this
	//     position) but backtrack on reaching the end of the pattern.

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && ((*Tmatch_block_8)(unsafe.Pointer(mb)).Fmoptions|(*Tmatch_block_8)(unsafe.Pointer(mb)).Fpoptions)&DPCRE2_ENDANCHORED != Tuint32_t(0)) {
		goto __179
	}

	if !(int32((*Theapframe)(unsafe.Pointer(F)).Fop) == OP_END) {
		goto __180
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__180:
	;

	return DMATCH_NOMATCH
__179:
	;

	// We have a successful match of the whole pattern. Record the result and
	//     then do a direct return from the function. If there is space in the offset
	//     vector, set any pairs that follow the highest-numbered captured string but
	//     are less than the number of capturing groups in the pattern to PCRE2_UNSET.
	//     It is documented that this happens. "Gaps" are set to PCRE2_UNSET
	//     dynamically. It is only those at the end that need setting here.

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_match_ptr = (*Theapframe)(unsafe.Pointer(F)).Feptr        // Record where we ended
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_offset_top = (*Theapframe)(unsafe.Pointer(F)).Foffset_top // and how many extracts were taken
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fmark = (*Theapframe)(unsafe.Pointer(F)).Fmark                 // and the last success mark
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Flast_used_ptr) {
		goto __181
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Flast_used_ptr = (*Theapframe)(unsafe.Pointer(F)).Feptr
__181:
	;

	*(*Tsize_t)(unsafe.Pointer(ovector)) = Tsize_t((int64((*Theapframe)(unsafe.Pointer(F)).Fstart_match) - int64((*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject)) / 1)
	*(*Tsize_t)(unsafe.Pointer(ovector + 1*8)) = Tsize_t((int64((*Theapframe)(unsafe.Pointer(F)).Feptr) - int64((*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject)) / 1)

	// Set i to the smaller of the sizes of the external and frame ovectors.

	i = Tuint32_t(2 * func() int32 {
		if int32(top_bracket)+1 > int32(oveccount) {
			return int32(oveccount)
		}
		return int32(top_bracket) + 1
	}())
	libc.Xmemcpy(tls, ovector+uintptr(2)*8, F+128, uint64(i-Tuint32_t(2))*uint64(unsafe.Sizeof(Tsize_t(0))))
__182:
	if !(Tsize_t(libc.PreDecUint32(&i, 1)) >= (*Theapframe)(unsafe.Pointer(F)).Foffset_top+uint64(2)) {
		goto __183
	}
	*(*Tsize_t)(unsafe.Pointer(ovector + uintptr(i)*8)) = libc.CplUint64(uint64(0))
	goto __182
__183:
	;
	return DMATCH_MATCH // Note: NOT RRETURN

	//=====================================================================
	// Match any single character type except newline; have to take care with
	//     CRLF newlines and partial matching.

__18:
	if !(func() int32 {
		if (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype != Tuint32_t(DNLTYPE_FIXED) {
			return libc.Bool32((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, (*Theapframe)(unsafe.Pointer(F)).Feptr, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+256, utf) != 0)
		}
		return libc.Bool32((*Theapframe)(unsafe.Pointer(F)).Feptr <= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260))) && ((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(1) || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + uintptr(1)))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260 + 1)))))
	}() != 0) {
		goto __184
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__184:
	;

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && (*Theapframe)(unsafe.Pointer(F)).Feptr == (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr(1) && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype == Tuint32_t(DNLTYPE_FIXED) && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(2) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260)))) {
		goto __185
	}

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __186
	}
	return -2
__186:
	;
__185:
	;
	// Fall through

	// Match any single character whatsoever.

__19:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __187
	} /* DO NOT merge the Feptr++ here; it must */
	// not be updated before SCHECK_PARTIAL.
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __188
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __189
	}
	return -2
__189:
	;
__188:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__187:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	if !(utf != 0) {
		goto __190
	}
__191:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0xc0 == 0x80) {
		goto __192
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __191
__192:
	;
__190:
	;
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __13

	// =====================================================================
	// Match a single code unit, even in UTF mode. This opcode really does
	//     match any code unit, even newline. (It really should be called ANYCODEUNIT,
	//     of course - the byte name is from pre-16 bit days.)

__20:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __193
	} /* DO NOT merge the Feptr++ here; it must */
	// not be updated before SCHECK_PARTIAL.
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __194
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __195
	}
	return -2
__195:
	;
__194:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__193:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __13

	// =====================================================================
	// Match a single character, casefully

__21:
	if !(utf != 0) {
		goto __196
	}

	(*Theapframe)(unsafe.Pointer(F)).Flength = uint64(1)
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode)))
	if !(fc >= 0xc0) {
		goto __198
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __199
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f
	(*Theapframe)(unsafe.Pointer(F)).Flength++
	goto __200
__199:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __201
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))&0x3f
	*(*Tsize_t)(unsafe.Pointer(F + 24)) += uint64(2)
	goto __202
__201:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __203
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))&0x3f
	*(*Tsize_t)(unsafe.Pointer(F + 24)) += uint64(3)
	goto __204
__203:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __205
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 4)))&0x3f
	*(*Tsize_t)(unsafe.Pointer(F + 24)) += uint64(4)
	goto __206
__205:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 5)))&0x3f
	*(*Tsize_t)(unsafe.Pointer(F + 24)) += uint64(5)
__206:
	;
__204:
	;
__202:
	;
__200:
	;
__198:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Flength > Tsize_t((int64((*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject)-int64((*Theapframe)(unsafe.Pointer(F)).Feptr))/1)) {
		goto __207
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __208
	}
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __209
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __210
	}
	return -2
__210:
	;
__209:
	;
__208:
	;
	/* Not SCHECK_PARTIAL() */
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__207:
	;
__211:
	if !((*Theapframe)(unsafe.Pointer(F)).Flength > uint64(0)) {
		goto __213
	}

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Fecode, 1)))) != int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))) {
		goto __214
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__214:
	;

	goto __212
__212:
	(*Theapframe)(unsafe.Pointer(F)).Flength--
	goto __211
	goto __213
__213:
	;
	goto __197
__196:

	/* Not UTF mode */

	if !((int64((*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject)-int64((*Theapframe)(unsafe.Pointer(F)).Feptr))/1 < int64(1)) {
		goto __215
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __216
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __217
	}
	return -2
__217:
	;
__216:
	;
	/* This one can use SCHECK_PARTIAL() */
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__215:
	;
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1))) != int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))) {
		goto __218
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__218:
	;

	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += uintptr(2)
__197:
	;
	goto __13

	// =====================================================================
	// Match a single character, caselessly. If we are at the end of the
	//     subject, give up immediately. We get here only when the pattern character
	//     has at most one other case. Characters with more than two cases are coded
	//     as OP_PROP with the pseudo-property PT_CLIST.

__22:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __219
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __220
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __221
	}
	return -2
__221:
	;
__220:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__219:
	;

	if !(utf != 0) {
		goto __222
	}

	(*Theapframe)(unsafe.Pointer(F)).Flength = uint64(1)
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode)))
	if !(fc >= 0xc0) {
		goto __224
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __225
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f
	(*Theapframe)(unsafe.Pointer(F)).Flength++
	goto __226
__225:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __227
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))&0x3f
	*(*Tsize_t)(unsafe.Pointer(F + 24)) += uint64(2)
	goto __228
__227:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __229
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))&0x3f
	*(*Tsize_t)(unsafe.Pointer(F + 24)) += uint64(3)
	goto __230
__229:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __231
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 4)))&0x3f
	*(*Tsize_t)(unsafe.Pointer(F + 24)) += uint64(4)
	goto __232
__231:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 5)))&0x3f
	*(*Tsize_t)(unsafe.Pointer(F + 24)) += uint64(5)
__232:
	;
__230:
	;
__228:
	;
__226:
	;
__224:
	;

	// If the pattern character's value is < 128, we know that its other case
	//       (if any) is also < 128 (and therefore only one code unit long in all
	//       code-unit widths), so we can use the fast lookup table. We checked above
	//       that there is at least one character left in the subject.

	if !(fc < Tuint32_t(128)) {
		goto __233
	}

	cc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Flcc + uintptr(fc)))) != int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Flcc + uintptr(cc))))) {
		goto __235
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__235:
	;

	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __234
__233:

	dc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(dc >= 0xc0) {
		goto __236
	}
	if !(dc&0x20 == Tuint32_t(0)) {
		goto __237
	}
	dc = dc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __238
__237:
	if !(dc&0x10 == Tuint32_t(0)) {
		goto __239
	}
	dc = dc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __240
__239:
	if !(dc&0x08 == Tuint32_t(0)) {
		goto __241
	}
	dc = dc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __242
__241:
	if !(dc&0x04 == Tuint32_t(0)) {
		goto __243
	}
	dc = dc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __244
__243:
	dc = dc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__244:
	;
__242:
	;
__240:
	;
__238:
	;
__236:
	;

	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8((*Theapframe)(unsafe.Pointer(F)).Flength)
	if !(dc != fc && dc != Tuint32_t(int32(fc)+(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fother_case)) {
		goto __245
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__245:
	;

__234:
	;
	goto __223
__222:
	if !(ucp != 0) {
		goto __246
	}

	cc1 = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))
	if !(fc < Tuint32_t(128)) {
		goto __248
	}

	if !(int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Flcc + uintptr(fc)))) != int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Flcc + uintptr(cc1))))) {
		goto __250
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__250:
	;

	goto __249
__248:

	if !(cc1 != fc && cc1 != Tuint32_t(int32(fc)+(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fother_case)) {
		goto __251
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__251:
	;

__249:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += uintptr(2)
	goto __247
__246:

	/* Not UTF or UCP mode; use the table for characters < 256. */

	if !(int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Flcc + uintptr(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))))) !=
		int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Flcc + uintptr(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))))))) {
		goto __252
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__252:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += uintptr(2)
__247:
	;
__223:
	;
	goto __13

	// =====================================================================
	// Match not a single character.

__23:
__24:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __253
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __254
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __255
	}
	return -2
__255:
	;
__254:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__253:
	;

	if !(utf != 0) {
		goto __256
	}

	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	ch = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Fecode, 1))))
	if !(ch >= 0xc0) {
		goto __258
	}
	if !(ch&0x20 == Tuint32_t(0)) {
		goto __259
	}
	ch = ch&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Fecode, 1))))&0x3f
	goto __260
__259:
	if !(ch&0x10 == Tuint32_t(0)) {
		goto __261
	}
	ch = ch&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += uintptr(2)
	goto __262
__261:
	if !(ch&0x08 == Tuint32_t(0)) {
		goto __263
	}
	ch = ch&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += uintptr(3)
	goto __264
__263:
	if !(ch&0x04 == Tuint32_t(0)) {
		goto __265
	}
	ch = ch&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += uintptr(4)
	goto __266
__265:
	ch = ch&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += uintptr(5)
__266:
	;
__264:
	;
__262:
	;
__260:
	;
__258:
	;

	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(fc >= 0xc0) {
		goto __267
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __268
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __269
__268:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __270
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __271
__270:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __272
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __273
__272:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __274
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __275
__274:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__275:
	;
__273:
	;
__271:
	;
__269:
	;
__267:
	;

	if !(ch == fc) {
		goto __276
	}

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
	// Caseful match
	goto __277
__276:
	if !(int32((*Theapframe)(unsafe.Pointer(F)).Fop) == OP_NOTI) {
		goto __278
	} /* If caseless */

	if !(ch > Tuint32_t(127)) {
		goto __279
	}
	ch = Tuint32_t(int32(ch) + (*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(ch)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(ch)%DUCD_BLOCK_SIZE])*12)).Fother_case)
	goto __280
__279:
	ch = Tuint32_t(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Ffcc + uintptr(ch))))
__280:
	;
	if !(ch == fc) {
		goto __281
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__281:
	;

__278:
	;
__277:
	;
	goto __257
__256:
	if !(ucp != 0) {
		goto __282
	}

	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	ch1 = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += uintptr(2)

	if !(ch1 == fc) {
		goto __284
	}

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
	// Caseful match
	goto __285
__284:
	if !(int32((*Theapframe)(unsafe.Pointer(F)).Fop) == OP_NOTI) {
		goto __286
	} /* If caseless */

	if !(ch1 > Tuint32_t(127)) {
		goto __287
	}
	ch1 = Tuint32_t(int32(ch1) + (*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(ch1)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(ch1)%DUCD_BLOCK_SIZE])*12)).Fother_case)
	goto __288
__287:
	ch1 = Tuint32_t(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Ffcc + uintptr(ch1))))
__288:
	;
	if !(ch1 == fc) {
		goto __289
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__289:
	;

__286:
	;
__285:
	;
	goto __283
__282:

	/* Neither UTF nor UCP is set */

	ch2 = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(ch2 == fc || int32((*Theapframe)(unsafe.Pointer(F)).Fop) == OP_NOTI && Tuint32_t(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Ffcc + uintptr(ch2)))) == fc) {
		goto __290
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__290:
	;

	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += uintptr(2)
__283:
	;
__257:
	;
	goto __13

	// =====================================================================
	// Match a single character repeatedly.

__25:
__26:
	*(*Tuint32_t)(unsafe.Pointer(F + 56)) = libc.AssignPtrUint32(F+56+1*4, uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))))
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8(1 + DIMM2_SIZE)
	goto REPEATCHAR

__27:
__28:
	reptype = REPTYPE_POS
	*(*Tuint32_t)(unsafe.Pointer(F + 56)) = Tuint32_t(0)
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4)) = uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))))
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8(1 + DIMM2_SIZE)
	goto REPEATCHAR

__29:
__30:
	reptype = REPTYPE_MAX
	*(*Tuint32_t)(unsafe.Pointer(F + 56)) = Tuint32_t(0)
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4)) = uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))))
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8(1 + DIMM2_SIZE)
	goto REPEATCHAR

__31:
__32:
	reptype = REPTYPE_MIN
	*(*Tuint32_t)(unsafe.Pointer(F + 56)) = Tuint32_t(0)
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4)) = uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))))
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8(1 + DIMM2_SIZE)
	goto REPEATCHAR

__33:
__34:
	reptype = REPTYPE_POS
	*(*Tuint32_t)(unsafe.Pointer(F + 56)) = Tuint32_t(0)
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4)) = 4294967295
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto REPEATCHAR

__35:
__36:
	reptype = REPTYPE_POS
	*(*Tuint32_t)(unsafe.Pointer(F + 56)) = Tuint32_t(1)
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4)) = 4294967295
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto REPEATCHAR

__37:
__38:
	reptype = REPTYPE_POS
	*(*Tuint32_t)(unsafe.Pointer(F + 56)) = Tuint32_t(0)
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4)) = Tuint32_t(1)
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto REPEATCHAR

__39:
__40:
__41:
__42:
__43:
__44:
__45:
__46:
__47:
__48:
__49:
__50:
	fc = Tuint32_t(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Fecode, 1)))) - func() int32 {
		if int32((*Theapframe)(unsafe.Pointer(F)).Fop) < OP_STARI {
			return OP_STAR
		}
		return OP_STARI
	}())
	*(*Tuint32_t)(unsafe.Pointer(F + 56)) = rep_min[fc]
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4)) = rep_max[fc]
	reptype = rep_typ[fc]

	// Common code for all repeated single-character matches. We first check
	//     for the minimum number of characters. If the minimum equals the maximum, we
	//     are done. Otherwise, if minimizing, check the rest of the pattern for a
	//     match; if there isn't one, advance up to the maximum, one character at a
	//     time.
	//
	//     If maximizing, advance up to the maximum number of matching characters,
	//     until Feptr is past the end of the maximum run. If possessive, we are
	//     then done (no backing up). Otherwise, match at this position; anything
	//     other than no match is immediately returned. For nomatch, back up one
	//     character, unless we are matching \R and the last thing matched was
	//     \r\n, in which case, back up two code units until we reach the first
	//     optional character position.
	//
	//     The various UTF/non-UTF and caseful/caseless cases are handled separately,
	//     for speed.

REPEATCHAR:
	if !(utf != 0) {
		goto __291
	}

	(*Theapframe)(unsafe.Pointer(F)).Flength = uint64(1)
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8 + 1*8)) = (*Theapframe)(unsafe.Pointer(F)).Fecode
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode)))
	if !(fc >= 0xc0) {
		goto __293
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __294
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f
	(*Theapframe)(unsafe.Pointer(F)).Flength++
	goto __295
__294:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __296
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))&0x3f
	*(*Tsize_t)(unsafe.Pointer(F + 24)) += uint64(2)
	goto __297
__296:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __298
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))&0x3f
	*(*Tsize_t)(unsafe.Pointer(F + 24)) += uint64(3)
	goto __299
__298:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __300
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 4)))&0x3f
	*(*Tsize_t)(unsafe.Pointer(F + 24)) += uint64(4)
	goto __301
__300:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 5)))&0x3f
	*(*Tsize_t)(unsafe.Pointer(F + 24)) += uint64(5)
__301:
	;
__299:
	;
__297:
	;
__295:
	;
__293:
	;

	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8((*Theapframe)(unsafe.Pointer(F)).Flength)

	// Handle multi-code-unit character matching, caseful and caseless.

	if !((*Theapframe)(unsafe.Pointer(F)).Flength > uint64(1)) {
		goto __302
	}

	if !(int32((*Theapframe)(unsafe.Pointer(F)).Fop) >= OP_STARI && libc.AssignUint32(&othercase, Tuint32_t(int32(fc)+(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fother_case)) != fc) {
		goto __303
	}
	(*Theapframe)(unsafe.Pointer(F)).Ftemp_size = Tsize_t(X_pcre2_ord2utf_8(tls, othercase, F+74))
	goto __304
__303:
	(*Theapframe)(unsafe.Pointer(F)).Ftemp_size = uint64(0)
__304:
	;

	i = Tuint32_t(1)
__305:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __307
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr <= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Theapframe)(unsafe.Pointer(F)).Flength) && libc.Xmemcmp(tls, (*Theapframe)(unsafe.Pointer(F)).Feptr, *(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8 + 1*8)), (*Theapframe)(unsafe.Pointer(F)).Flength*uint64(DPCRE2_CODE_UNIT_WIDTH/8)) == 0) {
		goto __308
	}
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += TPCRE2_SPTR8((*Theapframe)(unsafe.Pointer(F)).Flength)
	goto __309
__308:
	if !((*Theapframe)(unsafe.Pointer(F)).Ftemp_size > uint64(0) && (*Theapframe)(unsafe.Pointer(F)).Feptr <= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Theapframe)(unsafe.Pointer(F)).Ftemp_size) && libc.Xmemcmp(tls, (*Theapframe)(unsafe.Pointer(F)).Feptr, F+74, (*Theapframe)(unsafe.Pointer(F)).Ftemp_size*uint64(DPCRE2_CODE_UNIT_WIDTH/8)) == 0) {
		goto __310
	}
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += TPCRE2_SPTR8((*Theapframe)(unsafe.Pointer(F)).Ftemp_size)
	goto __311
__310:

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __312
	}
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __313
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __314
	}
	return -2
__314:
	;
__313:
	;
__312:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__311:
	;
__309:
	;
	goto __306
__306:
	i++
	goto __305
	goto __307
__307:
	;

	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56)) == *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __315
	}
	goto __11
__315:
	;

	if !(reptype == REPTYPE_MIN) {
		goto __316
	}

__318:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM202
	goto MATCH_RECURSE
L_RM202:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __321
	}
	rrc = rrc
	goto RETURN_SWITCH
__321:
	;

	if !(libc.PostIncUint32(&*(*Tuint32_t)(unsafe.Pointer(F + 56)), 1) >= *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __322
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__322:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr <= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Theapframe)(unsafe.Pointer(F)).Flength) && libc.Xmemcmp(tls, (*Theapframe)(unsafe.Pointer(F)).Feptr, *(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8 + 1*8)), (*Theapframe)(unsafe.Pointer(F)).Flength*uint64(DPCRE2_CODE_UNIT_WIDTH/8)) == 0) {
		goto __323
	}
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += TPCRE2_SPTR8((*Theapframe)(unsafe.Pointer(F)).Flength)
	goto __324
__323:
	if !((*Theapframe)(unsafe.Pointer(F)).Ftemp_size > uint64(0) && (*Theapframe)(unsafe.Pointer(F)).Feptr <= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Theapframe)(unsafe.Pointer(F)).Ftemp_size) && libc.Xmemcmp(tls, (*Theapframe)(unsafe.Pointer(F)).Feptr, F+74, (*Theapframe)(unsafe.Pointer(F)).Ftemp_size*uint64(DPCRE2_CODE_UNIT_WIDTH/8)) == 0) {
		goto __325
	}
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += TPCRE2_SPTR8((*Theapframe)(unsafe.Pointer(F)).Ftemp_size)
	goto __326
__325:

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __327
	}
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __328
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __329
	}
	return -2
__329:
	;
__328:
	;
__327:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__326:
	;
__324:
	;
	goto __319
__319:
	goto __318
	goto __320
__320:
	;
	// Control never gets here
	goto __317
__316: /* Maximize */

	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8)) = (*Theapframe)(unsafe.Pointer(F)).Feptr
	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__330:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __332
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr <= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Theapframe)(unsafe.Pointer(F)).Flength) && libc.Xmemcmp(tls, (*Theapframe)(unsafe.Pointer(F)).Feptr, *(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8 + 1*8)), (*Theapframe)(unsafe.Pointer(F)).Flength*uint64(DPCRE2_CODE_UNIT_WIDTH/8)) == 0) {
		goto __333
	}
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += TPCRE2_SPTR8((*Theapframe)(unsafe.Pointer(F)).Flength)
	goto __334
__333:
	if !((*Theapframe)(unsafe.Pointer(F)).Ftemp_size > uint64(0) && (*Theapframe)(unsafe.Pointer(F)).Feptr <= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Theapframe)(unsafe.Pointer(F)).Ftemp_size) && libc.Xmemcmp(tls, (*Theapframe)(unsafe.Pointer(F)).Feptr, F+74, (*Theapframe)(unsafe.Pointer(F)).Ftemp_size*uint64(DPCRE2_CODE_UNIT_WIDTH/8)) == 0) {
		goto __335
	}
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += TPCRE2_SPTR8((*Theapframe)(unsafe.Pointer(F)).Ftemp_size)
	goto __336
__335:

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __337
	}
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __338
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __339
	}
	return -2
__339:
	;
__338:
	;
__337:
	;

	goto __332
__336:
	;
__334:
	;
	goto __331
__331:
	i++
	goto __330
	goto __332
__332:
	;

	// After \C in UTF mode, Lstart_eptr might be in the middle of a
	//           Unicode character. Use <= Lstart_eptr to ensure backtracking doesn't
	//           go too far.

	if !(reptype != REPTYPE_POS) {
		goto __340
	}
__341:

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr <= *(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8))) {
		goto __344
	}
	goto __343
__344:
	;
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM203
	goto MATCH_RECURSE
L_RM203:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __345
	}
	rrc = rrc
	goto RETURN_SWITCH
__345:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr--
__346:
	if !(uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0xc0 == 0x80) {
		goto __347
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr--
	goto __346
__347:
	;
	goto __342
__342:
	goto __341
	goto __343
__343:
	;
__340:
	;
__317:
	;
	goto __13 // End of repeated wide character handling
__302:
	;

	// Length of UTF character is 1. Put it into the preserved variable and
	//       fall through to the non-UTF code.

	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) = fc
	goto __292
__291:

	// When not in UTF mode, load a single-code-unit character. Then proceed as
	//     above, using Unicode casing if either UTF or UCP is set.

	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Fecode, 1))))
__292:
	;

	// Caseless comparison

	if !(int32((*Theapframe)(unsafe.Pointer(F)).Fop) >= OP_STARI) {
		goto __348
	}

	if !(ucp != 0 && !(utf != 0) && *(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) > Tuint32_t(127)) {
		goto __350
	}
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4)) = Tuint32_t(int32(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4))) + (*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)))/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)))%DUCD_BLOCK_SIZE])*12)).Fother_case)
	goto __351
__350:
	// Lc will be < 128 in UTF-8 mode.
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4)) = Tuint32_t(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Ffcc + uintptr(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4))))))
__351:
	;

	i = Tuint32_t(1)
__352:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __354
	}
	// Faster than PCRE2_UCHAR
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __355
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __356
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __357
	}
	return -2
__357:
	;
__356:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__355:
	;
	cc2 = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) != cc2 && *(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4)) != cc2) {
		goto __358
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__358:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __353
__353:
	i++
	goto __352
	goto __354
__354:
	;
	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56)) == *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __359
	}
	goto __11
__359:
	;

	if !(reptype == REPTYPE_MIN) {
		goto __360
	}

__362:
	/* Faster than PCRE2_UCHAR */
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM25
	goto MATCH_RECURSE
L_RM25:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __365
	}
	rrc = rrc
	goto RETURN_SWITCH
__365:
	;

	if !(libc.PostIncUint32(&*(*Tuint32_t)(unsafe.Pointer(F + 56)), 1) >= *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __366
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__366:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __367
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __368
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __369
	}
	return -2
__369:
	;
__368:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__367:
	;
	cc3 = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) != cc3 && *(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4)) != cc3) {
		goto __370
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__370:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __363
__363:
	goto __362
	goto __364
__364:
	;
	// Control never gets here
	goto __361
__360: /* Maximize */

	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8)) = (*Theapframe)(unsafe.Pointer(F)).Feptr
	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__371:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __373
	}
	// Faster than PCRE2_UCHAR
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __374
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __375
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __376
	}
	return -2
__376:
	;
__375:
	;

	goto __373
__374:
	;
	cc4 = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) != cc4 && *(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4)) != cc4) {
		goto __377
	}
	goto __373
__377:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __372
__372:
	i++
	goto __371
	goto __373
__373:
	;
	if !(reptype != REPTYPE_POS) {
		goto __378
	}
__379:

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr == *(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8))) {
		goto __382
	}
	goto __381
__382:
	;
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM26
	goto MATCH_RECURSE
L_RM26:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr--
	if !(rrc != DMATCH_NOMATCH) {
		goto __383
	}
	rrc = rrc
	goto RETURN_SWITCH
__383:
	;

	goto __380
__380:
	goto __379
	goto __381
__381:
	;
__378:
	;
__361:
	;
	goto __349
__348:

	i = Tuint32_t(1)
__384:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __386
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __387
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __388
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __389
	}
	return -2
__389:
	;
__388:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__387:
	;
	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) != Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))) {
		goto __390
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__390:
	;

	goto __385
__385:
	i++
	goto __384
	goto __386
__386:
	;

	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56)) == *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __391
	}
	goto __11
__391:
	;

	if !(reptype == REPTYPE_MIN) {
		goto __392
	}

__394:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM27
	goto MATCH_RECURSE
L_RM27:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __397
	}
	rrc = rrc
	goto RETURN_SWITCH
__397:
	;

	if !(libc.PostIncUint32(&*(*Tuint32_t)(unsafe.Pointer(F + 56)), 1) >= *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __398
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__398:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __399
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __400
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __401
	}
	return -2
__401:
	;
__400:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__399:
	;
	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) != Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))) {
		goto __402
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__402:
	;

	goto __395
__395:
	goto __394
	goto __396
__396:
	;
	// Control never gets here
	goto __393
__392: /* Maximize */

	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8)) = (*Theapframe)(unsafe.Pointer(F)).Feptr
	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__403:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __405
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __406
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __407
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __408
	}
	return -2
__408:
	;
__407:
	;

	goto __405
__406:
	;

	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) != Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))) {
		goto __409
	}
	goto __405
__409:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __404
__404:
	i++
	goto __403
	goto __405
__405:
	;

	if !(reptype != REPTYPE_POS) {
		goto __410
	}
__411:

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr <= *(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8))) {
		goto __414
	}
	goto __413
__414:
	;
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM28
	goto MATCH_RECURSE
L_RM28:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr--
	if !(rrc != DMATCH_NOMATCH) {
		goto __415
	}
	rrc = rrc
	goto RETURN_SWITCH
__415:
	;

	goto __412
__412:
	goto __411
	goto __413
__413:
	;
__410:
	;
__393:
	;
__349:
	;
	goto __13

	// =====================================================================
	// Match a negated single one-byte character repeatedly. This is almost a
	//     repeat of the code for a repeated single character, but I haven't found a
	//     nice way of commoning these up that doesn't require a test of the
	//     positive/negative option for each character match. Maybe that wouldn't add
	//     very much to the time taken, but character matching *is* what this is all
	//     about...

__51:
__52:
	*(*Tuint32_t)(unsafe.Pointer(F + 56)) = libc.AssignPtrUint32(F+56+1*4, uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))))
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8(1 + DIMM2_SIZE)
	goto REPEATNOTCHAR

__53:
__54:
	*(*Tuint32_t)(unsafe.Pointer(F + 56)) = Tuint32_t(0)
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4)) = uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))))
	reptype = REPTYPE_MAX
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8(1 + DIMM2_SIZE)
	goto REPEATNOTCHAR

__55:
__56:
	*(*Tuint32_t)(unsafe.Pointer(F + 56)) = Tuint32_t(0)
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4)) = uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))))
	reptype = REPTYPE_MIN
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8(1 + DIMM2_SIZE)
	goto REPEATNOTCHAR

__57:
__58:
	reptype = REPTYPE_POS
	*(*Tuint32_t)(unsafe.Pointer(F + 56)) = Tuint32_t(0)
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4)) = 4294967295
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto REPEATNOTCHAR

__59:
__60:
	reptype = REPTYPE_POS
	*(*Tuint32_t)(unsafe.Pointer(F + 56)) = Tuint32_t(1)
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4)) = 4294967295
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto REPEATNOTCHAR

__61:
__62:
	reptype = REPTYPE_POS
	*(*Tuint32_t)(unsafe.Pointer(F + 56)) = Tuint32_t(0)
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4)) = Tuint32_t(1)
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto REPEATNOTCHAR

__63:
__64:
	reptype = REPTYPE_POS
	*(*Tuint32_t)(unsafe.Pointer(F + 56)) = Tuint32_t(0)
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4)) = uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))))
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8(1 + DIMM2_SIZE)
	goto REPEATNOTCHAR

__65:
__66:
__67:
__68:
__69:
__70:
__71:
__72:
__73:
__74:
__75:
__76:
	fc = Tuint32_t(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Fecode, 1)))) - func() int32 {
		if int32((*Theapframe)(unsafe.Pointer(F)).Fop) >= OP_NOTSTARI {
			return OP_NOTSTARI
		}
		return OP_NOTSTAR
	}())
	*(*Tuint32_t)(unsafe.Pointer(F + 56)) = rep_min[fc]
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4)) = rep_max[fc]
	reptype = rep_typ[fc]

	// Common code for all repeated single-character non-matches.

REPEATNOTCHAR:
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Fecode, 1))))
	if !(utf != 0 && *(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) >= 0xc0) {
		goto __416
	}
	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4))&0x20 == Tuint32_t(0)) {
		goto __417
	}
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) = *(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4))&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Fecode, 1))))&0x3f
	goto __418
__417:
	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4))&0x10 == Tuint32_t(0)) {
		goto __419
	}
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) = *(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4))&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += uintptr(2)
	goto __420
__419:
	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4))&0x08 == Tuint32_t(0)) {
		goto __421
	}
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) = *(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4))&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += uintptr(3)
	goto __422
__421:
	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4))&0x04 == Tuint32_t(0)) {
		goto __423
	}
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) = *(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4))&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += uintptr(4)
	goto __424
__423:
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) = *(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4))&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += uintptr(5)
__424:
	;
__422:
	;
__420:
	;
__418:
	;
__416:
	;

	// The code is duplicated for the caseless and caseful cases, for speed,
	//     since matching characters is likely to be quite common. First, ensure the
	//     minimum number of matches are present. If Lmin = Lmax, we are done.
	//     Otherwise, if minimizing, keep trying the rest of the expression and
	//     advancing one matching character if failing, up to the maximum.
	//     Alternatively, if maximizing, find the maximum number of characters and
	//     work backwards.

	if !(int32((*Theapframe)(unsafe.Pointer(F)).Fop) >= OP_NOTSTARI) {
		goto __425
	} /* Caseless */

	if !((utf != 0 || ucp != 0) && *(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) > Tuint32_t(127)) {
		goto __427
	}
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4)) = Tuint32_t(int32(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4))) + (*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)))/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)))%DUCD_BLOCK_SIZE])*12)).Fother_case)
	goto __428
__427:

	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4)) = Tuint32_t(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Ffcc + uintptr(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4))))))
__428:
	; // Other case from table

	if !(utf != 0) {
		goto __429
	}

	i = Tuint32_t(1)
__431:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __433
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __434
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __435
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __436
	}
	return -2
__436:
	;
__435:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__434:
	;
	d = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(d >= 0xc0) {
		goto __437
	}
	if !(d&0x20 == Tuint32_t(0)) {
		goto __438
	}
	d = d&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __439
__438:
	if !(d&0x10 == Tuint32_t(0)) {
		goto __440
	}
	d = d&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __441
__440:
	if !(d&0x08 == Tuint32_t(0)) {
		goto __442
	}
	d = d&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __443
__442:
	if !(d&0x04 == Tuint32_t(0)) {
		goto __444
	}
	d = d&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __445
__444:
	d = d&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__445:
	;
__443:
	;
__441:
	;
__439:
	;
__437:
	;

	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) == d || *(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4)) == d) {
		goto __446
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__446:
	;

	goto __432
__432:
	i++
	goto __431
	goto __433
__433:
	;
	goto __430
__429:

	/* Not UTF mode */

	i = Tuint32_t(1)
__447:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __449
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __450
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __451
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __452
	}
	return -2
__452:
	;
__451:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__450:
	;
	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) == Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) || *(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4)) == Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))) {
		goto __453
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__453:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __448
__448:
	i++
	goto __447
	goto __449
__449:
	;
__430:
	;

	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56)) == *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __454
	}
	goto __11
__454:
	; // Finished for exact count

	if !(reptype == REPTYPE_MIN) {
		goto __455
	}

	if !(utf != 0) {
		goto __457
	}

__459:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM204
	goto MATCH_RECURSE
L_RM204:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __462
	}
	rrc = rrc
	goto RETURN_SWITCH
__462:
	;

	if !(libc.PostIncUint32(&*(*Tuint32_t)(unsafe.Pointer(F + 56)), 1) >= *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __463
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__463:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __464
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __465
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __466
	}
	return -2
__466:
	;
__465:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__464:
	;
	d1 = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(d1 >= 0xc0) {
		goto __467
	}
	if !(d1&0x20 == Tuint32_t(0)) {
		goto __468
	}
	d1 = d1&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __469
__468:
	if !(d1&0x10 == Tuint32_t(0)) {
		goto __470
	}
	d1 = d1&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __471
__470:
	if !(d1&0x08 == Tuint32_t(0)) {
		goto __472
	}
	d1 = d1&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __473
__472:
	if !(d1&0x04 == Tuint32_t(0)) {
		goto __474
	}
	d1 = d1&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __475
__474:
	d1 = d1&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__475:
	;
__473:
	;
__471:
	;
__469:
	;
__467:
	;

	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) == d1 || *(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4)) == d1) {
		goto __476
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__476:
	;

	goto __460
__460:
	goto __459
	goto __461
__461:
	;
	goto __458
__457:

	/* Not UTF mode */

__477:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM29
	goto MATCH_RECURSE
L_RM29:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __480
	}
	rrc = rrc
	goto RETURN_SWITCH
__480:
	;

	if !(libc.PostIncUint32(&*(*Tuint32_t)(unsafe.Pointer(F + 56)), 1) >= *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __481
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__481:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __482
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __483
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __484
	}
	return -2
__484:
	;
__483:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__482:
	;
	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) == Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) || *(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4)) == Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))) {
		goto __485
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__485:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __478
__478:
	goto __477
	goto __479
__479:
	;
__458:
	;
	// Control never gets here
	goto __456
__455:

	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8)) = (*Theapframe)(unsafe.Pointer(F)).Feptr

	if !(utf != 0) {
		goto __486
	}

	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__488:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __490
	}

	len = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __491
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __492
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __493
	}
	return -2
__493:
	;
__492:
	;

	goto __490
__491:
	;
	d2 = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(d2 >= 0xc0) {
		goto __494
	}
	if !(d2&0x20 == Tuint32_t(0)) {
		goto __495
	}
	d2 = d2&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len++
	goto __496
__495:
	if !(d2&0x10 == Tuint32_t(0)) {
		goto __497
	}
	d2 = d2&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len = len + 2
	goto __498
__497:
	if !(d2&0x08 == Tuint32_t(0)) {
		goto __499
	}
	d2 = d2&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len = len + 3
	goto __500
__499:
	if !(d2&0x04 == Tuint32_t(0)) {
		goto __501
	}
	d2 = d2&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len = len + 4
	goto __502
__501:
	d2 = d2&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len = len + 5
__502:
	;
__500:
	;
__498:
	;
__496:
	;
__494:
	;

	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) == d2 || *(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4)) == d2) {
		goto __503
	}
	goto __490
__503:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += TPCRE2_SPTR8(len)
	goto __489
__489:
	i++
	goto __488
	goto __490
__490:
	;

	// After \C in UTF mode, Lstart_eptr might be in the middle of a
	//           Unicode character. Use <= Lstart_eptr to ensure backtracking doesn't
	//           go too far.

	if !(reptype != REPTYPE_POS) {
		goto __504
	}
__505:

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr <= *(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8))) {
		goto __508
	}
	goto __507
__508:
	;
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM205
	goto MATCH_RECURSE
L_RM205:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __509
	}
	rrc = rrc
	goto RETURN_SWITCH
__509:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr--
__510:
	if !(uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0xc0 == 0x80) {
		goto __511
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr--
	goto __510
__511:
	;
	goto __506
__506:
	goto __505
	goto __507
__507:
	;
__504:
	;
	goto __487
__486:

	/* Not UTF mode */

	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__512:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __514
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __515
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __516
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __517
	}
	return -2
__517:
	;
__516:
	;

	goto __514
__515:
	;
	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) == Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) || *(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4)) == Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))) {
		goto __518
	}
	goto __514
__518:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __513
__513:
	i++
	goto __512
	goto __514
__514:
	;
	if !(reptype != REPTYPE_POS) {
		goto __519
	}
__520:

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr == *(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8))) {
		goto __523
	}
	goto __522
__523:
	;
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM30
	goto MATCH_RECURSE
L_RM30:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __524
	}
	rrc = rrc
	goto RETURN_SWITCH
__524:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr--
	goto __521
__521:
	goto __520
	goto __522
__522:
	;
__519:
	;
__487:
	;
__456:
	;
	goto __426
__425:

	if !(utf != 0) {
		goto __525
	}

	i = Tuint32_t(1)
__527:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __529
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __530
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __531
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __532
	}
	return -2
__532:
	;
__531:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__530:
	;
	d3 = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(d3 >= 0xc0) {
		goto __533
	}
	if !(d3&0x20 == Tuint32_t(0)) {
		goto __534
	}
	d3 = d3&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __535
__534:
	if !(d3&0x10 == Tuint32_t(0)) {
		goto __536
	}
	d3 = d3&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __537
__536:
	if !(d3&0x08 == Tuint32_t(0)) {
		goto __538
	}
	d3 = d3&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __539
__538:
	if !(d3&0x04 == Tuint32_t(0)) {
		goto __540
	}
	d3 = d3&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __541
__540:
	d3 = d3&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__541:
	;
__539:
	;
__537:
	;
__535:
	;
__533:
	;

	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) == d3) {
		goto __542
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__542:
	;

	goto __528
__528:
	i++
	goto __527
	goto __529
__529:
	;
	goto __526
__525:
	/* Not UTF mode */

	i = Tuint32_t(1)
__543:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __545
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __546
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __547
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __548
	}
	return -2
__548:
	;
__547:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__546:
	;
	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) == Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))) {
		goto __549
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__549:
	;

	goto __544
__544:
	i++
	goto __543
	goto __545
__545:
	;
__526:
	;

	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56)) == *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __550
	}
	goto __11
__550:
	;

	if !(reptype == REPTYPE_MIN) {
		goto __551
	}

	if !(utf != 0) {
		goto __553
	}

__555:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM206
	goto MATCH_RECURSE
L_RM206:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __558
	}
	rrc = rrc
	goto RETURN_SWITCH
__558:
	;

	if !(libc.PostIncUint32(&*(*Tuint32_t)(unsafe.Pointer(F + 56)), 1) >= *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __559
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__559:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __560
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __561
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __562
	}
	return -2
__562:
	;
__561:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__560:
	;
	d4 = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(d4 >= 0xc0) {
		goto __563
	}
	if !(d4&0x20 == Tuint32_t(0)) {
		goto __564
	}
	d4 = d4&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __565
__564:
	if !(d4&0x10 == Tuint32_t(0)) {
		goto __566
	}
	d4 = d4&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __567
__566:
	if !(d4&0x08 == Tuint32_t(0)) {
		goto __568
	}
	d4 = d4&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __569
__568:
	if !(d4&0x04 == Tuint32_t(0)) {
		goto __570
	}
	d4 = d4&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __571
__570:
	d4 = d4&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__571:
	;
__569:
	;
__567:
	;
__565:
	;
__563:
	;

	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) == d4) {
		goto __572
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__572:
	;

	goto __556
__556:
	goto __555
	goto __557
__557:
	;
	goto __554
__553:
	/* Not UTF mode */

__573:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM31
	goto MATCH_RECURSE
L_RM31:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __576
	}
	rrc = rrc
	goto RETURN_SWITCH
__576:
	;

	if !(libc.PostIncUint32(&*(*Tuint32_t)(unsafe.Pointer(F + 56)), 1) >= *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __577
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__577:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __578
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __579
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __580
	}
	return -2
__580:
	;
__579:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__578:
	;
	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) == Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))) {
		goto __581
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__581:
	;

	goto __574
__574:
	goto __573
	goto __575
__575:
	;
__554:
	;
	// Control never gets here
	goto __552
__551:

	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8)) = (*Theapframe)(unsafe.Pointer(F)).Feptr

	if !(utf != 0) {
		goto __582
	}

	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__584:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __586
	}

	len1 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __587
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __588
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __589
	}
	return -2
__589:
	;
__588:
	;

	goto __586
__587:
	;
	d5 = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(d5 >= 0xc0) {
		goto __590
	}
	if !(d5&0x20 == Tuint32_t(0)) {
		goto __591
	}
	d5 = d5&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len1++
	goto __592
__591:
	if !(d5&0x10 == Tuint32_t(0)) {
		goto __593
	}
	d5 = d5&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len1 = len1 + 2
	goto __594
__593:
	if !(d5&0x08 == Tuint32_t(0)) {
		goto __595
	}
	d5 = d5&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len1 = len1 + 3
	goto __596
__595:
	if !(d5&0x04 == Tuint32_t(0)) {
		goto __597
	}
	d5 = d5&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len1 = len1 + 4
	goto __598
__597:
	d5 = d5&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len1 = len1 + 5
__598:
	;
__596:
	;
__594:
	;
__592:
	;
__590:
	;

	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) == d5) {
		goto __599
	}
	goto __586
__599:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += TPCRE2_SPTR8(len1)
	goto __585
__585:
	i++
	goto __584
	goto __586
__586:
	;

	// After \C in UTF mode, Lstart_eptr might be in the middle of a
	//           Unicode character. Use <= Lstart_eptr to ensure backtracking doesn't
	//           go too far.

	if !(reptype != REPTYPE_POS) {
		goto __600
	}
__601:

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr <= *(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8))) {
		goto __604
	}
	goto __603
__604:
	;
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM207
	goto MATCH_RECURSE
L_RM207:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __605
	}
	rrc = rrc
	goto RETURN_SWITCH
__605:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr--
__606:
	if !(uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0xc0 == 0x80) {
		goto __607
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr--
	goto __606
__607:
	;
	goto __602
__602:
	goto __601
	goto __603
__603:
	;
__600:
	;
	goto __583
__582:
	/* Not UTF mode */

	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__608:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __610
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __611
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __612
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __613
	}
	return -2
__613:
	;
__612:
	;

	goto __610
__611:
	;
	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) == Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))) {
		goto __614
	}
	goto __610
__614:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __609
__609:
	i++
	goto __608
	goto __610
__610:
	;
	if !(reptype != REPTYPE_POS) {
		goto __615
	}
__616:

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr == *(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8))) {
		goto __619
	}
	goto __618
__619:
	;
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM32
	goto MATCH_RECURSE
L_RM32:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __620
	}
	rrc = rrc
	goto RETURN_SWITCH
__620:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr--
	goto __617
__617:
	goto __616
	goto __618
__618:
	;
__615:
	;
__583:
	;
__552:
	;
__426:
	;
	goto __13

	// =====================================================================
	// Match a bit-mapped character class, possibly repeatedly. These opcodes
	//     are used when all the characters in the class have values in the range
	//     0-255, and either the matching is caseful, or the characters are in the
	//     range 0-127 when UTF processing is enabled. The only difference between
	//     OP_CLASS and OP_NCLASS occurs when a data character outside the range is
	//     encountered.

__77:
__78:

	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8 + 1*8)) = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(1) // Save for matching
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8(uint64(1) + uint64(32)/uint64(unsafe.Sizeof(TPCRE2_UCHAR8(0)))) // Advance past the item

	// Look past the end of the item to see if there is repeat information
	//       following. Then obey similar code to character type repeats.

	switch int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) {
	case OP_CRSTAR:
		goto __622
	case OP_CRMINSTAR:
		goto __623
	case OP_CRPLUS:
		goto __624
	case OP_CRMINPLUS:
		goto __625
	case OP_CRQUERY:
		goto __626
	case OP_CRMINQUERY:
		goto __627
	case OP_CRPOSSTAR:
		goto __628
	case OP_CRPOSPLUS:
		goto __629
	case OP_CRPOSQUERY:
		goto __630

	case OP_CRRANGE:
		goto __631
	case OP_CRMINRANGE:
		goto __632
	case OP_CRPOSRANGE:
		goto __633

	default:
		goto __634
	}
	goto __621

__622:
__623:
__624:
__625:
__626:
__627:
__628:
__629:
__630:
	fc = Tuint32_t(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Fecode, 1)))) - OP_CRSTAR)
	*(*Tuint32_t)(unsafe.Pointer(F + 56)) = rep_min[fc]
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4)) = rep_max[fc]
	reptype = rep_typ[fc]
	goto __621

__631:
__632:
__633:
	*(*Tuint32_t)(unsafe.Pointer(F + 56)) = uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))))
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4)) = uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 4))))
	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4)) == Tuint32_t(0)) {
		goto __635
	}
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4)) = 4294967295
__635:
	; // Max 0 => infinity
	reptype = rep_typ[int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode)))-OP_CRSTAR]
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8(1 + 2*DIMM2_SIZE)
	goto __621

__634: // No repeat follows
	*(*Tuint32_t)(unsafe.Pointer(F + 56)) = libc.AssignPtrUint32(F+56+1*4, Tuint32_t(1))
	goto __621
__621:
	;

	// First, ensure the minimum number of matches are present.

	if !(utf != 0) {
		goto __636
	}

	i = Tuint32_t(1)
__638:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __640
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __641
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __642
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __643
	}
	return -2
__643:
	;
__642:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__641:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(fc >= 0xc0) {
		goto __644
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __645
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __646
__645:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __647
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __648
__647:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __649
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __650
__649:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __651
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __652
__651:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__652:
	;
__650:
	;
__648:
	;
__646:
	;
__644:
	;

	if !(fc > Tuint32_t(255)) {
		goto __653
	}

	if !(int32((*Theapframe)(unsafe.Pointer(F)).Fop) == OP_CLASS) {
		goto __655
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__655:
	;

	goto __654
__653:
	if !(uint32(*(*uint8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8 + 1*8)) + uintptr(fc/Tuint32_t(8)))))&(uint32(1)<<(fc&Tuint32_t(7))) == uint32(0)) {
		goto __656
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__656:
	;
__654:
	;

	goto __639
__639:
	i++
	goto __638
	goto __640
__640:
	;
	goto __637
__636:
	/* Not UTF mode */

	i = Tuint32_t(1)
__657:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __659
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __660
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __661
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __662
	}
	return -2
__662:
	;
__661:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__660:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(uint32(*(*uint8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8 + 1*8)) + uintptr(fc/Tuint32_t(8)))))&(uint32(1)<<(fc&Tuint32_t(7))) == uint32(0)) {
		goto __663
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__663:
	;

	goto __658
__658:
	i++
	goto __657
	goto __659
__659:
	;
__637:
	;

	// If Lmax == Lmin we are done. Continue with main loop.

	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56)) == *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __664
	}
	goto __11
__664:
	;

	// If minimizing, keep testing the rest of the expression and advancing
	//       the pointer while it matches the class.

	if !(reptype == REPTYPE_MIN) {
		goto __665
	}

	if !(utf != 0) {
		goto __667
	}

__669:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM200
	goto MATCH_RECURSE
L_RM200:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __672
	}
	rrc = rrc
	goto RETURN_SWITCH
__672:
	;

	if !(libc.PostIncUint32(&*(*Tuint32_t)(unsafe.Pointer(F + 56)), 1) >= *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __673
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__673:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __674
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __675
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __676
	}
	return -2
__676:
	;
__675:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__674:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(fc >= 0xc0) {
		goto __677
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __678
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __679
__678:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __680
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __681
__680:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __682
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __683
__682:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __684
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __685
__684:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__685:
	;
__683:
	;
__681:
	;
__679:
	;
__677:
	;

	if !(fc > Tuint32_t(255)) {
		goto __686
	}

	if !(int32((*Theapframe)(unsafe.Pointer(F)).Fop) == OP_CLASS) {
		goto __688
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__688:
	;

	goto __687
__686:
	if !(uint32(*(*uint8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8 + 1*8)) + uintptr(fc/Tuint32_t(8)))))&(uint32(1)<<(fc&Tuint32_t(7))) == uint32(0)) {
		goto __689
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__689:
	;
__687:
	;

	goto __670
__670:
	goto __669
	goto __671
__671:
	;
	goto __668
__667:
	/* Not UTF mode */

__690:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM23
	goto MATCH_RECURSE
L_RM23:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __693
	}
	rrc = rrc
	goto RETURN_SWITCH
__693:
	;

	if !(libc.PostIncUint32(&*(*Tuint32_t)(unsafe.Pointer(F + 56)), 1) >= *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __694
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__694:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __695
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __696
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __697
	}
	return -2
__697:
	;
__696:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__695:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(uint32(*(*uint8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8 + 1*8)) + uintptr(fc/Tuint32_t(8)))))&(uint32(1)<<(fc&Tuint32_t(7))) == uint32(0)) {
		goto __698
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__698:
	;

	goto __691
__691:
	goto __690
	goto __692
__692:
	;
__668:
	;
	// Control never gets here
	goto __666
__665:

	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8)) = (*Theapframe)(unsafe.Pointer(F)).Feptr

	if !(utf != 0) {
		goto __699
	}

	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__701:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __703
	}

	len2 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __704
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __705
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __706
	}
	return -2
__706:
	;
__705:
	;

	goto __703
__704:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(fc >= 0xc0) {
		goto __707
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __708
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len2++
	goto __709
__708:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __710
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len2 = len2 + 2
	goto __711
__710:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __712
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len2 = len2 + 3
	goto __713
__712:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __714
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len2 = len2 + 4
	goto __715
__714:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len2 = len2 + 5
__715:
	;
__713:
	;
__711:
	;
__709:
	;
__707:
	;

	if !(fc > Tuint32_t(255)) {
		goto __716
	}

	if !(int32((*Theapframe)(unsafe.Pointer(F)).Fop) == OP_CLASS) {
		goto __718
	}
	goto __703
__718:
	;
	goto __717
__716:
	if !(uint32(*(*uint8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8 + 1*8)) + uintptr(fc/Tuint32_t(8)))))&(uint32(1)<<(fc&Tuint32_t(7))) == uint32(0)) {
		goto __719
	}
	goto __703
__719:
	;
__717:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += TPCRE2_SPTR8(len2)
	goto __702
__702:
	i++
	goto __701
	goto __703
__703:
	;

	if !(reptype == REPTYPE_POS) {
		goto __720
	}
	goto __11
__720:
	; // No backtracking

	// After \C in UTF mode, Lstart_eptr might be in the middle of a
	//           Unicode character. Use <= Lstart_eptr to ensure backtracking doesn't
	//           go too far.

__721:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM201
	goto MATCH_RECURSE
L_RM201:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __724
	}
	rrc = rrc
	goto RETURN_SWITCH
__724:
	;

	if !(libc.PostDecUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1) <= *(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8))) {
		goto __725
	}
	goto __723
__725:
	; // Tried at original position
__726:
	if !(uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0xc0 == 0x80) {
		goto __727
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr--
	goto __726
__727:
	;
	goto __722
__722:
	goto __721
	goto __723
__723:
	;
	goto __700
__699:
	/* Not UTF mode */

	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__728:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __730
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __731
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __732
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __733
	}
	return -2
__733:
	;
__732:
	;

	goto __730
__731:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(uint32(*(*uint8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8 + 1*8)) + uintptr(fc/Tuint32_t(8)))))&(uint32(1)<<(fc&Tuint32_t(7))) == uint32(0)) {
		goto __734
	}
	goto __730
__734:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __729
__729:
	i++
	goto __728
	goto __730
__730:
	;

	if !(reptype == REPTYPE_POS) {
		goto __735
	}
	goto __11
__735:
	; // No backtracking

__736:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= *(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8))) {
		goto __737
	}

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM24
	goto MATCH_RECURSE
L_RM24:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __738
	}
	rrc = rrc
	goto RETURN_SWITCH
__738:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr--
	goto __736
__737:
	;
__700:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__666:
	;

	// Control never gets here

	// =====================================================================
	// Match an extended character class. In the 8-bit library, this opcode is
	//     encountered only when UTF-8 mode mode is supported. In the 16-bit and
	//     32-bit libraries, codepoints greater than 255 may be encountered even when
	//     UTF is not supported.

__79:

	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8 + 1*8)) = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(1) + uintptr(DLINK_SIZE) // Save for matching
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))))) // Advance past the item

	switch int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) {
	case OP_CRSTAR:
		goto __740
	case OP_CRMINSTAR:
		goto __741
	case OP_CRPLUS:
		goto __742
	case OP_CRMINPLUS:
		goto __743
	case OP_CRQUERY:
		goto __744
	case OP_CRMINQUERY:
		goto __745
	case OP_CRPOSSTAR:
		goto __746
	case OP_CRPOSPLUS:
		goto __747
	case OP_CRPOSQUERY:
		goto __748

	case OP_CRRANGE:
		goto __749
	case OP_CRMINRANGE:
		goto __750
	case OP_CRPOSRANGE:
		goto __751

	default:
		goto __752
	}
	goto __739

__740:
__741:
__742:
__743:
__744:
__745:
__746:
__747:
__748:
	fc = Tuint32_t(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Fecode, 1)))) - OP_CRSTAR)
	*(*Tuint32_t)(unsafe.Pointer(F + 56)) = rep_min[fc]
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4)) = rep_max[fc]
	reptype = rep_typ[fc]
	goto __739

__749:
__750:
__751:
	*(*Tuint32_t)(unsafe.Pointer(F + 56)) = uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))))
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4)) = uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 4))))
	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4)) == Tuint32_t(0)) {
		goto __753
	}
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4)) = 4294967295
__753:
	; // Max 0 => infinity
	reptype = rep_typ[int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode)))-OP_CRSTAR]
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8(1 + 2*DIMM2_SIZE)
	goto __739

__752: // No repeat follows
	*(*Tuint32_t)(unsafe.Pointer(F + 56)) = libc.AssignPtrUint32(F+56+1*4, Tuint32_t(1))
	goto __739
__739:
	;

	// First, ensure the minimum number of matches are present.

	i = Tuint32_t(1)
__754:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __756
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __757
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __758
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __759
	}
	return -2
__759:
	;
__758:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__757:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __760
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __761
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __762
__761:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __763
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __764
__763:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __765
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __766
__765:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __767
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __768
__767:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__768:
	;
__766:
	;
__764:
	;
__762:
	;
__760:
	;

	if !!(X_pcre2_xclass_8(tls, fc, *(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8 + 1*8)), utf) != 0) {
		goto __769
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__769:
	;

	goto __755
__755:
	i++
	goto __754
	goto __756
__756:
	;

	// If Lmax == Lmin we can just continue with the main loop.

	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56)) == *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __770
	}
	goto __11
__770:
	;

	// If minimizing, keep testing the rest of the expression and advancing
	//       the pointer while it matches the class.

	if !(reptype == REPTYPE_MIN) {
		goto __771
	}

__773:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM100
	goto MATCH_RECURSE
L_RM100:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __776
	}
	rrc = rrc
	goto RETURN_SWITCH
__776:
	;

	if !(libc.PostIncUint32(&*(*Tuint32_t)(unsafe.Pointer(F + 56)), 1) >= *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __777
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__777:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __778
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __779
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __780
	}
	return -2
__780:
	;
__779:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__778:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __781
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __782
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __783
__782:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __784
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __785
__784:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __786
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __787
__786:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __788
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __789
__788:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__789:
	;
__787:
	;
__785:
	;
__783:
	;
__781:
	;

	if !!(X_pcre2_xclass_8(tls, fc, *(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8 + 1*8)), utf) != 0) {
		goto __790
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__790:
	;

	goto __774
__774:
	goto __773
	goto __775
__775:
	;
	// Control never gets here
	goto __772
__771:

	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8)) = (*Theapframe)(unsafe.Pointer(F)).Feptr
	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__791:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __793
	}

	len3 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __794
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __795
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __796
	}
	return -2
__796:
	;
__795:
	;

	goto __793
__794:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(utf != 0 && fc >= 0xc0) {
		goto __797
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __798
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len3++
	goto __799
__798:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __800
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len3 = len3 + 2
	goto __801
__800:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __802
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len3 = len3 + 3
	goto __803
__802:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __804
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len3 = len3 + 4
	goto __805
__804:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len3 = len3 + 5
__805:
	;
__803:
	;
__801:
	;
__799:
	;
__797:
	;

	if !!(X_pcre2_xclass_8(tls, fc, *(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8 + 1*8)), utf) != 0) {
		goto __806
	}
	goto __793
__806:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += TPCRE2_SPTR8(len3)
	goto __792
__792:
	i++
	goto __791
	goto __793
__793:
	;

	if !(reptype == REPTYPE_POS) {
		goto __807
	}
	goto __11
__807:
	; // No backtracking

	// After \C in UTF mode, Lstart_eptr might be in the middle of a
	//         Unicode character. Use <= Lstart_eptr to ensure backtracking doesn't
	//         go too far.

__808:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM101
	goto MATCH_RECURSE
L_RM101:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __811
	}
	rrc = rrc
	goto RETURN_SWITCH
__811:
	;

	if !(libc.PostDecUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1) <= *(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8))) {
		goto __812
	}
	goto __810
__812:
	; // Tried at original position
	if !(utf != 0) {
		goto __813
	}
__814:
	if !(uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0xc0 == 0x80) {
		goto __815
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr--
	goto __814
__815:
	;
__813:
	;
	goto __809
__809:
	goto __808
	goto __810
__810:
	;
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__772:
	;

	// Control never gets here

	// =====================================================================
	// Match various character types when PCRE2_UCP is not set. These opcodes
	//     are not generated when PCRE2_UCP is set - instead appropriate property
	//     tests are compiled.

__80:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __816
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __817
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __818
	}
	return -2
__818:
	;
__817:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__816:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __819
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __820
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __821
__820:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __822
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __823
__822:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __824
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __825
__824:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __826
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __827
__826:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__827:
	;
__825:
	;
__823:
	;
__821:
	;
__819:
	;

	if !(fc <= 255 && int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_digit != 0) {
		goto __828
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__828:
	;

	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __13

__81:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __829
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __830
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __831
	}
	return -2
__831:
	;
__830:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__829:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __832
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __833
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __834
__833:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __835
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __836
__835:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __837
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __838
__837:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __839
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __840
__839:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__840:
	;
__838:
	;
__836:
	;
__834:
	;
__832:
	;

	if !(!(fc <= 255) || int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_digit == 0) {
		goto __841
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__841:
	;

	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __13

__82:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __842
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __843
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __844
	}
	return -2
__844:
	;
__843:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__842:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __845
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __846
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __847
__846:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __848
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __849
__848:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __850
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __851
__850:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __852
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __853
__852:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__853:
	;
__851:
	;
__849:
	;
__847:
	;
__845:
	;

	if !(fc <= 255 && int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_space != 0) {
		goto __854
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__854:
	;

	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __13

__83:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __855
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __856
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __857
	}
	return -2
__857:
	;
__856:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__855:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __858
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __859
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __860
__859:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __861
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __862
__861:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __863
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __864
__863:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __865
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __866
__865:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__866:
	;
__864:
	;
__862:
	;
__860:
	;
__858:
	;

	if !(!(fc <= 255) || int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_space == 0) {
		goto __867
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__867:
	;

	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __13

__84:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __868
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __869
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __870
	}
	return -2
__870:
	;
__869:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__868:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __871
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __872
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __873
__872:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __874
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __875
__874:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __876
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __877
__876:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __878
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __879
__878:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__879:
	;
__877:
	;
__875:
	;
__873:
	;
__871:
	;

	if !(fc <= 255 && int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_word != 0) {
		goto __880
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__880:
	;

	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __13

__85:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __881
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __882
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __883
	}
	return -2
__883:
	;
__882:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__881:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __884
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __885
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __886
__885:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __887
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __888
__887:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __889
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __890
__889:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __891
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __892
__891:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__892:
	;
__890:
	;
__888:
	;
__886:
	;
__884:
	;

	if !(!(fc <= 255) || int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_word == 0) {
		goto __893
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__893:
	;

	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __13

__86:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __894
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __895
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __896
	}
	return -2
__896:
	;
__895:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__894:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __897
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __898
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __899
__898:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __900
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __901
__900:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __902
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __903
__902:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __904
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __905
__904:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__905:
	;
__903:
	;
__901:
	;
__899:
	;
__897:
	;

	switch fc {
	default:
		goto __907

	case Tuint32_t('\015'):
		goto __908

	case Tuint32_t('\012'):
		goto __909

	case Tuint32_t('\013'):
		goto __910
	case Tuint32_t('\014'):
		goto __911
	case Tuint32_t(uint8('\x85')):
		goto __912
	case Tuint32_t(0x2028):
		goto __913
	case Tuint32_t(0x2029):
		goto __914
	}
	goto __906

__907:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__908:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __915
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __917
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __918
	}
	return -2
__918:
	;
__917:
	;

	goto __916
__915:
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == '\012') {
		goto __919
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
__919:
	;
__916:
	;
	goto __906

__909:
	goto __906

__910:
__911:
__912:
__913:
__914:
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fbsr_convention) == DPCRE2_BSR_ANYCRLF) {
		goto __920
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__920:
	;

	goto __906
__906:
	;
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __13

__87:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __921
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __922
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __923
	}
	return -2
__923:
	;
__922:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__921:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __924
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __925
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __926
__925:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __927
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __928
__927:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __929
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __930
__929:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __931
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __932
__931:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__932:
	;
__930:
	;
__928:
	;
__926:
	;
__924:
	;

	switch fc {
	case Tuint32_t('\011'):
		goto __934
	case Tuint32_t('\040'):
		goto __935
	case Tuint32_t(uint8('\xa0')):
		goto __936
	case Tuint32_t(0x1680):
		goto __937 /* OGHAM SPACE MARK */
	case Tuint32_t(0x180e):
		goto __938 /* MONGOLIAN VOWEL SEPARATOR */
	case Tuint32_t(0x2000):
		goto __939 /* EN QUAD */
	case Tuint32_t(0x2001):
		goto __940 /* EM QUAD */
	case Tuint32_t(0x2002):
		goto __941 /* EN SPACE */
	case Tuint32_t(0x2003):
		goto __942 /* EM SPACE */
	case Tuint32_t(0x2004):
		goto __943 /* THREE-PER-EM SPACE */
	case Tuint32_t(0x2005):
		goto __944 /* FOUR-PER-EM SPACE */
	case Tuint32_t(0x2006):
		goto __945 /* SIX-PER-EM SPACE */
	case Tuint32_t(0x2007):
		goto __946 /* FIGURE SPACE */
	case Tuint32_t(0x2008):
		goto __947 /* PUNCTUATION SPACE */
	case Tuint32_t(0x2009):
		goto __948 /* THIN SPACE */
	case Tuint32_t(0x200A):
		goto __949 /* HAIR SPACE */
	case Tuint32_t(0x202f):
		goto __950 /* NARROW NO-BREAK SPACE */
	case Tuint32_t(0x205f):
		goto __951 /* MEDIUM MATHEMATICAL SPACE */
	case Tuint32_t(0x3000):
		goto __952 // Byte and multibyte cases
	default:
		goto __953
	}
	goto __933

__934:
__935:
__936:
__937: /* OGHAM SPACE MARK */
__938: /* MONGOLIAN VOWEL SEPARATOR */
__939: /* EN QUAD */
__940: /* EM QUAD */
__941: /* EN SPACE */
__942: /* EM SPACE */
__943: /* THREE-PER-EM SPACE */
__944: /* FOUR-PER-EM SPACE */
__945: /* SIX-PER-EM SPACE */
__946: /* FIGURE SPACE */
__947: /* PUNCTUATION SPACE */
__948: /* THIN SPACE */
__949: /* HAIR SPACE */
__950: /* NARROW NO-BREAK SPACE */
__951: /* MEDIUM MATHEMATICAL SPACE */
__952:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
	// Byte and multibyte cases
__953:
	goto __933
__933:
	;
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __13

__88:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __954
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __955
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __956
	}
	return -2
__956:
	;
__955:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__954:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __957
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __958
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __959
__958:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __960
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __961
__960:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __962
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __963
__962:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __964
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __965
__964:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__965:
	;
__963:
	;
__961:
	;
__959:
	;
__957:
	;

	switch fc {
	case Tuint32_t('\011'):
		goto __967
	case Tuint32_t('\040'):
		goto __968
	case Tuint32_t(uint8('\xa0')):
		goto __969
	case Tuint32_t(0x1680):
		goto __970 /* OGHAM SPACE MARK */
	case Tuint32_t(0x180e):
		goto __971 /* MONGOLIAN VOWEL SEPARATOR */
	case Tuint32_t(0x2000):
		goto __972 /* EN QUAD */
	case Tuint32_t(0x2001):
		goto __973 /* EM QUAD */
	case Tuint32_t(0x2002):
		goto __974 /* EN SPACE */
	case Tuint32_t(0x2003):
		goto __975 /* EM SPACE */
	case Tuint32_t(0x2004):
		goto __976 /* THREE-PER-EM SPACE */
	case Tuint32_t(0x2005):
		goto __977 /* FOUR-PER-EM SPACE */
	case Tuint32_t(0x2006):
		goto __978 /* SIX-PER-EM SPACE */
	case Tuint32_t(0x2007):
		goto __979 /* FIGURE SPACE */
	case Tuint32_t(0x2008):
		goto __980 /* PUNCTUATION SPACE */
	case Tuint32_t(0x2009):
		goto __981 /* THIN SPACE */
	case Tuint32_t(0x200A):
		goto __982 /* HAIR SPACE */
	case Tuint32_t(0x202f):
		goto __983 /* NARROW NO-BREAK SPACE */
	case Tuint32_t(0x205f):
		goto __984 /* MEDIUM MATHEMATICAL SPACE */
	case Tuint32_t(0x3000):
		goto __985 // Byte and multibyte cases
	default:
		goto __986
	}
	goto __966

__967:
__968:
__969:
__970: /* OGHAM SPACE MARK */
__971: /* MONGOLIAN VOWEL SEPARATOR */
__972: /* EN QUAD */
__973: /* EM QUAD */
__974: /* EN SPACE */
__975: /* EM SPACE */
__976: /* THREE-PER-EM SPACE */
__977: /* FOUR-PER-EM SPACE */
__978: /* SIX-PER-EM SPACE */
__979: /* FIGURE SPACE */
__980: /* PUNCTUATION SPACE */
__981: /* THIN SPACE */
__982: /* HAIR SPACE */
__983: /* NARROW NO-BREAK SPACE */
__984: /* MEDIUM MATHEMATICAL SPACE */
__985:
	goto __966 // Byte and multibyte cases
__986:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__966:
	;
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __13

__89:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __987
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __988
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __989
	}
	return -2
__989:
	;
__988:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__987:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __990
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __991
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __992
__991:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __993
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __994
__993:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __995
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __996
__995:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __997
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __998
__997:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__998:
	;
__996:
	;
__994:
	;
__992:
	;
__990:
	;

	switch fc {
	case Tuint32_t('\012'):
		goto __1000
	case Tuint32_t('\013'):
		goto __1001
	case Tuint32_t('\014'):
		goto __1002
	case Tuint32_t('\015'):
		goto __1003
	case Tuint32_t(uint8('\x85')):
		goto __1004
	case Tuint32_t(0x2028):
		goto __1005 /* LINE SEPARATOR */
	case Tuint32_t(0x2029):
		goto __1006
	default:
		goto __1007
	}
	goto __999

__1000:
__1001:
__1002:
__1003:
__1004:
__1005: /* LINE SEPARATOR */
__1006:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1007:
	goto __999
__999:
	;
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __13

__90:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1008
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1009
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1010
	}
	return -2
__1010:
	;
__1009:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1008:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1011
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __1012
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1013
__1012:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __1014
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1015
__1014:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __1016
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1017
__1016:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __1018
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1019
__1018:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__1019:
	;
__1017:
	;
__1015:
	;
__1013:
	;
__1011:
	;

	switch fc {
	case Tuint32_t('\012'):
		goto __1021
	case Tuint32_t('\013'):
		goto __1022
	case Tuint32_t('\014'):
		goto __1023
	case Tuint32_t('\015'):
		goto __1024
	case Tuint32_t(uint8('\x85')):
		goto __1025
	case Tuint32_t(0x2028):
		goto __1026 /* LINE SEPARATOR */
	case Tuint32_t(0x2029):
		goto __1027
	default:
		goto __1028
	}
	goto __1020

__1021:
__1022:
__1023:
__1024:
__1025:
__1026: /* LINE SEPARATOR */
__1027:
	goto __1020
__1028:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1020:
	;
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __13

	// =====================================================================
	// Check the next character by Unicode property. We will get here only
	//     if the support is in the binary; otherwise a compile-time error occurs.

__91:
__92:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1029
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1030
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1031
	}
	return -2
__1031:
	;
__1030:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1029:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1032
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __1033
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1034
__1033:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __1035
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1036
__1035:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __1037
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1038
__1037:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __1039
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1040
__1039:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__1040:
	;
__1038:
	;
__1036:
	;
__1034:
	;
__1032:
	;

	prop = uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12
	notmatch = libc.Bool32(int32((*Theapframe)(unsafe.Pointer(F)).Fop) == OP_NOTPROP)

	switch int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1))) {
	case DPT_ANY:
		goto __1042

	case DPT_LAMP:
		goto __1043

	case DPT_GC:
		goto __1044

	case DPT_PC:
		goto __1045

	case DPT_SC:
		goto __1046

	case DPT_SCX:
		goto __1047

	// These are specials

	case DPT_ALNUM:
		goto __1048

	// Perl space used to exclude VT, but from Perl 5.18 it is included,
	//         which means that Perl space and POSIX space are now identical. PCRE
	//         was changed at release 8.34.

	case DPT_SPACE:
		goto __1049 // Perl space
	case DPT_PXSPACE:
		goto __1050

	case DPT_WORD:
		goto __1051

	case DPT_CLIST:
		goto __1052

	case DPT_UCNC:
		goto __1053

	case DPT_BIDICL:
		goto __1054

	case DPT_BOOL:
		goto __1055

	// This should never occur

	default:
		goto __1056
	}
	goto __1041

__1042:
	if !(notmatch != 0) {
		goto __1057
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1057:
	;

	goto __1041

__1043:
	if !(libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop)).Fchartype) == ucp_Lu || int32((*Tucd_record)(unsafe.Pointer(prop)).Fchartype) == ucp_Ll || int32((*Tucd_record)(unsafe.Pointer(prop)).Fchartype) == ucp_Lt) == notmatch) {
		goto __1058
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1058:
	;

	goto __1041

__1044:
	if !(libc.Bool32(Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))) == X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype]) == notmatch) {
		goto __1059
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1059:
	;

	goto __1041

__1045:
	if !(libc.Bool32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))) == int32((*Tucd_record)(unsafe.Pointer(prop)).Fchartype)) == notmatch) {
		goto __1060
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1060:
	;

	goto __1041

__1046:
	if !(libc.Bool32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))) == int32((*Tucd_record)(unsafe.Pointer(prop)).Fscript)) == notmatch) {
		goto __1061
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1061:
	;

	goto __1041

__1047:

	ok = libc.Bool32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))) == int32((*Tucd_record)(unsafe.Pointer(prop)).Fscript) || *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_script_sets_8)) + uintptr(int32((*Tucd_record)(unsafe.Pointer(prop)).Fscriptx_bidiclass)&DUCD_SCRIPTX_MASK)*4 + uintptr(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))/32)*4))&(uint32(1)<<(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))%32)) != Tuint32_t(0))
	if !(ok == notmatch) {
		goto __1062
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1062:
	;

	goto __1041

	// These are specials

__1048:
	if !(libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_L || X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_N) == notmatch) {
		goto __1063
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1063:
	;

	goto __1041

	// Perl space used to exclude VT, but from Perl 5.18 it is included,
	//         which means that Perl space and POSIX space are now identical. PCRE
	//         was changed at release 8.34.

__1049: // Perl space
__1050: // POSIX space
	switch fc {
	case Tuint32_t('\011'):
		goto __1065
	case Tuint32_t('\040'):
		goto __1066
	case Tuint32_t(uint8('\xa0')):
		goto __1067
	case Tuint32_t(0x1680):
		goto __1068 /* OGHAM SPACE MARK */
	case Tuint32_t(0x180e):
		goto __1069 /* MONGOLIAN VOWEL SEPARATOR */
	case Tuint32_t(0x2000):
		goto __1070 /* EN QUAD */
	case Tuint32_t(0x2001):
		goto __1071 /* EM QUAD */
	case Tuint32_t(0x2002):
		goto __1072 /* EN SPACE */
	case Tuint32_t(0x2003):
		goto __1073 /* EM SPACE */
	case Tuint32_t(0x2004):
		goto __1074 /* THREE-PER-EM SPACE */
	case Tuint32_t(0x2005):
		goto __1075 /* FOUR-PER-EM SPACE */
	case Tuint32_t(0x2006):
		goto __1076 /* SIX-PER-EM SPACE */
	case Tuint32_t(0x2007):
		goto __1077 /* FIGURE SPACE */
	case Tuint32_t(0x2008):
		goto __1078 /* PUNCTUATION SPACE */
	case Tuint32_t(0x2009):
		goto __1079 /* THIN SPACE */
	case Tuint32_t(0x200A):
		goto __1080 /* HAIR SPACE */
	case Tuint32_t(0x202f):
		goto __1081 /* NARROW NO-BREAK SPACE */
	case Tuint32_t(0x205f):
		goto __1082 /* MEDIUM MATHEMATICAL SPACE */
	case Tuint32_t(0x3000):
		goto __1083
	case Tuint32_t('\012'):
		goto __1084
	case Tuint32_t('\013'):
		goto __1085
	case Tuint32_t('\014'):
		goto __1086
	case Tuint32_t('\015'):
		goto __1087
	case Tuint32_t(uint8('\x85')):
		goto __1088
	case Tuint32_t(0x2028):
		goto __1089 /* LINE SEPARATOR */
	case Tuint32_t(0x2029):
		goto __1090

	default:
		goto __1091
	}
	goto __1064

__1065:
__1066:
__1067:
__1068: /* OGHAM SPACE MARK */
__1069: /* MONGOLIAN VOWEL SEPARATOR */
__1070: /* EN QUAD */
__1071: /* EM QUAD */
__1072: /* EN SPACE */
__1073: /* EM SPACE */
__1074: /* THREE-PER-EM SPACE */
__1075: /* FOUR-PER-EM SPACE */
__1076: /* SIX-PER-EM SPACE */
__1077: /* FIGURE SPACE */
__1078: /* PUNCTUATION SPACE */
__1079: /* THIN SPACE */
__1080: /* HAIR SPACE */
__1081: /* NARROW NO-BREAK SPACE */
__1082: /* MEDIUM MATHEMATICAL SPACE */
__1083:
__1084:
__1085:
__1086:
__1087:
__1088:
__1089: /* LINE SEPARATOR */
__1090:
	if !(notmatch != 0) {
		goto __1092
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1092:
	;

	goto __1064

__1091:
	if !(libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_Z) == notmatch) {
		goto __1093
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1093:
	;

	goto __1064
__1064:
	;
	goto __1041

__1051:
	if !(libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_L || X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_N || fc == Tuint32_t('\137')) == notmatch) {
		goto __1094
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1094:
	;

	goto __1041

__1052:
	cp = uintptr(unsafe.Pointer(&X_pcre2_ucd_caseless_sets_8)) + uintptr(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))*4
__1095:

	if !(fc < *(*Tuint32_t)(unsafe.Pointer(cp))) {
		goto __1098
	}
	if !(notmatch != 0) {
		goto __1099
	}
	goto __1097
	goto __1100
__1099:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1100:
	;
__1098:
	;
	if !(fc == *(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&cp, 4)))) {
		goto __1101
	}
	if !(notmatch != 0) {
		goto __1102
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
	goto __1103
__1102:
	goto __1097
__1103:
	;
__1101:
	;
	goto __1096
__1096:
	goto __1095
	goto __1097
__1097:
	;
	goto __1041

__1053:
	if !(libc.Bool32(fc == Tuint32_t('\044') || fc == Tuint32_t('\100') || fc == Tuint32_t('\140') || fc >= Tuint32_t(0xa0) && fc <= Tuint32_t(0xd7ff) || fc >= Tuint32_t(0xe000)) == notmatch) {
		goto __1104
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1104:
	;

	goto __1041

__1054:
	if !(libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop)).Fscriptx_bidiclass)>>DUCD_BIDICLASS_SHIFT == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))) == notmatch) {
		goto __1105
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1105:
	;

	goto __1041

__1055:

	ok1 = libc.Bool32(*(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_boolprop_sets_8)) + uintptr(int32((*Tucd_record)(unsafe.Pointer(prop)).Fbprops)&DUCD_BPROPS_MASK)*4 + uintptr(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))/32)*4))&(uint32(1)<<(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))%32)) != Tuint32_t(0))
	if !(ok1 == notmatch) {
		goto __1106
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1106:
	;

	goto __1041

	// This should never occur

__1056:
	return -44
__1041:
	;

	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += uintptr(3)

	goto __13

	// =====================================================================
	// Match an extended Unicode sequence. We will get here only if the support
	//     is in the binary; otherwise a compile-time error occurs.

__93:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1107
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1109
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1110
	}
	return -2
__1110:
	;
__1109:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

	goto __1108
__1107:

	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1111
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __1112
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1113
__1112:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __1114
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1115
__1114:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __1116
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1117
__1116:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __1118
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1119
__1118:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__1119:
	;
__1117:
	;
__1115:
	;
__1113:
	;
__1111:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr = X_pcre2_extuni_8(tls, fc, (*Theapframe)(unsafe.Pointer(F)).Feptr, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject, utf,
		uintptr(0))
__1108:
	;
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1120
	}
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1121
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1122
	}
	return -2
__1122:
	;
__1121:
	;
__1120:
	;

	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __13

	// =====================================================================
	// Match a single character type repeatedly. Note that the property type
	//     does not need to be in a stack frame as it is not used within an RMATCH()
	//     loop.

__94:
	*(*Tuint32_t)(unsafe.Pointer(F + 56)) = libc.AssignPtrUint32(F+56+1*4, uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))))
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8(1 + DIMM2_SIZE)
	goto REPEATTYPE

__95:
__96:
	*(*Tuint32_t)(unsafe.Pointer(F + 56)) = Tuint32_t(0)
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4)) = uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))))
	if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) == OP_TYPEMINUPTO {
		reptype = REPTYPE_MIN
	} else {
		reptype = REPTYPE_MAX
	}
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8(1 + DIMM2_SIZE)
	goto REPEATTYPE

__97:
	reptype = REPTYPE_POS
	*(*Tuint32_t)(unsafe.Pointer(F + 56)) = Tuint32_t(0)
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4)) = 4294967295
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto REPEATTYPE

__98:
	reptype = REPTYPE_POS
	*(*Tuint32_t)(unsafe.Pointer(F + 56)) = Tuint32_t(1)
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4)) = 4294967295
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto REPEATTYPE

__99:
	reptype = REPTYPE_POS
	*(*Tuint32_t)(unsafe.Pointer(F + 56)) = Tuint32_t(0)
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4)) = Tuint32_t(1)
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto REPEATTYPE

__100:
	reptype = REPTYPE_POS
	*(*Tuint32_t)(unsafe.Pointer(F + 56)) = Tuint32_t(0)
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4)) = uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))))
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8(1 + DIMM2_SIZE)
	goto REPEATTYPE

__101:
__102:
__103:
__104:
__105:
__106:
	fc = Tuint32_t(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Fecode, 1)))) - OP_TYPESTAR)
	*(*Tuint32_t)(unsafe.Pointer(F + 56)) = rep_min[fc]
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4)) = rep_max[fc]
	reptype = rep_typ[fc]

	// Common code for all repeated character type matches.

REPEATTYPE:
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Fecode, 1)))) // Code for the character type

	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) == OP_PROP || *(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) == OP_NOTPROP) {
		goto __1123
	}

	proptype = int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Fecode, 1))))
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4)) = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Fecode, 1))))
	goto __1124
__1123:
	proptype = -1
__1124:
	;

	// First, ensure the minimum number of matches are present. Use inline
	//     code for maximizing the speed, and do the type test once at the start
	//     (i.e. keep it out of the loops). As there are no calls to RMATCH in the
	//     loops, we can use an ordinary variable for "notmatch". The code for UTF
	//     mode is separated out for tidiness, except for Unicode property tests.

	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56)) > Tuint32_t(0)) {
		goto __1125
	}

	if !(proptype >= 0) {
		goto __1126
	} /* Property tests in all modes */

	notmatch1 = libc.Bool32(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) == OP_NOTPROP)
	switch proptype {
	case DPT_ANY:
		goto __1129

	case DPT_LAMP:
		goto __1130

	case DPT_GC:
		goto __1131

	case DPT_PC:
		goto __1132

	case DPT_SC:
		goto __1133

	case DPT_SCX:
		goto __1134

	case DPT_ALNUM:
		goto __1135

	// Perl space used to exclude VT, but from Perl 5.18 it is included,
	//           which means that Perl space and POSIX space are now identical. PCRE
	//           was changed at release 8.34.

	case DPT_SPACE:
		goto __1136 // Perl space
	case DPT_PXSPACE:
		goto __1137

	case DPT_WORD:
		goto __1138

	case DPT_CLIST:
		goto __1139

	case DPT_UCNC:
		goto __1140

	case DPT_BIDICL:
		goto __1141

	case DPT_BOOL:
		goto __1142

	// This should not occur

	default:
		goto __1143
	}
	goto __1128

__1129:
	if !(notmatch1 != 0) {
		goto __1144
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1144:
	;

	i = Tuint32_t(1)
__1145:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __1147
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1148
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1149
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1150
	}
	return -2
__1150:
	;
__1149:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1148:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1151
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __1152
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1153
__1152:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __1154
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1155
__1154:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __1156
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1157
__1156:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __1158
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1159
__1158:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__1159:
	;
__1157:
	;
__1155:
	;
__1153:
	;
__1151:
	;

	goto __1146
__1146:
	i++
	goto __1145
	goto __1147
__1147:
	;
	goto __1128

__1130:
	i = Tuint32_t(1)
__1160:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __1162
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1163
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1164
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1165
	}
	return -2
__1165:
	;
__1164:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1163:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1166
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __1167
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1168
__1167:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __1169
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1170
__1169:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __1171
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1172
__1171:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __1173
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1174
__1173:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__1174:
	;
__1172:
	;
__1170:
	;
__1168:
	;
__1166:
	;

	chartype = int32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fchartype)
	if !(libc.Bool32(chartype == ucp_Lu || chartype == ucp_Ll || chartype == ucp_Lt) == notmatch1) {
		goto __1175
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1175:
	;

	goto __1161
__1161:
	i++
	goto __1160
	goto __1162
__1162:
	;
	goto __1128

__1131:
	i = Tuint32_t(1)
__1176:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __1178
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1179
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1180
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1181
	}
	return -2
__1181:
	;
__1180:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1179:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1182
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __1183
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1184
__1183:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __1185
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1186
__1185:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __1187
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1188
__1187:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __1189
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1190
__1189:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__1190:
	;
__1188:
	;
__1186:
	;
__1184:
	;
__1182:
	;

	if !(libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fchartype] == *(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4))) == notmatch1) {
		goto __1191
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1191:
	;

	goto __1177
__1177:
	i++
	goto __1176
	goto __1178
__1178:
	;
	goto __1128

__1132:
	i = Tuint32_t(1)
__1192:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __1194
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1195
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1196
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1197
	}
	return -2
__1197:
	;
__1196:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1195:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1198
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __1199
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1200
__1199:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __1201
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1202
__1201:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __1203
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1204
__1203:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __1205
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1206
__1205:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__1206:
	;
__1204:
	;
__1202:
	;
__1200:
	;
__1198:
	;

	if !(libc.Bool32(Tuint32_t((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fchartype) == *(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4))) == notmatch1) {
		goto __1207
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1207:
	;

	goto __1193
__1193:
	i++
	goto __1192
	goto __1194
__1194:
	;
	goto __1128

__1133:
	i = Tuint32_t(1)
__1208:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __1210
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1211
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1212
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1213
	}
	return -2
__1213:
	;
__1212:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1211:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1214
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __1215
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1216
__1215:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __1217
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1218
__1217:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __1219
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1220
__1219:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __1221
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1222
__1221:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__1222:
	;
__1220:
	;
__1218:
	;
__1216:
	;
__1214:
	;

	if !(libc.Bool32(Tuint32_t((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fscript) == *(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4))) == notmatch1) {
		goto __1223
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1223:
	;

	goto __1209
__1209:
	i++
	goto __1208
	goto __1210
__1210:
	;
	goto __1128

__1134:
	i = Tuint32_t(1)
__1224:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __1226
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1227
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1228
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1229
	}
	return -2
__1229:
	;
__1228:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1227:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1230
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __1231
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1232
__1231:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __1233
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1234
__1233:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __1235
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1236
__1235:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __1237
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1238
__1237:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__1238:
	;
__1236:
	;
__1234:
	;
__1232:
	;
__1230:
	;

	prop1 = uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12
	ok2 = libc.Bool32(Tuint32_t((*Tucd_record)(unsafe.Pointer(prop1)).Fscript) == *(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4)) || *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_script_sets_8)) + uintptr(int32((*Tucd_record)(unsafe.Pointer(prop1)).Fscriptx_bidiclass)&DUCD_SCRIPTX_MASK)*4 + uintptr(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4))/Tuint32_t(32))*4))&(uint32(1)<<(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4))%Tuint32_t(32))) != Tuint32_t(0))
	if !(ok2 == notmatch1) {
		goto __1239
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1239:
	;

	goto __1225
__1225:
	i++
	goto __1224
	goto __1226
__1226:
	;
	goto __1128

__1135:
	i = Tuint32_t(1)
__1240:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __1242
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1243
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1244
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1245
	}
	return -2
__1245:
	;
__1244:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1243:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1246
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __1247
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1248
__1247:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __1249
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1250
__1249:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __1251
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1252
__1251:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __1253
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1254
__1253:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__1254:
	;
__1252:
	;
__1250:
	;
__1248:
	;
__1246:
	;

	category = int32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fchartype])
	if !(libc.Bool32(category == ucp_L || category == ucp_N) == notmatch1) {
		goto __1255
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1255:
	;

	goto __1241
__1241:
	i++
	goto __1240
	goto __1242
__1242:
	;
	goto __1128

	// Perl space used to exclude VT, but from Perl 5.18 it is included,
	//           which means that Perl space and POSIX space are now identical. PCRE
	//           was changed at release 8.34.

__1136: // Perl space
__1137: // POSIX space
	i = Tuint32_t(1)
__1256:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __1258
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1259
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1260
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1261
	}
	return -2
__1261:
	;
__1260:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1259:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1262
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __1263
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1264
__1263:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __1265
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1266
__1265:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __1267
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1268
__1267:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __1269
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1270
__1269:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__1270:
	;
__1268:
	;
__1266:
	;
__1264:
	;
__1262:
	;

	switch fc {
	case Tuint32_t('\011'):
		goto __1272
	case Tuint32_t('\040'):
		goto __1273
	case Tuint32_t(uint8('\xa0')):
		goto __1274
	case Tuint32_t(0x1680):
		goto __1275 /* OGHAM SPACE MARK */
	case Tuint32_t(0x180e):
		goto __1276 /* MONGOLIAN VOWEL SEPARATOR */
	case Tuint32_t(0x2000):
		goto __1277 /* EN QUAD */
	case Tuint32_t(0x2001):
		goto __1278 /* EM QUAD */
	case Tuint32_t(0x2002):
		goto __1279 /* EN SPACE */
	case Tuint32_t(0x2003):
		goto __1280 /* EM SPACE */
	case Tuint32_t(0x2004):
		goto __1281 /* THREE-PER-EM SPACE */
	case Tuint32_t(0x2005):
		goto __1282 /* FOUR-PER-EM SPACE */
	case Tuint32_t(0x2006):
		goto __1283 /* SIX-PER-EM SPACE */
	case Tuint32_t(0x2007):
		goto __1284 /* FIGURE SPACE */
	case Tuint32_t(0x2008):
		goto __1285 /* PUNCTUATION SPACE */
	case Tuint32_t(0x2009):
		goto __1286 /* THIN SPACE */
	case Tuint32_t(0x200A):
		goto __1287 /* HAIR SPACE */
	case Tuint32_t(0x202f):
		goto __1288 /* NARROW NO-BREAK SPACE */
	case Tuint32_t(0x205f):
		goto __1289 /* MEDIUM MATHEMATICAL SPACE */
	case Tuint32_t(0x3000):
		goto __1290
	case Tuint32_t('\012'):
		goto __1291
	case Tuint32_t('\013'):
		goto __1292
	case Tuint32_t('\014'):
		goto __1293
	case Tuint32_t('\015'):
		goto __1294
	case Tuint32_t(uint8('\x85')):
		goto __1295
	case Tuint32_t(0x2028):
		goto __1296 /* LINE SEPARATOR */
	case Tuint32_t(0x2029):
		goto __1297

	default:
		goto __1298
	}
	goto __1271

__1272:
__1273:
__1274:
__1275: /* OGHAM SPACE MARK */
__1276: /* MONGOLIAN VOWEL SEPARATOR */
__1277: /* EN QUAD */
__1278: /* EM QUAD */
__1279: /* EN SPACE */
__1280: /* EM SPACE */
__1281: /* THREE-PER-EM SPACE */
__1282: /* FOUR-PER-EM SPACE */
__1283: /* SIX-PER-EM SPACE */
__1284: /* FIGURE SPACE */
__1285: /* PUNCTUATION SPACE */
__1286: /* THIN SPACE */
__1287: /* HAIR SPACE */
__1288: /* NARROW NO-BREAK SPACE */
__1289: /* MEDIUM MATHEMATICAL SPACE */
__1290:
__1291:
__1292:
__1293:
__1294:
__1295:
__1296: /* LINE SEPARATOR */
__1297:
	if !(notmatch1 != 0) {
		goto __1299
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1299:
	;

	goto __1271

__1298:
	if !(libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fchartype] == ucp_Z) == notmatch1) {
		goto __1300
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1300:
	;

	goto __1271
__1271:
	;
	goto __1257
__1257:
	i++
	goto __1256
	goto __1258
__1258:
	;
	goto __1128

__1138:
	i = Tuint32_t(1)
__1301:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __1303
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1304
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1305
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1306
	}
	return -2
__1306:
	;
__1305:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1304:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1307
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __1308
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1309
__1308:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __1310
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1311
__1310:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __1312
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1313
__1312:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __1314
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1315
__1314:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__1315:
	;
__1313:
	;
__1311:
	;
__1309:
	;
__1307:
	;

	category1 = int32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fchartype])
	if !(libc.Bool32(category1 == ucp_L || category1 == ucp_N || fc == Tuint32_t('\137')) == notmatch1) {
		goto __1316
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1316:
	;

	goto __1302
__1302:
	i++
	goto __1301
	goto __1303
__1303:
	;
	goto __1128

__1139:
	i = Tuint32_t(1)
__1317:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __1319
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1320
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1321
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1322
	}
	return -2
__1322:
	;
__1321:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1320:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1323
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __1324
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1325
__1324:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __1326
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1327
__1326:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __1328
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1329
__1328:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __1330
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1331
__1330:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__1331:
	;
__1329:
	;
__1327:
	;
__1325:
	;
__1323:
	;

	cp1 = uintptr(unsafe.Pointer(&X_pcre2_ucd_caseless_sets_8)) + uintptr(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4)))*4
__1332:

	if !(fc < *(*Tuint32_t)(unsafe.Pointer(cp1))) {
		goto __1335
	}

	if !(notmatch1 != 0) {
		goto __1336
	}
	goto __1334
__1336:
	;
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1335:
	;
	if !(fc == *(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&cp1, 4)))) {
		goto __1337
	}

	if !(notmatch1 != 0) {
		goto __1338
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1338:
	;

	goto __1334
__1337:
	;
	goto __1333
__1333:
	goto __1332
	goto __1334
__1334:
	;
	goto __1318
__1318:
	i++
	goto __1317
	goto __1319
__1319:
	;
	goto __1128

__1140:
	i = Tuint32_t(1)
__1339:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __1341
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1342
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1343
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1344
	}
	return -2
__1344:
	;
__1343:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1342:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1345
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __1346
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1347
__1346:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __1348
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1349
__1348:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __1350
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1351
__1350:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __1352
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1353
__1352:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__1353:
	;
__1351:
	;
__1349:
	;
__1347:
	;
__1345:
	;

	if !(libc.Bool32(fc == Tuint32_t('\044') || fc == Tuint32_t('\100') || fc == Tuint32_t('\140') || fc >= Tuint32_t(0xa0) && fc <= Tuint32_t(0xd7ff) || fc >= Tuint32_t(0xe000)) == notmatch1) {
		goto __1354
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1354:
	;

	goto __1340
__1340:
	i++
	goto __1339
	goto __1341
__1341:
	;
	goto __1128

__1141:
	i = Tuint32_t(1)
__1355:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __1357
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1358
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1359
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1360
	}
	return -2
__1360:
	;
__1359:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1358:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1361
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __1362
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1363
__1362:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __1364
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1365
__1364:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __1366
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1367
__1366:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __1368
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1369
__1368:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__1369:
	;
__1367:
	;
__1365:
	;
__1363:
	;
__1361:
	;

	if !(libc.Bool32(Tuint32_t(int32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fscriptx_bidiclass)>>DUCD_BIDICLASS_SHIFT) == *(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4))) == notmatch1) {
		goto __1370
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1370:
	;

	goto __1356
__1356:
	i++
	goto __1355
	goto __1357
__1357:
	;
	goto __1128

__1142:
	i = Tuint32_t(1)
__1371:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __1373
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1374
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1375
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1376
	}
	return -2
__1376:
	;
__1375:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1374:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1377
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __1378
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1379
__1378:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __1380
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1381
__1380:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __1382
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1383
__1382:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __1384
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1385
__1384:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__1385:
	;
__1383:
	;
__1381:
	;
__1379:
	;
__1377:
	;

	prop2 = uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12
	ok3 = libc.Bool32(*(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_boolprop_sets_8)) + uintptr(int32((*Tucd_record)(unsafe.Pointer(prop2)).Fbprops)&DUCD_BPROPS_MASK)*4 + uintptr(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4))/Tuint32_t(32))*4))&(uint32(1)<<(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4))%Tuint32_t(32))) != Tuint32_t(0))
	if !(ok3 == notmatch1) {
		goto __1386
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1386:
	;

	goto __1372
__1372:
	i++
	goto __1371
	goto __1373
__1373:
	;
	goto __1128

	// This should not occur

__1143:
	return -44
__1128:
	;
	goto __1127
__1126:
	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) == OP_EXTUNI) {
		goto __1387
	}

	i = Tuint32_t(1)
__1389:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __1391
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1392
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1394
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1395
	}
	return -2
__1395:
	;
__1394:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

	goto __1393
__1392:

	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1396
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __1397
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1398
__1397:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __1399
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1400
__1399:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __1401
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1402
__1401:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __1403
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1404
__1403:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__1404:
	;
__1402:
	;
__1400:
	;
__1398:
	;
__1396:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr = X_pcre2_extuni_8(tls, fc, (*Theapframe)(unsafe.Pointer(F)).Feptr, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject,
		(*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject, utf, uintptr(0))
__1393:
	;
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1405
	}
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1406
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1407
	}
	return -2
__1407:
	;
__1406:
	;
__1405:
	;

	goto __1390
__1390:
	i++
	goto __1389
	goto __1391
__1391:
	;
	goto __1388
__1387:

	// Handle all other cases in UTF mode

	if !(utf != 0) {
		goto __1408
	}
	switch *(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) {
	case OP_ANY:
		goto __1411

	case OP_ALLANY:
		goto __1412

	case OP_ANYBYTE:
		goto __1413

	case OP_ANYNL:
		goto __1414

	case OP_NOT_HSPACE:
		goto __1415

	case OP_HSPACE:
		goto __1416

	case OP_NOT_VSPACE:
		goto __1417

	case OP_VSPACE:
		goto __1418

	case OP_NOT_DIGIT:
		goto __1419

	case OP_DIGIT:
		goto __1420

	case OP_NOT_WHITESPACE:
		goto __1421

	case OP_WHITESPACE:
		goto __1422

	case OP_NOT_WORDCHAR:
		goto __1423

	case OP_WORDCHAR:
		goto __1424

	default:
		goto __1425
	}
	goto __1410

__1411:
	i = Tuint32_t(1)
__1426:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __1428
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1429
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1430
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1431
	}
	return -2
__1431:
	;
__1430:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1429:
	;
	if !(func() int32 {
		if (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype != Tuint32_t(DNLTYPE_FIXED) {
			return libc.Bool32((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, (*Theapframe)(unsafe.Pointer(F)).Feptr, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+256, utf) != 0)
		}
		return libc.Bool32((*Theapframe)(unsafe.Pointer(F)).Feptr <= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260))) && ((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(1) || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + uintptr(1)))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260 + 1)))))
	}() != 0) {
		goto __1432
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1432:
	;

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && (*Theapframe)(unsafe.Pointer(F)).Feptr+uintptr(1) >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype == Tuint32_t(DNLTYPE_FIXED) && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(2) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260)))) {
		goto __1433
	}

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1434
	}
	return -2
__1434:
	;
__1433:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
__1435:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0xc0 == 0x80) {
		goto __1436
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __1435
__1436:
	;
	goto __1427
__1427:
	i++
	goto __1426
	goto __1428
__1428:
	;
	goto __1410

__1412:
	i = Tuint32_t(1)
__1437:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __1439
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1440
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1441
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1442
	}
	return -2
__1442:
	;
__1441:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1440:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
__1443:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0xc0 == 0x80) {
		goto __1444
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __1443
__1444:
	;
	goto __1438
__1438:
	i++
	goto __1437
	goto __1439
__1439:
	;
	goto __1410

__1413:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr(*(*Tuint32_t)(unsafe.Pointer(F + 56)))) {
		goto __1445
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1445:
	;

	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += TPCRE2_SPTR8(*(*Tuint32_t)(unsafe.Pointer(F + 56)))
	goto __1410

__1414:
	i = Tuint32_t(1)
__1446:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __1448
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1449
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1450
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1451
	}
	return -2
__1451:
	;
__1450:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1449:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(fc >= 0xc0) {
		goto __1452
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __1453
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1454
__1453:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __1455
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1456
__1455:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __1457
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1458
__1457:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __1459
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1460
__1459:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__1460:
	;
__1458:
	;
__1456:
	;
__1454:
	;
__1452:
	;

	switch fc {
	default:
		goto __1462

	case Tuint32_t('\015'):
		goto __1463

	case Tuint32_t('\012'):
		goto __1464

	case Tuint32_t('\013'):
		goto __1465
	case Tuint32_t('\014'):
		goto __1466
	case Tuint32_t(uint8('\x85')):
		goto __1467
	case Tuint32_t(0x2028):
		goto __1468
	case Tuint32_t(0x2029):
		goto __1469
	}
	goto __1461

__1462:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1463:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == '\012') {
		goto __1470
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
__1470:
	;
	goto __1461

__1464:
	goto __1461

__1465:
__1466:
__1467:
__1468:
__1469:
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fbsr_convention) == DPCRE2_BSR_ANYCRLF) {
		goto __1471
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1471:
	;

	goto __1461
__1461:
	;
	goto __1447
__1447:
	i++
	goto __1446
	goto __1448
__1448:
	;
	goto __1410

__1415:
	i = Tuint32_t(1)
__1472:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __1474
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1475
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1476
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1477
	}
	return -2
__1477:
	;
__1476:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1475:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(fc >= 0xc0) {
		goto __1478
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __1479
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1480
__1479:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __1481
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1482
__1481:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __1483
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1484
__1483:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __1485
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1486
__1485:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__1486:
	;
__1484:
	;
__1482:
	;
__1480:
	;
__1478:
	;

	switch fc {
	case Tuint32_t('\011'):
		goto __1488
	case Tuint32_t('\040'):
		goto __1489
	case Tuint32_t(uint8('\xa0')):
		goto __1490
	case Tuint32_t(0x1680):
		goto __1491 /* OGHAM SPACE MARK */
	case Tuint32_t(0x180e):
		goto __1492 /* MONGOLIAN VOWEL SEPARATOR */
	case Tuint32_t(0x2000):
		goto __1493 /* EN QUAD */
	case Tuint32_t(0x2001):
		goto __1494 /* EM QUAD */
	case Tuint32_t(0x2002):
		goto __1495 /* EN SPACE */
	case Tuint32_t(0x2003):
		goto __1496 /* EM SPACE */
	case Tuint32_t(0x2004):
		goto __1497 /* THREE-PER-EM SPACE */
	case Tuint32_t(0x2005):
		goto __1498 /* FOUR-PER-EM SPACE */
	case Tuint32_t(0x2006):
		goto __1499 /* SIX-PER-EM SPACE */
	case Tuint32_t(0x2007):
		goto __1500 /* FIGURE SPACE */
	case Tuint32_t(0x2008):
		goto __1501 /* PUNCTUATION SPACE */
	case Tuint32_t(0x2009):
		goto __1502 /* THIN SPACE */
	case Tuint32_t(0x200A):
		goto __1503 /* HAIR SPACE */
	case Tuint32_t(0x202f):
		goto __1504 /* NARROW NO-BREAK SPACE */
	case Tuint32_t(0x205f):
		goto __1505 /* MEDIUM MATHEMATICAL SPACE */
	case Tuint32_t(0x3000):
		goto __1506
	default:
		goto __1507
	}
	goto __1487

__1488:
__1489:
__1490:
__1491: /* OGHAM SPACE MARK */
__1492: /* MONGOLIAN VOWEL SEPARATOR */
__1493: /* EN QUAD */
__1494: /* EM QUAD */
__1495: /* EN SPACE */
__1496: /* EM SPACE */
__1497: /* THREE-PER-EM SPACE */
__1498: /* FOUR-PER-EM SPACE */
__1499: /* SIX-PER-EM SPACE */
__1500: /* FIGURE SPACE */
__1501: /* PUNCTUATION SPACE */
__1502: /* THIN SPACE */
__1503: /* HAIR SPACE */
__1504: /* NARROW NO-BREAK SPACE */
__1505: /* MEDIUM MATHEMATICAL SPACE */
__1506:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1507:
	goto __1487
__1487:
	;
	goto __1473
__1473:
	i++
	goto __1472
	goto __1474
__1474:
	;
	goto __1410

__1416:
	i = Tuint32_t(1)
__1508:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __1510
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1511
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1512
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1513
	}
	return -2
__1513:
	;
__1512:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1511:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(fc >= 0xc0) {
		goto __1514
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __1515
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1516
__1515:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __1517
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1518
__1517:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __1519
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1520
__1519:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __1521
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1522
__1521:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__1522:
	;
__1520:
	;
__1518:
	;
__1516:
	;
__1514:
	;

	switch fc {
	case Tuint32_t('\011'):
		goto __1524
	case Tuint32_t('\040'):
		goto __1525
	case Tuint32_t(uint8('\xa0')):
		goto __1526
	case Tuint32_t(0x1680):
		goto __1527 /* OGHAM SPACE MARK */
	case Tuint32_t(0x180e):
		goto __1528 /* MONGOLIAN VOWEL SEPARATOR */
	case Tuint32_t(0x2000):
		goto __1529 /* EN QUAD */
	case Tuint32_t(0x2001):
		goto __1530 /* EM QUAD */
	case Tuint32_t(0x2002):
		goto __1531 /* EN SPACE */
	case Tuint32_t(0x2003):
		goto __1532 /* EM SPACE */
	case Tuint32_t(0x2004):
		goto __1533 /* THREE-PER-EM SPACE */
	case Tuint32_t(0x2005):
		goto __1534 /* FOUR-PER-EM SPACE */
	case Tuint32_t(0x2006):
		goto __1535 /* SIX-PER-EM SPACE */
	case Tuint32_t(0x2007):
		goto __1536 /* FIGURE SPACE */
	case Tuint32_t(0x2008):
		goto __1537 /* PUNCTUATION SPACE */
	case Tuint32_t(0x2009):
		goto __1538 /* THIN SPACE */
	case Tuint32_t(0x200A):
		goto __1539 /* HAIR SPACE */
	case Tuint32_t(0x202f):
		goto __1540 /* NARROW NO-BREAK SPACE */
	case Tuint32_t(0x205f):
		goto __1541 /* MEDIUM MATHEMATICAL SPACE */
	case Tuint32_t(0x3000):
		goto __1542
	default:
		goto __1543
	}
	goto __1523

__1524:
__1525:
__1526:
__1527: /* OGHAM SPACE MARK */
__1528: /* MONGOLIAN VOWEL SEPARATOR */
__1529: /* EN QUAD */
__1530: /* EM QUAD */
__1531: /* EN SPACE */
__1532: /* EM SPACE */
__1533: /* THREE-PER-EM SPACE */
__1534: /* FOUR-PER-EM SPACE */
__1535: /* SIX-PER-EM SPACE */
__1536: /* FIGURE SPACE */
__1537: /* PUNCTUATION SPACE */
__1538: /* THIN SPACE */
__1539: /* HAIR SPACE */
__1540: /* NARROW NO-BREAK SPACE */
__1541: /* MEDIUM MATHEMATICAL SPACE */
__1542:
	goto __1523
__1543:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1523:
	;
	goto __1509
__1509:
	i++
	goto __1508
	goto __1510
__1510:
	;
	goto __1410

__1417:
	i = Tuint32_t(1)
__1544:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __1546
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1547
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1548
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1549
	}
	return -2
__1549:
	;
__1548:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1547:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(fc >= 0xc0) {
		goto __1550
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __1551
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1552
__1551:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __1553
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1554
__1553:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __1555
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1556
__1555:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __1557
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1558
__1557:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__1558:
	;
__1556:
	;
__1554:
	;
__1552:
	;
__1550:
	;

	switch fc {
	case Tuint32_t('\012'):
		goto __1560
	case Tuint32_t('\013'):
		goto __1561
	case Tuint32_t('\014'):
		goto __1562
	case Tuint32_t('\015'):
		goto __1563
	case Tuint32_t(uint8('\x85')):
		goto __1564
	case Tuint32_t(0x2028):
		goto __1565 /* LINE SEPARATOR */
	case Tuint32_t(0x2029):
		goto __1566
	default:
		goto __1567
	}
	goto __1559

__1560:
__1561:
__1562:
__1563:
__1564:
__1565: /* LINE SEPARATOR */
__1566:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1567:
	goto __1559
__1559:
	;
	goto __1545
__1545:
	i++
	goto __1544
	goto __1546
__1546:
	;
	goto __1410

__1418:
	i = Tuint32_t(1)
__1568:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __1570
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1571
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1572
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1573
	}
	return -2
__1573:
	;
__1572:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1571:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(fc >= 0xc0) {
		goto __1574
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __1575
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1576
__1575:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __1577
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1578
__1577:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __1579
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1580
__1579:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __1581
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1582
__1581:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__1582:
	;
__1580:
	;
__1578:
	;
__1576:
	;
__1574:
	;

	switch fc {
	case Tuint32_t('\012'):
		goto __1584
	case Tuint32_t('\013'):
		goto __1585
	case Tuint32_t('\014'):
		goto __1586
	case Tuint32_t('\015'):
		goto __1587
	case Tuint32_t(uint8('\x85')):
		goto __1588
	case Tuint32_t(0x2028):
		goto __1589 /* LINE SEPARATOR */
	case Tuint32_t(0x2029):
		goto __1590
	default:
		goto __1591
	}
	goto __1583

__1584:
__1585:
__1586:
__1587:
__1588:
__1589: /* LINE SEPARATOR */
__1590:
	goto __1583
__1591:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1583:
	;
	goto __1569
__1569:
	i++
	goto __1568
	goto __1570
__1570:
	;
	goto __1410

__1419:
	i = Tuint32_t(1)
__1592:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __1594
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1595
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1596
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1597
	}
	return -2
__1597:
	;
__1596:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1595:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(fc >= 0xc0) {
		goto __1598
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __1599
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1600
__1599:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __1601
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1602
__1601:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __1603
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1604
__1603:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __1605
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1606
__1605:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__1606:
	;
__1604:
	;
__1602:
	;
__1600:
	;
__1598:
	;

	if !(fc < Tuint32_t(128) && int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_digit != 0) {
		goto __1607
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1607:
	;

	goto __1593
__1593:
	i++
	goto __1592
	goto __1594
__1594:
	;
	goto __1410

__1420:
	i = Tuint32_t(1)
__1608:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __1610
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1611
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1612
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1613
	}
	return -2
__1613:
	;
__1612:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1611:
	;
	cc5 = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(cc5 >= Tuint32_t(128) || int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(cc5))))&Dctype_digit == 0) {
		goto __1614
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1614:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	// No need to skip more code units - we know it has only one.
	goto __1609
__1609:
	i++
	goto __1608
	goto __1610
__1610:
	;
	goto __1410

__1421:
	i = Tuint32_t(1)
__1615:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __1617
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1618
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1619
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1620
	}
	return -2
__1620:
	;
__1619:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1618:
	;
	cc6 = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(cc6 < Tuint32_t(128) && int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(cc6))))&Dctype_space != 0) {
		goto __1621
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1621:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr++
__1622:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0xc0 == 0x80) {
		goto __1623
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __1622
__1623:
	;
	goto __1616
__1616:
	i++
	goto __1615
	goto __1617
__1617:
	;
	goto __1410

__1422:
	i = Tuint32_t(1)
__1624:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __1626
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1627
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1628
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1629
	}
	return -2
__1629:
	;
__1628:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1627:
	;
	cc7 = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(cc7 >= Tuint32_t(128) || int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(cc7))))&Dctype_space == 0) {
		goto __1630
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1630:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	// No need to skip more code units - we know it has only one.
	goto __1625
__1625:
	i++
	goto __1624
	goto __1626
__1626:
	;
	goto __1410

__1423:
	i = Tuint32_t(1)
__1631:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __1633
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1634
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1635
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1636
	}
	return -2
__1636:
	;
__1635:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1634:
	;
	cc8 = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(cc8 < Tuint32_t(128) && int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(cc8))))&Dctype_word != 0) {
		goto __1637
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1637:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr++
__1638:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0xc0 == 0x80) {
		goto __1639
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __1638
__1639:
	;
	goto __1632
__1632:
	i++
	goto __1631
	goto __1633
__1633:
	;
	goto __1410

__1424:
	i = Tuint32_t(1)
__1640:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __1642
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1643
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1644
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1645
	}
	return -2
__1645:
	;
__1644:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1643:
	;
	cc9 = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(cc9 >= Tuint32_t(128) || int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(cc9))))&Dctype_word == 0) {
		goto __1646
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1646:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	// No need to skip more code units - we know it has only one.
	goto __1641
__1641:
	i++
	goto __1640
	goto __1642
__1642:
	;
	goto __1410

__1425:
	return -44
__1410:
	;
	goto __1409
__1408:

	// Code for the non-UTF case for minimum matching of operators other
	//       than OP_PROP and OP_NOTPROP.

	switch *(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) {
	case OP_ANY:
		goto __1648

	case OP_ALLANY:
		goto __1649

	// This OP_ANYBYTE case will never be reached because \C gets turned
	//         into OP_ALLANY in non-UTF mode. Cut out the code so that coverage
	//         reports don't complain about it's never being used.

	// case OP_ANYBYTE:
	//        if (Feptr > mb->end_subject - Lmin)
	//          {
	//          SCHECK_PARTIAL();
	//          RRETURN(MATCH_NOMATCH);
	//          }
	//        Feptr += Lmin;
	//        break;
	case OP_ANYNL:
		goto __1650

	case OP_NOT_HSPACE:
		goto __1651

	case OP_HSPACE:
		goto __1652

	case OP_NOT_VSPACE:
		goto __1653

	case OP_VSPACE:
		goto __1654

	case OP_NOT_DIGIT:
		goto __1655

	case OP_DIGIT:
		goto __1656

	case OP_NOT_WHITESPACE:
		goto __1657

	case OP_WHITESPACE:
		goto __1658

	case OP_NOT_WORDCHAR:
		goto __1659

	case OP_WORDCHAR:
		goto __1660

	default:
		goto __1661
	}
	goto __1647

__1648:
	i = Tuint32_t(1)
__1662:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __1664
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1665
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1666
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1667
	}
	return -2
__1667:
	;
__1666:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1665:
	;
	if !(func() int32 {
		if (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype != Tuint32_t(DNLTYPE_FIXED) {
			return libc.Bool32((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, (*Theapframe)(unsafe.Pointer(F)).Feptr, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+256, utf) != 0)
		}
		return libc.Bool32((*Theapframe)(unsafe.Pointer(F)).Feptr <= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260))) && ((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(1) || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + uintptr(1)))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260 + 1)))))
	}() != 0) {
		goto __1668
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1668:
	;

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && (*Theapframe)(unsafe.Pointer(F)).Feptr+uintptr(1) >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype == Tuint32_t(DNLTYPE_FIXED) && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(2) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260)))) {
		goto __1669
	}

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1670
	}
	return -2
__1670:
	;
__1669:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __1663
__1663:
	i++
	goto __1662
	goto __1664
__1664:
	;
	goto __1647

__1649:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr(*(*Tuint32_t)(unsafe.Pointer(F + 56)))) {
		goto __1671
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1672
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1673
	}
	return -2
__1673:
	;
__1672:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1671:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += TPCRE2_SPTR8(*(*Tuint32_t)(unsafe.Pointer(F + 56)))
	goto __1647

	// This OP_ANYBYTE case will never be reached because \C gets turned
	//         into OP_ALLANY in non-UTF mode. Cut out the code so that coverage
	//         reports don't complain about it's never being used.

	// case OP_ANYBYTE:
	//        if (Feptr > mb->end_subject - Lmin)
	//          {
	//          SCHECK_PARTIAL();
	//          RRETURN(MATCH_NOMATCH);
	//          }
	//        Feptr += Lmin;
	//        break;
__1650:
	i = Tuint32_t(1)
__1674:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __1676
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1677
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1678
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1679
	}
	return -2
__1679:
	;
__1678:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1677:
	;
	switch int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1)))) {
	default:
		goto __1681

	case '\015':
		goto __1682

	case '\012':
		goto __1683

	case '\013':
		goto __1684
	case '\014':
		goto __1685
	case int32(uint8('\x85')):
		goto __1686
	}
	goto __1680

__1681:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1682:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == '\012') {
		goto __1687
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
__1687:
	;
	goto __1680

__1683:
	goto __1680

__1684:
__1685:
__1686:
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fbsr_convention) == DPCRE2_BSR_ANYCRLF) {
		goto __1688
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1688:
	;

	goto __1680
__1680:
	;
	goto __1675
__1675:
	i++
	goto __1674
	goto __1676
__1676:
	;
	goto __1647

__1651:
	i = Tuint32_t(1)
__1689:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __1691
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1692
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1693
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1694
	}
	return -2
__1694:
	;
__1693:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1692:
	;
	switch int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1)))) {
	default:
		goto __1696
	case '\011':
		goto __1697
	case '\040':
		goto __1698
	case int32(uint8('\xa0')):
		goto __1699
	}
	goto __1695

__1696:
	goto __1695
__1697:
__1698:
__1699:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1695:
	;
	goto __1690
__1690:
	i++
	goto __1689
	goto __1691
__1691:
	;
	goto __1647

__1652:
	i = Tuint32_t(1)
__1700:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __1702
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1703
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1704
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1705
	}
	return -2
__1705:
	;
__1704:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1703:
	;
	switch int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1)))) {
	default:
		goto __1707
	case '\011':
		goto __1708
	case '\040':
		goto __1709
	case int32(uint8('\xa0')):
		goto __1710
	}
	goto __1706

__1707:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1708:
__1709:
__1710:
	goto __1706
__1706:
	;
	goto __1701
__1701:
	i++
	goto __1700
	goto __1702
__1702:
	;
	goto __1647

__1653:
	i = Tuint32_t(1)
__1711:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __1713
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1714
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1715
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1716
	}
	return -2
__1716:
	;
__1715:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1714:
	;
	switch int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1)))) {
	case '\012':
		goto __1718
	case '\013':
		goto __1719
	case '\014':
		goto __1720
	case '\015':
		goto __1721
	case int32(uint8('\x85')):
		goto __1722
	default:
		goto __1723
	}
	goto __1717

__1718:
__1719:
__1720:
__1721:
__1722:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1723:
	goto __1717
__1717:
	;
	goto __1712
__1712:
	i++
	goto __1711
	goto __1713
__1713:
	;
	goto __1647

__1654:
	i = Tuint32_t(1)
__1724:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __1726
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1727
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1728
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1729
	}
	return -2
__1729:
	;
__1728:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1727:
	;
	switch int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1)))) {
	default:
		goto __1731
	case '\012':
		goto __1732
	case '\013':
		goto __1733
	case '\014':
		goto __1734
	case '\015':
		goto __1735
	case int32(uint8('\x85')):
		goto __1736
	}
	goto __1730

__1731:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1732:
__1733:
__1734:
__1735:
__1736:
	goto __1730
__1730:
	;
	goto __1725
__1725:
	i++
	goto __1724
	goto __1726
__1726:
	;
	goto __1647

__1655:
	i = Tuint32_t(1)
__1737:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __1739
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1740
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1741
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1742
	}
	return -2
__1742:
	;
__1741:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1740:
	;
	if !(1 != 0 && int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))))))&Dctype_digit != 0) {
		goto __1743
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1743:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __1738
__1738:
	i++
	goto __1737
	goto __1739
__1739:
	;
	goto __1647

__1656:
	i = Tuint32_t(1)
__1744:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __1746
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1747
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1748
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1749
	}
	return -2
__1749:
	;
__1748:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1747:
	;
	if !(!(1 != 0) || int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))))))&Dctype_digit == 0) {
		goto __1750
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1750:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __1745
__1745:
	i++
	goto __1744
	goto __1746
__1746:
	;
	goto __1647

__1657:
	i = Tuint32_t(1)
__1751:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __1753
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1754
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1755
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1756
	}
	return -2
__1756:
	;
__1755:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1754:
	;
	if !(1 != 0 && int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))))))&Dctype_space != 0) {
		goto __1757
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1757:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __1752
__1752:
	i++
	goto __1751
	goto __1753
__1753:
	;
	goto __1647

__1658:
	i = Tuint32_t(1)
__1758:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __1760
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1761
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1762
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1763
	}
	return -2
__1763:
	;
__1762:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1761:
	;
	if !(!(1 != 0) || int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))))))&Dctype_space == 0) {
		goto __1764
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1764:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __1759
__1759:
	i++
	goto __1758
	goto __1760
__1760:
	;
	goto __1647

__1659:
	i = Tuint32_t(1)
__1765:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __1767
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1768
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1769
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1770
	}
	return -2
__1770:
	;
__1769:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1768:
	;
	if !(1 != 0 && int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))))))&Dctype_word != 0) {
		goto __1771
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1771:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __1766
__1766:
	i++
	goto __1765
	goto __1767
__1767:
	;
	goto __1647

__1660:
	i = Tuint32_t(1)
__1772:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __1774
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1775
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1776
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1777
	}
	return -2
__1777:
	;
__1776:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1775:
	;
	if !(!(1 != 0) || int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))))))&Dctype_word == 0) {
		goto __1778
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1778:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __1773
__1773:
	i++
	goto __1772
	goto __1774
__1774:
	;
	goto __1647

__1661:
	return -44
__1647:
	;
__1409:
	;
__1388:
	;
__1127:
	;
__1125:
	;

	// If Lmin = Lmax we are done. Continue with the main loop.

	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56)) == *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __1779
	}
	goto __11
__1779:
	;

	// If minimizing, we have to test the rest of the pattern before each
	//     subsequent match. This means we cannot use a local "notmatch" variable as
	//     in the other cases. As all 4 temporary 32-bit values in the frame are
	//     already in use, just test the type each time.

	if !(reptype == REPTYPE_MIN) {
		goto __1780
	}

	if !(proptype >= 0) {
		goto __1782
	}

	switch proptype {
	case DPT_ANY:
		goto __1785
	// Control never gets here

	case DPT_LAMP:
		goto __1786
	// Control never gets here

	case DPT_GC:
		goto __1787
	// Control never gets here

	case DPT_PC:
		goto __1788
	// Control never gets here

	case DPT_SC:
		goto __1789
	// Control never gets here

	case DPT_SCX:
		goto __1790
	// Control never gets here

	case DPT_ALNUM:
		goto __1791
	// Control never gets here

	// Perl space used to exclude VT, but from Perl 5.18 it is included,
	//           which means that Perl space and POSIX space are now identical. PCRE
	//           was changed at release 8.34.

	case DPT_SPACE:
		goto __1792 // Perl space
	case DPT_PXSPACE:
		goto __1793
	// Control never gets here

	case DPT_WORD:
		goto __1794
	// Control never gets here

	case DPT_CLIST:
		goto __1795
	// Control never gets here

	case DPT_UCNC:
		goto __1796
	// Control never gets here

	case DPT_BIDICL:
		goto __1797
	// Control never gets here

	case DPT_BOOL:
		goto __1798
	// Control never gets here

	// This should never occur
	default:
		goto __1799
	}
	goto __1784

__1785:
__1800:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM208
	goto MATCH_RECURSE
L_RM208:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __1803
	}
	rrc = rrc
	goto RETURN_SWITCH
__1803:
	;

	if !(libc.PostIncUint32(&*(*Tuint32_t)(unsafe.Pointer(F + 56)), 1) >= *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __1804
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1804:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1805
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1806
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1807
	}
	return -2
__1807:
	;
__1806:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1805:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1808
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __1809
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1810
__1809:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __1811
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1812
__1811:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __1813
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1814
__1813:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __1815
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1816
__1815:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__1816:
	;
__1814:
	;
__1812:
	;
__1810:
	;
__1808:
	;

	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) == OP_NOTPROP) {
		goto __1817
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1817:
	;

	goto __1801
__1801:
	goto __1800
	goto __1802
__1802:
	;
	// Control never gets here

__1786:
__1818:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM209
	goto MATCH_RECURSE
L_RM209:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __1821
	}
	rrc = rrc
	goto RETURN_SWITCH
__1821:
	;

	if !(libc.PostIncUint32(&*(*Tuint32_t)(unsafe.Pointer(F + 56)), 1) >= *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __1822
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1822:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1823
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1824
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1825
	}
	return -2
__1825:
	;
__1824:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1823:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1826
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __1827
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1828
__1827:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __1829
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1830
__1829:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __1831
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1832
__1831:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __1833
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1834
__1833:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__1834:
	;
__1832:
	;
__1830:
	;
__1828:
	;
__1826:
	;

	chartype1 = int32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fchartype)
	if !(libc.Bool32(chartype1 == ucp_Lu || chartype1 == ucp_Ll || chartype1 == ucp_Lt) == libc.Bool32(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) == OP_NOTPROP)) {
		goto __1835
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1835:
	;

	goto __1819
__1819:
	goto __1818
	goto __1820
__1820:
	;
	// Control never gets here

__1787:
__1836:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM210
	goto MATCH_RECURSE
L_RM210:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __1839
	}
	rrc = rrc
	goto RETURN_SWITCH
__1839:
	;

	if !(libc.PostIncUint32(&*(*Tuint32_t)(unsafe.Pointer(F + 56)), 1) >= *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __1840
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1840:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1841
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1842
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1843
	}
	return -2
__1843:
	;
__1842:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1841:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1844
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __1845
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1846
__1845:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __1847
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1848
__1847:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __1849
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1850
__1849:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __1851
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1852
__1851:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__1852:
	;
__1850:
	;
__1848:
	;
__1846:
	;
__1844:
	;

	if !(libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fchartype] == *(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4))) == libc.Bool32(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) == OP_NOTPROP)) {
		goto __1853
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1853:
	;

	goto __1837
__1837:
	goto __1836
	goto __1838
__1838:
	;
	// Control never gets here

__1788:
__1854:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM211
	goto MATCH_RECURSE
L_RM211:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __1857
	}
	rrc = rrc
	goto RETURN_SWITCH
__1857:
	;

	if !(libc.PostIncUint32(&*(*Tuint32_t)(unsafe.Pointer(F + 56)), 1) >= *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __1858
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1858:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1859
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1860
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1861
	}
	return -2
__1861:
	;
__1860:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1859:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1862
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __1863
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1864
__1863:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __1865
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1866
__1865:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __1867
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1868
__1867:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __1869
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1870
__1869:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__1870:
	;
__1868:
	;
__1866:
	;
__1864:
	;
__1862:
	;

	if !(libc.Bool32(Tuint32_t((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fchartype) == *(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4))) == libc.Bool32(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) == OP_NOTPROP)) {
		goto __1871
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1871:
	;

	goto __1855
__1855:
	goto __1854
	goto __1856
__1856:
	;
	// Control never gets here

__1789:
__1872:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM212
	goto MATCH_RECURSE
L_RM212:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __1875
	}
	rrc = rrc
	goto RETURN_SWITCH
__1875:
	;

	if !(libc.PostIncUint32(&*(*Tuint32_t)(unsafe.Pointer(F + 56)), 1) >= *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __1876
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1876:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1877
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1878
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1879
	}
	return -2
__1879:
	;
__1878:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1877:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1880
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __1881
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1882
__1881:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __1883
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1884
__1883:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __1885
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1886
__1885:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __1887
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1888
__1887:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__1888:
	;
__1886:
	;
__1884:
	;
__1882:
	;
__1880:
	;

	if !(libc.Bool32(Tuint32_t((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fscript) == *(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4))) == libc.Bool32(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) == OP_NOTPROP)) {
		goto __1889
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1889:
	;

	goto __1873
__1873:
	goto __1872
	goto __1874
__1874:
	;
	// Control never gets here

__1790:
__1890:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM225
	goto MATCH_RECURSE
L_RM225:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __1893
	}
	rrc = rrc
	goto RETURN_SWITCH
__1893:
	;

	if !(libc.PostIncUint32(&*(*Tuint32_t)(unsafe.Pointer(F + 56)), 1) >= *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __1894
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1894:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1895
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1896
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1897
	}
	return -2
__1897:
	;
__1896:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1895:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1898
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __1899
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1900
__1899:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __1901
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1902
__1901:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __1903
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1904
__1903:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __1905
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1906
__1905:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__1906:
	;
__1904:
	;
__1902:
	;
__1900:
	;
__1898:
	;

	prop3 = uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12
	ok4 = libc.Bool32(Tuint32_t((*Tucd_record)(unsafe.Pointer(prop3)).Fscript) == *(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4)) ||
		*(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_script_sets_8)) + uintptr(int32((*Tucd_record)(unsafe.Pointer(prop3)).Fscriptx_bidiclass)&DUCD_SCRIPTX_MASK)*4 + uintptr(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4))/Tuint32_t(32))*4))&(uint32(1)<<(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4))%Tuint32_t(32))) != Tuint32_t(0))
	if !(ok4 == libc.Bool32(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) == OP_NOTPROP)) {
		goto __1907
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1907:
	;

	goto __1891
__1891:
	goto __1890
	goto __1892
__1892:
	;
	// Control never gets here

__1791:
__1908:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM213
	goto MATCH_RECURSE
L_RM213:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __1911
	}
	rrc = rrc
	goto RETURN_SWITCH
__1911:
	;

	if !(libc.PostIncUint32(&*(*Tuint32_t)(unsafe.Pointer(F + 56)), 1) >= *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __1912
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1912:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1913
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1914
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1915
	}
	return -2
__1915:
	;
__1914:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1913:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1916
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __1917
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1918
__1917:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __1919
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1920
__1919:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __1921
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1922
__1921:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __1923
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1924
__1923:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__1924:
	;
__1922:
	;
__1920:
	;
__1918:
	;
__1916:
	;

	category2 = int32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fchartype])
	if !(libc.Bool32(category2 == ucp_L || category2 == ucp_N) == libc.Bool32(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) == OP_NOTPROP)) {
		goto __1925
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1925:
	;

	goto __1909
__1909:
	goto __1908
	goto __1910
__1910:
	;
	// Control never gets here

	// Perl space used to exclude VT, but from Perl 5.18 it is included,
	//           which means that Perl space and POSIX space are now identical. PCRE
	//           was changed at release 8.34.

__1792: // Perl space
__1793: // POSIX space
__1926:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM214
	goto MATCH_RECURSE
L_RM214:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __1929
	}
	rrc = rrc
	goto RETURN_SWITCH
__1929:
	;

	if !(libc.PostIncUint32(&*(*Tuint32_t)(unsafe.Pointer(F + 56)), 1) >= *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __1930
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1930:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1931
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1932
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1933
	}
	return -2
__1933:
	;
__1932:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1931:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1934
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __1935
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1936
__1935:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __1937
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1938
__1937:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __1939
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1940
__1939:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __1941
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1942
__1941:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__1942:
	;
__1940:
	;
__1938:
	;
__1936:
	;
__1934:
	;

	switch fc {
	case Tuint32_t('\011'):
		goto __1944
	case Tuint32_t('\040'):
		goto __1945
	case Tuint32_t(uint8('\xa0')):
		goto __1946
	case Tuint32_t(0x1680):
		goto __1947 /* OGHAM SPACE MARK */
	case Tuint32_t(0x180e):
		goto __1948 /* MONGOLIAN VOWEL SEPARATOR */
	case Tuint32_t(0x2000):
		goto __1949 /* EN QUAD */
	case Tuint32_t(0x2001):
		goto __1950 /* EM QUAD */
	case Tuint32_t(0x2002):
		goto __1951 /* EN SPACE */
	case Tuint32_t(0x2003):
		goto __1952 /* EM SPACE */
	case Tuint32_t(0x2004):
		goto __1953 /* THREE-PER-EM SPACE */
	case Tuint32_t(0x2005):
		goto __1954 /* FOUR-PER-EM SPACE */
	case Tuint32_t(0x2006):
		goto __1955 /* SIX-PER-EM SPACE */
	case Tuint32_t(0x2007):
		goto __1956 /* FIGURE SPACE */
	case Tuint32_t(0x2008):
		goto __1957 /* PUNCTUATION SPACE */
	case Tuint32_t(0x2009):
		goto __1958 /* THIN SPACE */
	case Tuint32_t(0x200A):
		goto __1959 /* HAIR SPACE */
	case Tuint32_t(0x202f):
		goto __1960 /* NARROW NO-BREAK SPACE */
	case Tuint32_t(0x205f):
		goto __1961 /* MEDIUM MATHEMATICAL SPACE */
	case Tuint32_t(0x3000):
		goto __1962
	case Tuint32_t('\012'):
		goto __1963
	case Tuint32_t('\013'):
		goto __1964
	case Tuint32_t('\014'):
		goto __1965
	case Tuint32_t('\015'):
		goto __1966
	case Tuint32_t(uint8('\x85')):
		goto __1967
	case Tuint32_t(0x2028):
		goto __1968 /* LINE SEPARATOR */
	case Tuint32_t(0x2029):
		goto __1969

	default:
		goto __1970
	}
	goto __1943

__1944:
__1945:
__1946:
__1947: /* OGHAM SPACE MARK */
__1948: /* MONGOLIAN VOWEL SEPARATOR */
__1949: /* EN QUAD */
__1950: /* EM QUAD */
__1951: /* EN SPACE */
__1952: /* EM SPACE */
__1953: /* THREE-PER-EM SPACE */
__1954: /* FOUR-PER-EM SPACE */
__1955: /* SIX-PER-EM SPACE */
__1956: /* FIGURE SPACE */
__1957: /* PUNCTUATION SPACE */
__1958: /* THIN SPACE */
__1959: /* HAIR SPACE */
__1960: /* NARROW NO-BREAK SPACE */
__1961: /* MEDIUM MATHEMATICAL SPACE */
__1962:
__1963:
__1964:
__1965:
__1966:
__1967:
__1968: /* LINE SEPARATOR */
__1969:
	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) == OP_NOTPROP) {
		goto __1971
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1971:
	;

	goto __1943

__1970:
	if !(libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fchartype] == ucp_Z) == libc.Bool32(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) == OP_NOTPROP)) {
		goto __1972
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1972:
	;

	goto __1943
__1943:
	;
	goto __1927
__1927:
	goto __1926
	goto __1928
__1928:
	;
	// Control never gets here

__1794:
__1973:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM215
	goto MATCH_RECURSE
L_RM215:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __1976
	}
	rrc = rrc
	goto RETURN_SWITCH
__1976:
	;

	if !(libc.PostIncUint32(&*(*Tuint32_t)(unsafe.Pointer(F + 56)), 1) >= *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __1977
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1977:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1978
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1979
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1980
	}
	return -2
__1980:
	;
__1979:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1978:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1981
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __1982
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1983
__1982:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __1984
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1985
__1984:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __1986
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1987
__1986:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __1988
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1989
__1988:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__1989:
	;
__1987:
	;
__1985:
	;
__1983:
	;
__1981:
	;

	category3 = int32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fchartype])
	if !(libc.Bool32(category3 == ucp_L || category3 == ucp_N || fc == Tuint32_t('\137')) == libc.Bool32(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) == OP_NOTPROP)) {
		goto __1990
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1990:
	;

	goto __1974
__1974:
	goto __1973
	goto __1975
__1975:
	;
	// Control never gets here

__1795:
__1991:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM216
	goto MATCH_RECURSE
L_RM216:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __1994
	}
	rrc = rrc
	goto RETURN_SWITCH
__1994:
	;

	if !(libc.PostIncUint32(&*(*Tuint32_t)(unsafe.Pointer(F + 56)), 1) >= *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __1995
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1995:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1996
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1997
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1998
	}
	return -2
__1998:
	;
__1997:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1996:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1999
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __2000
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __2001
__2000:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __2002
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __2003
__2002:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __2004
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __2005
__2004:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __2006
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __2007
__2006:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__2007:
	;
__2005:
	;
__2003:
	;
__2001:
	;
__1999:
	;

	cp2 = uintptr(unsafe.Pointer(&X_pcre2_ucd_caseless_sets_8)) + uintptr(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4)))*4
__2008:

	if !(fc < *(*Tuint32_t)(unsafe.Pointer(cp2))) {
		goto __2011
	}

	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) == OP_NOTPROP) {
		goto __2012
	}
	goto __2010
__2012:
	;
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__2011:
	;
	if !(fc == *(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&cp2, 4)))) {
		goto __2013
	}

	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) == OP_NOTPROP) {
		goto __2014
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2014:
	;

	goto __2010
__2013:
	;
	goto __2009
__2009:
	goto __2008
	goto __2010
__2010:
	;
	goto __1992
__1992:
	goto __1991
	goto __1993
__1993:
	;
	// Control never gets here

__1796:
__2015:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM217
	goto MATCH_RECURSE
L_RM217:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __2018
	}
	rrc = rrc
	goto RETURN_SWITCH
__2018:
	;

	if !(libc.PostIncUint32(&*(*Tuint32_t)(unsafe.Pointer(F + 56)), 1) >= *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2019
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2019:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2020
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2021
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2022
	}
	return -2
__2022:
	;
__2021:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__2020:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __2023
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __2024
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __2025
__2024:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __2026
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __2027
__2026:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __2028
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __2029
__2028:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __2030
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __2031
__2030:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__2031:
	;
__2029:
	;
__2027:
	;
__2025:
	;
__2023:
	;

	if !(libc.Bool32(fc == Tuint32_t('\044') || fc == Tuint32_t('\100') || fc == Tuint32_t('\140') || fc >= Tuint32_t(0xa0) && fc <= Tuint32_t(0xd7ff) || fc >= Tuint32_t(0xe000)) == libc.Bool32(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) == OP_NOTPROP)) {
		goto __2032
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2032:
	;

	goto __2016
__2016:
	goto __2015
	goto __2017
__2017:
	;
	// Control never gets here

__1797:
__2033:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM224
	goto MATCH_RECURSE
L_RM224:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __2036
	}
	rrc = rrc
	goto RETURN_SWITCH
__2036:
	;

	if !(libc.PostIncUint32(&*(*Tuint32_t)(unsafe.Pointer(F + 56)), 1) >= *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2037
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2037:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2038
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2039
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2040
	}
	return -2
__2040:
	;
__2039:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__2038:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __2041
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __2042
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __2043
__2042:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __2044
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __2045
__2044:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __2046
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __2047
__2046:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __2048
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __2049
__2048:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__2049:
	;
__2047:
	;
__2045:
	;
__2043:
	;
__2041:
	;

	if !(libc.Bool32(Tuint32_t(int32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fscriptx_bidiclass)>>DUCD_BIDICLASS_SHIFT) == *(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4))) == libc.Bool32(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) == OP_NOTPROP)) {
		goto __2050
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2050:
	;

	goto __2034
__2034:
	goto __2033
	goto __2035
__2035:
	;
	// Control never gets here

__1798:
__2051:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM223
	goto MATCH_RECURSE
L_RM223:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __2054
	}
	rrc = rrc
	goto RETURN_SWITCH
__2054:
	;

	if !(libc.PostIncUint32(&*(*Tuint32_t)(unsafe.Pointer(F + 56)), 1) >= *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2055
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2055:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2056
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2057
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2058
	}
	return -2
__2058:
	;
__2057:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__2056:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __2059
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __2060
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __2061
__2060:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __2062
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __2063
__2062:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __2064
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __2065
__2064:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __2066
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __2067
__2066:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__2067:
	;
__2065:
	;
__2063:
	;
__2061:
	;
__2059:
	;

	prop4 = uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12
	ok5 = libc.Bool32(*(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_boolprop_sets_8)) + uintptr(int32((*Tucd_record)(unsafe.Pointer(prop4)).Fbprops)&DUCD_BPROPS_MASK)*4 + uintptr(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4))/Tuint32_t(32))*4))&(uint32(1)<<(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4))%Tuint32_t(32))) != Tuint32_t(0))
	if !(ok5 == libc.Bool32(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) == OP_NOTPROP)) {
		goto __2068
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2068:
	;

	goto __2052
__2052:
	goto __2051
	goto __2053
__2053:
	;
	// Control never gets here

	// This should never occur
__1799:
	return -44
__1784:
	;
	goto __1783
__1782:
	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) == OP_EXTUNI) {
		goto __2069
	}

__2071:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM218
	goto MATCH_RECURSE
L_RM218:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __2074
	}
	rrc = rrc
	goto RETURN_SWITCH
__2074:
	;

	if !(libc.PostIncUint32(&*(*Tuint32_t)(unsafe.Pointer(F + 56)), 1) >= *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2075
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2075:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2076
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2078
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2079
	}
	return -2
__2079:
	;
__2078:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

	goto __2077
__2076:

	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __2080
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __2081
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __2082
__2081:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __2083
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __2084
__2083:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __2085
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __2086
__2085:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __2087
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __2088
__2087:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__2088:
	;
__2086:
	;
__2084:
	;
__2082:
	;
__2080:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr = X_pcre2_extuni_8(tls, fc, (*Theapframe)(unsafe.Pointer(F)).Feptr, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject,
		utf, uintptr(0))
__2077:
	;
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2089
	}
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2090
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2091
	}
	return -2
__2091:
	;
__2090:
	;
__2089:
	;

	goto __2072
__2072:
	goto __2071
	goto __2073
__2073:
	;
	goto __2070
__2069:

	// UTF mode for non-property testing character types.

	if !(utf != 0) {
		goto __2092
	}

__2094:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM219
	goto MATCH_RECURSE
L_RM219:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __2097
	}
	rrc = rrc
	goto RETURN_SWITCH
__2097:
	;

	if !(libc.PostIncUint32(&*(*Tuint32_t)(unsafe.Pointer(F + 56)), 1) >= *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2098
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2098:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2099
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2100
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2101
	}
	return -2
__2101:
	;
__2100:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__2099:
	;
	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) == OP_ANY && func() int32 {
		if (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype != Tuint32_t(DNLTYPE_FIXED) {
			return libc.Bool32((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, (*Theapframe)(unsafe.Pointer(F)).Feptr, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+256, utf) != 0)
		}
		return libc.Bool32((*Theapframe)(unsafe.Pointer(F)).Feptr <= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260))) && ((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(1) || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + uintptr(1)))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260 + 1)))))
	}() != 0) {
		goto __2102
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2102:
	;

	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(fc >= 0xc0) {
		goto __2103
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __2104
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __2105
__2104:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __2106
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __2107
__2106:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __2108
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __2109
__2108:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __2110
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __2111
__2110:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__2111:
	;
__2109:
	;
__2107:
	;
__2105:
	;
__2103:
	;

	switch *(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) {
	case OP_ANY:
		goto __2113

	case OP_ALLANY:
		goto __2114
	case OP_ANYBYTE:
		goto __2115

	case OP_ANYNL:
		goto __2116

	case OP_NOT_HSPACE:
		goto __2117

	case OP_HSPACE:
		goto __2118

	case OP_NOT_VSPACE:
		goto __2119

	case OP_VSPACE:
		goto __2120

	case OP_NOT_DIGIT:
		goto __2121

	case OP_DIGIT:
		goto __2122

	case OP_NOT_WHITESPACE:
		goto __2123

	case OP_WHITESPACE:
		goto __2124

	case OP_NOT_WORDCHAR:
		goto __2125

	case OP_WORDCHAR:
		goto __2126

	default:
		goto __2127
	}
	goto __2112

__2113: // This is the non-NL case
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && (*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype == Tuint32_t(DNLTYPE_FIXED) && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(2) && fc == Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260)))) {
		goto __2128
	}

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2129
	}
	return -2
__2129:
	;
__2128:
	;
	goto __2112

__2114:
__2115:
	goto __2112

__2116:
	switch fc {
	default:
		goto __2131

	case Tuint32_t('\015'):
		goto __2132

	case Tuint32_t('\012'):
		goto __2133

	case Tuint32_t('\013'):
		goto __2134
	case Tuint32_t('\014'):
		goto __2135
	case Tuint32_t(uint8('\x85')):
		goto __2136
	case Tuint32_t(0x2028):
		goto __2137
	case Tuint32_t(0x2029):
		goto __2138
	}
	goto __2130

__2131:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__2132:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == '\012') {
		goto __2139
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
__2139:
	;
	goto __2130

__2133:
	goto __2130

__2134:
__2135:
__2136:
__2137:
__2138:
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fbsr_convention) == DPCRE2_BSR_ANYCRLF) {
		goto __2140
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2140:
	;

	goto __2130
__2130:
	;
	goto __2112

__2117:
	switch fc {
	case Tuint32_t('\011'):
		goto __2142
	case Tuint32_t('\040'):
		goto __2143
	case Tuint32_t(uint8('\xa0')):
		goto __2144
	case Tuint32_t(0x1680):
		goto __2145 /* OGHAM SPACE MARK */
	case Tuint32_t(0x180e):
		goto __2146 /* MONGOLIAN VOWEL SEPARATOR */
	case Tuint32_t(0x2000):
		goto __2147 /* EN QUAD */
	case Tuint32_t(0x2001):
		goto __2148 /* EM QUAD */
	case Tuint32_t(0x2002):
		goto __2149 /* EN SPACE */
	case Tuint32_t(0x2003):
		goto __2150 /* EM SPACE */
	case Tuint32_t(0x2004):
		goto __2151 /* THREE-PER-EM SPACE */
	case Tuint32_t(0x2005):
		goto __2152 /* FOUR-PER-EM SPACE */
	case Tuint32_t(0x2006):
		goto __2153 /* SIX-PER-EM SPACE */
	case Tuint32_t(0x2007):
		goto __2154 /* FIGURE SPACE */
	case Tuint32_t(0x2008):
		goto __2155 /* PUNCTUATION SPACE */
	case Tuint32_t(0x2009):
		goto __2156 /* THIN SPACE */
	case Tuint32_t(0x200A):
		goto __2157 /* HAIR SPACE */
	case Tuint32_t(0x202f):
		goto __2158 /* NARROW NO-BREAK SPACE */
	case Tuint32_t(0x205f):
		goto __2159 /* MEDIUM MATHEMATICAL SPACE */
	case Tuint32_t(0x3000):
		goto __2160
	default:
		goto __2161
	}
	goto __2141

__2142:
__2143:
__2144:
__2145: /* OGHAM SPACE MARK */
__2146: /* MONGOLIAN VOWEL SEPARATOR */
__2147: /* EN QUAD */
__2148: /* EM QUAD */
__2149: /* EN SPACE */
__2150: /* EM SPACE */
__2151: /* THREE-PER-EM SPACE */
__2152: /* FOUR-PER-EM SPACE */
__2153: /* SIX-PER-EM SPACE */
__2154: /* FIGURE SPACE */
__2155: /* PUNCTUATION SPACE */
__2156: /* THIN SPACE */
__2157: /* HAIR SPACE */
__2158: /* NARROW NO-BREAK SPACE */
__2159: /* MEDIUM MATHEMATICAL SPACE */
__2160:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__2161:
	goto __2141
__2141:
	;
	goto __2112

__2118:
	switch fc {
	case Tuint32_t('\011'):
		goto __2163
	case Tuint32_t('\040'):
		goto __2164
	case Tuint32_t(uint8('\xa0')):
		goto __2165
	case Tuint32_t(0x1680):
		goto __2166 /* OGHAM SPACE MARK */
	case Tuint32_t(0x180e):
		goto __2167 /* MONGOLIAN VOWEL SEPARATOR */
	case Tuint32_t(0x2000):
		goto __2168 /* EN QUAD */
	case Tuint32_t(0x2001):
		goto __2169 /* EM QUAD */
	case Tuint32_t(0x2002):
		goto __2170 /* EN SPACE */
	case Tuint32_t(0x2003):
		goto __2171 /* EM SPACE */
	case Tuint32_t(0x2004):
		goto __2172 /* THREE-PER-EM SPACE */
	case Tuint32_t(0x2005):
		goto __2173 /* FOUR-PER-EM SPACE */
	case Tuint32_t(0x2006):
		goto __2174 /* SIX-PER-EM SPACE */
	case Tuint32_t(0x2007):
		goto __2175 /* FIGURE SPACE */
	case Tuint32_t(0x2008):
		goto __2176 /* PUNCTUATION SPACE */
	case Tuint32_t(0x2009):
		goto __2177 /* THIN SPACE */
	case Tuint32_t(0x200A):
		goto __2178 /* HAIR SPACE */
	case Tuint32_t(0x202f):
		goto __2179 /* NARROW NO-BREAK SPACE */
	case Tuint32_t(0x205f):
		goto __2180 /* MEDIUM MATHEMATICAL SPACE */
	case Tuint32_t(0x3000):
		goto __2181
	default:
		goto __2182
	}
	goto __2162

__2163:
__2164:
__2165:
__2166: /* OGHAM SPACE MARK */
__2167: /* MONGOLIAN VOWEL SEPARATOR */
__2168: /* EN QUAD */
__2169: /* EM QUAD */
__2170: /* EN SPACE */
__2171: /* EM SPACE */
__2172: /* THREE-PER-EM SPACE */
__2173: /* FOUR-PER-EM SPACE */
__2174: /* SIX-PER-EM SPACE */
__2175: /* FIGURE SPACE */
__2176: /* PUNCTUATION SPACE */
__2177: /* THIN SPACE */
__2178: /* HAIR SPACE */
__2179: /* NARROW NO-BREAK SPACE */
__2180: /* MEDIUM MATHEMATICAL SPACE */
__2181:
	goto __2162
__2182:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__2162:
	;
	goto __2112

__2119:
	switch fc {
	case Tuint32_t('\012'):
		goto __2184
	case Tuint32_t('\013'):
		goto __2185
	case Tuint32_t('\014'):
		goto __2186
	case Tuint32_t('\015'):
		goto __2187
	case Tuint32_t(uint8('\x85')):
		goto __2188
	case Tuint32_t(0x2028):
		goto __2189 /* LINE SEPARATOR */
	case Tuint32_t(0x2029):
		goto __2190
	default:
		goto __2191
	}
	goto __2183

__2184:
__2185:
__2186:
__2187:
__2188:
__2189: /* LINE SEPARATOR */
__2190:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__2191:
	goto __2183
__2183:
	;
	goto __2112

__2120:
	switch fc {
	case Tuint32_t('\012'):
		goto __2193
	case Tuint32_t('\013'):
		goto __2194
	case Tuint32_t('\014'):
		goto __2195
	case Tuint32_t('\015'):
		goto __2196
	case Tuint32_t(uint8('\x85')):
		goto __2197
	case Tuint32_t(0x2028):
		goto __2198 /* LINE SEPARATOR */
	case Tuint32_t(0x2029):
		goto __2199
	default:
		goto __2200
	}
	goto __2192

__2193:
__2194:
__2195:
__2196:
__2197:
__2198: /* LINE SEPARATOR */
__2199:
	goto __2192
__2200:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__2192:
	;
	goto __2112

__2121:
	if !(fc < Tuint32_t(256) && int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_digit != 0) {
		goto __2201
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2201:
	;

	goto __2112

__2122:
	if !(fc >= Tuint32_t(256) || int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_digit == 0) {
		goto __2202
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2202:
	;

	goto __2112

__2123:
	if !(fc < Tuint32_t(256) && int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_space != 0) {
		goto __2203
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2203:
	;

	goto __2112

__2124:
	if !(fc >= Tuint32_t(256) || int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_space == 0) {
		goto __2204
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2204:
	;

	goto __2112

__2125:
	if !(fc < Tuint32_t(256) && int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_word != 0) {
		goto __2205
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2205:
	;

	goto __2112

__2126:
	if !(fc >= Tuint32_t(256) || int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_word == 0) {
		goto __2206
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2206:
	;

	goto __2112

__2127:
	return -44
__2112:
	;
	goto __2095
__2095:
	goto __2094
	goto __2096
__2096:
	;
	goto __2093
__2092:

	/* Not UTF mode */

__2207:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM33
	goto MATCH_RECURSE
L_RM33:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __2210
	}
	rrc = rrc
	goto RETURN_SWITCH
__2210:
	;

	if !(libc.PostIncUint32(&*(*Tuint32_t)(unsafe.Pointer(F + 56)), 1) >= *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2211
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2211:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2212
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2213
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2214
	}
	return -2
__2214:
	;
__2213:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__2212:
	;
	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) == OP_ANY && func() int32 {
		if (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype != Tuint32_t(DNLTYPE_FIXED) {
			return libc.Bool32((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, (*Theapframe)(unsafe.Pointer(F)).Feptr, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+256, utf) != 0)
		}
		return libc.Bool32((*Theapframe)(unsafe.Pointer(F)).Feptr <= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260))) && ((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(1) || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + uintptr(1)))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260 + 1)))))
	}() != 0) {
		goto __2215
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2215:
	;

	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	switch *(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) {
	case OP_ANY:
		goto __2217

	case OP_ALLANY:
		goto __2218
	case OP_ANYBYTE:
		goto __2219

	case OP_ANYNL:
		goto __2220

	case OP_NOT_HSPACE:
		goto __2221

	case OP_HSPACE:
		goto __2222

	case OP_NOT_VSPACE:
		goto __2223

	case OP_VSPACE:
		goto __2224

	case OP_NOT_DIGIT:
		goto __2225

	case OP_DIGIT:
		goto __2226

	case OP_NOT_WHITESPACE:
		goto __2227

	case OP_WHITESPACE:
		goto __2228

	case OP_NOT_WORDCHAR:
		goto __2229

	case OP_WORDCHAR:
		goto __2230

	default:
		goto __2231
	}
	goto __2216

__2217: // This is the non-NL case
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && (*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype == Tuint32_t(DNLTYPE_FIXED) && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(2) && fc == Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260)))) {
		goto __2232
	}

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2233
	}
	return -2
__2233:
	;
__2232:
	;
	goto __2216

__2218:
__2219:
	goto __2216

__2220:
	switch fc {
	default:
		goto __2235

	case Tuint32_t('\015'):
		goto __2236

	case Tuint32_t('\012'):
		goto __2237

	case Tuint32_t('\013'):
		goto __2238
	case Tuint32_t('\014'):
		goto __2239
	case Tuint32_t(uint8('\x85')):
		goto __2240
	}
	goto __2234

__2235:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__2236:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == '\012') {
		goto __2241
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
__2241:
	;
	goto __2234

__2237:
	goto __2234

__2238:
__2239:
__2240:
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fbsr_convention) == DPCRE2_BSR_ANYCRLF) {
		goto __2242
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2242:
	;

	goto __2234
__2234:
	;
	goto __2216

__2221:
	switch fc {
	default:
		goto __2244
	case Tuint32_t('\011'):
		goto __2245
	case Tuint32_t('\040'):
		goto __2246
	case Tuint32_t(uint8('\xa0')):
		goto __2247
	}
	goto __2243

__2244:
	goto __2243
__2245:
__2246:
__2247:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__2243:
	;
	goto __2216

__2222:
	switch fc {
	default:
		goto __2249
	case Tuint32_t('\011'):
		goto __2250
	case Tuint32_t('\040'):
		goto __2251
	case Tuint32_t(uint8('\xa0')):
		goto __2252
	}
	goto __2248

__2249:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__2250:
__2251:
__2252:
	goto __2248
__2248:
	;
	goto __2216

__2223:
	switch fc {
	default:
		goto __2254
	case Tuint32_t('\012'):
		goto __2255
	case Tuint32_t('\013'):
		goto __2256
	case Tuint32_t('\014'):
		goto __2257
	case Tuint32_t('\015'):
		goto __2258
	case Tuint32_t(uint8('\x85')):
		goto __2259
	}
	goto __2253

__2254:
	goto __2253
__2255:
__2256:
__2257:
__2258:
__2259:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__2253:
	;
	goto __2216

__2224:
	switch fc {
	default:
		goto __2261
	case Tuint32_t('\012'):
		goto __2262
	case Tuint32_t('\013'):
		goto __2263
	case Tuint32_t('\014'):
		goto __2264
	case Tuint32_t('\015'):
		goto __2265
	case Tuint32_t(uint8('\x85')):
		goto __2266
	}
	goto __2260

__2261:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__2262:
__2263:
__2264:
__2265:
__2266:
	goto __2260
__2260:
	;
	goto __2216

__2225:
	if !(1 != 0 && int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_digit != 0) {
		goto __2267
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2267:
	;

	goto __2216

__2226:
	if !(!(1 != 0) || int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_digit == 0) {
		goto __2268
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2268:
	;

	goto __2216

__2227:
	if !(1 != 0 && int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_space != 0) {
		goto __2269
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2269:
	;

	goto __2216

__2228:
	if !(!(1 != 0) || int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_space == 0) {
		goto __2270
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2270:
	;

	goto __2216

__2229:
	if !(1 != 0 && int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_word != 0) {
		goto __2271
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2271:
	;

	goto __2216

__2230:
	if !(!(1 != 0) || int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_word == 0) {
		goto __2272
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2272:
	;

	goto __2216

__2231:
	return -44
__2216:
	;
	goto __2208
__2208:
	goto __2207
	goto __2209
__2209:
	;
__2093:
	;
__2070:
	;
__1783:
	;
	// Control never gets here
	goto __1781
__1780:

	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8)) = (*Theapframe)(unsafe.Pointer(F)).Feptr // Remember where we started

	if !(proptype >= 0) {
		goto __2273
	}
	notmatch2 = libc.Bool32(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) == OP_NOTPROP)
	switch proptype {
	case DPT_ANY:
		goto __2276

	case DPT_LAMP:
		goto __2277

	case DPT_GC:
		goto __2278

	case DPT_PC:
		goto __2279

	case DPT_SC:
		goto __2280

	case DPT_SCX:
		goto __2281

	case DPT_ALNUM:
		goto __2282

	// Perl space used to exclude VT, but from Perl 5.18 it is included,
	//           which means that Perl space and POSIX space are now identical. PCRE
	//           was changed at release 8.34.

	case DPT_SPACE:
		goto __2283 // Perl space
	case DPT_PXSPACE:
		goto __2284

	case DPT_WORD:
		goto __2285

	case DPT_CLIST:
		goto __2286

	case DPT_UCNC:
		goto __2287

	case DPT_BIDICL:
		goto __2288

	case DPT_BOOL:
		goto __2289

	default:
		goto __2290
	}
	goto __2275

__2276:
	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__2291:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2293
	}

	len4 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2294
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2295
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2296
	}
	return -2
__2296:
	;
__2295:
	;

	goto __2293
__2294:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(utf != 0 && fc >= 0xc0) {
		goto __2297
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __2298
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len4++
	goto __2299
__2298:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __2300
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len4 = len4 + 2
	goto __2301
__2300:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __2302
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len4 = len4 + 3
	goto __2303
__2302:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __2304
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len4 = len4 + 4
	goto __2305
__2304:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len4 = len4 + 5
__2305:
	;
__2303:
	;
__2301:
	;
__2299:
	;
__2297:
	;

	if !(notmatch2 != 0) {
		goto __2306
	}
	goto __2293
__2306:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += TPCRE2_SPTR8(len4)
	goto __2292
__2292:
	i++
	goto __2291
	goto __2293
__2293:
	;
	goto __2275

__2277:
	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__2307:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2309
	}

	len5 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2310
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2311
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2312
	}
	return -2
__2312:
	;
__2311:
	;

	goto __2309
__2310:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(utf != 0 && fc >= 0xc0) {
		goto __2313
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __2314
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len5++
	goto __2315
__2314:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __2316
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len5 = len5 + 2
	goto __2317
__2316:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __2318
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len5 = len5 + 3
	goto __2319
__2318:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __2320
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len5 = len5 + 4
	goto __2321
__2320:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len5 = len5 + 5
__2321:
	;
__2319:
	;
__2317:
	;
__2315:
	;
__2313:
	;

	chartype2 = int32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fchartype)
	if !(libc.Bool32(chartype2 == ucp_Lu || chartype2 == ucp_Ll || chartype2 == ucp_Lt) == notmatch2) {
		goto __2322
	}
	goto __2309
__2322:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += TPCRE2_SPTR8(len5)
	goto __2308
__2308:
	i++
	goto __2307
	goto __2309
__2309:
	;
	goto __2275

__2278:
	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__2323:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2325
	}

	len6 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2326
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2327
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2328
	}
	return -2
__2328:
	;
__2327:
	;

	goto __2325
__2326:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(utf != 0 && fc >= 0xc0) {
		goto __2329
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __2330
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len6++
	goto __2331
__2330:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __2332
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len6 = len6 + 2
	goto __2333
__2332:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __2334
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len6 = len6 + 3
	goto __2335
__2334:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __2336
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len6 = len6 + 4
	goto __2337
__2336:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len6 = len6 + 5
__2337:
	;
__2335:
	;
__2333:
	;
__2331:
	;
__2329:
	;

	if !(libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fchartype] == *(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4))) == notmatch2) {
		goto __2338
	}
	goto __2325
__2338:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += TPCRE2_SPTR8(len6)
	goto __2324
__2324:
	i++
	goto __2323
	goto __2325
__2325:
	;
	goto __2275

__2279:
	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__2339:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2341
	}

	len7 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2342
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2343
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2344
	}
	return -2
__2344:
	;
__2343:
	;

	goto __2341
__2342:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(utf != 0 && fc >= 0xc0) {
		goto __2345
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __2346
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len7++
	goto __2347
__2346:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __2348
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len7 = len7 + 2
	goto __2349
__2348:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __2350
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len7 = len7 + 3
	goto __2351
__2350:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __2352
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len7 = len7 + 4
	goto __2353
__2352:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len7 = len7 + 5
__2353:
	;
__2351:
	;
__2349:
	;
__2347:
	;
__2345:
	;

	if !(libc.Bool32(Tuint32_t((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fchartype) == *(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4))) == notmatch2) {
		goto __2354
	}
	goto __2341
__2354:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += TPCRE2_SPTR8(len7)
	goto __2340
__2340:
	i++
	goto __2339
	goto __2341
__2341:
	;
	goto __2275

__2280:
	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__2355:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2357
	}

	len8 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2358
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2359
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2360
	}
	return -2
__2360:
	;
__2359:
	;

	goto __2357
__2358:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(utf != 0 && fc >= 0xc0) {
		goto __2361
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __2362
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len8++
	goto __2363
__2362:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __2364
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len8 = len8 + 2
	goto __2365
__2364:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __2366
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len8 = len8 + 3
	goto __2367
__2366:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __2368
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len8 = len8 + 4
	goto __2369
__2368:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len8 = len8 + 5
__2369:
	;
__2367:
	;
__2365:
	;
__2363:
	;
__2361:
	;

	if !(libc.Bool32(Tuint32_t((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fscript) == *(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4))) == notmatch2) {
		goto __2370
	}
	goto __2357
__2370:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += TPCRE2_SPTR8(len8)
	goto __2356
__2356:
	i++
	goto __2355
	goto __2357
__2357:
	;
	goto __2275

__2281:
	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__2371:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2373
	}

	len9 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2374
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2375
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2376
	}
	return -2
__2376:
	;
__2375:
	;

	goto __2373
__2374:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(utf != 0 && fc >= 0xc0) {
		goto __2377
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __2378
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len9++
	goto __2379
__2378:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __2380
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len9 = len9 + 2
	goto __2381
__2380:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __2382
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len9 = len9 + 3
	goto __2383
__2382:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __2384
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len9 = len9 + 4
	goto __2385
__2384:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len9 = len9 + 5
__2385:
	;
__2383:
	;
__2381:
	;
__2379:
	;
__2377:
	;

	prop5 = uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12
	ok6 = libc.Bool32(Tuint32_t((*Tucd_record)(unsafe.Pointer(prop5)).Fscript) == *(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4)) || *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_script_sets_8)) + uintptr(int32((*Tucd_record)(unsafe.Pointer(prop5)).Fscriptx_bidiclass)&DUCD_SCRIPTX_MASK)*4 + uintptr(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4))/Tuint32_t(32))*4))&(uint32(1)<<(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4))%Tuint32_t(32))) != Tuint32_t(0))
	if !(ok6 == notmatch2) {
		goto __2386
	}
	goto __2373
__2386:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += TPCRE2_SPTR8(len9)
	goto __2372
__2372:
	i++
	goto __2371
	goto __2373
__2373:
	;
	goto __2275

__2282:
	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__2387:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2389
	}

	len10 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2390
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2391
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2392
	}
	return -2
__2392:
	;
__2391:
	;

	goto __2389
__2390:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(utf != 0 && fc >= 0xc0) {
		goto __2393
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __2394
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len10++
	goto __2395
__2394:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __2396
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len10 = len10 + 2
	goto __2397
__2396:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __2398
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len10 = len10 + 3
	goto __2399
__2398:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __2400
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len10 = len10 + 4
	goto __2401
__2400:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len10 = len10 + 5
__2401:
	;
__2399:
	;
__2397:
	;
__2395:
	;
__2393:
	;

	category4 = int32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fchartype])
	if !(libc.Bool32(category4 == ucp_L || category4 == ucp_N) == notmatch2) {
		goto __2402
	}
	goto __2389
__2402:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += TPCRE2_SPTR8(len10)
	goto __2388
__2388:
	i++
	goto __2387
	goto __2389
__2389:
	;
	goto __2275

	// Perl space used to exclude VT, but from Perl 5.18 it is included,
	//           which means that Perl space and POSIX space are now identical. PCRE
	//           was changed at release 8.34.

__2283: // Perl space
__2284: // POSIX space
	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__2403:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2405
	}

	len11 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2406
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2407
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2408
	}
	return -2
__2408:
	;
__2407:
	;

	goto __2405
__2406:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(utf != 0 && fc >= 0xc0) {
		goto __2409
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __2410
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len11++
	goto __2411
__2410:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __2412
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len11 = len11 + 2
	goto __2413
__2412:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __2414
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len11 = len11 + 3
	goto __2415
__2414:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __2416
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len11 = len11 + 4
	goto __2417
__2416:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len11 = len11 + 5
__2417:
	;
__2415:
	;
__2413:
	;
__2411:
	;
__2409:
	;

	switch fc {
	case Tuint32_t('\011'):
		goto __2419
	case Tuint32_t('\040'):
		goto __2420
	case Tuint32_t(uint8('\xa0')):
		goto __2421
	case Tuint32_t(0x1680):
		goto __2422 /* OGHAM SPACE MARK */
	case Tuint32_t(0x180e):
		goto __2423 /* MONGOLIAN VOWEL SEPARATOR */
	case Tuint32_t(0x2000):
		goto __2424 /* EN QUAD */
	case Tuint32_t(0x2001):
		goto __2425 /* EM QUAD */
	case Tuint32_t(0x2002):
		goto __2426 /* EN SPACE */
	case Tuint32_t(0x2003):
		goto __2427 /* EM SPACE */
	case Tuint32_t(0x2004):
		goto __2428 /* THREE-PER-EM SPACE */
	case Tuint32_t(0x2005):
		goto __2429 /* FOUR-PER-EM SPACE */
	case Tuint32_t(0x2006):
		goto __2430 /* SIX-PER-EM SPACE */
	case Tuint32_t(0x2007):
		goto __2431 /* FIGURE SPACE */
	case Tuint32_t(0x2008):
		goto __2432 /* PUNCTUATION SPACE */
	case Tuint32_t(0x2009):
		goto __2433 /* THIN SPACE */
	case Tuint32_t(0x200A):
		goto __2434 /* HAIR SPACE */
	case Tuint32_t(0x202f):
		goto __2435 /* NARROW NO-BREAK SPACE */
	case Tuint32_t(0x205f):
		goto __2436 /* MEDIUM MATHEMATICAL SPACE */
	case Tuint32_t(0x3000):
		goto __2437
	case Tuint32_t('\012'):
		goto __2438
	case Tuint32_t('\013'):
		goto __2439
	case Tuint32_t('\014'):
		goto __2440
	case Tuint32_t('\015'):
		goto __2441
	case Tuint32_t(uint8('\x85')):
		goto __2442
	case Tuint32_t(0x2028):
		goto __2443 /* LINE SEPARATOR */
	case Tuint32_t(0x2029):
		goto __2444

	default:
		goto __2445
	}
	goto __2418

__2419:
__2420:
__2421:
__2422: /* OGHAM SPACE MARK */
__2423: /* MONGOLIAN VOWEL SEPARATOR */
__2424: /* EN QUAD */
__2425: /* EM QUAD */
__2426: /* EN SPACE */
__2427: /* EM SPACE */
__2428: /* THREE-PER-EM SPACE */
__2429: /* FOUR-PER-EM SPACE */
__2430: /* SIX-PER-EM SPACE */
__2431: /* FIGURE SPACE */
__2432: /* PUNCTUATION SPACE */
__2433: /* THIN SPACE */
__2434: /* HAIR SPACE */
__2435: /* NARROW NO-BREAK SPACE */
__2436: /* MEDIUM MATHEMATICAL SPACE */
__2437:
__2438:
__2439:
__2440:
__2441:
__2442:
__2443: /* LINE SEPARATOR */
__2444:
	if !(notmatch2 != 0) {
		goto __2446
	}
	goto ENDLOOP99
__2446:
	; // Break the loop
	goto __2418

__2445:
	if !(libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fchartype] == ucp_Z) == notmatch2) {
		goto __2447
	}
	goto ENDLOOP99
__2447:
	; // Break the loop
	goto __2418
__2418:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += TPCRE2_SPTR8(len11)
	goto __2404
__2404:
	i++
	goto __2403
	goto __2405
__2405:
	;
ENDLOOP99:
	goto __2275

__2285:
	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__2448:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2450
	}

	len12 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2451
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2452
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2453
	}
	return -2
__2453:
	;
__2452:
	;

	goto __2450
__2451:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(utf != 0 && fc >= 0xc0) {
		goto __2454
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __2455
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len12++
	goto __2456
__2455:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __2457
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len12 = len12 + 2
	goto __2458
__2457:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __2459
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len12 = len12 + 3
	goto __2460
__2459:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __2461
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len12 = len12 + 4
	goto __2462
__2461:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len12 = len12 + 5
__2462:
	;
__2460:
	;
__2458:
	;
__2456:
	;
__2454:
	;

	category5 = int32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fchartype])
	if !(libc.Bool32(category5 == ucp_L || category5 == ucp_N || fc == Tuint32_t('\137')) == notmatch2) {
		goto __2463
	}
	goto __2450
__2463:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += TPCRE2_SPTR8(len12)
	goto __2449
__2449:
	i++
	goto __2448
	goto __2450
__2450:
	;
	goto __2275

__2286:
	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__2464:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2466
	}

	len13 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2467
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2468
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2469
	}
	return -2
__2469:
	;
__2468:
	;

	goto __2466
__2467:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(utf != 0 && fc >= 0xc0) {
		goto __2470
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __2471
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len13++
	goto __2472
__2471:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __2473
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len13 = len13 + 2
	goto __2474
__2473:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __2475
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len13 = len13 + 3
	goto __2476
__2475:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __2477
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len13 = len13 + 4
	goto __2478
__2477:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len13 = len13 + 5
__2478:
	;
__2476:
	;
__2474:
	;
__2472:
	;
__2470:
	;

	cp3 = uintptr(unsafe.Pointer(&X_pcre2_ucd_caseless_sets_8)) + uintptr(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4)))*4
__2479:

	if !(fc < *(*Tuint32_t)(unsafe.Pointer(cp3))) {
		goto __2482
	}
	if !(notmatch2 != 0) {
		goto __2483
	}
	goto __2481
	goto __2484
__2483:
	goto GOT_MAX
__2484:
	;
__2482:
	;
	if !(fc == *(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&cp3, 4)))) {
		goto __2485
	}
	if !(notmatch2 != 0) {
		goto __2486
	}
	goto GOT_MAX
	goto __2487
__2486:
	goto __2481
__2487:
	;
__2485:
	;
	goto __2480
__2480:
	goto __2479
	goto __2481
__2481:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += TPCRE2_SPTR8(len13)
	goto __2465
__2465:
	i++
	goto __2464
	goto __2466
__2466:
	;
GOT_MAX:
	goto __2275

__2287:
	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__2488:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2490
	}

	len14 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2491
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2492
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2493
	}
	return -2
__2493:
	;
__2492:
	;

	goto __2490
__2491:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(utf != 0 && fc >= 0xc0) {
		goto __2494
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __2495
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len14++
	goto __2496
__2495:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __2497
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len14 = len14 + 2
	goto __2498
__2497:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __2499
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len14 = len14 + 3
	goto __2500
__2499:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __2501
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len14 = len14 + 4
	goto __2502
__2501:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len14 = len14 + 5
__2502:
	;
__2500:
	;
__2498:
	;
__2496:
	;
__2494:
	;

	if !(libc.Bool32(fc == Tuint32_t('\044') || fc == Tuint32_t('\100') || fc == Tuint32_t('\140') || fc >= Tuint32_t(0xa0) && fc <= Tuint32_t(0xd7ff) || fc >= Tuint32_t(0xe000)) == notmatch2) {
		goto __2503
	}
	goto __2490
__2503:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += TPCRE2_SPTR8(len14)
	goto __2489
__2489:
	i++
	goto __2488
	goto __2490
__2490:
	;
	goto __2275

__2288:
	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__2504:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2506
	}

	len15 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2507
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2508
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2509
	}
	return -2
__2509:
	;
__2508:
	;

	goto __2506
__2507:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(utf != 0 && fc >= 0xc0) {
		goto __2510
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __2511
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len15++
	goto __2512
__2511:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __2513
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len15 = len15 + 2
	goto __2514
__2513:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __2515
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len15 = len15 + 3
	goto __2516
__2515:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __2517
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len15 = len15 + 4
	goto __2518
__2517:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len15 = len15 + 5
__2518:
	;
__2516:
	;
__2514:
	;
__2512:
	;
__2510:
	;

	if !(libc.Bool32(Tuint32_t(int32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fscriptx_bidiclass)>>DUCD_BIDICLASS_SHIFT) == *(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4))) == notmatch2) {
		goto __2519
	}
	goto __2506
__2519:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += TPCRE2_SPTR8(len15)
	goto __2505
__2505:
	i++
	goto __2504
	goto __2506
__2506:
	;
	goto __2275

__2289:
	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__2520:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2522
	}

	len16 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2523
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2524
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2525
	}
	return -2
__2525:
	;
__2524:
	;

	goto __2522
__2523:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(utf != 0 && fc >= 0xc0) {
		goto __2526
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __2527
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len16++
	goto __2528
__2527:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __2529
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len16 = len16 + 2
	goto __2530
__2529:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __2531
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len16 = len16 + 3
	goto __2532
__2531:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __2533
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len16 = len16 + 4
	goto __2534
__2533:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len16 = len16 + 5
__2534:
	;
__2532:
	;
__2530:
	;
__2528:
	;
__2526:
	;

	prop6 = uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12
	ok7 = libc.Bool32(*(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_boolprop_sets_8)) + uintptr(int32((*Tucd_record)(unsafe.Pointer(prop6)).Fbprops)&DUCD_BPROPS_MASK)*4 + uintptr(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4))/Tuint32_t(32))*4))&(uint32(1)<<(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 3*4))%Tuint32_t(32))) != Tuint32_t(0))
	if !(ok7 == notmatch2) {
		goto __2535
	}
	goto __2522
__2535:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += TPCRE2_SPTR8(len16)
	goto __2521
__2521:
	i++
	goto __2520
	goto __2522
__2522:
	;
	goto __2275

__2290:
	return -44
__2275:
	;

	// Feptr is now past the end of the maximum run

	if !(reptype == REPTYPE_POS) {
		goto __2536
	}
	goto __11
__2536:
	; // No backtracking

	// After \C in UTF mode, Lstart_eptr might be in the middle of a
	//         Unicode character. Use <= Lstart_eptr to ensure backtracking doesn't
	//         go too far.

__2537:

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr <= *(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8))) {
		goto __2540
	}
	goto __2539
__2540:
	;
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM222
	goto MATCH_RECURSE
L_RM222:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __2541
	}
	rrc = rrc
	goto RETURN_SWITCH
__2541:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr--
	if !(utf != 0) {
		goto __2542
	}
__2543:
	if !(uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0xc0 == 0x80) {
		goto __2544
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr--
	goto __2543
__2544:
	;
__2542:
	;
	goto __2538
__2538:
	goto __2537
	goto __2539
__2539:
	;
	goto __2274
__2273:
	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) == OP_EXTUNI) {
		goto __2545
	}

	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__2547:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2549
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2550
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2552
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2553
	}
	return -2
__2553:
	;
__2552:
	;

	goto __2549
	goto __2551
__2550:

	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __2554
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __2555
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __2556
__2555:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __2557
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __2558
__2557:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __2559
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __2560
__2559:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __2561
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __2562
__2561:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += uintptr(5)
__2562:
	;
__2560:
	;
__2558:
	;
__2556:
	;
__2554:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr = X_pcre2_extuni_8(tls, fc, (*Theapframe)(unsafe.Pointer(F)).Feptr, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject,
		utf, uintptr(0))
__2551:
	;
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2563
	}
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2564
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2565
	}
	return -2
__2565:
	;
__2564:
	;
__2563:
	;

	goto __2548
__2548:
	i++
	goto __2547
	goto __2549
__2549:
	;

	// Feptr is now past the end of the maximum run

	if !(reptype == REPTYPE_POS) {
		goto __2566
	}
	goto __11
__2566:
	; // No backtracking

	// We use <= Lstart_eptr rather than == Lstart_eptr to detect the start
	//         of the run while backtracking because the use of \C in UTF mode can
	//         cause BACKCHAR to move back past Lstart_eptr. This is just palliative;
	//         the use of \C in UTF mode is fraught with danger.

__2567:

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr <= *(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8))) {
		goto __2570
	}
	goto __2569
__2570:
	; /* At start of char run */
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM220
	goto MATCH_RECURSE
L_RM220:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __2571
	}
	rrc = rrc
	goto RETURN_SWITCH
__2571:
	;

	// Backtracking over an extended grapheme cluster involves inspecting
	//           the previous two characters (if present) to see if a break is
	//           permitted between them.

	(*Theapframe)(unsafe.Pointer(F)).Feptr--
	if !!(utf != 0) {
		goto __2572
	}
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	goto __2573
__2572:

__2574:
	if !(uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0xc0 == 0x80) {
		goto __2575
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr--
	goto __2574
__2575:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(fc >= 0xc0) {
		goto __2576
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __2577
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	goto __2578
__2577:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __2579
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	goto __2580
__2579:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __2581
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	goto __2582
__2581:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __2583
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	goto __2584
__2583:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
__2584:
	;
__2582:
	;
__2580:
	;
__2578:
	;
__2576:
	;

__2573:
	;
	rgb = int32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fgbprop)

__2585:

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr <= *(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8))) {
		goto __2588
	}
	goto __2587
__2588:
	; // At start of char run
	fptr = (*Theapframe)(unsafe.Pointer(F)).Feptr - uintptr(1)
	if !!(utf != 0) {
		goto __2589
	}
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(fptr)))
	goto __2590
__2589:

__2591:
	if !(uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(fptr)))&0xc0 == 0x80) {
		goto __2592
	}
	fptr--
	goto __2591
__2592:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(fptr)))
	if !(fc >= 0xc0) {
		goto __2593
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __2594
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(fptr + 1)))&0x3f
	goto __2595
__2594:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __2596
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(fptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(fptr + 2)))&0x3f
	goto __2597
__2596:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __2598
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(fptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(fptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(fptr + 3)))&0x3f
	goto __2599
__2598:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __2600
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(fptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(fptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(fptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(fptr + 4)))&0x3f
	goto __2601
__2600:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(fptr + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(fptr + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(fptr + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(fptr + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(fptr + 5)))&0x3f
__2601:
	;
__2599:
	;
__2597:
	;
__2595:
	;
__2593:
	;

__2590:
	;
	lgb = int32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fgbprop)
	if !(X_pcre2_ucp_gbtable_8[lgb]&(uint32(1)<<rgb) == Tuint32_t(0)) {
		goto __2602
	}
	goto __2587
__2602:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr = fptr
	rgb = lgb
	goto __2586
__2586:
	goto __2585
	goto __2587
__2587:
	;
	goto __2568
__2568:
	goto __2567
	goto __2569
__2569:
	;
	goto __2546
__2545:

	if !(utf != 0) {
		goto __2603
	}

	switch *(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) {
	case OP_ANY:
		goto __2606

	case OP_ALLANY:
		goto __2607

	// The "byte" (i.e. "code unit") case is the same as non-UTF

	case OP_ANYBYTE:
		goto __2608

	case OP_ANYNL:
		goto __2609

	case OP_NOT_HSPACE:
		goto __2610
	case OP_HSPACE:
		goto __2611

	case OP_NOT_VSPACE:
		goto __2612
	case OP_VSPACE:
		goto __2613

	case OP_NOT_DIGIT:
		goto __2614

	case OP_DIGIT:
		goto __2615

	case OP_NOT_WHITESPACE:
		goto __2616

	case OP_WHITESPACE:
		goto __2617

	case OP_NOT_WORDCHAR:
		goto __2618

	case OP_WORDCHAR:
		goto __2619

	default:
		goto __2620
	}
	goto __2605

__2606:
	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__2621:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2623
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2624
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2625
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2626
	}
	return -2
__2626:
	;
__2625:
	;

	goto __2623
__2624:
	;
	if !(func() int32 {
		if (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype != Tuint32_t(DNLTYPE_FIXED) {
			return libc.Bool32((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, (*Theapframe)(unsafe.Pointer(F)).Feptr, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+256, utf) != 0)
		}
		return libc.Bool32((*Theapframe)(unsafe.Pointer(F)).Feptr <= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260))) && ((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(1) || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + uintptr(1)))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260 + 1)))))
	}() != 0) {
		goto __2627
	}
	goto __2623
__2627:
	;
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && (*Theapframe)(unsafe.Pointer(F)).Feptr+uintptr(1) >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype == Tuint32_t(DNLTYPE_FIXED) && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(2) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260)))) {
		goto __2628
	}

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2629
	}
	return -2
__2629:
	;
__2628:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
__2630:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0xc0 == 0x80) {
		goto __2631
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __2630
__2631:
	;
	goto __2622
__2622:
	i++
	goto __2621
	goto __2623
__2623:
	;
	goto __2605

__2607:
	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4)) < 4294967295) {
		goto __2632
	}

	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__2634:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2636
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2637
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2638
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2639
	}
	return -2
__2639:
	;
__2638:
	;

	goto __2636
__2637:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
__2640:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0xc0 == 0x80) {
		goto __2641
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __2640
__2641:
	;
	goto __2635
__2635:
	i++
	goto __2634
	goto __2636
__2636:
	;
	goto __2633
__2632:

	(*Theapframe)(unsafe.Pointer(F)).Feptr = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject // Unlimited UTF-8 repeat
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2642
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2643
	}
	return -2
__2643:
	;
__2642:
	;

__2633:
	;
	goto __2605

	// The "byte" (i.e. "code unit") case is the same as non-UTF

__2608:
	fc = *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4)) - *(*Tuint32_t)(unsafe.Pointer(F + 56))
	if !(fc > Tuint32_t((int64((*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject)-int64((*Theapframe)(unsafe.Pointer(F)).Feptr))/1)) {
		goto __2644
	}

	(*Theapframe)(unsafe.Pointer(F)).Feptr = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2646
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2647
	}
	return -2
__2647:
	;
__2646:
	;

	goto __2645
__2644:
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += TPCRE2_SPTR8(fc)
__2645:
	;
	goto __2605

__2609:
	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__2648:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2650
	}

	len17 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2651
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2652
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2653
	}
	return -2
__2653:
	;
__2652:
	;

	goto __2650
__2651:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(fc >= 0xc0) {
		goto __2654
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __2655
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len17++
	goto __2656
__2655:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __2657
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len17 = len17 + 2
	goto __2658
__2657:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __2659
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len17 = len17 + 3
	goto __2660
__2659:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __2661
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len17 = len17 + 4
	goto __2662
__2661:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len17 = len17 + 5
__2662:
	;
__2660:
	;
__2658:
	;
__2656:
	;
__2654:
	;

	if !(fc == Tuint32_t('\015')) {
		goto __2663
	}

	if !(libc.PreIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1) >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2665
	}
	goto __2650
__2665:
	;
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == '\012') {
		goto __2666
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
__2666:
	;
	goto __2664
__2663:

	if !(fc != Tuint32_t('\012') && (int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fbsr_convention) == DPCRE2_BSR_ANYCRLF || fc != Tuint32_t('\013') && fc != Tuint32_t('\014') && fc != Tuint32_t(uint8('\x85')) &&
		fc != Tuint32_t(0x2028) && fc != Tuint32_t(0x2029))) {
		goto __2667
	}
	goto __2650
__2667:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += TPCRE2_SPTR8(len17)
__2664:
	;
	goto __2649
__2649:
	i++
	goto __2648
	goto __2650
__2650:
	;
	goto __2605

__2610:
__2611:
	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__2668:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2670
	}

	len18 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2671
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2672
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2673
	}
	return -2
__2673:
	;
__2672:
	;

	goto __2670
__2671:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(fc >= 0xc0) {
		goto __2674
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __2675
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len18++
	goto __2676
__2675:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __2677
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len18 = len18 + 2
	goto __2678
__2677:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __2679
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len18 = len18 + 3
	goto __2680
__2679:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __2681
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len18 = len18 + 4
	goto __2682
__2681:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len18 = len18 + 5
__2682:
	;
__2680:
	;
__2678:
	;
__2676:
	;
__2674:
	;

	switch fc {
	case Tuint32_t('\011'):
		goto __2684
	case Tuint32_t('\040'):
		goto __2685
	case Tuint32_t(uint8('\xa0')):
		goto __2686
	case Tuint32_t(0x1680):
		goto __2687 /* OGHAM SPACE MARK */
	case Tuint32_t(0x180e):
		goto __2688 /* MONGOLIAN VOWEL SEPARATOR */
	case Tuint32_t(0x2000):
		goto __2689 /* EN QUAD */
	case Tuint32_t(0x2001):
		goto __2690 /* EM QUAD */
	case Tuint32_t(0x2002):
		goto __2691 /* EN SPACE */
	case Tuint32_t(0x2003):
		goto __2692 /* EM SPACE */
	case Tuint32_t(0x2004):
		goto __2693 /* THREE-PER-EM SPACE */
	case Tuint32_t(0x2005):
		goto __2694 /* FOUR-PER-EM SPACE */
	case Tuint32_t(0x2006):
		goto __2695 /* SIX-PER-EM SPACE */
	case Tuint32_t(0x2007):
		goto __2696 /* FIGURE SPACE */
	case Tuint32_t(0x2008):
		goto __2697 /* PUNCTUATION SPACE */
	case Tuint32_t(0x2009):
		goto __2698 /* THIN SPACE */
	case Tuint32_t(0x200A):
		goto __2699 /* HAIR SPACE */
	case Tuint32_t(0x202f):
		goto __2700 /* NARROW NO-BREAK SPACE */
	case Tuint32_t(0x205f):
		goto __2701 /* MEDIUM MATHEMATICAL SPACE */
	case Tuint32_t(0x3000):
		goto __2702
	default:
		goto __2703
	}
	goto __2683

__2684:
__2685:
__2686:
__2687: /* OGHAM SPACE MARK */
__2688: /* MONGOLIAN VOWEL SEPARATOR */
__2689: /* EN QUAD */
__2690: /* EM QUAD */
__2691: /* EN SPACE */
__2692: /* EM SPACE */
__2693: /* THREE-PER-EM SPACE */
__2694: /* FOUR-PER-EM SPACE */
__2695: /* SIX-PER-EM SPACE */
__2696: /* FIGURE SPACE */
__2697: /* PUNCTUATION SPACE */
__2698: /* THIN SPACE */
__2699: /* HAIR SPACE */
__2700: /* NARROW NO-BREAK SPACE */
__2701: /* MEDIUM MATHEMATICAL SPACE */
__2702:
	gotspace = DTRUE
	goto __2683
__2703:
	gotspace = DFALSE
	goto __2683
__2683:
	;
	if !(gotspace == libc.Bool32(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) == OP_NOT_HSPACE)) {
		goto __2704
	}
	goto __2670
__2704:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += TPCRE2_SPTR8(len18)
	goto __2669
__2669:
	i++
	goto __2668
	goto __2670
__2670:
	;
	goto __2605

__2612:
__2613:
	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__2705:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2707
	}

	len19 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2708
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2709
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2710
	}
	return -2
__2710:
	;
__2709:
	;

	goto __2707
__2708:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(fc >= 0xc0) {
		goto __2711
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __2712
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len19++
	goto __2713
__2712:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __2714
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len19 = len19 + 2
	goto __2715
__2714:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __2716
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len19 = len19 + 3
	goto __2717
__2716:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __2718
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len19 = len19 + 4
	goto __2719
__2718:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len19 = len19 + 5
__2719:
	;
__2717:
	;
__2715:
	;
__2713:
	;
__2711:
	;

	switch fc {
	case Tuint32_t('\012'):
		goto __2721
	case Tuint32_t('\013'):
		goto __2722
	case Tuint32_t('\014'):
		goto __2723
	case Tuint32_t('\015'):
		goto __2724
	case Tuint32_t(uint8('\x85')):
		goto __2725
	case Tuint32_t(0x2028):
		goto __2726 /* LINE SEPARATOR */
	case Tuint32_t(0x2029):
		goto __2727
	default:
		goto __2728
	}
	goto __2720

__2721:
__2722:
__2723:
__2724:
__2725:
__2726: /* LINE SEPARATOR */
__2727:
	gotspace1 = DTRUE
	goto __2720
__2728:
	gotspace1 = DFALSE
	goto __2720
__2720:
	;
	if !(gotspace1 == libc.Bool32(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) == OP_NOT_VSPACE)) {
		goto __2729
	}
	goto __2707
__2729:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += TPCRE2_SPTR8(len19)
	goto __2706
__2706:
	i++
	goto __2705
	goto __2707
__2707:
	;
	goto __2605

__2614:
	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__2730:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2732
	}

	len20 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2733
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2734
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2735
	}
	return -2
__2735:
	;
__2734:
	;

	goto __2732
__2733:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(fc >= 0xc0) {
		goto __2736
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __2737
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len20++
	goto __2738
__2737:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __2739
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len20 = len20 + 2
	goto __2740
__2739:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __2741
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len20 = len20 + 3
	goto __2742
__2741:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __2743
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len20 = len20 + 4
	goto __2744
__2743:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len20 = len20 + 5
__2744:
	;
__2742:
	;
__2740:
	;
__2738:
	;
__2736:
	;

	if !(fc < Tuint32_t(256) && int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_digit != 0) {
		goto __2745
	}
	goto __2732
__2745:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += TPCRE2_SPTR8(len20)
	goto __2731
__2731:
	i++
	goto __2730
	goto __2732
__2732:
	;
	goto __2605

__2615:
	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__2746:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2748
	}

	len21 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2749
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2750
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2751
	}
	return -2
__2751:
	;
__2750:
	;

	goto __2748
__2749:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(fc >= 0xc0) {
		goto __2752
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __2753
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len21++
	goto __2754
__2753:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __2755
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len21 = len21 + 2
	goto __2756
__2755:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __2757
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len21 = len21 + 3
	goto __2758
__2757:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __2759
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len21 = len21 + 4
	goto __2760
__2759:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len21 = len21 + 5
__2760:
	;
__2758:
	;
__2756:
	;
__2754:
	;
__2752:
	;

	if !(fc >= Tuint32_t(256) || int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_digit == 0) {
		goto __2761
	}
	goto __2748
__2761:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += TPCRE2_SPTR8(len21)
	goto __2747
__2747:
	i++
	goto __2746
	goto __2748
__2748:
	;
	goto __2605

__2616:
	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__2762:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2764
	}

	len22 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2765
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2766
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2767
	}
	return -2
__2767:
	;
__2766:
	;

	goto __2764
__2765:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(fc >= 0xc0) {
		goto __2768
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __2769
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len22++
	goto __2770
__2769:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __2771
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len22 = len22 + 2
	goto __2772
__2771:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __2773
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len22 = len22 + 3
	goto __2774
__2773:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __2775
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len22 = len22 + 4
	goto __2776
__2775:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len22 = len22 + 5
__2776:
	;
__2774:
	;
__2772:
	;
__2770:
	;
__2768:
	;

	if !(fc < Tuint32_t(256) && int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_space != 0) {
		goto __2777
	}
	goto __2764
__2777:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += TPCRE2_SPTR8(len22)
	goto __2763
__2763:
	i++
	goto __2762
	goto __2764
__2764:
	;
	goto __2605

__2617:
	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__2778:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2780
	}

	len23 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2781
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2782
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2783
	}
	return -2
__2783:
	;
__2782:
	;

	goto __2780
__2781:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(fc >= 0xc0) {
		goto __2784
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __2785
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len23++
	goto __2786
__2785:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __2787
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len23 = len23 + 2
	goto __2788
__2787:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __2789
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len23 = len23 + 3
	goto __2790
__2789:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __2791
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len23 = len23 + 4
	goto __2792
__2791:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len23 = len23 + 5
__2792:
	;
__2790:
	;
__2788:
	;
__2786:
	;
__2784:
	;

	if !(fc >= Tuint32_t(256) || int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_space == 0) {
		goto __2793
	}
	goto __2780
__2793:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += TPCRE2_SPTR8(len23)
	goto __2779
__2779:
	i++
	goto __2778
	goto __2780
__2780:
	;
	goto __2605

__2618:
	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__2794:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2796
	}

	len24 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2797
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2798
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2799
	}
	return -2
__2799:
	;
__2798:
	;

	goto __2796
__2797:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(fc >= 0xc0) {
		goto __2800
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __2801
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len24++
	goto __2802
__2801:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __2803
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len24 = len24 + 2
	goto __2804
__2803:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __2805
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len24 = len24 + 3
	goto __2806
__2805:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __2807
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len24 = len24 + 4
	goto __2808
__2807:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len24 = len24 + 5
__2808:
	;
__2806:
	;
__2804:
	;
__2802:
	;
__2800:
	;

	if !(fc < Tuint32_t(256) && int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_word != 0) {
		goto __2809
	}
	goto __2796
__2809:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += TPCRE2_SPTR8(len24)
	goto __2795
__2795:
	i++
	goto __2794
	goto __2796
__2796:
	;
	goto __2605

__2619:
	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__2810:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2812
	}

	len25 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2813
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2814
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2815
	}
	return -2
__2815:
	;
__2814:
	;

	goto __2812
__2813:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(fc >= 0xc0) {
		goto __2816
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __2817
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len25++
	goto __2818
__2817:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __2819
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len25 = len25 + 2
	goto __2820
__2819:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __2821
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len25 = len25 + 3
	goto __2822
__2821:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __2823
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len25 = len25 + 4
	goto __2824
__2823:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len25 = len25 + 5
__2824:
	;
__2822:
	;
__2820:
	;
__2818:
	;
__2816:
	;

	if !(fc >= Tuint32_t(256) || int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_word == 0) {
		goto __2825
	}
	goto __2812
__2825:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += TPCRE2_SPTR8(len25)
	goto __2811
__2811:
	i++
	goto __2810
	goto __2812
__2812:
	;
	goto __2605

__2620:
	return -44
__2605:
	;

	if !(reptype == REPTYPE_POS) {
		goto __2826
	}
	goto __11
__2826:
	; // No backtracking

	// After \C in UTF mode, Lstart_eptr might be in the middle of a
	//         Unicode character. Use <= Lstart_eptr to ensure backtracking doesn't go
	//         too far.

__2827:

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr <= *(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8))) {
		goto __2830
	}
	goto __2829
__2830:
	;
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM221
	goto MATCH_RECURSE
L_RM221:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __2831
	}
	rrc = rrc
	goto RETURN_SWITCH
__2831:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr--
__2832:
	if !(uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0xc0 == 0x80) {
		goto __2833
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr--
	goto __2832
__2833:
	;
	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) == OP_ANYNL && (*Theapframe)(unsafe.Pointer(F)).Feptr > *(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8)) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == '\012' && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr - uintptr(1)))) == '\015') {
		goto __2834
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr--
__2834:
	;
	goto __2828
__2828:
	goto __2827
	goto __2829
__2829:
	;
	goto __2604
__2603:

	/* Not UTF mode */

	switch *(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) {
	case OP_ANY:
		goto __2836

	case OP_ALLANY:
		goto __2837
	case OP_ANYBYTE:
		goto __2838

	case OP_ANYNL:
		goto __2839

	case OP_NOT_HSPACE:
		goto __2840

	case OP_HSPACE:
		goto __2841

	case OP_NOT_VSPACE:
		goto __2842

	case OP_VSPACE:
		goto __2843

	case OP_NOT_DIGIT:
		goto __2844

	case OP_DIGIT:
		goto __2845

	case OP_NOT_WHITESPACE:
		goto __2846

	case OP_WHITESPACE:
		goto __2847

	case OP_NOT_WORDCHAR:
		goto __2848

	case OP_WORDCHAR:
		goto __2849

	default:
		goto __2850
	}
	goto __2835

__2836:
	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__2851:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2853
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2854
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2855
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2856
	}
	return -2
__2856:
	;
__2855:
	;

	goto __2853
__2854:
	;
	if !(func() int32 {
		if (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype != Tuint32_t(DNLTYPE_FIXED) {
			return libc.Bool32((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, (*Theapframe)(unsafe.Pointer(F)).Feptr, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+256, utf) != 0)
		}
		return libc.Bool32((*Theapframe)(unsafe.Pointer(F)).Feptr <= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260))) && ((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(1) || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + uintptr(1)))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260 + 1)))))
	}() != 0) {
		goto __2857
	}
	goto __2853
__2857:
	;
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && (*Theapframe)(unsafe.Pointer(F)).Feptr+uintptr(1) >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype == Tuint32_t(DNLTYPE_FIXED) && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(2) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260)))) {
		goto __2858
	}

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2859
	}
	return -2
__2859:
	;
__2858:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __2852
__2852:
	i++
	goto __2851
	goto __2853
__2853:
	;
	goto __2835

__2837:
__2838:
	fc = *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4)) - *(*Tuint32_t)(unsafe.Pointer(F + 56))
	if !(fc > Tuint32_t((int64((*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject)-int64((*Theapframe)(unsafe.Pointer(F)).Feptr))/1)) {
		goto __2860
	}

	(*Theapframe)(unsafe.Pointer(F)).Feptr = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2862
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2863
	}
	return -2
__2863:
	;
__2862:
	;

	goto __2861
__2860:
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += TPCRE2_SPTR8(fc)
__2861:
	;
	goto __2835

__2839:
	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__2864:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2866
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2867
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2868
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2869
	}
	return -2
__2869:
	;
__2868:
	;

	goto __2866
__2867:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(fc == Tuint32_t('\015')) {
		goto __2870
	}

	if !(libc.PreIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1) >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2872
	}
	goto __2866
__2872:
	;
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == '\012') {
		goto __2873
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
__2873:
	;
	goto __2871
__2870:

	if !(fc != Tuint32_t('\012') && (int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fbsr_convention) == DPCRE2_BSR_ANYCRLF || fc != Tuint32_t('\013') && fc != Tuint32_t('\014') && fc != Tuint32_t(uint8('\x85')))) {
		goto __2874
	}
	goto __2866
__2874:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
__2871:
	;
	goto __2865
__2865:
	i++
	goto __2864
	goto __2866
__2866:
	;
	goto __2835

__2840:
	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__2875:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2877
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2878
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2879
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2880
	}
	return -2
__2880:
	;
__2879:
	;

	goto __2877
__2878:
	;
	switch int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) {
	default:
		goto __2882
	case '\011':
		goto __2883
	case '\040':
		goto __2884
	case int32(uint8('\xa0')):
		goto __2885
	}
	goto __2881

__2882:
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __2881
__2883:
__2884:
__2885:
	goto ENDLOOP00
__2881:
	;
	goto __2876
__2876:
	i++
	goto __2875
	goto __2877
__2877:
	;
ENDLOOP00:
	goto __2835

__2841:
	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__2886:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2888
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2889
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2890
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2891
	}
	return -2
__2891:
	;
__2890:
	;

	goto __2888
__2889:
	;
	switch int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) {
	default:
		goto __2893
	case '\011':
		goto __2894
	case '\040':
		goto __2895
	case int32(uint8('\xa0')):
		goto __2896
	}
	goto __2892

__2893:
	goto ENDLOOP01
__2894:
__2895:
__2896:
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __2892
__2892:
	;
	goto __2887
__2887:
	i++
	goto __2886
	goto __2888
__2888:
	;
ENDLOOP01:
	goto __2835

__2842:
	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__2897:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2899
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2900
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2901
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2902
	}
	return -2
__2902:
	;
__2901:
	;

	goto __2899
__2900:
	;
	switch int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) {
	default:
		goto __2904
	case '\012':
		goto __2905
	case '\013':
		goto __2906
	case '\014':
		goto __2907
	case '\015':
		goto __2908
	case int32(uint8('\x85')):
		goto __2909
	}
	goto __2903

__2904:
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __2903
__2905:
__2906:
__2907:
__2908:
__2909:
	goto ENDLOOP02
__2903:
	;
	goto __2898
__2898:
	i++
	goto __2897
	goto __2899
__2899:
	;
ENDLOOP02:
	goto __2835

__2843:
	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__2910:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2912
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2913
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2914
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2915
	}
	return -2
__2915:
	;
__2914:
	;

	goto __2912
__2913:
	;
	switch int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) {
	default:
		goto __2917
	case '\012':
		goto __2918
	case '\013':
		goto __2919
	case '\014':
		goto __2920
	case '\015':
		goto __2921
	case int32(uint8('\x85')):
		goto __2922
	}
	goto __2916

__2917:
	goto ENDLOOP03
__2918:
__2919:
__2920:
__2921:
__2922:
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __2916
__2916:
	;
	goto __2911
__2911:
	i++
	goto __2910
	goto __2912
__2912:
	;
ENDLOOP03:
	goto __2835

__2844:
	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__2923:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2925
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2926
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2927
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2928
	}
	return -2
__2928:
	;
__2927:
	;

	goto __2925
__2926:
	;
	if !(1 != 0 && int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))))))&Dctype_digit != 0) {
		goto __2929
	}
	goto __2925
__2929:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __2924
__2924:
	i++
	goto __2923
	goto __2925
__2925:
	;
	goto __2835

__2845:
	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__2930:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2932
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2933
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2934
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2935
	}
	return -2
__2935:
	;
__2934:
	;

	goto __2932
__2933:
	;
	if !(!(1 != 0) || int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))))))&Dctype_digit == 0) {
		goto __2936
	}
	goto __2932
__2936:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __2931
__2931:
	i++
	goto __2930
	goto __2932
__2932:
	;
	goto __2835

__2846:
	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__2937:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2939
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2940
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2941
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2942
	}
	return -2
__2942:
	;
__2941:
	;

	goto __2939
__2940:
	;
	if !(1 != 0 && int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))))))&Dctype_space != 0) {
		goto __2943
	}
	goto __2939
__2943:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __2938
__2938:
	i++
	goto __2937
	goto __2939
__2939:
	;
	goto __2835

__2847:
	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__2944:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2946
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2947
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2948
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2949
	}
	return -2
__2949:
	;
__2948:
	;

	goto __2946
__2947:
	;
	if !(!(1 != 0) || int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))))))&Dctype_space == 0) {
		goto __2950
	}
	goto __2946
__2950:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __2945
__2945:
	i++
	goto __2944
	goto __2946
__2946:
	;
	goto __2835

__2848:
	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__2951:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2953
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2954
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2955
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2956
	}
	return -2
__2956:
	;
__2955:
	;

	goto __2953
__2954:
	;
	if !(1 != 0 && int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))))))&Dctype_word != 0) {
		goto __2957
	}
	goto __2953
__2957:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __2952
__2952:
	i++
	goto __2951
	goto __2953
__2953:
	;
	goto __2835

__2849:
	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__2958:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2960
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2961
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2962
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2963
	}
	return -2
__2963:
	;
__2962:
	;

	goto __2960
__2961:
	;
	if !(!(1 != 0) || int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))))))&Dctype_word == 0) {
		goto __2964
	}
	goto __2960
__2964:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __2959
__2959:
	i++
	goto __2958
	goto __2960
__2960:
	;
	goto __2835

__2850:
	return -44
__2835:
	;

	if !(reptype == REPTYPE_POS) {
		goto __2965
	}
	goto __11
__2965:
	; // No backtracking

__2966:

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr == *(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8))) {
		goto __2969
	}
	goto __2968
__2969:
	;
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM34
	goto MATCH_RECURSE
L_RM34:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __2970
	}
	rrc = rrc
	goto RETURN_SWITCH
__2970:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr--
	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) == OP_ANYNL && (*Theapframe)(unsafe.Pointer(F)).Feptr > *(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8)) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == '\012' && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + libc.UintptrFromInt32(-1)))) == '\015') {
		goto __2971
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr--
__2971:
	;
	goto __2967
__2967:
	goto __2966
	goto __2968
__2968:
	;
__2604:
	;
__2546:
	;
__2274:
	;
__1781:
	;
	goto __13 // End of repeat character type processing

	// =====================================================================
	// Match a back reference, possibly repeatedly. Look past the end of the
	//     item to see if there is repeat information following. The OP_REF and
	//     OP_REFI opcodes are used for a reference to a numbered group or to a
	//     non-duplicated named group. For a duplicated named group, OP_DNREF and
	//     OP_DNREFI are used. In this case we must scan the list of groups to which
	//     the name refers, and use the first one that is set.

__107:
__108:
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) = Tuint32_t(libc.Bool32(int32((*Theapframe)(unsafe.Pointer(F)).Fop) == OP_DNREFI))

	count = int32(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 4)))))
	slot = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fname_table + uintptr(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))))*uint32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fname_entry_size))
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8(1 + 2*DIMM2_SIZE)

__2972:
	if !(libc.PostDecInt32(&count, 1) > 0) {
		goto __2973
	}

	(*Theapframe)(unsafe.Pointer(F)).Ftemp_size = Tsize_t(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(slot)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(slot + 1))))<<1 - uint32(2))
	if !((*Theapframe)(unsafe.Pointer(F)).Ftemp_size < (*Theapframe)(unsafe.Pointer(F)).Foffset_top && *(*Tsize_t)(unsafe.Pointer(F + 128 + uintptr((*Theapframe)(unsafe.Pointer(F)).Ftemp_size)*8)) != libc.CplUint64(uint64(0))) {
		goto __2974
	}
	goto __2973
__2974:
	;
	slot += TPCRE2_SPTR8((*Tmatch_block_8)(unsafe.Pointer(mb)).Fname_entry_size)
	goto __2972
__2973:
	;

	goto REF_REPEAT

__109:
__110:
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) = Tuint32_t(libc.Bool32(int32((*Theapframe)(unsafe.Pointer(F)).Fop) == OP_REFI))
	(*Theapframe)(unsafe.Pointer(F)).Ftemp_size = Tsize_t(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))))<<1 - uint32(2))
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8(1 + DIMM2_SIZE)

	// Set up for repetition, or handle the non-repeated case. The maximum and
	//     minimum must be in the heap frame, but as they are short-term values, we
	//     use temporary fields.

REF_REPEAT:
	switch int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) {
	case OP_CRSTAR:
		goto __2976
	case OP_CRMINSTAR:
		goto __2977
	case OP_CRPLUS:
		goto __2978
	case OP_CRMINPLUS:
		goto __2979
	case OP_CRQUERY:
		goto __2980
	case OP_CRMINQUERY:
		goto __2981

	case OP_CRRANGE:
		goto __2982
	case OP_CRMINRANGE:
		goto __2983

	default:
		goto __2984
	}
	goto __2975

__2976:
__2977:
__2978:
__2979:
__2980:
__2981:
	fc = Tuint32_t(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Fecode, 1)))) - OP_CRSTAR)
	*(*Tuint32_t)(unsafe.Pointer(F + 56)) = rep_min[fc]
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4)) = rep_max[fc]
	reptype = rep_typ[fc]
	goto __2975

__2982:
__2983:
	*(*Tuint32_t)(unsafe.Pointer(F + 56)) = uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))))
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4)) = uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 4))))
	reptype = rep_typ[int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode)))-OP_CRSTAR]
	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4)) == Tuint32_t(0)) {
		goto __2985
	}
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4)) = 4294967295
__2985:
	; // Max 0 => infinity
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8(1 + 2*DIMM2_SIZE)
	goto __2975

__2984: /* No repeat follows */

	rrc = match_ref(tls, (*Theapframe)(unsafe.Pointer(F)).Ftemp_size, int32(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4))), F, mb, bp)
	if !(rrc != 0) {
		goto __2986
	}

	if !(rrc > 0) {
		goto __2987
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject
__2987:
	; // Partial match
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2988
	}
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2989
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2990
	}
	return -2
__2990:
	;
__2989:
	;
__2988:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__2986:
	;

	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += TPCRE2_SPTR8(*(*Tsize_t)(unsafe.Pointer(bp)))
	goto __11 // With the main loop
__2975:
	;

	// Handle repeated back references. If a set group has length zero, just
	//     continue with the main loop, because it matches however many times. For an
	//     unset reference, if the minimum is zero, we can also just continue. We can
	//     also continue if PCRE2_MATCH_UNSET_BACKREF is set, because this makes unset
	//     group behave as a zero-length group. For any other unset cases, carrying
	//     on will result in NOMATCH.

	if !((*Theapframe)(unsafe.Pointer(F)).Ftemp_size < (*Theapframe)(unsafe.Pointer(F)).Foffset_top && *(*Tsize_t)(unsafe.Pointer(F + 128 + uintptr((*Theapframe)(unsafe.Pointer(F)).Ftemp_size)*8)) != libc.CplUint64(uint64(0))) {
		goto __2991
	}

	if !(*(*Tsize_t)(unsafe.Pointer(F + 128 + uintptr((*Theapframe)(unsafe.Pointer(F)).Ftemp_size)*8)) == *(*Tsize_t)(unsafe.Pointer(F + 128 + uintptr((*Theapframe)(unsafe.Pointer(F)).Ftemp_size+uint64(1))*8))) {
		goto __2993
	}
	goto __11
__2993:
	;
	goto __2992
__2991: /* Group is not set */

	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56)) == Tuint32_t(0) || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fpoptions&DPCRE2_MATCH_UNSET_BACKREF != Tuint32_t(0)) {
		goto __2994
	}
	goto __11
__2994:
	;
__2992:
	;

	// First, ensure the minimum number of matches are present.

	i = Tuint32_t(1)
__2995:
	if !(i <= *(*Tuint32_t)(unsafe.Pointer(F + 56))) {
		goto __2997
	}

	rrc = match_ref(tls, (*Theapframe)(unsafe.Pointer(F)).Ftemp_size, int32(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4))), F, mb, bp+8)
	if !(rrc != 0) {
		goto __2998
	}

	if !(rrc > 0) {
		goto __2999
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject
__2999:
	; // Partial match
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __3000
	}
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __3001
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __3002
	}
	return -2
__3002:
	;
__3001:
	;
__3000:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__2998:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += TPCRE2_SPTR8(*(*Tsize_t)(unsafe.Pointer(bp + 8)))
	goto __2996
__2996:
	i++
	goto __2995
	goto __2997
__2997:
	;

	// If min = max, we are done. They are not both allowed to be zero.

	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56)) == *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __3003
	}
	goto __11
__3003:
	;

	// If minimizing, keep trying and advancing the pointer.

	if !(reptype == REPTYPE_MIN) {
		goto __3004
	}

__3006:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM20
	goto MATCH_RECURSE
L_RM20:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __3009
	}
	rrc = rrc
	goto RETURN_SWITCH
__3009:
	;

	if !(libc.PostIncUint32(&*(*Tuint32_t)(unsafe.Pointer(F + 56)), 1) >= *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __3010
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__3010:
	;

	rrc = match_ref(tls, (*Theapframe)(unsafe.Pointer(F)).Ftemp_size, int32(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4))), F, mb, bp+16)
	if !(rrc != 0) {
		goto __3011
	}

	if !(rrc > 0) {
		goto __3012
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject
__3012:
	; // Partial match
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __3013
	}
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __3014
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __3015
	}
	return -2
__3015:
	;
__3014:
	;
__3013:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__3011:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += TPCRE2_SPTR8(*(*Tsize_t)(unsafe.Pointer(bp + 16)))
	goto __3007
__3007:
	goto __3006
	goto __3008
__3008:
	;
	// Control never gets here
	goto __3005
__3004:
	samelengths = DTRUE
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8)) = (*Theapframe)(unsafe.Pointer(F)).Feptr // Starting position
	(*Theapframe)(unsafe.Pointer(F)).Flength = *(*Tsize_t)(unsafe.Pointer(F + 128 + uintptr((*Theapframe)(unsafe.Pointer(F)).Ftemp_size+uint64(1))*8)) - *(*Tsize_t)(unsafe.Pointer(F + 128 + uintptr((*Theapframe)(unsafe.Pointer(F)).Ftemp_size)*8))

	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__3016:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __3018
	}

	rrc = match_ref(tls, (*Theapframe)(unsafe.Pointer(F)).Ftemp_size, int32(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4))), F, mb, bp+24)
	if !(rrc != 0) {
		goto __3019
	}

	// Can't use CHECK_PARTIAL because we don't want to update Feptr in
	//           the soft partial matching case.

	if !(rrc > 0 && int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr) {
		goto __3020
	}

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __3021
	}
	return -2
__3021:
	;
__3020:
	;
	goto __3018
__3019:
	;

	if !(*(*Tsize_t)(unsafe.Pointer(bp + 24)) != (*Theapframe)(unsafe.Pointer(F)).Flength) {
		goto __3022
	}
	samelengths = DFALSE
__3022:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += TPCRE2_SPTR8(*(*Tsize_t)(unsafe.Pointer(bp + 24)))
	goto __3017
__3017:
	i++
	goto __3016
	goto __3018
__3018:
	;

	// If the length matched for each repetition is the same as the length of
	//       the captured group, we can easily work backwards. This is the normal
	//       case. However, in caseless UTF-8 mode there are pairs of case-equivalent
	//       characters whose lengths (in terms of code units) differ. However, this
	//       is very rare, so we handle it by re-matching fewer and fewer times.

	if !(samelengths != 0) {
		goto __3023
	}

__3025:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= *(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8))) {
		goto __3026
	}

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM21
	goto MATCH_RECURSE
L_RM21:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __3027
	}
	rrc = rrc
	goto RETURN_SWITCH
__3027:
	;

	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) -= TPCRE2_SPTR8((*Theapframe)(unsafe.Pointer(F)).Flength)
	goto __3025
__3026:
	;
	goto __3024
__3023:

	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4)) = i
__3028:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM22
	goto MATCH_RECURSE
L_RM22:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __3031
	}
	rrc = rrc
	goto RETURN_SWITCH
__3031:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr == *(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8))) {
		goto __3032
	}
	goto __3030
__3032:
	; // Failed after minimal repetition
	(*Theapframe)(unsafe.Pointer(F)).Feptr = *(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8))
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))--
	i = *(*Tuint32_t)(unsafe.Pointer(F + 56))
__3033:
	if !(i < *(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __3035
	}

	match_ref(tls, (*Theapframe)(unsafe.Pointer(F)).Ftemp_size, int32(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4))), F, mb, bp+32)
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) += TPCRE2_SPTR8(*(*Tsize_t)(unsafe.Pointer(bp + 32)))
	goto __3034
__3034:
	i++
	goto __3033
	goto __3035
__3035:
	;
	goto __3029
__3029:
	goto __3028
	goto __3030
__3030:
	;
__3024:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__3005:
	;
	// Control never gets here

	// =========================================================================
	//           Opcodes for the start of various parenthesized items
	// =========================================================================

	// In all cases, if the result of RMATCH() is MATCH_THEN, check whether the
	//     (*THEN) is within the current branch by comparing the address of OP_THEN
	//     that is passed back with the end of the branch. If (*THEN) is within the
	//     current branch, and the branch is one of two or more alternatives (it
	//     either starts or ends with OP_ALT), we have reached the limit of THEN's
	//     action, so convert the return code to NOMATCH, which will cause normal
	//     backtracking to happen from now on. Otherwise, THEN is passed back to an
	//     outer alternative. This implements Perl's treatment of parenthesized
	//     groups, where a group not containing | does not affect the current
	//     alternative, that is, (X) is NOT the same as (X|(*F)).

	// =====================================================================
	// BRAZERO, BRAMINZERO and SKIPZERO occur just before a non-possessive
	//     bracket group, indicating that it may occur zero times. It may repeat
	//     infinitely, or not at all - i.e. it could be ()* or ()? or even (){0} in
	//     the pattern. Brackets with fixed upper repeat limits are compiled as a
	//     number of copies, with the optional ones preceded by BRAZERO or BRAMINZERO.
	//     Possessive groups with possible zero repeats are preceded by BRAPOSZERO.

__111:
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8)) = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(1)
	start_ecode = *(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8))
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM9
	goto MATCH_RECURSE
L_RM9:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __3036
	}
	rrc = rrc
	goto RETURN_SWITCH
__3036:
	;

__3037:
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8)) += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8)) + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8)) + 2)))))
	goto __3038
__3038:
	if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8))))) == OP_ALT {
		goto __3037
	}
	goto __3039
__3039:
	;
	(*Theapframe)(unsafe.Pointer(F)).Fecode = *(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8)) + uintptr(1) + uintptr(DLINK_SIZE)
	goto __13

__112:
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8)) = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(1)
__3040:
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8)) += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8)) + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8)) + 2)))))
	goto __3041
__3041:
	if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8))))) == OP_ALT {
		goto __3040
	}
	goto __3042
__3042:
	;
	start_ecode = *(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8)) + uintptr(1) + uintptr(DLINK_SIZE)
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM10
	goto MATCH_RECURSE
L_RM10:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __3043
	}
	rrc = rrc
	goto RETURN_SWITCH
__3043:
	;

	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __13

__113:
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
__3044:
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))))
	goto __3045
__3045:
	if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) == OP_ALT {
		goto __3044
	}
	goto __3046
__3046:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8(1 + DLINK_SIZE)
	goto __13

	// =====================================================================
	// Handle possessive brackets with an unlimited repeat. The end of these
	//     brackets will always be OP_KETRPOS, which returns MATCH_KETRPOS without
	//     going further in the pattern.

__114:
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) = Tuint32_t(DTRUE) // Zero repeat is allowed
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += uintptr(1)
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) == OP_CBRAPOS || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) == OP_SCBRAPOS) {
		goto __3047
	}
	goto POSSESSIVE_CAPTURE
__3047:
	;
	goto POSSESSIVE_NON_CAPTURE

__115:
__116:
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) = Tuint32_t(DFALSE) // Zero repeat not allowed

POSSESSIVE_NON_CAPTURE:
	*(*Tuint32_t)(unsafe.Pointer(F + 56)) = DGF_NOCAPTURE // Remembered frame type
	goto POSSESSIVE_GROUP

__117:
__118:
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) = Tuint32_t(DFALSE) // Zero repeat not allowed

POSSESSIVE_CAPTURE:
	number = uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 4))))
	*(*Tuint32_t)(unsafe.Pointer(F + 56)) = DGF_CAPTURE | number // Remembered frame type

POSSESSIVE_GROUP:
	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4)) = Tuint32_t(DFALSE)                         // Never matched
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8 + 1*8)) = (*Theapframe)(unsafe.Pointer(F)).Fecode // Start of this group

__3048:

	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8)) = (*Theapframe)(unsafe.Pointer(F)).Feptr // Position at group start
	group_frame_type = *(*Tuint32_t)(unsafe.Pointer(F + 56))
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(X_pcre2_OP_lengths_8[*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))])
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM8
	goto MATCH_RECURSE
L_RM8:
	;

	if !(rrc == -998) {
		goto __3051
	}

	*(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4)) = Tuint32_t(DTRUE) // Matched at least once
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr == *(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8))) {
		goto __3052
	} /* Empty match; skip to end */

__3053:
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))))
	goto __3054
__3054:
	if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) == OP_ALT {
		goto __3053
	}
	goto __3055
__3055:
	;
	goto __3050
__3052:
	;

	(*Theapframe)(unsafe.Pointer(F)).Fecode = *(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8 + 1*8))
	goto __3049
__3051:
	;

	// See comment above about handling THEN.

	if !(rrc == -993) {
		goto __3056
	}

	next_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))))
	if !((*Tmatch_block_8)(unsafe.Pointer(mb)).Fverb_ecode_ptr < next_ecode && (int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) == OP_ALT || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(next_ecode))) == OP_ALT)) {
		goto __3057
	}
	rrc = DMATCH_NOMATCH
__3057:
	;
__3056:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __3058
	}
	rrc = rrc
	goto RETURN_SWITCH
__3058:
	;

	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))))
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) != OP_ALT) {
		goto __3059
	}
	goto __3050
__3059:
	;
	goto __3049
__3049:
	goto __3048
	goto __3050
__3050:
	;

	// Success if matched something or zero repeat allowed

	if !(*(*Tuint32_t)(unsafe.Pointer(F + 56 + 1*4)) != 0 || *(*Tuint32_t)(unsafe.Pointer(F + 56 + 2*4)) != 0) {
		goto __3060
	}

	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8(1 + DLINK_SIZE)
	goto __13
__3060:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

	// =====================================================================
	// Handle non-capturing brackets that cannot match an empty string. When we
	//     get to the final alternative within the brackets, as long as there are no
	//     THEN's in the pattern, we can optimize by not recording a new backtracking
	//     point. (Ideally we should test for a THEN within this group, but we don't
	//     have that information.) Don't do this if we are at the very top level,
	//     however, because that would make handling assertions and once-only brackets
	//     messier when there is nothing to go back to.

__119:
	if !((*Tmatch_block_8)(unsafe.Pointer(mb)).Fhasthen != 0 || (*Theapframe)(unsafe.Pointer(F)).Frdepth == Tuint32_t(0)) {
		goto __3061
	}

	*(*Tuint32_t)(unsafe.Pointer(F + 56)) = Tuint32_t(0)
	goto GROUPLOOP
__3061:
	;

__3062:

	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8)) = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))))
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8))))) != OP_ALT) {
		goto __3065
	}
	goto __3064
__3065:
	;

	/* This is never the final branch. We do not need to test for MATCH_THEN
	   here because this code is not used when there is a THEN in the pattern. */

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(X_pcre2_OP_lengths_8[*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))])
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM1
	goto MATCH_RECURSE
L_RM1:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __3066
	}
	rrc = rrc
	goto RETURN_SWITCH
__3066:
	;

	(*Theapframe)(unsafe.Pointer(F)).Fecode = *(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8))
	goto __3063
__3063:
	goto __3062
	goto __3064
__3064:
	;

	// Hit the start of the final branch. Continue at this level.

	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8(X_pcre2_OP_lengths_8[*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))])
	goto __13

	// =====================================================================
	// Handle a capturing bracket, other than those that are possessive with an
	//     unlimited repeat.

__120:
__121:
	*(*Tuint32_t)(unsafe.Pointer(F + 56)) = DGF_CAPTURE | uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 4))))
	goto GROUPLOOP

	// =====================================================================
	// Atomic groups and non-capturing brackets that can match an empty string
	//     must record a backtracking point and also set up a chained frame.

__122:
__123:
__124:
	*(*Tuint32_t)(unsafe.Pointer(F + 56)) = DGF_NOCAPTURE | uint32((*Theapframe)(unsafe.Pointer(F)).Fop)

GROUPLOOP:
__3067:

	group_frame_type = *(*Tuint32_t)(unsafe.Pointer(F + 56))
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(X_pcre2_OP_lengths_8[*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))])
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM2
	goto MATCH_RECURSE
L_RM2:
	;

	if !(rrc == -993) {
		goto __3070
	}

	next_ecode1 = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))))
	if !((*Tmatch_block_8)(unsafe.Pointer(mb)).Fverb_ecode_ptr < next_ecode1 && (int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) == OP_ALT || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(next_ecode1))) == OP_ALT)) {
		goto __3071
	}
	rrc = DMATCH_NOMATCH
__3071:
	;
__3070:
	;
	if !(rrc != DMATCH_NOMATCH) {
		goto __3072
	}
	rrc = rrc
	goto RETURN_SWITCH
__3072:
	;

	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))))
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) != OP_ALT) {
		goto __3073
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__3073:
	;

	goto __3068
__3068:
	goto __3067
	goto __3069
__3069:
	;
	// Control never reaches here.

	// =====================================================================
	// Recursion either matches the current regex, or some subexpression. The
	//     offset data is the offset to the starting bracket from the start of the
	//     whole pattern. (This is so that it works from duplicated subpatterns.)

__125:
	bracode = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_code + uintptr(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))))
	if bracode == (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_code {
		number = uint32(0)
	} else {
		number = uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bracode + 3)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bracode + 4))))
	}

	// If we are already in a recursion, check for repeating the same one
	//     without advancing the subject pointer. This should catch convoluted mutual
	//     recursions. (Some simple cases are caught at compile time.)

	if !((*Theapframe)(unsafe.Pointer(F)).Fcurrent_recurse != DRECURSE_UNSET) {
		goto __3074
	}

	offset = (*Theapframe)(unsafe.Pointer(F)).Flast_group_offset
__3075:
	if !(offset != libc.CplUint64(uint64(0))) {
		goto __3076
	}

	N = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fmatch_frames + uintptr(offset)
	P = N - uintptr(frame_size)
	if !((*Theapframe)(unsafe.Pointer(N)).Fgroup_frame_type == DGF_RECURSE|number) {
		goto __3077
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr == (*Theapframe)(unsafe.Pointer(P)).Feptr) {
		goto __3078
	}
	return -52
__3078:
	;
	goto __3076
__3077:
	;
	offset = (*Theapframe)(unsafe.Pointer(P)).Flast_group_offset
	goto __3075
__3076:
	;
__3074:
	;

	// Now run the recursion, branch by branch.

	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8)) = bracode
	*(*Tuint32_t)(unsafe.Pointer(F + 56)) = DGF_RECURSE | number

__3079:

	group_frame_type = *(*Tuint32_t)(unsafe.Pointer(F + 56))
	start_ecode = *(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8)) + uintptr(X_pcre2_OP_lengths_8[*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8))))])
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM11
	goto MATCH_RECURSE
L_RM11:
	;

	next_ecode2 = *(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8)) + uintptr(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8)) + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8)) + 2)))))

	// Handle backtracking verbs, which are defined in a range that can
	//       easily be tested for. PCRE does not allow THEN, SKIP, PRUNE or COMMIT to
	//       escape beyond a recursion; they cause a NOMATCH for the entire recursion.
	//
	//       When one of these verbs triggers, the current recursion group number is
	//       recorded. If it matches the recursion we are processing, the verb
	//       happened within the recursion and we must deal with it. Otherwise it must
	//       have happened after the recursion completed, and so has to be passed
	//       back. See comment above about handling THEN.

	if !(rrc >= -997 && rrc <= -993 && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fverb_current_recurse == *(*Tuint32_t)(unsafe.Pointer(F + 56))^DGF_RECURSE) {
		goto __3082
	}

	if !(rrc == -993 && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fverb_ecode_ptr < next_ecode2 && (int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8))))) == OP_ALT || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(next_ecode2))) == OP_ALT)) {
		goto __3083
	}
	rrc = DMATCH_NOMATCH
	goto __3084
__3083:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__3084:
	;

__3082:
	;

	// Note that carrying on after (*ACCEPT) in a recursion is handled in the
	//       OP_ACCEPT code. Nothing needs to be done here.

	if !(rrc != DMATCH_NOMATCH) {
		goto __3085
	}
	rrc = rrc
	goto RETURN_SWITCH
__3085:
	;

	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8)) = next_ecode2
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8))))) != OP_ALT) {
		goto __3086
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__3086:
	;

	goto __3080
__3080:
	goto __3079
	goto __3081
__3081:
	;
	// Control never reaches here.

	// =====================================================================
	// Positive assertions are like other groups except that PCRE doesn't allow
	//     the effect of (*THEN) to escape beyond an assertion; it is therefore
	//     treated as NOMATCH. (*ACCEPT) is treated as successful assertion, with its
	//     captures and mark retained. Any other return is an error.

__126:
__127:
__128:
__129:
	*(*Tuint32_t)(unsafe.Pointer(F + 56)) = DGF_NOCAPTURE | uint32((*Theapframe)(unsafe.Pointer(F)).Fop)
__3087:

	group_frame_type = *(*Tuint32_t)(unsafe.Pointer(F + 56))
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(X_pcre2_OP_lengths_8[*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))])
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM3
	goto MATCH_RECURSE
L_RM3:
	;

	if !(rrc == -999) {
		goto __3090
	}

	libc.Xmemcpy(tls, F+128,
		assert_accept_frame+uintptr(uint64(uintptr(0)+128)),
		(*Theapframe)(unsafe.Pointer(assert_accept_frame)).Foffset_top*Tsize_t(unsafe.Sizeof(Tsize_t(0))))
	(*Theapframe)(unsafe.Pointer(F)).Foffset_top = (*Theapframe)(unsafe.Pointer(assert_accept_frame)).Foffset_top
	(*Theapframe)(unsafe.Pointer(F)).Fmark = (*Theapframe)(unsafe.Pointer(assert_accept_frame)).Fmark
	goto __3089
__3090:
	;
	if !(rrc != DMATCH_NOMATCH && rrc != -993) {
		goto __3091
	}
	rrc = rrc
	goto RETURN_SWITCH
__3091:
	;

	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))))
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) != OP_ALT) {
		goto __3092
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__3092:
	;

	goto __3088
__3088:
	goto __3087
	goto __3089
__3089:
	;

__3093:
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))))
	goto __3094
__3094:
	if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) == OP_ALT {
		goto __3093
	}
	goto __3095
__3095:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8(1 + DLINK_SIZE)
	goto __13

	// =====================================================================
	// Handle negative assertions. Loop for each non-matching branch as for
	//     positive assertions.

__130:
__131:
	*(*Tuint32_t)(unsafe.Pointer(F + 56)) = DGF_NOCAPTURE | uint32((*Theapframe)(unsafe.Pointer(F)).Fop)

__3096:

	group_frame_type = *(*Tuint32_t)(unsafe.Pointer(F + 56))
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(X_pcre2_OP_lengths_8[*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))])
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM4
	goto MATCH_RECURSE
L_RM4:
	;

	switch rrc {
	case -999:
		goto __3100 // Assertion matched, therefore it fails.
	case DMATCH_MATCH:
		goto __3101

	case DMATCH_NOMATCH:
		goto __3102 // Branch failed, try next if present.
	case -993:
		goto __3103

	case -997:
		goto __3104 // Assertion forced to fail, therefore continue.
	case -995:
		goto __3105
	case -996:
		goto __3106

	default:
		goto __3107
	}
	goto __3099

__3100: // Assertion matched, therefore it fails.
__3101:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__3102: // Branch failed, try next if present.
__3103:
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))))
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) != OP_ALT) {
		goto __3108
	}
	goto ASSERT_NOT_FAILED
__3108:
	;
	goto __3099

__3104: // Assertion forced to fail, therefore continue.
__3105:
__3106:
__3109:
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))))
	goto __3110
__3110:
	if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) == OP_ALT {
		goto __3109
	}
	goto __3111
__3111:
	;
	goto ASSERT_NOT_FAILED

__3107: /* Pass back any other return */
	rrc = rrc
	goto RETURN_SWITCH

__3099:
	;
	goto __3097
__3097:
	goto __3096
	goto __3098
__3098:
	;

	// None of the branches have matched or there was a backtrack to (*COMMIT),
	//     (*SKIP), (*PRUNE), or (*THEN) in the last branch. This is success for a
	//     negative assertion, so carry on.

ASSERT_NOT_FAILED:
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8(1 + DLINK_SIZE)
	goto __13

	// =====================================================================
	// The callout item calls an external function, if one is provided, passing
	//     details of the match so far. This is mainly for debugging, though the
	//     function is able to force a failure.

__132:
__133:
	rrc = do_callout1(tls, F, mb, bp)
	if !(rrc > 0) {
		goto __3112
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__3112:
	;

	if !(rrc < 0) {
		goto __3113
	}
	rrc = rrc
	goto RETURN_SWITCH
__3113:
	;

	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8(*(*Tsize_t)(unsafe.Pointer(bp)))
	goto __13

	// =====================================================================
	// Conditional group: compilation checked that there are no more than two
	//     branches. If the condition is false, skipping the first branch takes us
	//     past the end of the item if there is only one branch, but that's exactly
	//     what we want.

__134:
__135:

	// The variable Flength will be added to Fecode when the condition is
	//     false, to get to the second branch. Setting it to the offset to the ALT or
	//     KET, then incrementing Fecode achieves this effect. However, if the second
	//     branch is non-existent, we must point to the KET so that the end of the
	//     group is correctly processed. We now have Fecode pointing to the condition
	//     or callout.

	(*Theapframe)(unsafe.Pointer(F)).Flength = Tsize_t(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))))) // Offset to the second branch
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr((*Theapframe)(unsafe.Pointer(F)).Flength)))) != OP_ALT) {
		goto __3114
	}
	*(*Tsize_t)(unsafe.Pointer(F + 24)) -= uint64(1 + DLINK_SIZE)
__3114:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8(1 + DLINK_SIZE) // From this opcode

	// Because of the way auto-callout works during compile, a callout item is
	//     inserted between OP_COND and an assertion condition. Such a callout can
	//     also be inserted manually.

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) == OP_CALLOUT || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) == OP_CALLOUT_STR) {
		goto __3115
	}

	rrc = do_callout1(tls, F, mb, bp)
	if !(rrc > 0) {
		goto __3116
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__3116:
	;

	if !(rrc < 0) {
		goto __3117
	}
	rrc = rrc
	goto RETURN_SWITCH
__3117:
	;

	// Advance Fecode past the callout, so it now points to the condition. We
	//       must adjust Flength so that the value of Fecode+Flength is unchanged.

	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8(*(*Tsize_t)(unsafe.Pointer(bp)))
	*(*Tsize_t)(unsafe.Pointer(F + 24)) -= *(*Tsize_t)(unsafe.Pointer(bp))
__3115:
	;

	// Test the various possible conditions

	condition = DFALSE
	switch int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) {
	case OP_RREF:
		goto __3119

	case OP_DNRREF:
		goto __3120

	case OP_CREF:
		goto __3121

	case OP_DNCREF:
		goto __3122

	case OP_FALSE:
		goto __3123
	case OP_FAIL:
		goto __3124

	case OP_TRUE:
		goto __3125

	// The condition is an assertion. Run code similar to the assertion code
	//       above.

	default:
		goto __3126
	}
	goto __3118

__3119: // Group recursion test
	if !((*Theapframe)(unsafe.Pointer(F)).Fcurrent_recurse != DRECURSE_UNSET) {
		goto __3127
	}

	number = uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))))
	condition = libc.Bool32(number == Tuint32_t(DRREF_ANY) || number == (*Theapframe)(unsafe.Pointer(F)).Fcurrent_recurse)
__3127:
	;
	goto __3118

__3120: // Duplicate named group recursion test
	if !((*Theapframe)(unsafe.Pointer(F)).Fcurrent_recurse != DRECURSE_UNSET) {
		goto __3128
	}

	count1 = int32(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 4)))))
	slot1 = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fname_table + uintptr(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))))*uint32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fname_entry_size))
__3129:
	if !(libc.PostDecInt32(&count1, 1) > 0) {
		goto __3130
	}

	number = uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(slot1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(slot1 + 1))))
	condition = libc.Bool32(number == (*Theapframe)(unsafe.Pointer(F)).Fcurrent_recurse)
	if !(condition != 0) {
		goto __3131
	}
	goto __3130
__3131:
	;
	slot1 += TPCRE2_SPTR8((*Tmatch_block_8)(unsafe.Pointer(mb)).Fname_entry_size)
	goto __3129
__3130:
	;
__3128:
	;
	goto __3118

__3121: // Numbered group used test
	offset = Tsize_t(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))))<<1 - uint32(2)) // Doubled ref number
	condition = libc.Bool32(offset < (*Theapframe)(unsafe.Pointer(F)).Foffset_top && *(*Tsize_t)(unsafe.Pointer(F + 128 + uintptr(offset)*8)) != libc.CplUint64(uint64(0)))
	goto __3118

__3122: /* Duplicate named group used test */

	count2 = int32(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 4)))))
	slot2 = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fname_table + uintptr(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))))*uint32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fname_entry_size))
__3132:
	if !(libc.PostDecInt32(&count2, 1) > 0) {
		goto __3133
	}

	offset = Tsize_t(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(slot2)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(slot2 + 1))))<<1 - uint32(2))
	condition = libc.Bool32(offset < (*Theapframe)(unsafe.Pointer(F)).Foffset_top && *(*Tsize_t)(unsafe.Pointer(F + 128 + uintptr(offset)*8)) != libc.CplUint64(uint64(0)))
	if !(condition != 0) {
		goto __3134
	}
	goto __3133
__3134:
	;
	slot2 += TPCRE2_SPTR8((*Tmatch_block_8)(unsafe.Pointer(mb)).Fname_entry_size)
	goto __3132
__3133:
	;

	goto __3118

__3123:
__3124: // The assertion (?!) becomes OP_FAIL
	goto __3118

__3125:
	condition = DTRUE
	goto __3118

	// The condition is an assertion. Run code similar to the assertion code
	//       above.

__3126:
	*(*Tuint32_t)(unsafe.Pointer(F + 56)) = Tuint32_t(libc.Bool32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) == OP_ASSERT || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) == OP_ASSERTBACK))
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8)) = (*Theapframe)(unsafe.Pointer(F)).Fecode

__3135:

	group_frame_type = DGF_CONDASSERT | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode)))
	start_ecode = *(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8)) + uintptr(X_pcre2_OP_lengths_8[*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8))))])
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM5
	goto MATCH_RECURSE
L_RM5:
	;

	switch rrc {
	case -999:
		goto __3139

	// Fall through
	// In the case of a match, the captures have already been put into
	//           the current frame.

	case DMATCH_MATCH:
		goto __3140

	// PCRE doesn't allow the effect of (*THEN) to escape beyond an
	//           assertion; it is therefore always treated as NOMATCH.

	case DMATCH_NOMATCH:
		goto __3141
	case -993:
		goto __3142

	// These force no match without checking other branches.

	case -997:
		goto __3143
	case -995:
		goto __3144
	case -996:
		goto __3145

	default:
		goto __3146
	}
	goto __3138

__3139: // Save captures
	libc.Xmemcpy(tls, F+128,
		assert_accept_frame+uintptr(uint64(uintptr(0)+128)),
		(*Theapframe)(unsafe.Pointer(assert_accept_frame)).Foffset_top*Tsize_t(unsafe.Sizeof(Tsize_t(0))))
	(*Theapframe)(unsafe.Pointer(F)).Foffset_top = (*Theapframe)(unsafe.Pointer(assert_accept_frame)).Foffset_top

	// Fall through
	// In the case of a match, the captures have already been put into
	//           the current frame.

__3140:
	condition = TBOOL(*(*Tuint32_t)(unsafe.Pointer(F + 56))) // TRUE for positive assertion
	goto __3138

	// PCRE doesn't allow the effect of (*THEN) to escape beyond an
	//           assertion; it is therefore always treated as NOMATCH.

__3141:
__3142:
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8)) += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8)) + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8)) + 2)))))
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 8))))) == OP_ALT) {
		goto __3147
	}
	goto __3136
__3147:
	;                                                                         // Try next branch
	condition = libc.BoolInt32(!(*(*Tuint32_t)(unsafe.Pointer(F + 56)) != 0)) // TRUE for negative assertion
	goto __3138

	// These force no match without checking other branches.

__3143:
__3144:
__3145:
	condition = libc.BoolInt32(!(*(*Tuint32_t)(unsafe.Pointer(F + 56)) != 0))
	goto __3138

__3146:
	rrc = rrc
	goto RETURN_SWITCH

__3138:
	;
	goto __3137 // Out of the branch loop
	goto __3136
__3136:
	goto __3135
	goto __3137
__3137:
	;

	// If the condition is true, find the end of the assertion so that
	//       advancing past it gets us to the start of the first branch.

	if !(condition != 0) {
		goto __3148
	}

__3149:
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))))
	goto __3150
__3150:
	if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) == OP_ALT {
		goto __3149
	}
	goto __3151
__3151:
	;
__3148:
	;
	goto __3118 // End of assertion condition
__3118:
	;

	// Choose branch according to the condition.

	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += func() uintptr {
		if condition != 0 {
			return uintptr(X_pcre2_OP_lengths_8[*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))])
		}
		return uintptr((*Theapframe)(unsafe.Pointer(F)).Flength)
	}()

	// If the opcode is OP_SCOND it means we are at a repeated conditional
	//     group that might match an empty string. We must therefore descend a level
	//     so that the start is remembered for checking. For OP_COND we can just
	//     continue at this level.

	if !(int32((*Theapframe)(unsafe.Pointer(F)).Fop) == OP_SCOND) {
		goto __3152
	}

	group_frame_type = DGF_NOCAPTURE | uint32((*Theapframe)(unsafe.Pointer(F)).Fop)
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM35
	goto MATCH_RECURSE
L_RM35:
	;

	rrc = rrc
	goto RETURN_SWITCH

__3152:
	;
	goto __13

	// =========================================================================
	//                  End of start of parenthesis opcodes
	// =========================================================================

	// =====================================================================
	// Move the subject pointer back. This occurs only at the start of each
	//     branch of a lookbehind assertion. If we are too close to the start to move
	//     back, fail. When working with UTF-8 we move back a number of characters,
	//     not bytes.

__136:
	number = uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))))
	if !(utf != 0) {
		goto __3153
	}

__3155:
	if !(libc.PostDecUint32(&number, 1) > Tuint32_t(0)) {
		goto __3156
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr <= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fcheck_subject) {
		goto __3157
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__3157:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr--
__3158:
	if !(uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0xc0 == 0x80) {
		goto __3159
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr--
	goto __3158
__3159:
	;
	goto __3155
__3156:
	;
	goto __3154
__3153:

	/* No UTF-8 support, or not in UTF-8 mode: count is code unit count */

	if !(Tptrdiff_t(number) > (int64((*Theapframe)(unsafe.Pointer(F)).Feptr)-int64((*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject))/1) {
		goto __3160
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__3160:
	;

	*(*TPCRE2_SPTR8)(unsafe.Pointer(F + 80)) -= TPCRE2_SPTR8(number)
__3154:
	;

	// Save the earliest consulted character, then skip to next opcode

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr) {
		goto __3161
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr = (*Theapframe)(unsafe.Pointer(F)).Feptr
__3161:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8(1 + DLINK_SIZE)
	goto __13

	// =====================================================================
	// An alternation is the end of a branch; scan along to find the end of the
	//     bracketed group.

__137:
__3162:
	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))))
	goto __3163
__3163:
	if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) == OP_ALT {
		goto __3162
	}
	goto __3164
__3164:
	;
	goto __13

	// =====================================================================
	// The end of a parenthesized group. For all but OP_BRA and OP_COND, the
	//     starting frame was added to the chained frames in order to remember the
	//     starting subject position for the group.

__138:
__139:
__140:
__141:

	bracode = (*Theapframe)(unsafe.Pointer(F)).Fecode - uintptr(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))))

	// Point N to the frame at the start of the most recent group.
	//     Remember the subject pointer at the start of the group.

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bracode))) != OP_BRA && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bracode))) != OP_COND) {
		goto __3165
	}

	N = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fmatch_frames + uintptr((*Theapframe)(unsafe.Pointer(F)).Flast_group_offset)
	P = N - uintptr(frame_size)
	(*Theapframe)(unsafe.Pointer(F)).Flast_group_offset = (*Theapframe)(unsafe.Pointer(P)).Flast_group_offset

	// If we are at the end of an assertion that is a condition, return a
	//       match, discarding any intermediate backtracking points. Copy back the
	//       mark setting and the captures into the frame before N so that they are
	//       set on return. Doing this for all assertions, both positive and negative,
	//       seems to match what Perl does.

	if !((*Theapframe)(unsafe.Pointer(N)).Fgroup_frame_type&0xffff0000 == DGF_CONDASSERT) {
		goto __3167
	}

	libc.Xmemcpy(tls, P+uintptr(uint64(uintptr(0)+128)), F+128,
		(*Theapframe)(unsafe.Pointer(F)).Foffset_top*Tsize_t(unsafe.Sizeof(Tsize_t(0))))
	(*Theapframe)(unsafe.Pointer(P)).Foffset_top = (*Theapframe)(unsafe.Pointer(F)).Foffset_top
	(*Theapframe)(unsafe.Pointer(P)).Fmark = (*Theapframe)(unsafe.Pointer(F)).Fmark
	(*Theapframe)(unsafe.Pointer(F)).Fback_frame = Tsize_t((int64(F) - int64(P)) / 1)
	rrc = DMATCH_MATCH
	goto RETURN_SWITCH

__3167:
	;
	goto __3166
__3165:
	P = uintptr(0)
__3166:
	; // Indicates starting frame not recorded

	// The group was not a conditional assertion.

	switch int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bracode))) {
	case OP_BRA:
		goto __3169 // No need to do anything for these
	case OP_COND:
		goto __3170
	case OP_SCOND:
		goto __3171

	// Non-atomic positive assertions are like OP_BRA, except that the
	//       subject pointer must be put back to where it was at the start of the
	//       assertion.

	case OP_ASSERT_NA:
		goto __3172
	case OP_ASSERTBACK_NA:
		goto __3173

	// Atomic positive assertions are like OP_ONCE, except that in addition
	//       the subject pointer must be put back to where it was at the start of the
	//       assertion.

	case OP_ASSERT:
		goto __3174
	case OP_ASSERTBACK:
		goto __3175
	// Fall through

	// For an atomic group, discard internal backtracking points. We must
	//       also ensure that any remaining branches within the top-level of the group
	//       are not tried. Do this by adjusting the code pointer within the backtrack
	//       frame so that it points to the final branch.

	case OP_ONCE:
		goto __3176

	// A matching negative assertion returns MATCH, which is turned into
	//       NOMATCH at the assertion level.

	case OP_ASSERT_NOT:
		goto __3177
	case OP_ASSERTBACK_NOT:
		goto __3178

	// At the end of a script run, apply the script-checking rules. This code
	//       will never by exercised if Unicode support it not compiled, because in
	//       that environment script runs cause an error at compile time.

	case OP_SCRIPT_RUN:
		goto __3179

	// Whole-pattern recursion is coded as a recurse into group 0, so it
	//       won't be picked up here. Instead, we catch it when the OP_END is reached.
	//       Other recursion is handled here.

	case OP_CBRA:
		goto __3180
	case OP_CBRAPOS:
		goto __3181
	case OP_SCBRA:
		goto __3182
	case OP_SCBRAPOS:
		goto __3183
	}
	goto __3168

__3169: // No need to do anything for these
__3170:
__3171:
	goto __3168

	// Non-atomic positive assertions are like OP_BRA, except that the
	//       subject pointer must be put back to where it was at the start of the
	//       assertion.

__3172:
__3173:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Flast_used_ptr) {
		goto __3184
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Flast_used_ptr = (*Theapframe)(unsafe.Pointer(F)).Feptr
__3184:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr = (*Theapframe)(unsafe.Pointer(P)).Feptr
	goto __3168

	// Atomic positive assertions are like OP_ONCE, except that in addition
	//       the subject pointer must be put back to where it was at the start of the
	//       assertion.

__3174:
__3175:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Flast_used_ptr) {
		goto __3185
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Flast_used_ptr = (*Theapframe)(unsafe.Pointer(F)).Feptr
__3185:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr = (*Theapframe)(unsafe.Pointer(P)).Feptr
	// Fall through

	// For an atomic group, discard internal backtracking points. We must
	//       also ensure that any remaining branches within the top-level of the group
	//       are not tried. Do this by adjusting the code pointer within the backtrack
	//       frame so that it points to the final branch.

__3176:
	(*Theapframe)(unsafe.Pointer(F)).Fback_frame = Tsize_t((int64(F) - int64(P)) / 1)
__3186:

	y = uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(P)).Fecode + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(P)).Fecode + 2))))
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(P)).Fecode + uintptr(y)))) != OP_ALT) {
		goto __3189
	}
	goto __3188
__3189:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(P)) += TPCRE2_SPTR8(y)
	goto __3187
__3187:
	goto __3186
	goto __3188
__3188:
	;
	goto __3168

	// A matching negative assertion returns MATCH, which is turned into
	//       NOMATCH at the assertion level.

__3177:
__3178:
	rrc = DMATCH_MATCH
	goto RETURN_SWITCH

	// At the end of a script run, apply the script-checking rules. This code
	//       will never by exercised if Unicode support it not compiled, because in
	//       that environment script runs cause an error at compile time.

__3179:
	if !!(X_pcre2_script_run_8(tls, (*Theapframe)(unsafe.Pointer(P)).Feptr, (*Theapframe)(unsafe.Pointer(F)).Feptr, utf) != 0) {
		goto __3190
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__3190:
	;

	goto __3168

	// Whole-pattern recursion is coded as a recurse into group 0, so it
	//       won't be picked up here. Instead, we catch it when the OP_END is reached.
	//       Other recursion is handled here.

__3180:
__3181:
__3182:
__3183:
	number = uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bracode + 3)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bracode + 4))))

	// Handle a recursively called group. We reinstate the previous set of
	//       captures and then carry on after the recursion call.

	if !((*Theapframe)(unsafe.Pointer(F)).Fcurrent_recurse == number) {
		goto __3191
	}

	P = N - uintptr(frame_size)
	libc.Xmemcpy(tls, F+uintptr(uint64(uintptr(0)+128)), P+128,
		(*Theapframe)(unsafe.Pointer(P)).Foffset_top*Tsize_t(unsafe.Sizeof(Tsize_t(0))))
	(*Theapframe)(unsafe.Pointer(F)).Foffset_top = (*Theapframe)(unsafe.Pointer(P)).Foffset_top
	(*Theapframe)(unsafe.Pointer(F)).Fcapture_last = (*Theapframe)(unsafe.Pointer(P)).Fcapture_last
	(*Theapframe)(unsafe.Pointer(F)).Fcurrent_recurse = (*Theapframe)(unsafe.Pointer(P)).Fcurrent_recurse
	(*Theapframe)(unsafe.Pointer(F)).Fecode = (*Theapframe)(unsafe.Pointer(P)).Fecode + uintptr(1) + uintptr(DLINK_SIZE)
	goto __11 // With next opcode
__3191:
	;

	// Deal with actual capturing.

	offset = Tsize_t(number<<1 - Tuint32_t(2))
	(*Theapframe)(unsafe.Pointer(F)).Fcapture_last = number
	*(*Tsize_t)(unsafe.Pointer(F + 128 + uintptr(offset)*8)) = Tsize_t((int64((*Theapframe)(unsafe.Pointer(P)).Feptr) - int64((*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject)) / 1)
	*(*Tsize_t)(unsafe.Pointer(F + 128 + uintptr(offset+uint64(1))*8)) = Tsize_t((int64((*Theapframe)(unsafe.Pointer(F)).Feptr) - int64((*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject)) / 1)
	if !(offset >= (*Theapframe)(unsafe.Pointer(F)).Foffset_top) {
		goto __3192
	}
	(*Theapframe)(unsafe.Pointer(F)).Foffset_top = offset + uint64(2)
__3192:
	;
	goto __3168
__3168:
	; // End actions relating to the starting opcode

	// OP_KETRPOS is a possessive repeating ket. Remember the current position,
	//     and return the MATCH_KETRPOS. This makes it possible to do the repeats one
	//     at a time from the outer level. This must precede the empty string test -
	//     in this case that test is done at the outer level.

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) == OP_KETRPOS) {
		goto __3193
	}

	libc.Xmemcpy(tls, P+uintptr(uint64(uintptr(0)+80)),
		F+uintptr(uint64(uintptr(0)+80)),
		frame_copy_size)
	rrc = -998
	goto RETURN_SWITCH

__3193:
	;

	// Handle the different kinds of closing brackets. A non-repeating ket
	//     needs no special action, just continuing at this level. This also happens
	//     for the repeating kets if the group matched no characters, in order to
	//     forcibly break infinite loops. Otherwise, the repeating kets try the rest
	//     of the pattern or restart from the preceding bracket, in the appropriate
	//     order.

	if !(int32((*Theapframe)(unsafe.Pointer(F)).Fop) != OP_KET && (P == uintptr(0) || (*Theapframe)(unsafe.Pointer(F)).Feptr != (*Theapframe)(unsafe.Pointer(P)).Feptr)) {
		goto __3194
	}

	if !(int32((*Theapframe)(unsafe.Pointer(F)).Fop) == OP_KETRMIN) {
		goto __3195
	}

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(1) + uintptr(DLINK_SIZE)
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM6
	goto MATCH_RECURSE
L_RM6:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __3196
	}
	rrc = rrc
	goto RETURN_SWITCH
__3196:
	;

	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) -= TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))))
	goto __13 // End of ket processing
__3195:
	;

	/* Repeat the maximum number of times (KETRMAX) */

	start_ecode = bracode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM7
	goto MATCH_RECURSE
L_RM7:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __3197
	}
	rrc = rrc
	goto RETURN_SWITCH
__3197:
	;

__3194:
	;

	// Carry on at this level for a non-repeating ket, or after matching an
	//     empty string, or after repeating for a maximum number of times.

	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8(1 + DLINK_SIZE)
	goto __13

	// =====================================================================
	// Start and end of line assertions, not multiline mode.

__142: // Start of line, unless PCRE2_NOTBOL is set.
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr != (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_NOTBOL != Tuint32_t(0)) {
		goto __3198
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__3198:
	;

	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __13

__143: // Unconditional start of subject
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr != (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject) {
		goto __3199
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__3199:
	;

	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __13

	// When PCRE2_NOTEOL is unset, assert before the subject end, or a
	//     terminating newline unless PCRE2_DOLLAR_ENDONLY is set.

__144:
	if !((*Tmatch_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_NOTEOL != Tuint32_t(0)) {
		goto __3200
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__3200:
	;

	if !((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpoptions&DPCRE2_DOLLAR_ENDONLY == Tuint32_t(0)) {
		goto __3201
	}
	goto ASSERT_NL_OR_EOS
__3201:
	;

	// Fall through
	// Unconditional end of subject assertion (\z)

__145:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __3202
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__3202:
	;

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0) {
		goto __3203
	}

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __3204
	}
	return -2
__3204:
	;
__3203:
	;
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __13

	// End of subject or ending \n assertion (\Z)

__146:
ASSERT_NL_OR_EOS:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && (!(func() int32 {
		if (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype != Tuint32_t(DNLTYPE_FIXED) {
			return libc.Bool32((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, (*Theapframe)(unsafe.Pointer(F)).Feptr, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+256, utf) != 0)
		}
		return libc.Bool32((*Theapframe)(unsafe.Pointer(F)).Feptr <= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260))) && ((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(1) || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + uintptr(1)))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260 + 1)))))
	}() != 0) || (*Theapframe)(unsafe.Pointer(F)).Feptr != (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen))) {
		goto __3205
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && (*Theapframe)(unsafe.Pointer(F)).Feptr+uintptr(1) >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype == Tuint32_t(DNLTYPE_FIXED) && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(2) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260)))) {
		goto __3206
	}

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __3207
	}
	return -2
__3207:
	;
__3206:
	;
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__3205:
	;

	// Either at end of string or \n before end.

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0) {
		goto __3208
	}

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __3209
	}
	return -2
__3209:
	;
__3208:
	;
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __13

	// =====================================================================
	// Start and end of line assertions, multiline mode.

	// Start of subject unless notbol, or after any newline except for one at
	//     the very end, unless PCRE2_ALT_CIRCUMFLEX is set.

__147:
	if !((*Tmatch_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_NOTBOL != Tuint32_t(0) && (*Theapframe)(unsafe.Pointer(F)).Feptr == (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject) {
		goto __3210
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__3210:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr != (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject && ((*Theapframe)(unsafe.Pointer(F)).Feptr == (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fpoptions&DPCRE2_ALT_CIRCUMFLEX == Tuint32_t(0) || !(func() int32 {
		if (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype != Tuint32_t(DNLTYPE_FIXED) {
			return libc.Bool32((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject && X_pcre2_was_newline_8(tls, (*Theapframe)(unsafe.Pointer(F)).Feptr, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject, mb+256, utf) != 0)
		}
		return libc.Bool32((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject+uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr - uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen)))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260))) && ((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(1) || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr - uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen) + uintptr(1)))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260 + 1)))))
	}() != 0))) {
		goto __3211
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__3211:
	;

	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __13

	// Assert before any newline, or before end of subject unless noteol is
	//     set.

__148:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __3212
	}

	if !!(func() int32 {
		if (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype != Tuint32_t(DNLTYPE_FIXED) {
			return libc.Bool32((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, (*Theapframe)(unsafe.Pointer(F)).Feptr, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+256, utf) != 0)
		}
		return libc.Bool32((*Theapframe)(unsafe.Pointer(F)).Feptr <= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260))) && ((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(1) || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + uintptr(1)))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260 + 1)))))
	}() != 0) {
		goto __3214
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && (*Theapframe)(unsafe.Pointer(F)).Feptr+uintptr(1) >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype == Tuint32_t(DNLTYPE_FIXED) && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(2) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260)))) {
		goto __3215
	}

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __3216
	}
	return -2
__3216:
	;
__3215:
	;
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__3214:
	;
	goto __3213
__3212:

	if !((*Tmatch_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_NOTEOL != Tuint32_t(0)) {
		goto __3217
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__3217:
	;

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __3218
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __3219
	}
	return -2
__3219:
	;
__3218:
	;

__3213:
	;
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __13

	// =====================================================================
	// Start of match assertion

__149:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr != (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject+uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_offset)) {
		goto __3220
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__3220:
	;

	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __13

	// =====================================================================
	// Reset the start of match point

__150:
	(*Theapframe)(unsafe.Pointer(F)).Fstart_match = (*Theapframe)(unsafe.Pointer(F)).Feptr
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __13

	// =====================================================================
	// Word boundary assertions. Find out if the previous and current
	//     characters are "word" characters. It takes a bit more work in UTF mode.
	//     Characters > 255 are assumed to be "non-word" characters when PCRE2_UCP is
	//     not set. When it is set, use Unicode properties if available, even when not
	//     in UTF mode. Remember the earliest and latest consulted characters.

__151:
__152:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr == (*Tmatch_block_8)(unsafe.Pointer(mb)).Fcheck_subject) {
		goto __3221
	}
	prev_is_word = DFALSE
	goto __3222
__3221:

	lastptr = (*Theapframe)(unsafe.Pointer(F)).Feptr - uintptr(1)
	if !(utf != 0) {
		goto __3223
	}

__3225:
	if !(uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(lastptr)))&0xc0 == 0x80) {
		goto __3226
	}
	lastptr--
	goto __3225
__3226:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(lastptr)))
	if !(fc >= 0xc0) {
		goto __3227
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __3228
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(lastptr + 1)))&0x3f
	goto __3229
__3228:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __3230
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(lastptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(lastptr + 2)))&0x3f
	goto __3231
__3230:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __3232
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(lastptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(lastptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(lastptr + 3)))&0x3f
	goto __3233
__3232:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __3234
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(lastptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(lastptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(lastptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(lastptr + 4)))&0x3f
	goto __3235
__3234:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(lastptr + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(lastptr + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(lastptr + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(lastptr + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(lastptr + 5)))&0x3f
__3235:
	;
__3233:
	;
__3231:
	;
__3229:
	;
__3227:
	;

	goto __3224
__3223:
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(lastptr)))
__3224:
	;
	if !(lastptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr) {
		goto __3236
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr = lastptr
__3236:
	;
	if !((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpoptions&DPCRE2_UCP != Tuint32_t(0)) {
		goto __3237
	}

	if !(fc == Tuint32_t('_')) {
		goto __3239
	}
	prev_is_word = DTRUE
	goto __3240
__3239:

	cat = int32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fchartype])
	prev_is_word = libc.Bool32(cat == ucp_L || cat == ucp_N)
__3240:
	;
	goto __3238
__3237:
	prev_is_word = libc.Bool32(fc <= 255 && int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_word != 0)
__3238:
	;
__3222:
	;

	// Get status of next character

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __3241
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __3243
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __3244
	}
	return -2
__3244:
	;
__3243:
	;

	cur_is_word = DFALSE
	goto __3242
__3241:

	nextptr = (*Theapframe)(unsafe.Pointer(F)).Feptr + uintptr(1)
	if !(utf != 0) {
		goto __3245
	}

__3247:
	if !(nextptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(nextptr)))&0xc0 == 0x80) {
		goto __3248
	}
	nextptr++
	goto __3247
__3248:
	;
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(fc >= 0xc0) {
		goto __3249
	}
	if !(fc&0x20 == Tuint32_t(0)) {
		goto __3250
	}
	fc = fc&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	goto __3251
__3250:
	if !(fc&0x10 == Tuint32_t(0)) {
		goto __3252
	}
	fc = fc&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	goto __3253
__3252:
	if !(fc&0x08 == Tuint32_t(0)) {
		goto __3254
	}
	fc = fc&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	goto __3255
__3254:
	if !(fc&0x04 == Tuint32_t(0)) {
		goto __3256
	}
	fc = fc&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	goto __3257
__3256:
	fc = fc&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
__3257:
	;
__3255:
	;
__3253:
	;
__3251:
	;
__3249:
	;

	goto __3246
__3245:
	fc = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
__3246:
	;
	if !(nextptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Flast_used_ptr) {
		goto __3258
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Flast_used_ptr = nextptr
__3258:
	;
	if !((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpoptions&DPCRE2_UCP != Tuint32_t(0)) {
		goto __3259
	}

	if !(fc == Tuint32_t('_')) {
		goto __3261
	}
	cur_is_word = DTRUE
	goto __3262
__3261:

	cat1 = int32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fchartype])
	cur_is_word = libc.Bool32(cat1 == ucp_L || cat1 == ucp_N)
__3262:
	;
	goto __3260
__3259:
	cur_is_word = libc.Bool32(fc <= 255 && int32(*(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_word != 0)
__3260:
	;
__3242:
	;

	// Now see if the situation is what we want

	if !(func() int32 {
		if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Fecode, 1)))) == OP_WORD_BOUNDARY {
			return libc.Bool32(cur_is_word == prev_is_word)
		}
		return libc.Bool32(cur_is_word != prev_is_word)
	}() != 0) {
		goto __3263
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__3263:
	;

	goto __13

	// =====================================================================
	// Backtracking (*VERB)s, with and without arguments. Note that if the
	//     pattern is successfully matched, we do not come back from RMATCH.

__153:
	(*Theapframe)(unsafe.Pointer(F)).Fmark = libc.AssignPtrUintptr(mb+208, (*Theapframe)(unsafe.Pointer(F)).Fecode+uintptr(2))
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(X_pcre2_OP_lengths_8[*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))]) + uintptr(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM12
	goto MATCH_RECURSE
L_RM12:
	;

	// A return of MATCH_SKIP_ARG means that matching failed at SKIP with an
	//     argument, and we must check whether that argument matches this MARK's
	//     argument. It is passed back in mb->verb_skip_ptr. If it does match, we
	//     return MATCH_SKIP with mb->verb_skip_ptr now pointing to the subject
	//     position that corresponds to this mark. Otherwise, pass back the return
	//     code unaltered.

	if !(rrc == -994 && X_pcre2_strcmp_8(tls, (*Theapframe)(unsafe.Pointer(F)).Fecode+uintptr(2), (*Tmatch_block_8)(unsafe.Pointer(mb)).Fverb_skip_ptr) == 0) {
		goto __3264
	}

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fverb_skip_ptr = (*Theapframe)(unsafe.Pointer(F)).Feptr /* Pass back current position */
	rrc = -995
	goto RETURN_SWITCH

__3264:
	;
	rrc = rrc
	goto RETURN_SWITCH

__154:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

	// Record the current recursing group number in mb->verb_current_recurse
	//     when a backtracking return such as MATCH_COMMIT is given. This enables the
	//     recurse processing to catch verbs from within the recursion.

__155:
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(X_pcre2_OP_lengths_8[*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))])
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM13
	goto MATCH_RECURSE
L_RM13:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __3265
	}
	rrc = rrc
	goto RETURN_SWITCH
__3265:
	;

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fverb_current_recurse = (*Theapframe)(unsafe.Pointer(F)).Fcurrent_recurse
	rrc = -997
	goto RETURN_SWITCH

__156:
	(*Theapframe)(unsafe.Pointer(F)).Fmark = libc.AssignPtrUintptr(mb+208, (*Theapframe)(unsafe.Pointer(F)).Fecode+uintptr(2))
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(X_pcre2_OP_lengths_8[*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))]) + uintptr(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM36
	goto MATCH_RECURSE
L_RM36:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __3266
	}
	rrc = rrc
	goto RETURN_SWITCH
__3266:
	;

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fverb_current_recurse = (*Theapframe)(unsafe.Pointer(F)).Fcurrent_recurse
	rrc = -997
	goto RETURN_SWITCH

__157:
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(X_pcre2_OP_lengths_8[*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))])
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM14
	goto MATCH_RECURSE
L_RM14:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __3267
	}
	rrc = rrc
	goto RETURN_SWITCH
__3267:
	;

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fverb_current_recurse = (*Theapframe)(unsafe.Pointer(F)).Fcurrent_recurse
	rrc = -996
	goto RETURN_SWITCH

__158:
	(*Theapframe)(unsafe.Pointer(F)).Fmark = libc.AssignPtrUintptr(mb+208, (*Theapframe)(unsafe.Pointer(F)).Fecode+uintptr(2))
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(X_pcre2_OP_lengths_8[*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))]) + uintptr(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM15
	goto MATCH_RECURSE
L_RM15:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __3268
	}
	rrc = rrc
	goto RETURN_SWITCH
__3268:
	;

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fverb_current_recurse = (*Theapframe)(unsafe.Pointer(F)).Fcurrent_recurse
	rrc = -996
	goto RETURN_SWITCH

__159:
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(X_pcre2_OP_lengths_8[*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))])
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM16
	goto MATCH_RECURSE
L_RM16:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __3269
	}
	rrc = rrc
	goto RETURN_SWITCH
__3269:
	;

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fverb_skip_ptr = (*Theapframe)(unsafe.Pointer(F)).Feptr // Pass back current position
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fverb_current_recurse = (*Theapframe)(unsafe.Pointer(F)).Fcurrent_recurse
	rrc = -995
	goto RETURN_SWITCH

	// Note that, for Perl compatibility, SKIP with an argument does NOT set
	//     nomatch_mark. When a pattern match ends with a SKIP_ARG for which there was
	//     not a matching mark, we have to re-run the match, ignoring the SKIP_ARG
	//     that failed and any that precede it (either they also failed, or were not
	//     triggered). To do this, we maintain a count of executed SKIP_ARGs. If a
	//     SKIP_ARG gets to top level, the match is re-run with mb->ignore_skip_arg
	//     set to the count of the one that failed.

__160:
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fskip_arg_count++
	if !((*Tmatch_block_8)(unsafe.Pointer(mb)).Fskip_arg_count <= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fignore_skip_arg) {
		goto __3270
	}

	*(*TPCRE2_SPTR8)(unsafe.Pointer(F)) += TPCRE2_SPTR8(int32(X_pcre2_OP_lengths_8[*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))]) + int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1))))
	goto __13
__3270:
	;
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(X_pcre2_OP_lengths_8[*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))]) + uintptr(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM17
	goto MATCH_RECURSE
L_RM17:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __3271
	}
	rrc = rrc
	goto RETURN_SWITCH
__3271:
	;

	// Pass back the current skip name and return the special MATCH_SKIP_ARG
	//     return code. This will either be caught by a matching MARK, or get to the
	//     top, where it causes a rematch with mb->ignore_skip_arg set to the value of
	//     mb->skip_arg_count.

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fverb_skip_ptr = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(2)
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fverb_current_recurse = (*Theapframe)(unsafe.Pointer(F)).Fcurrent_recurse
	rrc = -994
	goto RETURN_SWITCH

	// For THEN (and THEN_ARG) we pass back the address of the opcode, so that
	//     the branch in which it occurs can be determined.

__161:
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(X_pcre2_OP_lengths_8[*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))])
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM18
	goto MATCH_RECURSE
L_RM18:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __3272
	}
	rrc = rrc
	goto RETURN_SWITCH
__3272:
	;

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fverb_ecode_ptr = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fverb_current_recurse = (*Theapframe)(unsafe.Pointer(F)).Fcurrent_recurse
	rrc = -993
	goto RETURN_SWITCH

__162:
	(*Theapframe)(unsafe.Pointer(F)).Fmark = libc.AssignPtrUintptr(mb+208, (*Theapframe)(unsafe.Pointer(F)).Fecode+uintptr(2))
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(X_pcre2_OP_lengths_8[*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))]) + uintptr(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM19
	goto MATCH_RECURSE
L_RM19:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __3273
	}
	rrc = rrc
	goto RETURN_SWITCH
__3273:
	;

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fverb_ecode_ptr = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fverb_current_recurse = (*Theapframe)(unsafe.Pointer(F)).Fcurrent_recurse
	rrc = -993
	goto RETURN_SWITCH

	// =====================================================================
	// There's been some horrible disaster. Arrival here can only mean there is
	//     something seriously wrong in the code above or the OP_xxx definitions.

__163:
	return -44
__13:
	;

	// Do not insert any code in here without much thought; it is assumed
	//   that "continue" in the code above comes out to here to repeat the main
	//   loop.

	goto __11
__11:
	goto __10
	goto __12
__12:
	; // End of main loop
	// Control never reaches here

	// =========================================================================
	// The RRETURN() macro jumps here. The number that is saved in Freturn_id
	// indicates which label we actually want to return to. The value in Frdepth is
	// the index number of the frame in the vector. The return value has been placed
	// in rrc.

RETURN_SWITCH:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Flast_used_ptr) {
		goto __3274
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Flast_used_ptr = (*Theapframe)(unsafe.Pointer(F)).Feptr
__3274:
	;
	if !((*Theapframe)(unsafe.Pointer(F)).Frdepth == Tuint32_t(0)) {
		goto __3275
	}
	return rrc
__3275:
	;                                                                                                          // Exit from the top level
	F = F - uintptr((*Theapframe)(unsafe.Pointer(F)).Fback_frame)                                              // Backtrack
	*(*Tuint32_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fcb + 104)) |= DPCRE2_CALLOUT_BACKTRACK // Note for callouts

	switch int32((*Theapframe)(unsafe.Pointer(F)).Freturn_id) {
	case 1:
		goto __3277
	case 2:
		goto __3278
	case 3:
		goto __3279
	case 4:
		goto __3280
	case 5:
		goto __3281
	case 6:
		goto __3282
	case 7:
		goto __3283
	case 8:
		goto __3284
	case 9:
		goto __3285
	case 10:
		goto __3286
	case 11:
		goto __3287
	case 12:
		goto __3288
	case 13:
		goto __3289
	case 14:
		goto __3290
	case 15:
		goto __3291
	case 16:
		goto __3292
	case 17:
		goto __3293
	case 18:
		goto __3294
	case 19:
		goto __3295
	case 20:
		goto __3296
	case 21:
		goto __3297
	case 22:
		goto __3298
	case 23:
		goto __3299
	case 24:
		goto __3300
	case 25:
		goto __3301
	case 26:
		goto __3302
	case 27:
		goto __3303
	case 28:
		goto __3304
	case 29:
		goto __3305
	case 30:
		goto __3306
	case 31:
		goto __3307
	case 32:
		goto __3308
	case 33:
		goto __3309
	case 34:
		goto __3310
	case 35:
		goto __3311
	case 36:
		goto __3312

	case 100:
		goto __3313
	case 101:
		goto __3314

	case 200:
		goto __3315
	case 201:
		goto __3316
	case 202:
		goto __3317
	case 203:
		goto __3318
	case 204:
		goto __3319
	case 205:
		goto __3320
	case 206:
		goto __3321
	case 207:
		goto __3322
	case 208:
		goto __3323
	case 209:
		goto __3324
	case 210:
		goto __3325
	case 211:
		goto __3326
	case 212:
		goto __3327
	case 213:
		goto __3328
	case 214:
		goto __3329
	case 215:
		goto __3330
	case 216:
		goto __3331
	case 217:
		goto __3332
	case 218:
		goto __3333
	case 219:
		goto __3334
	case 220:
		goto __3335
	case 221:
		goto __3336
	case 222:
		goto __3337
	case 223:
		goto __3338
	case 224:
		goto __3339
	case 225:
		goto __3340

	default:
		goto __3341
	}
	goto __3276

__3277:
	goto L_RM1
__3278:
	goto L_RM2
__3279:
	goto L_RM3
__3280:
	goto L_RM4
__3281:
	goto L_RM5
__3282:
	goto L_RM6
__3283:
	goto L_RM7
__3284:
	goto L_RM8
__3285:
	goto L_RM9
__3286:
	goto L_RM10
__3287:
	goto L_RM11
__3288:
	goto L_RM12
__3289:
	goto L_RM13
__3290:
	goto L_RM14
__3291:
	goto L_RM15
__3292:
	goto L_RM16
__3293:
	goto L_RM17
__3294:
	goto L_RM18
__3295:
	goto L_RM19
__3296:
	goto L_RM20
__3297:
	goto L_RM21
__3298:
	goto L_RM22
__3299:
	goto L_RM23
__3300:
	goto L_RM24
__3301:
	goto L_RM25
__3302:
	goto L_RM26
__3303:
	goto L_RM27
__3304:
	goto L_RM28
__3305:
	goto L_RM29
__3306:
	goto L_RM30
__3307:
	goto L_RM31
__3308:
	goto L_RM32
__3309:
	goto L_RM33
__3310:
	goto L_RM34
__3311:
	goto L_RM35
__3312:
	goto L_RM36

__3313:
	goto L_RM100
__3314:
	goto L_RM101

__3315:
	goto L_RM200
__3316:
	goto L_RM201
__3317:
	goto L_RM202
__3318:
	goto L_RM203
__3319:
	goto L_RM204
__3320:
	goto L_RM205
__3321:
	goto L_RM206
__3322:
	goto L_RM207
__3323:
	goto L_RM208
__3324:
	goto L_RM209
__3325:
	goto L_RM210
__3326:
	goto L_RM211
__3327:
	goto L_RM212
__3328:
	goto L_RM213
__3329:
	goto L_RM214
__3330:
	goto L_RM215
__3331:
	goto L_RM216
__3332:
	goto L_RM217
__3333:
	goto L_RM218
__3334:
	goto L_RM219
__3335:
	goto L_RM220
__3336:
	goto L_RM221
__3337:
	goto L_RM222
__3338:
	goto L_RM223
__3339:
	goto L_RM224
__3340:
	goto L_RM225

__3341:
	return -44
__3276:
	;
	return int32(0)
}

// ************************************************
//
//           Match a Regular Expression           *
//

// This function applies a compiled pattern to a subject string and picks out
// portions of the string if it matches. Two elements in the vector are set for
// each substring: the offsets to the start and end of the substring.
//
// Arguments:
//   code            points to the compiled expression
//   subject         points to the subject string
//   length          length of subject string (may contain binary zeros)
//   start_offset    where to start in the subject string
//   options         option bits
//   match_data      points to a match_data block
//   mcontext        points a PCRE2 context
//
// Returns:          > 0 => success; value is the number of ovector pairs filled
//                   = 0 => success, but ovector is not big enough
//                   = -1 => failed to match (PCRE2_ERROR_NOMATCH)
//                   = -2 => partial match (PCRE2_ERROR_PARTIAL)
//                   < -2 => some kind of unexpected problem

func Xpcre2_match_8(tls *libc.TLS, code uintptr, subject TPCRE2_SPTR8, length Tsize_t, start_offset Tsize_t, options Tuint32_t, match_data uintptr, mcontext uintptr) int32 { /* pcre2_match.c:6297:1: */
	bp := tls.Alloc(20880)
	defer tls.Free(20880)

	var rc int32
	var was_zero_terminated int32
	var start_bits uintptr
	var re uintptr
	var anchored TBOOL
	var firstline TBOOL
	var has_first_cu TBOOL
	var has_req_cu TBOOL
	var startline TBOOL
	var memchr_found_first_cu TPCRE2_SPTR8
	var memchr_found_first_cu2 TPCRE2_SPTR8
	var first_cu TPCRE2_UCHAR8
	var first_cu2 TPCRE2_UCHAR8
	var req_cu TPCRE2_UCHAR8
	var req_cu2 TPCRE2_UCHAR8
	var bumpalong_limit TPCRE2_SPTR8
	var end_subject TPCRE2_SPTR8
	var true_end_subject TPCRE2_SPTR8
	var start_match TPCRE2_SPTR8
	var req_cu_ptr TPCRE2_SPTR8
	var start_partial TPCRE2_SPTR8
	var match_partial TPCRE2_SPTR8

	// This flag is needed even when Unicode is not supported for convenience
	// (it is used by the IS_NEWLINE macro).

	var utf TBOOL
	var ucp TBOOL
	var allow_invalid TBOOL
	var fragment_options Tuint32_t
	var frame_size Tsize_t

	// We need to have mb as a pointer to a match block, because the IS_NEWLINE
	// macro is used below, and it expects NLBLOCK to be defined as a pointer.

	// var cb Tpcre2_callout_block_8 at bp+20768, 112

	// var actual_match_block Tmatch_block_8 at bp, 288

	var mb uintptr

	// Allocate an initial vector of backtracking frames on the stack. If this
	// proves to be too small, it is replaced by a larger one on the heap. To get a
	// vector of the size required that is aligned for pointers, allocate it as a
	// vector of pointers.

	// var stack_frames_vector [2560]TPCRE2_SPTR8 at bp+288, 20480

	var i uint32
	var skipped_bad_start TBOOL
	var t TPCRE2_SPTR8
	var c TPCRE2_UCHAR8
	var ok TBOOL
	// In 16-bit and 32_bit modes we have to do our own search, so can
	//           look for both cases at once.

	// In 8-bit mode, the use of memchr() gives a big speed up, even
	//           though we have to call it twice in order to find the earliest
	//           occurrence of the code unit in either of its cases. Caching is used
	//           to remember the positions of previously found code units. This can
	//           make a huge difference when the strings are very long and only one
	//           case is actually present.

	var pp1 TPCRE2_SPTR8
	var pp2 TPCRE2_SPTR8
	var searchlength Tsize_t
	var c1 Tuint32_t
	var pp TPCRE2_SPTR8
	var check_length Tsize_t
	var p TPCRE2_SPTR8
	var new_start_match TPCRE2_SPTR8
	was_zero_terminated = 0
	start_bits = uintptr(0)
	re = code
	has_first_cu = DFALSE
	has_req_cu = DFALSE
	first_cu = TPCRE2_UCHAR8(0)
	first_cu2 = TPCRE2_UCHAR8(0)
	req_cu = TPCRE2_UCHAR8(0)
	req_cu2 = TPCRE2_UCHAR8(0)
	utf = DFALSE
	ucp = DFALSE
	fragment_options = Tuint32_t(0)
	mb = bp                                                        /* &actual_match_block */
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fstack_frames = bp + 288 /* stack_frames_vector */

	// Recognize NULL, length 0 as an empty string.

	if !(subject == uintptr(0) && length == uint64(0)) {
		goto __1
	}
	subject = ts + 797 /* "" */
__1:
	;

	// Plausibility checks

	if !(options&libc.CplUint32(DPCRE2_ANCHORED|DPCRE2_ENDANCHORED|DPCRE2_NOTBOL|DPCRE2_NOTEOL|DPCRE2_NOTEMPTY|DPCRE2_NOTEMPTY_ATSTART|DPCRE2_NO_UTF_CHECK|DPCRE2_PARTIAL_HARD|DPCRE2_PARTIAL_SOFT|DPCRE2_NO_JIT|DPCRE2_COPY_MATCHED_SUBJECT) != Tuint32_t(0)) {
		goto __2
	}
	return -34
__2:
	;
	if !(code == uintptr(0) || subject == uintptr(0) || match_data == uintptr(0)) {
		goto __3
	}
	return -51
__3:
	;

	start_match = subject + uintptr(start_offset)
	req_cu_ptr = start_match - uintptr(1)
	if !(length == libc.CplUint64(uint64(0))) {
		goto __4
	}

	length = X_pcre2_strlen_8(tls, subject)
	was_zero_terminated = 1
__4:
	;
	true_end_subject = libc.AssignUintptr(&end_subject, subject+uintptr(length))

	if !(start_offset > length) {
		goto __5
	}
	return -33
__5:
	;

	// Check that the first field in the block is the magic number.

	if !(uint64((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fmagic_number) != DMAGIC_NUMBER) {
		goto __6
	}
	return -31
__6:
	;

	// Check the code unit width.

	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&Tuint32_t(DPCRE2_MODE8|DPCRE2_MODE16|DPCRE2_MODE32) != Tuint32_t(DPCRE2_CODE_UNIT_WIDTH/8)) {
		goto __7
	}
	return -32
__7:
	;

	// PCRE2_NOTEMPTY and PCRE2_NOTEMPTY_ATSTART are match-time flags in the
	// options variable for this function. Users of PCRE2 who are not calling the
	// function directly would like to have a way of setting these flags, in the same
	// way that they can set pcre2_compile() flags like PCRE2_NO_AUTOPOSSESS with
	// constructions like (*NO_AUTOPOSSESS). To enable this, (*NOTEMPTY) and
	// (*NOTEMPTY_ATSTART) set bits in the pattern's "flag" function which we now
	// transfer to the options for this function. The bits are guaranteed to be
	// adjacent, but do not have the same values. This bit of Boolean trickery assumes
	// that the match-time bits are not more significant than the flag bits. If by
	// accident this is not the case, a compile-time division by zero error will
	// occur.

	options = options | (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&Tuint32_t(DPCRE2_NOTEMPTY_SET|DPCRE2_NE_ATST_SET)/(uint32((DPCRE2_NOTEMPTY_SET|DPCRE2_NE_ATST_SET)&(libc.CplInt32(DPCRE2_NOTEMPTY_SET|DPCRE2_NE_ATST_SET)+1))/((DPCRE2_NOTEMPTY|DPCRE2_NOTEMPTY_ATSTART)&(libc.CplUint32(DPCRE2_NOTEMPTY|DPCRE2_NOTEMPTY_ATSTART)+uint32(1))))

	// If the pattern was successfully studied with JIT support, we will run the
	// JIT executable instead of the rest of this function. Most options must be set
	// at compile time for the JIT code to be usable.

	// Initialize UTF/UCP parameters.

	utf = libc.Bool32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_UTF != Tuint32_t(0))
	allow_invalid = libc.Bool32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_MATCH_INVALID_UTF != Tuint32_t(0))
	ucp = libc.Bool32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_UCP != Tuint32_t(0))

	// Convert the partial matching flags into an integer.

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial = func() uint16 {
		if options&DPCRE2_PARTIAL_HARD != Tuint32_t(0) {
			return uint16(2)
		}
		return func() uint16 {
			if options&DPCRE2_PARTIAL_SOFT != Tuint32_t(0) {
				return uint16(1)
			}
			return uint16(0)
		}()
	}()

	// Partial matching and PCRE2_ENDANCHORED are currently not allowed at the same
	// time.

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options|options)&DPCRE2_ENDANCHORED != Tuint32_t(0)) {
		goto __8
	}
	return -34
__8:
	;

	// It is an error to set an offset limit without setting the flag at compile
	// time.

	if !(mcontext != uintptr(0) && (*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Foffset_limit != libc.CplUint64(uint64(0)) && (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_USE_OFFSET_LIMIT == Tuint32_t(0)) {
		goto __9
	}
	return -56
__9:
	;

	// If the match data block was previously used with PCRE2_COPY_MATCHED_SUBJECT,
	// free the memory that was obtained. Set the field to NULL for no match cases.

	if !(uint32((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fflags)&DPCRE2_MD_COPIED_SUBJECT != uint32(0)) {
		goto __10
	}

	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmemctl.Ffree})).f(tls, (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fsubject,
		(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmemctl.Fmemory_data)
	*(*Tuint8_t)(unsafe.Pointer(match_data + 73)) &= libc.Uint8FromUint32(libc.CplUint32(DPCRE2_MD_COPIED_SUBJECT))
__10:
	;
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fsubject = uintptr(0)

	// Zero the error offset in case the first code unit is invalid UTF.

	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fstartchar = uint64(0)

	// ============================= JIT matching ==============================

	// Prepare for JIT matching. Check a UTF string for validity unless no check is
	// requested or invalid UTF can be handled. We check only the portion of the
	// subject that might be be inspected during matching - from the offset minus the
	// maximum lookbehind to the given length. This saves time when a small part of a
	// large subject is being matched by the use of a starting offset. Note that the
	// maximum lookbehind is a number of characters, not code units.

	// ========================= End of JIT matching ==========================

	// Proceed with non-JIT matching. The default is to allow lookbehinds to the
	// start of the subject. A UTF check when there is a non-zero offset may change
	// this.

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fcheck_subject = subject

	// If a UTF subject string was not checked for validity in the JIT code above,
	// check it here, and handle support for invalid UTF strings. The check above
	// happens only when invalid UTF is not supported and PCRE2_NO_CHECK_UTF is unset.
	// If we get here in those circumstances, it means the subject string is valid,
	// but for some reason JIT matching was not successful. There is no need to check
	// the subject again.
	//
	// We check only the portion of the subject that might be be inspected during
	// matching - from the offset minus the maximum lookbehind to the given length.
	// This saves time when a small part of a large subject is being matched by the
	// use of a starting offset. Note that the maximum lookbehind is a number of
	// characters, not code units.
	//
	// Note also that support for invalid UTF forces a check, overriding the setting
	// of PCRE2_NO_CHECK_UTF.

	if !(utf != 0 && (options&DPCRE2_NO_UTF_CHECK == Tuint32_t(0) || allow_invalid != 0)) {
		goto __11
	}

	skipped_bad_start = DFALSE

	// For 8-bit and 16-bit UTF, check that the first code unit is a valid
	//   character start. If we are handling invalid UTF, just skip over such code
	//   units. Otherwise, give an appropriate error.

	if !(allow_invalid != 0) {
		goto __12
	}

__14:
	if !(start_match < end_subject && uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(start_match)))&0xc0 == 0x80) {
		goto __15
	}

	start_match++
	skipped_bad_start = DTRUE
	goto __14
__15:
	;
	goto __13
__12:
	if !(start_match < end_subject && uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(start_match)))&0xc0 == 0x80) {
		goto __16
	}

	if !(start_offset > uint64(0)) {
		goto __17
	}
	return -36
__17:
	;
	return -22 // Isolated 0x80 byte
__16:
	;
__13:
	;

	// The mb->check_subject field points to the start of UTF checking;
	//   lookbehinds can go back no further than this.

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fcheck_subject = start_match

	// Move back by the maximum lookbehind, just in case it happens at the very
	//   start of matching, but don't do this if we skipped bad 8-bit or 16-bit code
	//   units above.

	if !!(skipped_bad_start != 0) {
		goto __18
	}

	i = uint32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fmax_lookbehind)
__19:
	if !(i > uint32(0) && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fcheck_subject > subject) {
		goto __21
	}

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fcheck_subject--
__22:
	if !((*Tmatch_block_8)(unsafe.Pointer(mb)).Fcheck_subject > subject && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fcheck_subject)))&0xc0 == 0x80) {
		goto __23
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fcheck_subject--
	goto __22
__23:
	;
	goto __20
__20:
	i--
	goto __19
	goto __21
__21:
	;
__18:
	;

	// Validate the relevant portion of the subject. There's a loop in case we
	//   encounter bad UTF in the characters preceding start_match which we are
	//   scanning because of a lookbehind.

__24:

	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Frc = X_pcre2_valid_utf_8(tls, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fcheck_subject,
		length-Tsize_t((int64((*Tmatch_block_8)(unsafe.Pointer(mb)).Fcheck_subject)-int64(subject))/1), match_data+64)

	if !((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Frc == 0) {
		goto __27
	}
	goto __26
__27:
	; // Valid UTF string

	// Invalid UTF string. Adjust the offset to be an absolute offset in the
	//     whole string. If we are handling invalid UTF strings, set end_subject to
	//     stop before the bad code unit, and set the options to "not end of line".
	//     Otherwise return the error.

	*(*Tsize_t)(unsafe.Pointer(match_data + 64)) += Tsize_t((int64((*Tmatch_block_8)(unsafe.Pointer(mb)).Fcheck_subject) - int64(subject)) / 1)
	if !(!(allow_invalid != 0) || (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Frc > 0) {
		goto __28
	}
	return (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Frc
__28:
	;
	end_subject = subject + uintptr((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fstartchar)

	// If the end precedes start_match, it means there is invalid UTF in the
	//     extra code units we reversed over because of a lookbehind. Advance past the
	//     first bad code unit, and then skip invalid character starting code units in
	//     8-bit and 16-bit modes, and try again with the original end point.

	if !(end_subject < start_match) {
		goto __29
	}

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fcheck_subject = end_subject + uintptr(1)
__31:
	if !((*Tmatch_block_8)(unsafe.Pointer(mb)).Fcheck_subject < start_match && uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fcheck_subject)))&0xc0 == 0x80) {
		goto __32
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fcheck_subject++
	goto __31
__32:
	;
	end_subject = true_end_subject
	goto __30
__29:

	fragment_options = DPCRE2_NOTEOL
	goto __26
__30:
	;
	goto __25
__25:
	goto __24
	goto __26
__26:
	;
__11:
	;

	// A NULL match context means "use a default context", but we take the memory
	// control functions from the pattern.

	if !(mcontext == uintptr(0)) {
		goto __33
	}

	mcontext = uintptr(unsafe.Pointer(&X_pcre2_default_match_context_8))
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fmemctl = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fmemctl
	goto __34
__33:
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fmemctl = (*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fmemctl
__34:
	;

	anchored = libc.Bool32(((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options|options)&DPCRE2_ANCHORED != Tuint32_t(0))
	firstline = libc.Bool32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_FIRSTLINE != Tuint32_t(0))
	startline = libc.Bool32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&Tuint32_t(DPCRE2_STARTLINE) != Tuint32_t(0))
	if (*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Foffset_limit == libc.CplUint64(uint64(0)) {
		bumpalong_limit = true_end_subject
	} else {
		bumpalong_limit = subject + uintptr((*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Foffset_limit)
	}

	// Initialize and set up the fixed fields in the callout block, with a pointer
	// in the match block.

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fcb = bp + 20768 /* &cb */
	(*Tpcre2_callout_block_8)(unsafe.Pointer(bp + 20768 /* &cb */)).Fversion = Tuint32_t(2)
	(*Tpcre2_callout_block_8)(unsafe.Pointer(bp + 20768 /* &cb */)).Fsubject = subject
	(*Tpcre2_callout_block_8)(unsafe.Pointer(bp + 20768 /* &cb */)).Fsubject_length = Tsize_t((int64(end_subject) - int64(subject)) / 1)
	(*Tpcre2_callout_block_8)(unsafe.Pointer(bp + 20768 /* &cb */)).Fcallout_flags = Tuint32_t(0)

	// Fill in the remaining fields in the match block, except for moptions, which
	// gets set later.

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fcallout = (*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fcallout
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fcallout_data = (*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fcallout_data

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject = subject
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_offset = start_offset
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject = end_subject
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhasthen = libc.Bool32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&Tuint32_t(DPCRE2_HASTHEN) != Tuint32_t(0))
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial = libc.Bool32(int32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fmax_lookbehind) > 0 || (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&Tuint32_t(DPCRE2_MATCH_EMPTY) != Tuint32_t(0))
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fpoptions = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options // Pattern options
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fignore_skip_arg = Tuint32_t(0)
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fmark = libc.AssignPtrUintptr(mb+208, uintptr(0)) // In case never set

	// The name table is needed for finding all the numbers associated with a
	// given name, for condition testing. The code follows the name table.

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fname_table = re + uintptr(uint64(unsafe.Sizeof(Tpcre2_real_code_8{})))
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fname_count = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fname_count
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fname_entry_size = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fname_entry_size
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_code = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fname_table + uintptr(int32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fname_count)*int32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fname_entry_size))

	// Process the \R and newline settings.

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fbsr_convention = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fbsr_convention
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype = Tuint32_t(DNLTYPE_FIXED)
	switch int32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fnewline_convention) {
	case DPCRE2_NEWLINE_CR:
		goto __36

	case DPCRE2_NEWLINE_LF:
		goto __37

	case DPCRE2_NEWLINE_NUL:
		goto __38

	case DPCRE2_NEWLINE_CRLF:
		goto __39

	case DPCRE2_NEWLINE_ANY:
		goto __40

	case DPCRE2_NEWLINE_ANYCRLF:
		goto __41

	default:
		goto __42
	}
	goto __35

__36:
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen = Tuint32_t(1)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260)) = TPCRE2_UCHAR8('\015')
	goto __35

__37:
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen = Tuint32_t(1)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260)) = TPCRE2_UCHAR8('\012')
	goto __35

__38:
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen = Tuint32_t(1)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260)) = TPCRE2_UCHAR8(0)
	goto __35

__39:
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen = Tuint32_t(2)
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260)) = TPCRE2_UCHAR8('\015')
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260 + 1)) = TPCRE2_UCHAR8('\012')
	goto __35

__40:
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype = Tuint32_t(DNLTYPE_ANY)
	goto __35

__41:
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype = Tuint32_t(DNLTYPE_ANYCRLF)
	goto __35

__42:
	return -44
__35:
	;

	// The backtracking frames have fixed data at the front, and a PCRE2_SIZE
	// vector at the end, whose size depends on the number of capturing parentheses in
	// the pattern. It is not used at all if there are no capturing parentheses.
	//
	//   frame_size             is the total size of each frame
	//   mb->frame_vector_size  is the total usable size of the vector (rounded down
	//                            to a whole number of frames)
	//
	// The last of these is changed within the match() function if the frame vector
	// has to be expanded. We therefore put it into the match block so that it is
	// correct when calling match() more than once for non-anchored patterns.
	//
	// We must also pad frame_size for alignment to ensure subsequent frames are as
	// aligned as heapframe. Whilst ovector is word-aligned due to being a PCRE2_SIZE
	// array, that does not guarantee it is suitably aligned for pointers, as some
	// architectures have pointers that are larger than a size_t.

	frame_size = (uint64(uintptr(0)+128) + uint64(int32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftop_bracket)*2)*uint64(unsafe.Sizeof(Tsize_t(0))) + uint64(uintptr(0)+8) - uint64(1)) & libc.CplUint64(uint64(uintptr(0)+8)-uint64(1))

	// Limits set in the pattern override the match context only if they are
	// smaller.

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fheap_limit = func() uint64 {
		if (*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fheap_limit < (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flimit_heap {
			return uint64((*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fheap_limit)
		}
		return uint64((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flimit_heap)
	}()

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fmatch_limit = func() uint32 {
		if (*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fmatch_limit < (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flimit_match {
			return (*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fmatch_limit
		}
		return (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flimit_match
	}()

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fmatch_limit_depth = func() uint32 {
		if (*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fdepth_limit < (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flimit_depth {
			return (*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fdepth_limit
		}
		return (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flimit_depth
	}()

	// If a pattern has very many capturing parentheses, the frame size may be very
	// large. Ensure that there are at least 10 available frames by getting an initial
	// vector on the heap if necessary, except when the heap limit prevents this. Get
	// fewer if possible. (The heap limit is in kibibytes.)

	if !(frame_size <= uint64(DSTART_FRAMES_SIZE/10)) {
		goto __43
	}

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fmatch_frames = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstack_frames // Initial frame vector on the stack
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fframe_vector_size = uint64(DSTART_FRAMES_SIZE) / frame_size * frame_size
	goto __44
__43:

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fframe_vector_size = frame_size * uint64(10)
	if !((*Tmatch_block_8)(unsafe.Pointer(mb)).Fframe_vector_size/uint64(1024) > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fheap_limit) {
		goto __45
	}

	if !(frame_size > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fheap_limit*uint64(1024)) {
		goto __46
	}
	return -63
__46:
	;
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fframe_vector_size = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fheap_limit * uint64(1024) / frame_size * frame_size
__45:
	;
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fmatch_frames = (*struct {
		f func(*libc.TLS, Tsize_t, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*Tmatch_block_8)(unsafe.Pointer(mb)).Fmemctl.Fmalloc})).f(tls, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fframe_vector_size,
		(*Tmatch_block_8)(unsafe.Pointer(mb)).Fmemctl.Fmemory_data)
	if !((*Tmatch_block_8)(unsafe.Pointer(mb)).Fmatch_frames == uintptr(0)) {
		goto __47
	}
	return -48
__47:
	;
__44:
	;

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fmatch_frames_top = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fmatch_frames + uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fframe_vector_size)

	// Write to the ovector within the first frame to mark every capture unset and
	// to avoid uninitialized memory read errors when it is copied to a new frame.

	libc.Xmemset(tls, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fmatch_frames+uintptr(uint64(uintptr(0)+128)), 0xff,
		frame_size-Tsize_t(uintptr(0)+128))

	// Pointers to the individual character tables

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Flcc = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftables + uintptr(Dlcc_offset)
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Ffcc = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftables + uintptr(Dfcc_offset)
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftables + uintptr(Dcbits_offset+Dcbit_length)

	// Set up the first code unit to match, if available. If there's no first code
	// unit there may be a bitmap of possible first characters.

	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&Tuint32_t(DPCRE2_FIRSTSET) != Tuint32_t(0)) {
		goto __48
	}

	has_first_cu = DTRUE
	first_cu = libc.AssignUint8(&first_cu2, TPCRE2_UCHAR8((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ffirst_codeunit))
	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&Tuint32_t(DPCRE2_FIRSTCASELESS) != Tuint32_t(0)) {
		goto __50
	}

	first_cu2 = *(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Ffcc + uintptr(first_cu)))
	if !(int32(first_cu) > 127 && ucp != 0 && !(utf != 0)) {
		goto __51
	}
	first_cu2 = TPCRE2_UCHAR8(Tuint32_t(int32(first_cu) + (*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(first_cu)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(first_cu)%DUCD_BLOCK_SIZE])*12)).Fother_case))
__51:
	;
__50:
	;
	goto __49
__48:
	if !(!(startline != 0) && (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&Tuint32_t(DPCRE2_FIRSTMAPSET) != Tuint32_t(0)) {
		goto __52
	}
	start_bits = re + 40 /* &.start_bitmap */
__52:
	;
__49:
	;

	// There may also be a "last known required character" set.

	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&Tuint32_t(DPCRE2_LASTSET) != Tuint32_t(0)) {
		goto __53
	}

	has_req_cu = DTRUE
	req_cu = libc.AssignUint8(&req_cu2, TPCRE2_UCHAR8((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flast_codeunit))
	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&Tuint32_t(DPCRE2_LASTCASELESS) != Tuint32_t(0)) {
		goto __54
	}

	req_cu2 = *(*Tuint8_t)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Ffcc + uintptr(req_cu)))
	if !(int32(req_cu) > 127 && ucp != 0 && !(utf != 0)) {
		goto __55
	}
	req_cu2 = TPCRE2_UCHAR8(Tuint32_t(int32(req_cu) + (*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(req_cu)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(req_cu)%DUCD_BLOCK_SIZE])*12)).Fother_case))
__55:
	;
__54:
	;
__53:
	;

	// ==========================================================================

	// Loop for handling unanchored repeated matching attempts; for anchored regexs
	// the loop runs just once.

FRAGMENT_RESTART:

	start_partial = libc.AssignUintptr(&match_partial, uintptr(0))
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DFALSE

	memchr_found_first_cu = uintptr(0)
	memchr_found_first_cu2 = uintptr(0)

__56:

	// ----------------- Start of match optimizations ----------------

	// There are some optimizations that avoid running the match if a known
	//   starting point is not found, or if a known later code unit is not present.
	//   However, there is an option (settable at compile time) that disables these,
	//   for testing and for ensuring that all callouts do actually occur.

	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_NO_START_OPTIMIZE == Tuint32_t(0)) {
		goto __59
	}

	// If firstline is TRUE, the start of the match is constrained to the first
	//     line of a multiline string. That is, the match must be before or at the
	//     first newline following the start of matching. Temporarily adjust
	//     end_subject so that we stop the scans for a first code unit at a newline.
	//     If the match fails at the newline, later code breaks the loop.

	if !(firstline != 0) {
		goto __60
	}

	t = start_match
	if !(utf != 0) {
		goto __61
	}

__63:
	if !(t < end_subject && !(func() int32 {
		if (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype != Tuint32_t(DNLTYPE_FIXED) {
			return libc.Bool32(t < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, t, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+256, utf) != 0)
		}
		return libc.Bool32(t <= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(t))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260))) && ((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(1) || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(t + uintptr(1)))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260 + 1)))))
	}() != 0)) {
		goto __64
	}

	t++
__65:
	if !(t < end_subject && uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(t)))&0xc0 == 0x80) {
		goto __66
	}
	t++
	goto __65
__66:
	;
	goto __63
__64:
	;
	goto __62
__61:
__67:
	if !(t < end_subject && !(func() int32 {
		if (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype != Tuint32_t(DNLTYPE_FIXED) {
			return libc.Bool32(t < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, t, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+256, utf) != 0)
		}
		return libc.Bool32(t <= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(t))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260))) && ((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(1) || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(t + uintptr(1)))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260 + 1)))))
	}() != 0)) {
		goto __68
	}
	t++
	goto __67
__68:
	;
__62:
	;
	end_subject = t
__60:
	;

	// Anchored: check the first code unit if one is recorded. This may seem
	//     pointless but it can help in detecting a no match case without scanning for
	//     the required code unit.

	if !(anchored != 0) {
		goto __69
	}

	if !(has_first_cu != 0 || start_bits != uintptr(0)) {
		goto __71
	}

	ok = libc.Bool32(start_match < end_subject)
	if !(ok != 0) {
		goto __72
	}

	c = *(*TPCRE2_UCHAR8)(unsafe.Pointer(start_match))
	ok = libc.Bool32(has_first_cu != 0 && (int32(c) == int32(first_cu) || int32(c) == int32(first_cu2)))
	if !(!(ok != 0) && start_bits != uintptr(0)) {
		goto __73
	}

	ok = libc.Bool32(uint32(*(*Tuint8_t)(unsafe.Pointer(start_bits + uintptr(int32(c)/8))))&(uint32(1)<<(int32(c)&7)) != uint32(0))
__73:
	;
__72:
	;
	if !!(ok != 0) {
		goto __74
	}

	rc = DMATCH_NOMATCH
	goto __58
__74:
	;
__71:
	;
	goto __70
__69:

	if !(has_first_cu != 0) {
		goto __75
	}

	if !(int32(first_cu) != int32(first_cu2)) {
		goto __77
	} /* Caseless */

	// In 16-bit and 32_bit modes we have to do our own search, so can
	//           look for both cases at once.

	// In 8-bit mode, the use of memchr() gives a big speed up, even
	//           though we have to call it twice in order to find the earliest
	//           occurrence of the code unit in either of its cases. Caching is used
	//           to remember the positions of previously found code units. This can
	//           make a huge difference when the strings are very long and only one
	//           case is actually present.

	pp1 = uintptr(0)
	pp2 = uintptr(0)
	searchlength = Tsize_t((int64(end_subject) - int64(start_match)) / 1)

	// If we haven't got a previously found position for first_cu, or if
	//           the current starting position is later, we need to do a search. If
	//           the code unit is not found, set it to the end.

	if !(memchr_found_first_cu == uintptr(0) || start_match > memchr_found_first_cu) {
		goto __79
	}

	pp1 = libc.Xmemchr(tls, start_match, int32(first_cu), searchlength)
	if pp1 == uintptr(0) {
		memchr_found_first_cu = end_subject
	} else {
		memchr_found_first_cu = pp1
	}
	goto __80
__79:
	if memchr_found_first_cu == end_subject {
		pp1 = uintptr(0)
	} else {
		pp1 = memchr_found_first_cu
	}
__80:
	;

	// Do the same thing for the other case.

	if !(memchr_found_first_cu2 == uintptr(0) || start_match > memchr_found_first_cu2) {
		goto __81
	}

	pp2 = libc.Xmemchr(tls, start_match, int32(first_cu2), searchlength)
	if pp2 == uintptr(0) {
		memchr_found_first_cu2 = end_subject
	} else {
		memchr_found_first_cu2 = pp2
	}
	goto __82
__81:
	if memchr_found_first_cu2 == end_subject {
		pp2 = uintptr(0)
	} else {
		pp2 = memchr_found_first_cu2
	}
__82:
	;

	// Set the start to the end of the subject if neither case was found.
	//           Otherwise, use the earlier found point.

	if !(pp1 == uintptr(0)) {
		goto __83
	}
	if pp2 == uintptr(0) {
		start_match = end_subject
	} else {
		start_match = pp2
	}
	goto __84
__83:
	if pp2 == uintptr(0) || pp1 < pp2 {
		start_match = pp1
	} else {
		start_match = pp2
	}
__84:
	;

	goto __78
__77:

	start_match = libc.Xmemchr(tls, start_match, int32(first_cu), uint64((int64(end_subject)-int64(start_match))/1))
	if !(start_match == uintptr(0)) {
		goto __85
	}
	start_match = end_subject
__85:
	;
__78:
	;

	// If we can't find the required first code unit, having reached the
	//         true end of the subject, break the bumpalong loop, to force a match
	//         failure, except when doing partial matching, when we let the next cycle
	//         run at the end of the subject. To see why, consider the pattern
	//         /(?<=abc)def/, which partially matches "abc", even though the string
	//         does not contain the starting character "d". If we have not reached the
	//         true end of the subject (PCRE2_FIRSTLINE caused end_subject to be
	//         temporarily modified) we also let the cycle run, because the matching
	//         string is legitimately allowed to start with the first code unit of a
	//         newline.

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) == 0 && start_match >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __86
	}

	rc = DMATCH_NOMATCH
	goto __58
__86:
	;
	goto __76
__75:
	if !(startline != 0) {
		goto __87
	}

	if !(start_match > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject+uintptr(start_offset)) {
		goto __89
	}

	if !(utf != 0) {
		goto __90
	}

__92:
	if !(start_match < end_subject && !(func() int32 {
		if (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype != Tuint32_t(DNLTYPE_FIXED) {
			return libc.Bool32(start_match > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject && X_pcre2_was_newline_8(tls, start_match, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject, mb+256, utf) != 0)
		}
		return libc.Bool32(start_match >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject+uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(start_match - uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen)))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260))) && ((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(1) || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(start_match - uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen) + uintptr(1)))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260 + 1)))))
	}() != 0)) {
		goto __93
	}

	start_match++
__94:
	if !(start_match < end_subject && uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(start_match)))&0xc0 == 0x80) {
		goto __95
	}
	start_match++
	goto __94
__95:
	;
	goto __92
__93:
	;
	goto __91
__90:
__96:
	if !(start_match < end_subject && !(func() int32 {
		if (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype != Tuint32_t(DNLTYPE_FIXED) {
			return libc.Bool32(start_match > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject && X_pcre2_was_newline_8(tls, start_match, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject, mb+256, utf) != 0)
		}
		return libc.Bool32(start_match >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject+uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(start_match - uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen)))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260))) && ((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(1) || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(start_match - uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen) + uintptr(1)))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260 + 1)))))
	}() != 0)) {
		goto __97
	}
	start_match++
	goto __96
__97:
	;
__91:
	;

	// If we have just passed a CR and the newline option is ANY or
	//           ANYCRLF, and we are now at a LF, advance the match position by one
	//           more code unit.

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(start_match + libc.UintptrFromInt32(-1)))) == '\015' && ((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype == Tuint32_t(DNLTYPE_ANY) || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype == Tuint32_t(DNLTYPE_ANYCRLF)) && start_match < end_subject && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(start_match))) == '\012') {
		goto __98
	}
	start_match++
__98:
	;
__89:
	;
	goto __88
__87:
	if !(start_bits != uintptr(0)) {
		goto __99
	}

__100:
	if !(start_match < end_subject) {
		goto __101
	}

	c1 = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(start_match)))
	if !(uint32(*(*Tuint8_t)(unsafe.Pointer(start_bits + uintptr(c1/Tuint32_t(8)))))&(uint32(1)<<(c1&Tuint32_t(7))) != uint32(0)) {
		goto __102
	}
	goto __101
__102:
	;
	start_match++
	goto __100
__101:
	;

	// See comment above in first_cu checking about the next few lines.

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) == 0 && start_match >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __103
	}

	rc = DMATCH_NOMATCH
	goto __58
__103:
	;
__99:
	;
__88:
	;
__76:
	;
__70:
	; // End first code unit handling

	// Restore fudged end_subject

	end_subject = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject

	// The following two optimizations must be disabled for partial matching.

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) == 0) {
		goto __104
	}

	// The minimum matching length is a lower bound; no string of that length
	//       may actually match the pattern. Although the value is, strictly, in
	//       characters, we treat it as code units to avoid spending too much time in
	//       this optimization.

	if !((int64(end_subject)-int64(start_match))/1 < int64((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fminlength)) {
		goto __105
	}

	rc = DMATCH_NOMATCH
	goto __58
__105:
	;

	// If req_cu is set, we know that that code unit must appear in the
	//       subject for the (non-partial) match to succeed. If the first code unit is
	//       set, req_cu must be later in the subject; otherwise the test starts at
	//       the match point. This optimization can save a huge amount of backtracking
	//       in patterns with nested unlimited repeats that aren't going to match.
	//       Writing separate code for caseful/caseless versions makes it go faster,
	//       as does using an autoincrement and backing off on a match. As in the case
	//       of the first code unit, using memchr() in the 8-bit library gives a big
	//       speed up. Unlike the first_cu check above, we do not need to call
	//       memchr() twice in the caseless case because we only need to check for the
	//       presence of the character in either case, not find the first occurrence.
	//
	//       The search can be skipped if the code unit was found later than the
	//       current starting point in a previous iteration of the bumpalong loop.
	//
	//       HOWEVER: when the subject string is very, very long, searching to its end
	//       can take a long time, and give bad performance on quite ordinary
	//       anchored patterns. This showed up when somebody was matching something
	//       like /^\d+C/ on a 32-megabyte string... so we don't do this when the
	//       string is sufficiently long, but it's worth searching a lot more for
	//       unanchored patterns.

	p = start_match + uintptr(func() int32 {
		if has_first_cu != 0 {
			return 1
		}
		return 0
	}())
	if !(has_req_cu != 0 && p > req_cu_ptr) {
		goto __106
	}

	check_length = Tsize_t((int64(end_subject) - int64(start_match)) / 1)

	if !(check_length < uint64(DREQ_CU_MAX) || !(anchored != 0) && check_length < uint64(DREQ_CU_MAX*1000)) {
		goto __107
	}

	if !(int32(req_cu) != int32(req_cu2)) {
		goto __108
	} /* Caseless */

	pp = p
	p = libc.Xmemchr(tls, pp, int32(req_cu), uint64((int64(end_subject)-int64(pp))/1))
	if !(p == uintptr(0)) {
		goto __110
	}

	p = libc.Xmemchr(tls, pp, int32(req_cu2), uint64((int64(end_subject)-int64(pp))/1))
	if !(p == uintptr(0)) {
		goto __111
	}
	p = end_subject
__111:
	;
__110:
	;
	goto __109
__108:

	p = libc.Xmemchr(tls, p, int32(req_cu), uint64((int64(end_subject)-int64(p))/1))
	if !(p == uintptr(0)) {
		goto __112
	}
	p = end_subject
__112:
	;
__109:
	;

	// If we can't find the required code unit, break the bumpalong loop,
	//           forcing a match failure.

	if !(p >= end_subject) {
		goto __113
	}

	rc = DMATCH_NOMATCH
	goto __58
__113:
	;

	// If we have found the required code unit, save the point where we
	//           found it, so that we don't search again next time round the bumpalong
	//           loop if the start hasn't yet passed this code unit.

	req_cu_ptr = p
__107:
	;
__106:
	;
__104:
	;
__59:
	;

	// ------------ End of start of match optimizations ------------

	// Give no match if we have passed the bumpalong limit.

	if !(start_match > bumpalong_limit) {
		goto __114
	}

	rc = DMATCH_NOMATCH
	goto __58
__114:
	;

	// OK, we can now run the match. If "hitend" is set afterwards, remember the
	//   first starting point for which a partial match was found.

	(*Tpcre2_callout_block_8)(unsafe.Pointer(bp + 20768 /* &cb */)).Fstart_match = Tsize_t((int64(start_match) - int64(subject)) / 1)
	*(*Tuint32_t)(unsafe.Pointer(bp + 20768 + 104)) |= DPCRE2_CALLOUT_STARTMATCH

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr = start_match
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Flast_used_ptr = start_match
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fmoptions = options | fragment_options
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fmatch_call_count = Tuint32_t(0)
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_offset_top = uint64(0)
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fskip_arg_count = Tuint32_t(0)

	rc = match(tls, start_match, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_code, match_data+80,
		(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Foveccount, (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftop_bracket, frame_size, mb)

	if !((*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend != 0 && start_partial == uintptr(0)) {
		goto __115
	}

	start_partial = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr
	match_partial = start_match
__115:
	;

	switch rc {
	// If MATCH_SKIP_ARG reaches this level it means that a MARK that matched
	//     the SKIP's arg was not found. In this circumstance, Perl ignores the SKIP
	//     entirely. The only way we can do that is to re-do the match at the same
	//     point, with a flag to force SKIP with an argument to be ignored. Just
	//     treating this case as NOMATCH does not work because it does not check other
	//     alternatives in patterns such as A(*SKIP:A)B|AC when the subject is AC.

	case -994:
		goto __117

	// SKIP passes back the next starting point explicitly, but if it is no
	//     greater than the match we have just done, treat it as NOMATCH.

	case -995:
		goto __118
	// Fall through

	// NOMATCH and PRUNE advance by one character. THEN at this level acts
	//     exactly like PRUNE. Unset ignore SKIP-with-argument.

	case DMATCH_NOMATCH:
		goto __119
	case -996:
		goto __120
	case -993:
		goto __121

	// COMMIT disables the bumpalong, but otherwise behaves as NOMATCH.

	case -997:
		goto __122

	// Any other return is either a match, or some kind of error.

	default:
		goto __123
	}
	goto __116

	// If MATCH_SKIP_ARG reaches this level it means that a MARK that matched
	//     the SKIP's arg was not found. In this circumstance, Perl ignores the SKIP
	//     entirely. The only way we can do that is to re-do the match at the same
	//     point, with a flag to force SKIP with an argument to be ignored. Just
	//     treating this case as NOMATCH does not work because it does not check other
	//     alternatives in patterns such as A(*SKIP:A)B|AC when the subject is AC.

__117:
	new_start_match = start_match
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fignore_skip_arg = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fskip_arg_count
	goto __116

	// SKIP passes back the next starting point explicitly, but if it is no
	//     greater than the match we have just done, treat it as NOMATCH.

__118:
	if !((*Tmatch_block_8)(unsafe.Pointer(mb)).Fverb_skip_ptr > start_match) {
		goto __124
	}

	new_start_match = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fverb_skip_ptr
	goto __116
__124:
	;
	// Fall through

	// NOMATCH and PRUNE advance by one character. THEN at this level acts
	//     exactly like PRUNE. Unset ignore SKIP-with-argument.

__119:
__120:
__121:
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fignore_skip_arg = Tuint32_t(0)
	new_start_match = start_match + uintptr(1)
	if !(utf != 0) {
		goto __125
	}
__126:
	if !(new_start_match < end_subject && uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(new_start_match)))&0xc0 == 0x80) {
		goto __127
	}
	new_start_match++
	goto __126
__127:
	;
__125:
	;
	goto __116

	// COMMIT disables the bumpalong, but otherwise behaves as NOMATCH.

__122:
	rc = DMATCH_NOMATCH
	goto ENDLOOP

	// Any other return is either a match, or some kind of error.

__123:
	goto ENDLOOP
__116:
	;

	// Control reaches here for the various types of "no match at this point"
	//   result. Reset the code to MATCH_NOMATCH for subsequent checking.

	rc = DMATCH_NOMATCH

	// If PCRE2_FIRSTLINE is set, the match must happen before or at the first
	//   newline in the subject (though it may continue over the newline). Therefore,
	//   if we have just failed to match, starting at a newline, do not continue.

	if !(firstline != 0 && func() int32 {
		if (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype != Tuint32_t(DNLTYPE_FIXED) {
			return libc.Bool32(start_match < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, start_match, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+256, utf) != 0)
		}
		return libc.Bool32(start_match <= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(start_match))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260))) && ((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(1) || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(start_match + uintptr(1)))) == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mb + 260 + 1)))))
	}() != 0) {
		goto __128
	}
	goto __58
__128:
	;

	// Advance to new matching position

	start_match = new_start_match

	// Break the loop if the pattern is anchored or if we have passed the end of
	//   the subject.

	if !(anchored != 0 || start_match > end_subject) {
		goto __129
	}
	goto __58
__129:
	;

	// If we have just passed a CR and we are now at a LF, and the pattern does
	//   not contain any explicit matches for \r or \n, and the newline option is CRLF
	//   or ANY or ANYCRLF, advance the match position by one more code unit. In
	//   normal matching start_match will aways be greater than the first position at
	//   this stage, but a failed *SKIP can cause a return at the same point, which is
	//   why the first test exists.

	if !(start_match > subject+uintptr(start_offset) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(start_match + libc.UintptrFromInt32(-1)))) == '\015' && start_match < end_subject && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(start_match))) == '\012' && (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&Tuint32_t(DPCRE2_HASCRORLF) == Tuint32_t(0) && ((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype == Tuint32_t(DNLTYPE_ANY) || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype == Tuint32_t(DNLTYPE_ANYCRLF) || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == Tuint32_t(2))) {
		goto __130
	}
	start_match++
__130:
	;

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fmark = uintptr(0) // Reset for start of next match attempt
	goto __57
__57:
	goto __56
	goto __58
__58:
	; // End of for(;;) "bumpalong" loop

	// ==========================================================================

	// When we reach here, one of the following stopping conditions is true:
	//
	// (1) The match succeeded, either completely, or partially;
	//
	// (2) The pattern is anchored or the match was failed after (*COMMIT);
	//
	// (3) We are past the end of the subject or the bumpalong limit;
	//
	// (4) PCRE2_FIRSTLINE is set and we have failed to match at a newline, because
	//     this option requests that a match occur at or before the first newline in
	//     the subject.
	//
	// (5) Some kind of error occurred.
	//

ENDLOOP:

	// If end_subject != true_end_subject, it means we are handling invalid UTF,
	// and have just processed a non-terminal fragment. If this resulted in no match
	// or a partial match we must carry on to the next fragment (a partial match is
	// returned to the caller only at the very end of the subject). A loop is used to
	// avoid trying to match against empty fragments; if the pattern can match an
	// empty string it would have done so already.

	if !(utf != 0 && end_subject != true_end_subject && (rc == DMATCH_NOMATCH || rc == -2)) {
		goto __131
	}

__132:

	// Advance past the first bad code unit, and then skip invalid character
	//     starting code units in 8-bit and 16-bit modes.

	start_match = end_subject + uintptr(1)

__135:
	if !(start_match < true_end_subject && uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(start_match)))&0xc0 == 0x80) {
		goto __136
	}
	start_match++
	goto __135
__136:
	;

	// If we have hit the end of the subject, there isn't another non-empty
	//     fragment, so give up.

	if !(start_match >= true_end_subject) {
		goto __137
	}

	rc = DMATCH_NOMATCH // In case it was partial
	goto __134
__137:
	;

	// Check the rest of the subject

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fcheck_subject = start_match
	rc = X_pcre2_valid_utf_8(tls, start_match, length-Tsize_t((int64(start_match)-int64(subject))/1),
		match_data+64)

	// The rest of the subject is valid UTF.

	if !(rc == 0) {
		goto __138
	}

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject = libc.AssignUintptr(&end_subject, true_end_subject)
	fragment_options = DPCRE2_NOTBOL
	goto FRAGMENT_RESTART
	goto __139
__138:
	if !(rc < 0) {
		goto __140
	}

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject = libc.AssignUintptr(&end_subject, start_match+uintptr((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fstartchar))
	if !(end_subject > start_match) {
		goto __141
	}

	fragment_options = DPCRE2_NOTBOL | DPCRE2_NOTEOL
	goto FRAGMENT_RESTART
__141:
	;
__140:
	;
__139:
	;
	goto __133
__133:
	goto __132
	goto __134
__134:
	;
__131:
	;

	// Release an enlarged frame vector that is on the heap.

	if !((*Tmatch_block_8)(unsafe.Pointer(mb)).Fmatch_frames != (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstack_frames) {
		goto __142
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*Tmatch_block_8)(unsafe.Pointer(mb)).Fmemctl.Ffree})).f(tls, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fmatch_frames, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fmemctl.Fmemory_data)
__142:
	;

	// Fill in fields that are always returned in the match data.

	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fcode = re
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmark = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fmark
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmatchedby = PCRE2_MATCHEDBY_INTERPRETER

	// Handle a fully successful match. Set the return code to the number of
	// captured strings, or 0 if there were too many to fit into the ovector, and then
	// set the remaining returned values before returning. Make a copy of the subject
	// string if requested.

	if !(rc == DMATCH_MATCH) {
		goto __143
	}

	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Frc = func() int32 {
		if int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_offset_top) >= 2*int32((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Foveccount) {
			return 0
		}
		return int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_offset_top)/2 + 1
	}()
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fstartchar = Tsize_t((int64(start_match) - int64(subject)) / 1)
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fleftchar = Tsize_t((int64((*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr) - int64(subject)) / 1)
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Frightchar = Tsize_t((func() int64 {
		if (*Tmatch_block_8)(unsafe.Pointer(mb)).Flast_used_ptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_match_ptr {
			return int64((*Tmatch_block_8)(unsafe.Pointer(mb)).Flast_used_ptr)
		}
		return int64((*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_match_ptr)
	}() - int64(subject)) / 1)
	if !(options&DPCRE2_COPY_MATCHED_SUBJECT != Tuint32_t(0)) {
		goto __144
	}

	length = (length + Tsize_t(was_zero_terminated)) * uint64(DPCRE2_CODE_UNIT_WIDTH/8)
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fsubject = (*struct {
		f func(*libc.TLS, Tsize_t, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmemctl.Fmalloc})).f(tls, length,
		(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmemctl.Fmemory_data)
	if !((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fsubject == uintptr(0)) {
		goto __146
	}
	return -48
__146:
	;
	libc.Xmemcpy(tls, (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fsubject, subject, length)
	*(*Tuint8_t)(unsafe.Pointer(match_data + 73)) |= uint8(DPCRE2_MD_COPIED_SUBJECT)
	goto __145
__144:
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fsubject = subject
__145:
	;
	return (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Frc
__143:
	;

	// Control gets here if there has been a partial match, an error, or if the
	// overall match attempt has failed at all permitted starting positions. Any mark
	// data is in the nomatch_mark field.

	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmark = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnomatch_mark

	// For anything other than nomatch or partial match, just return the code.

	if !(rc != DMATCH_NOMATCH && rc != -2) {
		goto __147
	}
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Frc = rc
	goto __148
__147:
	if !(match_partial != uintptr(0)) {
		goto __149
	}

	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fsubject = subject
	*(*Tsize_t)(unsafe.Pointer(match_data + 80)) = Tsize_t((int64(match_partial) - int64(subject)) / 1)
	*(*Tsize_t)(unsafe.Pointer(match_data + 80 + 1*8)) = Tsize_t((int64(end_subject) - int64(subject)) / 1)
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fstartchar = Tsize_t((int64(match_partial) - int64(subject)) / 1)
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fleftchar = Tsize_t((int64(start_partial) - int64(subject)) / 1)
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Frightchar = Tsize_t((int64(end_subject) - int64(subject)) / 1)
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Frc = -2
	goto __150
__149:
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Frc = -1
__150:
	;
__148:
	;

	return (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Frc
}

// End of pcre2_match.c

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// ************************************************
//
//  Create a match data block given ovector size  *
//

// A minimum of 1 is imposed on the number of ovector pairs.

func Xpcre2_match_data_create_8(tls *libc.TLS, oveccount Tuint32_t, gcontext uintptr) uintptr { /* pcre2_match_data.c:56:33: */
	var yield uintptr
	if oveccount < Tuint32_t(1) {
		oveccount = Tuint32_t(1)
	}
	yield = X_pcre2_memctl_malloc_8(tls,
		uint64(uintptr(0)+80)+uint64(Tuint32_t(2)*oveccount)*uint64(unsafe.Sizeof(Tsize_t(0))),
		gcontext)
	if yield == uintptr(0) {
		return uintptr(0)
	}
	(*Tpcre2_match_data_8)(unsafe.Pointer(yield)).Foveccount = Tuint16_t(oveccount)
	(*Tpcre2_match_data_8)(unsafe.Pointer(yield)).Fflags = Tuint8_t(0)
	return yield
}

// ************************************************
//
//  Create a match data block using pattern data  *
//

// If no context is supplied, use the memory allocator from the code.

func Xpcre2_match_data_create_from_pattern_8(tls *libc.TLS, code uintptr, gcontext uintptr) uintptr { /* pcre2_match_data.c:78:33: */
	if gcontext == uintptr(0) {
		gcontext = code
	}
	return Xpcre2_match_data_create_8(tls, uint32(int32((*Tpcre2_real_code_8)(unsafe.Pointer(code)).Ftop_bracket)+1),
		gcontext)
}

// ************************************************
//
//            Free a match data block             *
//

func Xpcre2_match_data_free_8(tls *libc.TLS, match_data uintptr) { /* pcre2_match_data.c:94:1: */
	if match_data != uintptr(0) {
		if uint32((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fflags)&DPCRE2_MD_COPIED_SUBJECT != uint32(0) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmemctl.Ffree})).f(tls, (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fsubject,
				(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmemctl.Fmemory_data)
		}
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmemctl.Ffree})).f(tls, match_data, (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmemctl.Fmemory_data)
	}
}

// ************************************************
//
//         Get last mark in match                 *
//

func Xpcre2_get_mark_8(tls *libc.TLS, match_data uintptr) TPCRE2_SPTR8 { /* pcre2_match_data.c:112:1: */
	return (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmark
}

// ************************************************
//
//          Get pointer to ovector                *
//

func Xpcre2_get_ovector_pointer_8(tls *libc.TLS, match_data uintptr) uintptr { /* pcre2_match_data.c:123:27: */
	return match_data + 80 /* &.ovector */
}

// ************************************************
//
//          Get number of ovector slots           *
//

func Xpcre2_get_ovector_count_8(tls *libc.TLS, match_data uintptr) Tuint32_t { /* pcre2_match_data.c:136:1: */
	return Tuint32_t((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Foveccount)
}

// ************************************************
//
//         Get starting code unit in match        *
//

func Xpcre2_get_startchar_8(tls *libc.TLS, match_data uintptr) Tsize_t { /* pcre2_match_data.c:148:1: */
	return (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fstartchar
}

// ************************************************
//
//         Get size of match data block           *
//

func Xpcre2_get_match_data_size_8(tls *libc.TLS, match_data uintptr) Tsize_t { /* pcre2_match_data.c:160:1: */
	return uint64(uintptr(0)+80) + uint64(2*int32((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Foveccount))*uint64(unsafe.Sizeof(Tsize_t(0)))
}

// End of pcre2_match_data.c

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// ************************************************
//
//      Check for newline at given position       *
//

// This function is called only via the IS_NEWLINE macro, which does so only
// when the newline type is NLTYPE_ANY or NLTYPE_ANYCRLF. The case of a fixed
// newline (NLTYPE_FIXED) is handled inline. It is guaranteed that the code unit
// pointed to by ptr is less than the end of the string.
//
// Arguments:
//   ptr          pointer to possible newline
//   type         the newline type
//   endptr       pointer to the end of the string
//   lenptr       where to return the length
//   utf          TRUE if in utf mode
//
// Returns:       TRUE or FALSE

func X_pcre2_is_newline_8(tls *libc.TLS, ptr TPCRE2_SPTR8, type1 Tuint32_t, endptr TPCRE2_SPTR8, lenptr uintptr, utf TBOOL) TBOOL { /* pcre2_newline.c:79:1: */
	var c Tuint32_t

	if utf != 0 {
		c = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr)))
		if c >= 0xc0 {
			if c&0x20 == Tuint32_t(0) {
				c = c&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 1)))&0x3f
			} else if c&0x10 == Tuint32_t(0) {
				c = c&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 2)))&0x3f
			} else if c&0x08 == Tuint32_t(0) {
				c = c&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 3)))&0x3f
			} else if c&0x04 == Tuint32_t(0) {
				c = c&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 4)))&0x3f
			} else {
				c = c&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 5)))&0x3f
			}
		}

	} else {
		c = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr)))
	}

	if type1 == Tuint32_t(DNLTYPE_ANYCRLF) {
		switch c {
		case Tuint32_t('\012'):
			*(*Tuint32_t)(unsafe.Pointer(lenptr)) = Tuint32_t(1)
			return DTRUE
			fallthrough

		case Tuint32_t('\015'):
			*(*Tuint32_t)(unsafe.Pointer(lenptr)) = func() uint32 {
				if ptr < endptr-uintptr(1) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 1))) == '\012' {
					return uint32(2)
				}
				return uint32(1)
			}()
			return DTRUE
			fallthrough

		default:
			return DFALSE
		}
	} else {
		switch c {
		case Tuint32_t('\012'):
			fallthrough
		case Tuint32_t('\013'):
			fallthrough
		case Tuint32_t('\014'):
			*(*Tuint32_t)(unsafe.Pointer(lenptr)) = Tuint32_t(1)
			return DTRUE
			fallthrough

		case Tuint32_t('\015'):
			*(*Tuint32_t)(unsafe.Pointer(lenptr)) = func() uint32 {
				if ptr < endptr-uintptr(1) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 1))) == '\012' {
					return uint32(2)
				}
				return uint32(1)
			}()
			return DTRUE
			fallthrough

		case Tuint32_t(uint8('\x85')):
			*(*Tuint32_t)(unsafe.Pointer(lenptr)) = func() uint32 {
				if utf != 0 {
					return uint32(2)
				}
				return uint32(1)
			}()
			return DTRUE
			fallthrough

		case Tuint32_t(0x2028):
			fallthrough // LS
		case Tuint32_t(0x2029): // PS
			*(*Tuint32_t)(unsafe.Pointer(lenptr)) = Tuint32_t(3)
			return DTRUE
			fallthrough

		default:
			return DFALSE
		}
	}
	return TBOOL(0)
}

// ************************************************
//
//     Check for newline at previous position     *
//

// This function is called only via the WAS_NEWLINE macro, which does so only
// when the newline type is NLTYPE_ANY or NLTYPE_ANYCRLF. The case of a fixed
// newline (NLTYPE_FIXED) is handled inline. It is guaranteed that the initial
// value of ptr is greater than the start of the string that is being processed.
//
// Arguments:
//   ptr          pointer to possible newline
//   type         the newline type
//   startptr     pointer to the start of the string
//   lenptr       where to return the length
//   utf          TRUE if in utf mode
//
// Returns:       TRUE or FALSE

func X_pcre2_was_newline_8(tls *libc.TLS, ptr TPCRE2_SPTR8, type1 Tuint32_t, startptr TPCRE2_SPTR8, lenptr uintptr, utf TBOOL) TBOOL { /* pcre2_newline.c:169:1: */
	var c Tuint32_t
	ptr--

	if utf != 0 {
		for uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr)))&0xc0 == 0x80 {
			ptr--
		}
		c = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr)))
		if c >= 0xc0 {
			if c&0x20 == Tuint32_t(0) {
				c = c&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 1)))&0x3f
			} else if c&0x10 == Tuint32_t(0) {
				c = c&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 2)))&0x3f
			} else if c&0x08 == Tuint32_t(0) {
				c = c&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 3)))&0x3f
			} else if c&0x04 == Tuint32_t(0) {
				c = c&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 4)))&0x3f
			} else {
				c = c&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 1)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 2)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 3)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 4)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 5)))&0x3f
			}
		}

	} else {
		c = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr)))
	}

	if type1 == Tuint32_t(DNLTYPE_ANYCRLF) {
		switch c {
		case Tuint32_t('\012'):
			*(*Tuint32_t)(unsafe.Pointer(lenptr)) = func() uint32 {
				if ptr > startptr && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + libc.UintptrFromInt32(-1)))) == '\015' {
					return uint32(2)
				}
				return uint32(1)
			}()
			return DTRUE
			fallthrough

		case Tuint32_t('\015'):
			*(*Tuint32_t)(unsafe.Pointer(lenptr)) = Tuint32_t(1)
			return DTRUE
			fallthrough

		default:
			return DFALSE
		}
	} else {
		switch c {
		case Tuint32_t('\012'):
			*(*Tuint32_t)(unsafe.Pointer(lenptr)) = func() uint32 {
				if ptr > startptr && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + libc.UintptrFromInt32(-1)))) == '\015' {
					return uint32(2)
				}
				return uint32(1)
			}()
			return DTRUE
			fallthrough

		case Tuint32_t('\013'):
			fallthrough
		case Tuint32_t('\014'):
			fallthrough
		case Tuint32_t('\015'):
			*(*Tuint32_t)(unsafe.Pointer(lenptr)) = Tuint32_t(1)
			return DTRUE
			fallthrough

		case Tuint32_t(uint8('\x85')):
			*(*Tuint32_t)(unsafe.Pointer(lenptr)) = func() uint32 {
				if utf != 0 {
					return uint32(2)
				}
				return uint32(1)
			}()
			return DTRUE
			fallthrough

		case Tuint32_t(0x2028):
			fallthrough // LS
		case Tuint32_t(0x2029): // PS
			*(*Tuint32_t)(unsafe.Pointer(lenptr)) = Tuint32_t(3)
			return DTRUE
			fallthrough

		default:
			return DFALSE
		}
	}
	return TBOOL(0)
}

// End of pcre2_newline.c

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// If SUPPORT_UNICODE is not defined, this function will never be called.
// Supply a dummy function because some compilers do not like empty source
// modules.

// ************************************************
//
//          Convert code point to UTF             *
//

//
// Arguments:
//   cvalue     the character value
//   buffer     pointer to buffer for result
//
// Returns:     number of code units placed in the buffer

func X_pcre2_ord2utf_8(tls *libc.TLS, cvalue Tuint32_t, buffer uintptr) uint32 { /* pcre2_ord2utf.c:81:1: */
	// Convert to UTF-8

	var i int32
	var j int32
	for i = 0; i < X_pcre2_utf8_table1_size; i++ {
		if int32(cvalue) <= X_pcre2_utf8_table1[i] {
			break
		}
	}
	buffer += uintptr(i)
	for j = i; j > 0; j-- {
		*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostDecUintptr(&buffer, 1))) = TPCRE2_UCHAR8(Tuint32_t(0x80) | cvalue&Tuint32_t(0x3f))
		cvalue >>= 6
	}
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(buffer)) = TPCRE2_UCHAR8(Tuint32_t(X_pcre2_utf8_table2[i]) | cvalue)
	return uint32(i + 1)

	// Convert to UTF-16

}

// End of pcre_ord2utf.c

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// ************************************************
//
//        Return info about compiled pattern      *
//

//
// Arguments:
//   code          points to compiled code
//   what          what information is required
//   where         where to put the information; if NULL, return length
//
// Returns:        0 when data returned
//                 > 0 when length requested
//                 < 0 on error or unset value

func Xpcre2_pattern_info_8(tls *libc.TLS, code uintptr, what Tuint32_t, where uintptr) int32 { /* pcre2_pattern_info.c:65:1: */
	var re uintptr = code

	if where == uintptr(0) {
		switch what {
		case Tuint32_t(DPCRE2_INFO_ALLOPTIONS):
			fallthrough
		case Tuint32_t(DPCRE2_INFO_ARGOPTIONS):
			fallthrough
		case Tuint32_t(DPCRE2_INFO_BACKREFMAX):
			fallthrough
		case Tuint32_t(DPCRE2_INFO_BSR):
			fallthrough
		case Tuint32_t(DPCRE2_INFO_CAPTURECOUNT):
			fallthrough
		case Tuint32_t(DPCRE2_INFO_DEPTHLIMIT):
			fallthrough
		case Tuint32_t(DPCRE2_INFO_EXTRAOPTIONS):
			fallthrough
		case Tuint32_t(DPCRE2_INFO_FIRSTCODETYPE):
			fallthrough
		case Tuint32_t(DPCRE2_INFO_FIRSTCODEUNIT):
			fallthrough
		case Tuint32_t(DPCRE2_INFO_HASBACKSLASHC):
			fallthrough
		case Tuint32_t(DPCRE2_INFO_HASCRORLF):
			fallthrough
		case Tuint32_t(DPCRE2_INFO_HEAPLIMIT):
			fallthrough
		case Tuint32_t(DPCRE2_INFO_JCHANGED):
			fallthrough
		case Tuint32_t(DPCRE2_INFO_LASTCODETYPE):
			fallthrough
		case Tuint32_t(DPCRE2_INFO_LASTCODEUNIT):
			fallthrough
		case Tuint32_t(DPCRE2_INFO_MATCHEMPTY):
			fallthrough
		case Tuint32_t(DPCRE2_INFO_MATCHLIMIT):
			fallthrough
		case Tuint32_t(DPCRE2_INFO_MAXLOOKBEHIND):
			fallthrough
		case Tuint32_t(DPCRE2_INFO_MINLENGTH):
			fallthrough
		case Tuint32_t(DPCRE2_INFO_NAMEENTRYSIZE):
			fallthrough
		case Tuint32_t(DPCRE2_INFO_NAMECOUNT):
			fallthrough
		case Tuint32_t(DPCRE2_INFO_NEWLINE):
			return int32(unsafe.Sizeof(Tuint32_t(0)))
			fallthrough

		case Tuint32_t(DPCRE2_INFO_FIRSTBITMAP):
			return int32(unsafe.Sizeof(uintptr(0)))
			fallthrough

		case Tuint32_t(DPCRE2_INFO_JITSIZE):
			fallthrough
		case Tuint32_t(DPCRE2_INFO_SIZE):
			fallthrough
		case Tuint32_t(DPCRE2_INFO_FRAMESIZE):
			return int32(unsafe.Sizeof(Tsize_t(0)))
			fallthrough

		case Tuint32_t(DPCRE2_INFO_NAMETABLE):
			return int32(unsafe.Sizeof(TPCRE2_SPTR8(0)))
		}
	}

	if re == uintptr(0) {
		return -51
	}

	// Check that the first field in the block is the magic number. If it is not,
	// return with PCRE2_ERROR_BADMAGIC.

	if uint64((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fmagic_number) != DMAGIC_NUMBER {
		return -31
	}

	// Check that this pattern was compiled in the correct bit mode

	if (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&Tuint32_t(DPCRE2_CODE_UNIT_WIDTH/8) == Tuint32_t(0) {
		return -32
	}

	switch what {
	case Tuint32_t(DPCRE2_INFO_ALLOPTIONS):
		*(*Tuint32_t)(unsafe.Pointer(where)) = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options
		break

	case Tuint32_t(DPCRE2_INFO_ARGOPTIONS):
		*(*Tuint32_t)(unsafe.Pointer(where)) = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fcompile_options
		break

	case Tuint32_t(DPCRE2_INFO_BACKREFMAX):
		*(*Tuint32_t)(unsafe.Pointer(where)) = Tuint32_t((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftop_backref)
		break

	case Tuint32_t(DPCRE2_INFO_BSR):
		*(*Tuint32_t)(unsafe.Pointer(where)) = Tuint32_t((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fbsr_convention)
		break

	case Tuint32_t(DPCRE2_INFO_CAPTURECOUNT):
		*(*Tuint32_t)(unsafe.Pointer(where)) = Tuint32_t((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftop_bracket)
		break

	case Tuint32_t(DPCRE2_INFO_DEPTHLIMIT):
		*(*Tuint32_t)(unsafe.Pointer(where)) = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flimit_depth
		if (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flimit_depth == 4294967295 {
			return -55
		}
		break

	case Tuint32_t(DPCRE2_INFO_EXTRAOPTIONS):
		*(*Tuint32_t)(unsafe.Pointer(where)) = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fextra_options
		break

	case Tuint32_t(DPCRE2_INFO_FIRSTCODETYPE):
		*(*Tuint32_t)(unsafe.Pointer(where)) = func() uint32 {
			if (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&Tuint32_t(DPCRE2_FIRSTSET) != Tuint32_t(0) {
				return uint32(1)
			}
			return func() uint32 {
				if (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&Tuint32_t(DPCRE2_STARTLINE) != Tuint32_t(0) {
					return uint32(2)
				}
				return uint32(0)
			}()
		}()
		break

	case Tuint32_t(DPCRE2_INFO_FIRSTCODEUNIT):
		*(*Tuint32_t)(unsafe.Pointer(where)) = func() uint32 {
			if (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&Tuint32_t(DPCRE2_FIRSTSET) != Tuint32_t(0) {
				return (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ffirst_codeunit
			}
			return uint32(0)
		}()
		break

	case Tuint32_t(DPCRE2_INFO_FIRSTBITMAP):
		*(*uintptr)(unsafe.Pointer(where)) = func() uintptr {
			if (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&Tuint32_t(DPCRE2_FIRSTMAPSET) != Tuint32_t(0) {
				return re + 40
			}
			return uintptr(0)
		}()
		break

	case Tuint32_t(DPCRE2_INFO_FRAMESIZE):
		*(*Tsize_t)(unsafe.Pointer(where)) = uint64(uintptr(0)+128) + uint64(int32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftop_bracket)*2)*uint64(unsafe.Sizeof(Tsize_t(0)))
		break

	case Tuint32_t(DPCRE2_INFO_HASBACKSLASHC):
		*(*Tuint32_t)(unsafe.Pointer(where)) = Tuint32_t(libc.Bool32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&Tuint32_t(DPCRE2_HASBKC) != Tuint32_t(0)))
		break

	case Tuint32_t(DPCRE2_INFO_HASCRORLF):
		*(*Tuint32_t)(unsafe.Pointer(where)) = Tuint32_t(libc.Bool32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&Tuint32_t(DPCRE2_HASCRORLF) != Tuint32_t(0)))
		break

	case Tuint32_t(DPCRE2_INFO_HEAPLIMIT):
		*(*Tuint32_t)(unsafe.Pointer(where)) = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flimit_heap
		if (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flimit_heap == 4294967295 {
			return -55
		}
		break

	case Tuint32_t(DPCRE2_INFO_JCHANGED):
		*(*Tuint32_t)(unsafe.Pointer(where)) = Tuint32_t(libc.Bool32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&Tuint32_t(DPCRE2_JCHANGED) != Tuint32_t(0)))
		break

	case Tuint32_t(DPCRE2_INFO_JITSIZE):
		*(*Tsize_t)(unsafe.Pointer(where)) = uint64(0)
		break

	case Tuint32_t(DPCRE2_INFO_LASTCODETYPE):
		*(*Tuint32_t)(unsafe.Pointer(where)) = func() uint32 {
			if (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&Tuint32_t(DPCRE2_LASTSET) != Tuint32_t(0) {
				return uint32(1)
			}
			return uint32(0)
		}()
		break

	case Tuint32_t(DPCRE2_INFO_LASTCODEUNIT):
		*(*Tuint32_t)(unsafe.Pointer(where)) = func() uint32 {
			if (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&Tuint32_t(DPCRE2_LASTSET) != Tuint32_t(0) {
				return (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flast_codeunit
			}
			return uint32(0)
		}()
		break

	case Tuint32_t(DPCRE2_INFO_MATCHEMPTY):
		*(*Tuint32_t)(unsafe.Pointer(where)) = Tuint32_t(libc.Bool32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&Tuint32_t(DPCRE2_MATCH_EMPTY) != Tuint32_t(0)))
		break

	case Tuint32_t(DPCRE2_INFO_MATCHLIMIT):
		*(*Tuint32_t)(unsafe.Pointer(where)) = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flimit_match
		if (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flimit_match == 4294967295 {
			return -55
		}
		break

	case Tuint32_t(DPCRE2_INFO_MAXLOOKBEHIND):
		*(*Tuint32_t)(unsafe.Pointer(where)) = Tuint32_t((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fmax_lookbehind)
		break

	case Tuint32_t(DPCRE2_INFO_MINLENGTH):
		*(*Tuint32_t)(unsafe.Pointer(where)) = Tuint32_t((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fminlength)
		break

	case Tuint32_t(DPCRE2_INFO_NAMEENTRYSIZE):
		*(*Tuint32_t)(unsafe.Pointer(where)) = Tuint32_t((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fname_entry_size)
		break

	case Tuint32_t(DPCRE2_INFO_NAMECOUNT):
		*(*Tuint32_t)(unsafe.Pointer(where)) = Tuint32_t((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fname_count)
		break

	case Tuint32_t(DPCRE2_INFO_NAMETABLE):
		*(*TPCRE2_SPTR8)(unsafe.Pointer(where)) = re + uintptr(uint64(unsafe.Sizeof(Tpcre2_real_code_8{})))
		break

	case Tuint32_t(DPCRE2_INFO_NEWLINE):
		*(*Tuint32_t)(unsafe.Pointer(where)) = Tuint32_t((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fnewline_convention)
		break

	case Tuint32_t(DPCRE2_INFO_SIZE):
		*(*Tsize_t)(unsafe.Pointer(where)) = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fblocksize
		break

	default:
		return -34
	}

	return 0
}

// ************************************************
//
//              Callout enumerator                *
//

//
// Arguments:
//   code          points to compiled code
//   callback      function called for each callout block
//   callout_data  user data passed to the callback
//
// Returns:        0 when successfully completed
//                 < 0 on local error
//                != 0 for callback error

func Xpcre2_callout_enumerate_8(tls *libc.TLS, code uintptr, callback uintptr, callout_data uintptr) int32 { /* pcre2_pattern_info.c:268:1: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	var re uintptr = code
	// var cb Tpcre2_callout_enumerate_block_8 at bp, 56

	var cc TPCRE2_SPTR8
	var utf TBOOL

	if re == uintptr(0) {
		return -51
	}

	utf = libc.Bool32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_UTF != Tuint32_t(0))

	// Check that the first field in the block is the magic number. If it is not,
	// return with PCRE2_ERROR_BADMAGIC.

	if uint64((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fmagic_number) != DMAGIC_NUMBER {
		return -31
	}

	// Check that this pattern was compiled in the correct bit mode

	if (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&Tuint32_t(DPCRE2_CODE_UNIT_WIDTH/8) == Tuint32_t(0) {
		return -32
	}

	(*Tpcre2_callout_enumerate_block_8)(unsafe.Pointer(bp /* &cb */)).Fversion = Tuint32_t(0)
	cc = re + uintptr(uint64(unsafe.Sizeof(Tpcre2_real_code_8{}))) +
		uintptr(int32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fname_count)*int32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fname_entry_size))

	for 1 != 0 {
		var rc int32
		switch int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc))) {
		case OP_END:
			return 0

		case OP_CHAR:
			fallthrough
		case OP_CHARI:
			fallthrough
		case OP_NOT:
			fallthrough
		case OP_NOTI:
			fallthrough
		case OP_STAR:
			fallthrough
		case OP_MINSTAR:
			fallthrough
		case OP_PLUS:
			fallthrough
		case OP_MINPLUS:
			fallthrough
		case OP_QUERY:
			fallthrough
		case OP_MINQUERY:
			fallthrough
		case OP_UPTO:
			fallthrough
		case OP_MINUPTO:
			fallthrough
		case OP_EXACT:
			fallthrough
		case OP_POSSTAR:
			fallthrough
		case OP_POSPLUS:
			fallthrough
		case OP_POSQUERY:
			fallthrough
		case OP_POSUPTO:
			fallthrough
		case OP_STARI:
			fallthrough
		case OP_MINSTARI:
			fallthrough
		case OP_PLUSI:
			fallthrough
		case OP_MINPLUSI:
			fallthrough
		case OP_QUERYI:
			fallthrough
		case OP_MINQUERYI:
			fallthrough
		case OP_UPTOI:
			fallthrough
		case OP_MINUPTOI:
			fallthrough
		case OP_EXACTI:
			fallthrough
		case OP_POSSTARI:
			fallthrough
		case OP_POSPLUSI:
			fallthrough
		case OP_POSQUERYI:
			fallthrough
		case OP_POSUPTOI:
			fallthrough
		case OP_NOTSTAR:
			fallthrough
		case OP_NOTMINSTAR:
			fallthrough
		case OP_NOTPLUS:
			fallthrough
		case OP_NOTMINPLUS:
			fallthrough
		case OP_NOTQUERY:
			fallthrough
		case OP_NOTMINQUERY:
			fallthrough
		case OP_NOTUPTO:
			fallthrough
		case OP_NOTMINUPTO:
			fallthrough
		case OP_NOTEXACT:
			fallthrough
		case OP_NOTPOSSTAR:
			fallthrough
		case OP_NOTPOSPLUS:
			fallthrough
		case OP_NOTPOSQUERY:
			fallthrough
		case OP_NOTPOSUPTO:
			fallthrough
		case OP_NOTSTARI:
			fallthrough
		case OP_NOTMINSTARI:
			fallthrough
		case OP_NOTPLUSI:
			fallthrough
		case OP_NOTMINPLUSI:
			fallthrough
		case OP_NOTQUERYI:
			fallthrough
		case OP_NOTMINQUERYI:
			fallthrough
		case OP_NOTUPTOI:
			fallthrough
		case OP_NOTMINUPTOI:
			fallthrough
		case OP_NOTEXACTI:
			fallthrough
		case OP_NOTPOSSTARI:
			fallthrough
		case OP_NOTPOSPLUSI:
			fallthrough
		case OP_NOTPOSQUERYI:
			fallthrough
		case OP_NOTPOSUPTOI:
			cc += TPCRE2_SPTR8(X_pcre2_OP_lengths_8[*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc))])
			if utf != 0 && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + libc.UintptrFromInt32(-1)))) >= 0xc0 {
				cc += TPCRE2_SPTR8(X_pcre2_utf8_table4[uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + libc.UintptrFromInt32(-1))))&0x3f])
			}
			break

		case OP_TYPESTAR:
			fallthrough
		case OP_TYPEMINSTAR:
			fallthrough
		case OP_TYPEPLUS:
			fallthrough
		case OP_TYPEMINPLUS:
			fallthrough
		case OP_TYPEQUERY:
			fallthrough
		case OP_TYPEMINQUERY:
			fallthrough
		case OP_TYPEUPTO:
			fallthrough
		case OP_TYPEMINUPTO:
			fallthrough
		case OP_TYPEEXACT:
			fallthrough
		case OP_TYPEPOSSTAR:
			fallthrough
		case OP_TYPEPOSPLUS:
			fallthrough
		case OP_TYPEPOSQUERY:
			fallthrough
		case OP_TYPEPOSUPTO:
			cc += TPCRE2_SPTR8(X_pcre2_OP_lengths_8[*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc))])
			if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + libc.UintptrFromInt32(-1)))) == OP_PROP || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + libc.UintptrFromInt32(-1)))) == OP_NOTPROP {
				cc += uintptr(2)
			}
			break

		case OP_XCLASS:
			cc += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 2)))))
			break

		case OP_MARK:
			fallthrough
		case OP_COMMIT_ARG:
			fallthrough
		case OP_PRUNE_ARG:
			fallthrough
		case OP_SKIP_ARG:
			fallthrough
		case OP_THEN_ARG:
			cc += TPCRE2_SPTR8(int32(X_pcre2_OP_lengths_8[*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc))]) + int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 1))))
			break

		case OP_CALLOUT:
			(*Tpcre2_callout_enumerate_block_8)(unsafe.Pointer(bp /* &cb */)).Fpattern_position = Tsize_t(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 2)))))
			(*Tpcre2_callout_enumerate_block_8)(unsafe.Pointer(bp /* &cb */)).Fnext_item_length = Tsize_t(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 3)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 4)))))
			(*Tpcre2_callout_enumerate_block_8)(unsafe.Pointer(bp /* &cb */)).Fcallout_number = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 5)))
			(*Tpcre2_callout_enumerate_block_8)(unsafe.Pointer(bp /* &cb */)).Fcallout_string_offset = uint64(0)
			(*Tpcre2_callout_enumerate_block_8)(unsafe.Pointer(bp /* &cb */)).Fcallout_string_length = uint64(0)
			(*Tpcre2_callout_enumerate_block_8)(unsafe.Pointer(bp /* &cb */)).Fcallout_string = uintptr(0)
			rc = (*struct {
				f func(*libc.TLS, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{callback})).f(tls, bp /* &cb */, callout_data)
			if rc != 0 {
				return rc
			}
			cc += TPCRE2_SPTR8(X_pcre2_OP_lengths_8[*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc))])
			break

		case OP_CALLOUT_STR:
			(*Tpcre2_callout_enumerate_block_8)(unsafe.Pointer(bp /* &cb */)).Fpattern_position = Tsize_t(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 2)))))
			(*Tpcre2_callout_enumerate_block_8)(unsafe.Pointer(bp /* &cb */)).Fnext_item_length = Tsize_t(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 3)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 4)))))
			(*Tpcre2_callout_enumerate_block_8)(unsafe.Pointer(bp /* &cb */)).Fcallout_number = Tuint32_t(0)
			(*Tpcre2_callout_enumerate_block_8)(unsafe.Pointer(bp /* &cb */)).Fcallout_string_offset = Tsize_t(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 7)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 8)))))
			(*Tpcre2_callout_enumerate_block_8)(unsafe.Pointer(bp /* &cb */)).Fcallout_string_length = Tsize_t(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 5)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 6)))) - uint32(1+4*DLINK_SIZE) - uint32(2))
			(*Tpcre2_callout_enumerate_block_8)(unsafe.Pointer(bp /* &cb */)).Fcallout_string = cc + uintptr(1+4*DLINK_SIZE) + uintptr(1)
			rc = (*struct {
				f func(*libc.TLS, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{callback})).f(tls, bp /* &cb */, callout_data)
			if rc != 0 {
				return rc
			}
			cc += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 5)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 6)))))
			break

		default:
			cc += TPCRE2_SPTR8(X_pcre2_OP_lengths_8[*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc))])
			break
		}
	}
	return int32(0)
}

// End of pcre2_pattern_info.c

func X_pcre2_script_run_8(tls *libc.TLS, ptr TPCRE2_SPTR8, endptr TPCRE2_SPTR8, utf TBOOL) TBOOL { /* pcre2_script_run.c:85:1: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var require_state Tuint32_t = SCRIPT_UNSET
	// var require_map [6]Tuint32_t at bp, 24

	// var map1 [6]Tuint32_t at bp+24, 24

	var require_digitset Tuint32_t = Tuint32_t(0)
	var c Tuint32_t

	// Any string containing fewer than 2 characters is a valid script run.

	if ptr >= endptr {
		return DTRUE
	}
	c = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&ptr, 1))))
	if utf != 0 && c >= 0xc0 {
		if c&0x20 == Tuint32_t(0) {
			c = c&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&ptr, 1))))&0x3f
		} else if c&0x10 == Tuint32_t(0) {
			c = c&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 1)))&0x3f
			ptr += uintptr(2)
		} else if c&0x08 == Tuint32_t(0) {
			c = c&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 2)))&0x3f
			ptr += uintptr(3)
		} else if c&0x04 == Tuint32_t(0) {
			c = c&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 3)))&0x3f
			ptr += uintptr(4)
		} else {
			c = c&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 4)))&0x3f
			ptr += uintptr(5)
		}
	}

	if ptr >= endptr {
		return DTRUE
	}

	// Initialize the require map. This is a full-size bitmap that has a bit for
	// every script, as opposed to the maps in ucd_script_sets, which only have bits
	// for scripts less than ucp_Unknown - those that appear in script extension
	// lists.

	{
		var i int32 = 0
	__1:
		if !(i < ucp_Script_Count/32+1) {
			goto __3
		}
		*(*Tuint32_t)(unsafe.Pointer(bp + uintptr(i)*4)) = Tuint32_t(0)
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
	}

	// Scan strings of two or more characters, checking the Unicode characteristics
	// of each code point. There is special code for scripts that can be combined with
	// characters from the Han Chinese script. This may be used in conjunction with
	// four other scripts in these combinations:
	//
	// . Han with Hiragana and Katakana is allowed (for Japanese).
	// . Han with Bopomofo is allowed (for Taiwanese Mandarin).
	// . Han with Hangul is allowed (for Korean).
	//
	// If the first significant character's script is one of the four, the required
	// script type is immediately known. However, if the first significant
	// character's script is Han, we have to keep checking for a non-Han character.
	// Hence the SCRIPT_HANPENDING state.

	for {
		var ucd uintptr = uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12
		var script Tuint32_t = Tuint32_t((*Tucd_record)(unsafe.Pointer(ucd)).Fscript)

		// If the script is Unknown, the string is not a valid script run. Such
		//   characters can only form script runs of length one (see test above).

		if script == ucp_Unknown {
			return DFALSE
		}

		// A character without any script extensions whose script is Inherited or
		//   Common is always accepted with any script. If there are extensions, the
		//   following processing happens for all scripts.

		if int32((*Tucd_record)(unsafe.Pointer(ucd)).Fscriptx_bidiclass)&DUCD_SCRIPTX_MASK != 0 || script != ucp_Inherited && script != ucp_Common {
			var OK TBOOL

			// Set up a full-sized map for this character that can include bits for all
			//     scripts. Copy the scriptx map for this character (which covers those
			//     scripts that appear in script extension lists), set the remaining values to
			//     zero, and then, except for Common or Inherited, add this script's bit to
			//     the map.

			libc.Xmemcpy(tls, bp+24, uintptr(unsafe.Pointer(&X_pcre2_ucd_script_sets_8))+uintptr(int32((*Tucd_record)(unsafe.Pointer(ucd)).Fscriptx_bidiclass)&DUCD_SCRIPTX_MASK)*4, uint64(ucp_Unknown/32+1)*uint64(unsafe.Sizeof(Tuint32_t(0))))
			libc.Xmemset(tls, bp+24+uintptr(ucp_Unknown/32+1)*4, 0, uint64(ucp_Script_Count/32+1-(ucp_Unknown/32+1))*uint64(unsafe.Sizeof(Tuint32_t(0))))
			if script != ucp_Common && script != ucp_Inherited {
				*(*Tuint32_t)(unsafe.Pointer(bp + 24 + uintptr(script/Tuint32_t(32))*4)) |= uint32(1) << (script % Tuint32_t(32))
			}

			// Handle the different checking states

			switch require_state {
			// First significant character - it might follow Common or Inherited
			//       characters that do not have any script extensions.

			case SCRIPT_UNSET:
				switch script {
				case ucp_Han:
					require_state = SCRIPT_HANPENDING
					break
					fallthrough

				case ucp_Hiragana:
					fallthrough
				case ucp_Katakana:
					require_state = SCRIPT_HANHIRAKATA
					break
					fallthrough

				case ucp_Bopomofo:
					require_state = SCRIPT_HANBOPOMOFO
					break
					fallthrough

				case ucp_Hangul:
					require_state = SCRIPT_HANHANGUL
					break
					fallthrough

				default:
					libc.Xmemcpy(tls, bp, bp+24, uint64(ucp_Script_Count/32+1)*uint64(unsafe.Sizeof(Tuint32_t(0))))
					require_state = SCRIPT_MAP
					break
				}
				break
				fallthrough

			// The first significant character was Han. An inspection of the Unicode
			//       11.0.0 files shows that there are the following types of Script Extension
			//       list that involve the Han, Bopomofo, Hiragana, Katakana, and Hangul
			//       scripts:
			//
			//       . Bopomofo + Han
			//       . Han + Hiragana + Katakana
			//       . Hiragana + Katakana
			//       . Bopopmofo + Hangul + Han + Hiragana + Katakana
			//
			//       The following code tries to make sense of this.

			case SCRIPT_HANPENDING:
				if script != ucp_Han {
					var chspecial Tuint32_t = Tuint32_t(0)

					if *(*Tuint32_t)(unsafe.Pointer(bp + 24))&(uint32(1)<<(ucp_Bopomofo%32)) != Tuint32_t(0) {
						chspecial = chspecial | Tuint32_t(DFOUND_BOPOMOFO)
					}
					if *(*Tuint32_t)(unsafe.Pointer(bp + 24))&(uint32(1)<<(ucp_Hiragana%32)) != Tuint32_t(0) {
						chspecial = chspecial | Tuint32_t(DFOUND_HIRAGANA)
					}
					if *(*Tuint32_t)(unsafe.Pointer(bp + 24))&(uint32(1)<<(ucp_Katakana%32)) != Tuint32_t(0) {
						chspecial = chspecial | Tuint32_t(DFOUND_KATAKANA)
					}
					if *(*Tuint32_t)(unsafe.Pointer(bp + 24))&(uint32(1)<<(ucp_Hangul%32)) != Tuint32_t(0) {
						chspecial = chspecial | Tuint32_t(DFOUND_HANGUL)
					}

					if chspecial == Tuint32_t(0) {
						return DFALSE
					} // Not allowed with Han

					if chspecial == Tuint32_t(DFOUND_BOPOMOFO) {
						require_state = SCRIPT_HANBOPOMOFO
					} else if chspecial == Tuint32_t(DFOUND_HIRAGANA|DFOUND_KATAKANA) {
						require_state = SCRIPT_HANHIRAKATA
					}

					// Otherwise this character must be allowed with all of them, so remain
					//         in the pending state.
				}
				break
				fallthrough

			// Previously encountered one of the "with Han" scripts. Check that
			//       this character is appropriate.

			case SCRIPT_HANHIRAKATA:
				if *(*Tuint32_t)(unsafe.Pointer(bp + 24))&(uint32(1)<<(ucp_Han%32))+*(*Tuint32_t)(unsafe.Pointer(bp + 24))&(uint32(1)<<(ucp_Hiragana%32))+*(*Tuint32_t)(unsafe.Pointer(bp + 24))&(uint32(1)<<(ucp_Katakana%32)) == Tuint32_t(0) {
					return DFALSE
				}
				break
				fallthrough

			case SCRIPT_HANBOPOMOFO:
				if *(*Tuint32_t)(unsafe.Pointer(bp + 24))&(uint32(1)<<(ucp_Han%32))+*(*Tuint32_t)(unsafe.Pointer(bp + 24))&(uint32(1)<<(ucp_Bopomofo%32)) == Tuint32_t(0) {
					return DFALSE
				}
				break
				fallthrough

			case SCRIPT_HANHANGUL:
				if *(*Tuint32_t)(unsafe.Pointer(bp + 24))&(uint32(1)<<(ucp_Han%32))+*(*Tuint32_t)(unsafe.Pointer(bp + 24))&(uint32(1)<<(ucp_Hangul%32)) == Tuint32_t(0) {
					return DFALSE
				}
				break
				fallthrough

			// Previously encountered one or more characters that are allowed with a
			//       list of scripts.

			case SCRIPT_MAP:
				OK = DFALSE

				{
					var i int32 = 0
				__4:
					if !(i < ucp_Script_Count/32+1) {
						goto __6
					}
					{
						if *(*Tuint32_t)(unsafe.Pointer(bp + uintptr(i)*4))&*(*Tuint32_t)(unsafe.Pointer(bp + 24 + uintptr(i)*4)) != Tuint32_t(0) {
							OK = DTRUE
							goto __6
						}

					}
					goto __5
				__5:
					i++
					goto __4
					goto __6
				__6:
				}

				if !(OK != 0) {
					return DFALSE
				}

				// The rest of the string must be in this script, but we have to
				//       allow for the Han complications.

				switch script {
				case ucp_Han:
					require_state = SCRIPT_HANPENDING
					break
					fallthrough

				case ucp_Hiragana:
					fallthrough
				case ucp_Katakana:
					require_state = SCRIPT_HANHIRAKATA
					break
					fallthrough

				case ucp_Bopomofo:
					require_state = SCRIPT_HANBOPOMOFO
					break
					fallthrough

				case ucp_Hangul:
					require_state = SCRIPT_HANHANGUL
					break
					fallthrough

				// Compute the intersection of the required list of scripts and the
				//         allowed scripts for this character.

				default:
					{
						var i int32 = 0
					__7:
						if !(i < ucp_Script_Count/32+1) {
							goto __9
						}
						*(*Tuint32_t)(unsafe.Pointer(bp + uintptr(i)*4)) &= *(*Tuint32_t)(unsafe.Pointer(bp + 24 + uintptr(i)*4))
						goto __8
					__8:
						i++
						goto __7
						goto __9
					__9:
					}
					break
				}

				break
			}
		} // End checking character's script and extensions.

		// The character is in an acceptable script. We must now ensure that all
		//   decimal digits in the string come from the same set. Some scripts (e.g.
		//   Common, Arabic) have more than one set of decimal digits. This code does
		//   not allow mixing sets, even within the same script. The vector called
		//   PRIV(ucd_digit_sets)[] contains, in its first element, the number of
		//   following elements, and then, in ascending order, the code points of the
		//   '9' characters in every set of 10 digits. Each set is identified by the
		//   offset in the vector of its '9' character. An initial check of the first
		//   value picks up ASCII digits quickly. Otherwise, a binary chop is used.

		if int32((*Tucd_record)(unsafe.Pointer(ucd)).Fchartype) == ucp_Nd {
			var digitset Tuint32_t

			if c <= X_pcre2_ucd_digit_sets_8[1] {
				digitset = Tuint32_t(1)
			} else {
				var mid int32
				var bot int32 = 1
				var top int32 = int32(X_pcre2_ucd_digit_sets_8[0])
				for {
					if top <= bot+1 {
						digitset = Tuint32_t(top)
						break
					}
					mid = (top + bot) / 2
					if c <= X_pcre2_ucd_digit_sets_8[mid] {
						top = mid
					} else {
						bot = mid
					}
				}
			}

			// A required value of 0 means "unset".

			if require_digitset == Tuint32_t(0) {
				require_digitset = digitset
			} else if digitset != require_digitset {
				return DFALSE
			}
		} // End digit handling

		// If we haven't yet got to the end, pick up the next character.

		if ptr >= endptr {
			return DTRUE
		}
		c = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&ptr, 1))))
		if utf != 0 && c >= 0xc0 {
			if c&0x20 == Tuint32_t(0) {
				c = c&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&ptr, 1))))&0x3f
			} else if c&0x10 == Tuint32_t(0) {
				c = c&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 1)))&0x3f
				ptr += uintptr(2)
			} else if c&0x08 == Tuint32_t(0) {
				c = c&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 2)))&0x3f
				ptr += uintptr(3)
			} else if c&0x04 == Tuint32_t(0) {
				c = c&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 3)))&0x3f
				ptr += uintptr(4)
			} else {
				c = c&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ptr + 4)))&0x3f
				ptr += uintptr(5)
			}
		}

	}
	return TBOOL(0) // End checking loop

}

// End of pcre2_script_run.c

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// Magic number to provide a small check against being handed junk.

// Deserialization is limited to the current PCRE version and
// character width.

// ************************************************
//
//           Serialize compiled patterns          *
//

func Xpcre2_serialize_encode_8(tls *libc.TLS, codes uintptr, number_of_codes Tint32_t, serialized_bytes uintptr, serialized_size uintptr, gcontext uintptr) Tint32_t { /* pcre2_serialize.c:72:1: */
	var bytes uintptr
	var dst_bytes uintptr
	var i Tint32_t
	var total_size Tsize_t
	var re uintptr
	var tables uintptr
	var data uintptr

	var memctl uintptr
	if gcontext != uintptr(0) {
		memctl = gcontext
	} else {
		memctl = uintptr(unsafe.Pointer(&X_pcre2_default_compile_context_8))
	}

	if codes == uintptr(0) || serialized_bytes == uintptr(0) || serialized_size == uintptr(0) {
		return -51
	}

	if number_of_codes <= 0 {
		return -29
	}

	// Compute total size.
	total_size = uint64(unsafe.Sizeof(Tpcre2_serialized_data{})) + uint64(Dcbits_offset+Dcbit_length+256)
	tables = uintptr(0)

	for i = 0; i < number_of_codes; i++ {
		if *(*uintptr)(unsafe.Pointer(codes + uintptr(i)*8)) == uintptr(0) {
			return -51
		}
		re = *(*uintptr)(unsafe.Pointer(codes + uintptr(i)*8))
		if uint64((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fmagic_number) != DMAGIC_NUMBER {
			return -31
		}
		if tables == uintptr(0) {
			tables = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftables
		} else if tables != (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftables {
			return -30
		}
		total_size = total_size + (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fblocksize
	}

	// Initialize the byte stream.
	bytes = (*struct {
		f func(*libc.TLS, Tsize_t, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_memctl)(unsafe.Pointer(memctl)).Fmalloc})).f(tls, total_size+Tsize_t(unsafe.Sizeof(Tpcre2_memctl{})), (*Tpcre2_memctl)(unsafe.Pointer(memctl)).Fmemory_data)
	if bytes == uintptr(0) {
		return -48
	}

	// The controller is stored as a hidden parameter.
	libc.Xmemcpy(tls, bytes, memctl, uint64(unsafe.Sizeof(Tpcre2_memctl{})))
	bytes += uintptr(unsafe.Sizeof(Tpcre2_memctl{}))

	data = bytes
	(*Tpcre2_serialized_data)(unsafe.Pointer(data)).Fmagic = DSERIALIZED_DATA_MAGIC
	(*Tpcre2_serialized_data)(unsafe.Pointer(data)).Fversion = Tuint32_t(DPCRE2_MAJOR | int32(DPCRE2_MINOR)<<16)
	(*Tpcre2_serialized_data)(unsafe.Pointer(data)).Fconfig = uint32(uint64(unsafe.Sizeof(TPCRE2_UCHAR8(0))) | uint64(uint64(unsafe.Sizeof(uintptr(0))))<<8 | uint64(uint64(unsafe.Sizeof(Tsize_t(0))))<<16)
	(*Tpcre2_serialized_data)(unsafe.Pointer(data)).Fnumber_of_codes = number_of_codes

	// Copy all compiled code data.
	dst_bytes = bytes + uintptr(uint64(unsafe.Sizeof(Tpcre2_serialized_data{})))
	libc.Xmemcpy(tls, dst_bytes, tables, uint64(Dcbits_offset+Dcbit_length+256))
	dst_bytes += uintptr(Dcbits_offset + Dcbit_length + 256)

	for i = 0; i < number_of_codes; i++ {
		re = *(*uintptr)(unsafe.Pointer(codes + uintptr(i)*8))
		libc.Xmemcpy(tls, dst_bytes, re, (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fblocksize)

		// Certain fields in the compiled code block are re-set during
		//   deserialization. In order to ensure that the serialized data stream is always
		//   the same for the same pattern, set them to zero here. We can't assume the
		//   copy of the pattern is correctly aligned for accessing the fields as part of
		//   a structure. Note the use of sizeof(void *) in the second of these, to
		//   specify the size of a pointer. If sizeof(uint8_t *) is used (tables is a
		//   pointer to uint8_t), gcc gives a warning because the first argument is also a
		//   pointer to uint8_t. Casting the first argument to (void *) can stop this, but
		//   it didn't stop Coverity giving the same complaint.

		libc.Xmemset(tls, dst_bytes+uintptr(uint64(uintptr(0))), 0,
			uint64(unsafe.Sizeof(Tpcre2_memctl{})))
		libc.Xmemset(tls, dst_bytes+uintptr(uint64(uintptr(0)+24)), 0,
			uint64(unsafe.Sizeof(uintptr(0))))
		libc.Xmemset(tls, dst_bytes+uintptr(uint64(uintptr(0)+32)), 0,
			uint64(unsafe.Sizeof(uintptr(0))))

		dst_bytes += uintptr((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fblocksize)
	}

	*(*uintptr)(unsafe.Pointer(serialized_bytes)) = bytes
	*(*Tsize_t)(unsafe.Pointer(serialized_size)) = total_size
	return number_of_codes
}

// ************************************************
//
//          Deserialize compiled patterns         *
//

func Xpcre2_serialize_decode_8(tls *libc.TLS, codes uintptr, number_of_codes Tint32_t, bytes uintptr, gcontext uintptr) Tint32_t { /* pcre2_serialize.c:163:1: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var data uintptr = bytes
	var memctl uintptr
	if gcontext != uintptr(0) {
		memctl = gcontext
	} else {
		memctl = uintptr(unsafe.Pointer(&X_pcre2_default_compile_context_8))
	}
	var src_bytes uintptr
	var dst_re uintptr
	var tables uintptr
	var i Tint32_t
	var j Tint32_t

	// Sanity checks.

	if data == uintptr(0) || codes == uintptr(0) {
		return -51
	}
	if number_of_codes <= 0 {
		return -29
	}
	if (*Tpcre2_serialized_data)(unsafe.Pointer(data)).Fnumber_of_codes <= 0 {
		return -62
	}
	if (*Tpcre2_serialized_data)(unsafe.Pointer(data)).Fmagic != DSERIALIZED_DATA_MAGIC {
		return -31
	}
	if (*Tpcre2_serialized_data)(unsafe.Pointer(data)).Fversion != Tuint32_t(DPCRE2_MAJOR|int32(DPCRE2_MINOR)<<16) {
		return -32
	}
	if uint64((*Tpcre2_serialized_data)(unsafe.Pointer(data)).Fconfig) != uint64(unsafe.Sizeof(TPCRE2_UCHAR8(0)))|uint64(uint64(unsafe.Sizeof(uintptr(0))))<<8|uint64(uint64(unsafe.Sizeof(Tsize_t(0))))<<16 {
		return -32
	}

	if number_of_codes > (*Tpcre2_serialized_data)(unsafe.Pointer(data)).Fnumber_of_codes {
		number_of_codes = (*Tpcre2_serialized_data)(unsafe.Pointer(data)).Fnumber_of_codes
	}

	src_bytes = bytes + uintptr(uint64(unsafe.Sizeof(Tpcre2_serialized_data{})))

	// Decode tables. The reference count for the tables is stored immediately
	// following them.

	tables = (*struct {
		f func(*libc.TLS, Tsize_t, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_memctl)(unsafe.Pointer(memctl)).Fmalloc})).f(tls, uint64(Dcbits_offset+Dcbit_length+256)+uint64(unsafe.Sizeof(Tsize_t(0))), (*Tpcre2_memctl)(unsafe.Pointer(memctl)).Fmemory_data)
	if tables == uintptr(0) {
		return -48
	}

	libc.Xmemcpy(tls, tables, src_bytes, uint64(Dcbits_offset+Dcbit_length+256))
	*(*Tsize_t)(unsafe.Pointer(tables + uintptr(Dcbits_offset+Dcbit_length+256))) = Tsize_t(number_of_codes)
	src_bytes += uintptr(Dcbits_offset + Dcbit_length + 256)

	// Decode the byte stream. We must not try to read the size from the compiled
	// code block in the stream, because it might be unaligned, which causes errors on
	// hardware such as Sparc-64 that doesn't like unaligned memory accesses. The type
	// of the blocksize field is given its own name to ensure that it is the same here
	// as in the block.

	for i = 0; i < number_of_codes; i++ {
		// var blocksize Tsize_t at bp, 8

		libc.Xmemcpy(tls, bp, src_bytes+uintptr(uint64(uintptr(0)+72)),
			uint64(unsafe.Sizeof(Tsize_t(0))))
		if *(*Tsize_t)(unsafe.Pointer(bp)) <= Tsize_t(unsafe.Sizeof(Tpcre2_real_code_8{})) {
			return -62
		}

		// The allocator provided by gcontext replaces the original one.

		dst_re = X_pcre2_memctl_malloc_8(tls, *(*Tsize_t)(unsafe.Pointer(bp /* blocksize */)),
			gcontext)
		if dst_re == uintptr(0) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_memctl)(unsafe.Pointer(memctl)).Ffree})).f(tls, tables, (*Tpcre2_memctl)(unsafe.Pointer(memctl)).Fmemory_data)
			for j = 0; j < i; j++ {
				(*struct {
					f func(*libc.TLS, uintptr, uintptr)
				})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_memctl)(unsafe.Pointer(memctl)).Ffree})).f(tls, *(*uintptr)(unsafe.Pointer(codes + uintptr(j)*8)), (*Tpcre2_memctl)(unsafe.Pointer(memctl)).Fmemory_data)
				*(*uintptr)(unsafe.Pointer(codes + uintptr(j)*8)) = uintptr(0)
			}
			return -48
		}

		// The new allocator must be preserved.

		libc.Xmemcpy(tls, dst_re+uintptr(uint64(unsafe.Sizeof(Tpcre2_memctl{}))),
			src_bytes+uintptr(uint64(unsafe.Sizeof(Tpcre2_memctl{}))), *(*Tsize_t)(unsafe.Pointer(bp))-Tsize_t(unsafe.Sizeof(Tpcre2_memctl{})))
		if uint64((*Tpcre2_real_code_8)(unsafe.Pointer(dst_re)).Fmagic_number) != DMAGIC_NUMBER || int32((*Tpcre2_real_code_8)(unsafe.Pointer(dst_re)).Fname_entry_size) > DMAX_NAME_SIZE+DIMM2_SIZE+1 || int32((*Tpcre2_real_code_8)(unsafe.Pointer(dst_re)).Fname_count) > DMAX_NAME_COUNT {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_memctl)(unsafe.Pointer(memctl)).Ffree})).f(tls, dst_re, (*Tpcre2_memctl)(unsafe.Pointer(memctl)).Fmemory_data)
			return -62
		}

		// At the moment only one table is supported.

		(*Tpcre2_real_code_8)(unsafe.Pointer(dst_re)).Ftables = tables
		(*Tpcre2_real_code_8)(unsafe.Pointer(dst_re)).Fexecutable_jit = uintptr(0)
		*(*Tuint32_t)(unsafe.Pointer(dst_re + 96)) |= Tuint32_t(DPCRE2_DEREF_TABLES)

		*(*uintptr)(unsafe.Pointer(codes + uintptr(i)*8)) = dst_re
		src_bytes += uintptr(*(*Tsize_t)(unsafe.Pointer(bp /* blocksize */)))
	}

	return number_of_codes
}

// ************************************************
//
//    Get the number of serialized patterns       *
//

func Xpcre2_serialize_get_number_of_codes_8(tls *libc.TLS, bytes uintptr) Tint32_t { /* pcre2_serialize.c:259:1: */
	var data uintptr = bytes

	if data == uintptr(0) {
		return -51
	}
	if (*Tpcre2_serialized_data)(unsafe.Pointer(data)).Fmagic != DSERIALIZED_DATA_MAGIC {
		return -31
	}
	if (*Tpcre2_serialized_data)(unsafe.Pointer(data)).Fversion != Tuint32_t(DPCRE2_MAJOR|int32(DPCRE2_MINOR)<<16) {
		return -32
	}
	if uint64((*Tpcre2_serialized_data)(unsafe.Pointer(data)).Fconfig) != uint64(unsafe.Sizeof(TPCRE2_UCHAR8(0)))|uint64(uint64(unsafe.Sizeof(uintptr(0))))<<8|uint64(uint64(unsafe.Sizeof(Tsize_t(0))))<<16 {
		return -32
	}

	return (*Tpcre2_serialized_data)(unsafe.Pointer(data)).Fnumber_of_codes
}

// ************************************************
//
//            Free the allocated stream           *
//

func Xpcre2_serialize_free_8(tls *libc.TLS, bytes uintptr) { /* pcre2_serialize.c:277:1: */
	if bytes != uintptr(0) {
		var memctl uintptr = bytes - uintptr(uint64(unsafe.Sizeof(Tpcre2_memctl{})))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_memctl)(unsafe.Pointer(memctl)).Ffree})).f(tls, memctl, (*Tpcre2_memctl)(unsafe.Pointer(memctl)).Fmemory_data)
	}
}

// End of pcre2_serialize.c

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// ************************************************
//
//    Emulated memmove() for systems without it   *
//

// This function can make use of bcopy() if it is available. Otherwise do it by
// steam, as there some non-Unix environments that lack both memmove() and
// bcopy().

// ************************************************
//
//    Compare two zero-terminated PCRE2 strings   *
//

//
// Arguments:
//   str1        first string
//   str2        second string
//
// Returns:      0, 1, or -1

func X_pcre2_strcmp_8(tls *libc.TLS, str1 TPCRE2_SPTR8, str2 TPCRE2_SPTR8) int32 { /* pcre2_string_utils.c:102:1: */
	var c1 TPCRE2_UCHAR8
	var c2 TPCRE2_UCHAR8
	for int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(str1))) != 0 || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(str2))) != 0 {
		c1 = *(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&str1, 1)))
		c2 = *(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&str2, 1)))
		if int32(c1) != int32(c2) {
			return libc.Bool32(int32(c1) > int32(c2))<<1 - 1
		}
	}
	return 0
}

// ************************************************
//
//  Compare zero-terminated PCRE2 & 8-bit strings *
//

// As the 8-bit string is almost always a literal, its type is specified as
// const char *.
//
// Arguments:
//   str1        first string
//   str2        second string
//
// Returns:      0, 1, or -1

func X_pcre2_strcmp_c8_8(tls *libc.TLS, str1 TPCRE2_SPTR8, str2 uintptr) int32 { /* pcre2_string_utils.c:130:1: */
	var c1 TPCRE2_UCHAR8
	var c2 TPCRE2_UCHAR8
	for int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(str1))) != 0 || int32(*(*uint8)(unsafe.Pointer(str2))) != 0 {
		c1 = *(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&str1, 1)))
		c2 = TPCRE2_UCHAR8(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&str2, 1))))
		if int32(c1) != int32(c2) {
			return libc.Bool32(int32(c1) > int32(c2))<<1 - 1
		}
	}
	return 0
}

// ************************************************
//
//    Compare two PCRE2 strings, given a length   *
//

//
// Arguments:
//   str1        first string
//   str2        second string
//   len         the length
//
// Returns:      0, 1, or -1

func X_pcre2_strncmp_8(tls *libc.TLS, str1 TPCRE2_SPTR8, str2 TPCRE2_SPTR8, len Tsize_t) int32 { /* pcre2_string_utils.c:157:1: */
	var c1 TPCRE2_UCHAR8
	var c2 TPCRE2_UCHAR8
	for ; len > uint64(0); len-- {
		c1 = *(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&str1, 1)))
		c2 = *(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&str2, 1)))
		if int32(c1) != int32(c2) {
			return libc.Bool32(int32(c1) > int32(c2))<<1 - 1
		}
	}
	return 0
}

// ************************************************
//
// Compare PCRE2 string to 8-bit string by length *
//

// As the 8-bit string is almost always a literal, its type is specified as
// const char *.
//
// Arguments:
//   str1        first string
//   str2        second string
//   len         the length
//
// Returns:      0, 1, or -1

func X_pcre2_strncmp_c8_8(tls *libc.TLS, str1 TPCRE2_SPTR8, str2 uintptr, len Tsize_t) int32 { /* pcre2_string_utils.c:186:1: */
	var c1 TPCRE2_UCHAR8
	var c2 TPCRE2_UCHAR8
	for ; len > uint64(0); len-- {
		c1 = *(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&str1, 1)))
		c2 = TPCRE2_UCHAR8(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&str2, 1))))
		if int32(c1) != int32(c2) {
			return libc.Bool32(int32(c1) > int32(c2))<<1 - 1
		}
	}
	return 0
}

// ************************************************
//
//        Find the length of a PCRE2 string       *
//

//
// Argument:    the string
// Returns:     the length

func X_pcre2_strlen_8(tls *libc.TLS, str TPCRE2_SPTR8) Tsize_t { /* pcre2_string_utils.c:209:1: */
	var c Tsize_t = uint64(0)
	for int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&str, 1)))) != 0 {
		c++
	}
	return c
}

// ************************************************
//
// Copy 8-bit 0-terminated string to PCRE2 string *
//

// Arguments:
//   str1     buffer to receive the string
//   str2     8-bit string to be copied
//
// Returns:   the number of code units used (excluding trailing zero)

func X_pcre2_strcpy_c8_8(tls *libc.TLS, str1 uintptr, str2 uintptr) Tsize_t { /* pcre2_string_utils.c:229:1: */
	var t uintptr = str1
	for int32(*(*uint8)(unsafe.Pointer(str2))) != 0 {
		*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&t, 1))) = TPCRE2_UCHAR8(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&str2, 1))))
	}
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(t)) = TPCRE2_UCHAR8(0)
	return Tsize_t((int64(t) - int64(str1)) / 1)
}

// End of pcre2_string_utils.c

// ************************************************
//
//   Find the minimum subject length for a group  *
//

// Scan a parenthesized group and compute the minimum length of subject that
// is needed to match it. This is a lower bound; it does not mean there is a
// string of that length that matches. In UTF mode, the result is in characters
// rather than code units. The field in a compiled pattern for storing the minimum
// length is 16-bits long (on the grounds that anything longer than that is
// pathological), so we give up when we reach that amount. This also means that
// integer overflow for really crazy patterns cannot happen.
//
// Backreference minimum lengths are cached to speed up multiple references. This
// function is called only when the highest back reference in the pattern is less
// than or equal to MAX_CACHE_BACKREF, which is one less than the size of the
// caching vector. The zeroth element contains the number of the highest set
// value.
//
// Arguments:
//   re              compiled pattern block
//   code            pointer to start of group (the bracket)
//   startcode       pointer to start of the whole pattern's code
//   utf             UTF flag
//   recurses        chain of recurse_check to catch mutual recursion
//   countptr        pointer to call count (to catch over complexity)
//   backref_cache   vector for caching back references.
//
// This function is no longer called when the pattern contains (*ACCEPT); however,
// the old code for returning -1 is retained, just in case.
//
// Returns:   the minimum length
//            -1 \C in UTF-8 mode
//               or (*ACCEPT)
//               or pattern too complicated
//            -2 internal error (missing capturing bracket)
//            -3 internal error (opcode not listed)

func find_minlength(tls *libc.TLS, re uintptr, code TPCRE2_SPTR8, startcode TPCRE2_SPTR8, utf TBOOL, recurses uintptr, countptr uintptr, backref_cache uintptr) int32 { /* pcre2_study.c:103:1: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var length int32
	var branchlength int32
	var prev_cap_recno int32
	var prev_cap_d int32
	var prev_recurse_recno int32
	var prev_recurse_d int32
	var once_fudge Tuint32_t
	var had_recurse TBOOL
	var dupcapused TBOOL
	var nextbranch TPCRE2_SPTR8
	var cc uintptr
	// var this_recurse Trecurse_check at bp, 16

	var r uintptr
	var dd int32
	var i int32
	var count int32
	var slot uintptr
	var r1 uintptr
	var i1 int32
	var r2 uintptr
	var d int32
	var min int32
	var recno int32
	var op TPCRE2_UCHAR8
	var cs uintptr
	var ce uintptr
	length = -1
	branchlength = 0
	prev_cap_recno = -1
	prev_cap_d = 0
	prev_recurse_recno = -1
	prev_recurse_d = 0
	once_fudge = Tuint32_t(0)
	had_recurse = DFALSE
	dupcapused = libc.Bool32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&Tuint32_t(DPCRE2_DUPCAPUSED) != Tuint32_t(0))
	nextbranch = code + uintptr(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2)))))
	cc = code + uintptr(1) + uintptr(DLINK_SIZE)

	// If this is a "could be empty" group, its minimum length is 0.

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code))) >= OP_SBRA && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code))) <= OP_SCOND) {
		goto __1
	}
	return 0
__1:
	;

	// Skip over capturing bracket number

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code))) == OP_CBRA || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code))) == OP_CBRAPOS) {
		goto __2
	}
	cc += uintptr(DIMM2_SIZE)
__2:
	;

	// A large and/or complex regex can take too long to process.

	if !(libc.PostIncInt32(&*(*int32)(unsafe.Pointer(countptr)), 1) > 1000) {
		goto __3
	}
	return -1
__3:
	;

	// Scan along the opcodes for this branch. If we get to the end of the branch,
	// check the length against that of the other branches. If the accumulated length
	// passes 16-bits, reset to that value and skip the rest of the branch.

__4:

	if !(branchlength >= 65535) {
		goto __7
	}

	branchlength = 65535
	cc = nextbranch
__7:
	;

	op = *(*TPCRE2_UCHAR8)(unsafe.Pointer(cc))
	switch int32(op) {
	case OP_COND:
		goto __9
	case OP_SCOND:
		goto __10

	case OP_BRA:
		goto __11
	// Fall through

	case OP_ONCE:
		goto __12
	case OP_SCRIPT_RUN:
		goto __13
	case OP_SBRA:
		goto __14
	case OP_BRAPOS:
		goto __15
	case OP_SBRAPOS:
		goto __16

	// To save time for repeated capturing subpatterns, we remember the
	//     length of the previous one. Unfortunately we can't do the same for
	//     the unnumbered ones above. Nor can we do this if (?| is present in the
	//     pattern because captures with the same number are not then identical.

	case OP_CBRA:
		goto __17
	case OP_SCBRA:
		goto __18
	case OP_CBRAPOS:
		goto __19
	case OP_SCBRAPOS:
		goto __20

	// ACCEPT makes things far too complicated; we have to give up. In fact,
	//     from 10.34 onwards, if a pattern contains (*ACCEPT), this function is not
	//     used. However, leave the code in place, just in case.

	case OP_ACCEPT:
		goto __21
	case OP_ASSERT_ACCEPT:
		goto __22

	// Reached end of a branch; if it's a ket it is the end of a nested
	//     call. If it's ALT it is an alternation in a nested call. If it is END it's
	//     the end of the outer call. All can be handled by the same code. If the
	//     length of any branch is zero, there is no need to scan any subsequent
	//     branches.

	case OP_ALT:
		goto __23
	case OP_KET:
		goto __24
	case OP_KETRMAX:
		goto __25
	case OP_KETRMIN:
		goto __26
	case OP_KETRPOS:
		goto __27
	case OP_END:
		goto __28

	// Skip over assertive subpatterns

	case OP_ASSERT:
		goto __29
	case OP_ASSERT_NOT:
		goto __30
	case OP_ASSERTBACK:
		goto __31
	case OP_ASSERTBACK_NOT:
		goto __32
	case OP_ASSERT_NA:
		goto __33
	case OP_ASSERTBACK_NA:
		goto __34
	// Fall through

	// Skip over things that don't match chars

	case OP_REVERSE:
		goto __35
	case OP_CREF:
		goto __36
	case OP_DNCREF:
		goto __37
	case OP_RREF:
		goto __38
	case OP_DNRREF:
		goto __39
	case OP_FALSE:
		goto __40
	case OP_TRUE:
		goto __41
	case OP_CALLOUT:
		goto __42
	case OP_SOD:
		goto __43
	case OP_SOM:
		goto __44
	case OP_EOD:
		goto __45
	case OP_EODN:
		goto __46
	case OP_CIRC:
		goto __47
	case OP_CIRCM:
		goto __48
	case OP_DOLL:
		goto __49
	case OP_DOLLM:
		goto __50
	case OP_NOT_WORD_BOUNDARY:
		goto __51
	case OP_WORD_BOUNDARY:
		goto __52

	case OP_CALLOUT_STR:
		goto __53

	// Skip over a subpattern that has a {0} or {0,x} quantifier

	case OP_BRAZERO:
		goto __54
	case OP_BRAMINZERO:
		goto __55
	case OP_BRAPOSZERO:
		goto __56
	case OP_SKIPZERO:
		goto __57

	// Handle literal characters and + repetitions

	case OP_CHAR:
		goto __58
	case OP_CHARI:
		goto __59
	case OP_NOT:
		goto __60
	case OP_NOTI:
		goto __61
	case OP_PLUS:
		goto __62
	case OP_PLUSI:
		goto __63
	case OP_MINPLUS:
		goto __64
	case OP_MINPLUSI:
		goto __65
	case OP_POSPLUS:
		goto __66
	case OP_POSPLUSI:
		goto __67
	case OP_NOTPLUS:
		goto __68
	case OP_NOTPLUSI:
		goto __69
	case OP_NOTMINPLUS:
		goto __70
	case OP_NOTMINPLUSI:
		goto __71
	case OP_NOTPOSPLUS:
		goto __72
	case OP_NOTPOSPLUSI:
		goto __73

	case OP_TYPEPLUS:
		goto __74
	case OP_TYPEMINPLUS:
		goto __75
	case OP_TYPEPOSPLUS:
		goto __76

	// Handle exact repetitions. The count is already in characters, but we
	//     may need to skip over a multibyte character in UTF mode.

	case OP_EXACT:
		goto __77
	case OP_EXACTI:
		goto __78
	case OP_NOTEXACT:
		goto __79
	case OP_NOTEXACTI:
		goto __80

	case OP_TYPEEXACT:
		goto __81

	// Handle single-char non-literal matchers

	case OP_PROP:
		goto __82
	case OP_NOTPROP:
		goto __83
	// Fall through

	case OP_NOT_DIGIT:
		goto __84
	case OP_DIGIT:
		goto __85
	case OP_NOT_WHITESPACE:
		goto __86
	case OP_WHITESPACE:
		goto __87
	case OP_NOT_WORDCHAR:
		goto __88
	case OP_WORDCHAR:
		goto __89
	case OP_ANY:
		goto __90
	case OP_ALLANY:
		goto __91
	case OP_EXTUNI:
		goto __92
	case OP_HSPACE:
		goto __93
	case OP_NOT_HSPACE:
		goto __94
	case OP_VSPACE:
		goto __95
	case OP_NOT_VSPACE:
		goto __96

	// "Any newline" might match two characters, but it also might match just
	//     one.

	case OP_ANYNL:
		goto __97

	// The single-byte matcher means we can't proceed in UTF mode. (In
	//     non-UTF mode \C will actually be turned into OP_ALLANY, so won't ever
	//     appear, but leave the code, just in case.)

	case OP_ANYBYTE:
		goto __98

	// For repeated character types, we have to test for \p and \P, which have
	//     an extra two bytes of parameters.

	case OP_TYPESTAR:
		goto __99
	case OP_TYPEMINSTAR:
		goto __100
	case OP_TYPEQUERY:
		goto __101
	case OP_TYPEMINQUERY:
		goto __102
	case OP_TYPEPOSSTAR:
		goto __103
	case OP_TYPEPOSQUERY:
		goto __104

	case OP_TYPEUPTO:
		goto __105
	case OP_TYPEMINUPTO:
		goto __106
	case OP_TYPEPOSUPTO:
		goto __107

	// Check a class for variable quantification

	case OP_CLASS:
		goto __108
	case OP_NCLASS:
		goto __109
	case OP_XCLASS:
		goto __110

	// Backreferences and subroutine calls (OP_RECURSE) are treated in the same
	//     way: we find the minimum length for the subpattern. A recursion
	//     (backreference or subroutine) causes an a flag to be set that causes the
	//     length of this branch to be ignored. The logic is that a recursion can only
	//     make sense if there is another alternative that stops the recursing. That
	//     will provide the minimum length (when no recursion happens).
	//
	//     If PCRE2_MATCH_UNSET_BACKREF is set, a backreference to an unset bracket
	//     matches an empty string (by default it causes a matching failure), so in
	//     that case we must set the minimum length to zero.
	//
	//     For backreferenes, if duplicate numbers are present in the pattern we check
	//     for a reference to a duplicate. If it is, we don't know which version will
	//     be referenced, so we have to set the minimum length to zero.

	// Duplicate named pattern back reference.

	case OP_DNREF:
		goto __111
	case OP_DNREFI:
		goto __112

	// Single back reference by number. References by name are converted to by
	//     number when there is no duplication.

	case OP_REF:
		goto __113
	case OP_REFI:
		goto __114

	// Recursion always refers to the first occurrence of a subpattern with a
	//     given number. Therefore, we can always make use of caching, even when the
	//     pattern contains multiple subpatterns with the same number.

	case OP_RECURSE:
		goto __115

	// Anything else does not or need not match a character. We can get the
	//     item's length from the table, but for those that can match zero occurrences
	//     of a character, we must take special action for UTF-8 characters. As it
	//     happens, the "NOT" versions of these opcodes are used at present only for
	//     ASCII characters, so they could be omitted from this list. However, in
	//     future that may change, so we include them here so as not to leave a
	//     gotcha for a future maintainer.

	case OP_UPTO:
		goto __116
	case OP_UPTOI:
		goto __117
	case OP_NOTUPTO:
		goto __118
	case OP_NOTUPTOI:
		goto __119
	case OP_MINUPTO:
		goto __120
	case OP_MINUPTOI:
		goto __121
	case OP_NOTMINUPTO:
		goto __122
	case OP_NOTMINUPTOI:
		goto __123
	case OP_POSUPTO:
		goto __124
	case OP_POSUPTOI:
		goto __125
	case OP_NOTPOSUPTO:
		goto __126
	case OP_NOTPOSUPTOI:
		goto __127

	case OP_STAR:
		goto __128
	case OP_STARI:
		goto __129
	case OP_NOTSTAR:
		goto __130
	case OP_NOTSTARI:
		goto __131
	case OP_MINSTAR:
		goto __132
	case OP_MINSTARI:
		goto __133
	case OP_NOTMINSTAR:
		goto __134
	case OP_NOTMINSTARI:
		goto __135
	case OP_POSSTAR:
		goto __136
	case OP_POSSTARI:
		goto __137
	case OP_NOTPOSSTAR:
		goto __138
	case OP_NOTPOSSTARI:
		goto __139

	case OP_QUERY:
		goto __140
	case OP_QUERYI:
		goto __141
	case OP_NOTQUERY:
		goto __142
	case OP_NOTQUERYI:
		goto __143
	case OP_MINQUERY:
		goto __144
	case OP_MINQUERYI:
		goto __145
	case OP_NOTMINQUERY:
		goto __146
	case OP_NOTMINQUERYI:
		goto __147
	case OP_POSQUERY:
		goto __148
	case OP_POSQUERYI:
		goto __149
	case OP_NOTPOSQUERY:
		goto __150
	case OP_NOTPOSQUERYI:
		goto __151

	// Skip these, but we need to add in the name length.

	case OP_MARK:
		goto __152
	case OP_COMMIT_ARG:
		goto __153
	case OP_PRUNE_ARG:
		goto __154
	case OP_SKIP_ARG:
		goto __155
	case OP_THEN_ARG:
		goto __156

	// The remaining opcodes are just skipped over.

	case OP_CLOSE:
		goto __157
	case OP_COMMIT:
		goto __158
	case OP_FAIL:
		goto __159
	case OP_PRUNE:
		goto __160
	case OP_SET_SOM:
		goto __161
	case OP_SKIP:
		goto __162
	case OP_THEN:
		goto __163

	// This should not occur: we list all opcodes explicitly so that when
	//     new ones get added they are properly considered.

	default:
		goto __164
	}
	goto __8

__9:
__10:

	// If there is only one branch in a condition, the implied branch has zero
	//     length, so we don't add anything. This covers the DEFINE "condition"
	//     automatically. If there are two branches we can treat it the same as any
	//     other non-capturing subpattern.

	cs = cc + uintptr(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 2)))))
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cs))) != OP_ALT) {
		goto __165
	}

	cc = cs + uintptr(1) + uintptr(DLINK_SIZE)
	goto __8
__165:
	;
	goto PROCESS_NON_CAPTURE

__11:
	// There's a special case of OP_BRA, when it is wrapped round a repeated
	//     OP_RECURSE. We'd like to process the latter at this level so that
	//     remembering the value works for repeated cases. So we do nothing, but
	//     set a fudge value to skip over the OP_KET after the recurse.

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 3))) == OP_RECURSE && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 6))) == OP_KET) {
		goto __166
	}

	once_fudge = Tuint32_t(1 + DLINK_SIZE)
	cc += uintptr(1 + DLINK_SIZE)
	goto __8
__166:
	;
	// Fall through

__12:
__13:
__14:
__15:
__16:
PROCESS_NON_CAPTURE:
	d = find_minlength(tls, re, cc, startcode, utf, recurses, countptr,
		backref_cache)
	if !(d < 0) {
		goto __167
	}
	return d
__167:
	;
	branchlength = branchlength + d
__168:
	cc += uintptr(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 2)))))
	goto __169
__169:
	if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc))) == OP_ALT {
		goto __168
	}
	goto __170
__170:
	;
	cc += uintptr(1 + DLINK_SIZE)
	goto __8

	// To save time for repeated capturing subpatterns, we remember the
	//     length of the previous one. Unfortunately we can't do the same for
	//     the unnumbered ones above. Nor can we do this if (?| is present in the
	//     pattern because captures with the same number are not then identical.

__17:
__18:
__19:
__20:
	recno = int32(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 3)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 4)))))
	if !(dupcapused != 0 || recno != prev_cap_recno) {
		goto __171
	}

	prev_cap_recno = recno
	prev_cap_d = find_minlength(tls, re, cc, startcode, utf, recurses, countptr,
		backref_cache)
	if !(prev_cap_d < 0) {
		goto __172
	}
	return prev_cap_d
__172:
	;
__171:
	;
	branchlength = branchlength + prev_cap_d
__173:
	cc += uintptr(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 2)))))
	goto __174
__174:
	if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc))) == OP_ALT {
		goto __173
	}
	goto __175
__175:
	;
	cc += uintptr(1 + DLINK_SIZE)
	goto __8

	// ACCEPT makes things far too complicated; we have to give up. In fact,
	//     from 10.34 onwards, if a pattern contains (*ACCEPT), this function is not
	//     used. However, leave the code in place, just in case.

__21:
__22:
	return -1

	// Reached end of a branch; if it's a ket it is the end of a nested
	//     call. If it's ALT it is an alternation in a nested call. If it is END it's
	//     the end of the outer call. All can be handled by the same code. If the
	//     length of any branch is zero, there is no need to scan any subsequent
	//     branches.

__23:
__24:
__25:
__26:
__27:
__28:
	if !(length < 0 || !(had_recurse != 0) && branchlength < length) {
		goto __176
	}
	length = branchlength
__176:
	;
	if !(int32(op) != OP_ALT || length == 0) {
		goto __177
	}
	return length
__177:
	;
	nextbranch = cc + uintptr(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 2)))))
	cc += uintptr(1 + DLINK_SIZE)
	branchlength = 0
	had_recurse = DFALSE
	goto __8

	// Skip over assertive subpatterns

__29:
__30:
__31:
__32:
__33:
__34:
__178:
	cc += uintptr(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 2)))))
	goto __179
__179:
	if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc))) == OP_ALT {
		goto __178
	}
	goto __180
__180:
	;
	// Fall through

	// Skip over things that don't match chars

__35:
__36:
__37:
__38:
__39:
__40:
__41:
__42:
__43:
__44:
__45:
__46:
__47:
__48:
__49:
__50:
__51:
__52:
	cc += uintptr(X_pcre2_OP_lengths_8[*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc))])
	goto __8

__53:
	cc += uintptr(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 5)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 6)))))
	goto __8

	// Skip over a subpattern that has a {0} or {0,x} quantifier

__54:
__55:
__56:
__57:
	cc += uintptr(X_pcre2_OP_lengths_8[*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc))])
__181:
	cc += uintptr(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 2)))))
	goto __182
__182:
	if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc))) == OP_ALT {
		goto __181
	}
	goto __183
__183:
	;
	cc += uintptr(1 + DLINK_SIZE)
	goto __8

	// Handle literal characters and + repetitions

__58:
__59:
__60:
__61:
__62:
__63:
__64:
__65:
__66:
__67:
__68:
__69:
__70:
__71:
__72:
__73:
	branchlength++
	cc += uintptr(2)
	if !(utf != 0 && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + libc.UintptrFromInt32(-1)))) >= 0xc0) {
		goto __184
	}
	cc += uintptr(X_pcre2_utf8_table4[uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + libc.UintptrFromInt32(-1))))&0x3f])
__184:
	;
	goto __8

__74:
__75:
__76:
	branchlength++
	cc += func() uintptr {
		if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 1))) == OP_PROP || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 1))) == OP_NOTPROP {
			return uintptr(4)
		}
		return uintptr(2)
	}()
	goto __8

	// Handle exact repetitions. The count is already in characters, but we
	//     may need to skip over a multibyte character in UTF mode.

__77:
__78:
__79:
__80:
	branchlength = int32(uint32(branchlength) + uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 2)))))
	cc += uintptr(2 + DIMM2_SIZE)
	if !(utf != 0 && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + libc.UintptrFromInt32(-1)))) >= 0xc0) {
		goto __185
	}
	cc += uintptr(X_pcre2_utf8_table4[uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + libc.UintptrFromInt32(-1))))&0x3f])
__185:
	;
	goto __8

__81:
	branchlength = int32(uint32(branchlength) + uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 2)))))
	cc += uintptr(2 + DIMM2_SIZE + func() int32 {
		if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 3))) == OP_PROP ||
			int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 3))) == OP_NOTPROP {
			return 2
		}
		return 0
	}())
	goto __8

	// Handle single-char non-literal matchers

__82:
__83:
	cc += uintptr(2)
	// Fall through

__84:
__85:
__86:
__87:
__88:
__89:
__90:
__91:
__92:
__93:
__94:
__95:
__96:
	branchlength++
	cc++
	goto __8

	// "Any newline" might match two characters, but it also might match just
	//     one.

__97:
	branchlength = branchlength + 1
	cc++
	goto __8

	// The single-byte matcher means we can't proceed in UTF mode. (In
	//     non-UTF mode \C will actually be turned into OP_ALLANY, so won't ever
	//     appear, but leave the code, just in case.)

__98:
	if !(utf != 0) {
		goto __186
	}
	return -1
__186:
	;
	branchlength++
	cc++
	goto __8

	// For repeated character types, we have to test for \p and \P, which have
	//     an extra two bytes of parameters.

__99:
__100:
__101:
__102:
__103:
__104:
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 1))) == OP_PROP || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 1))) == OP_NOTPROP) {
		goto __187
	}
	cc += uintptr(2)
__187:
	;
	cc += uintptr(X_pcre2_OP_lengths_8[op])
	goto __8

__105:
__106:
__107:
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 3))) == OP_PROP ||
		int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 3))) == OP_NOTPROP) {
		goto __188
	}
	cc += uintptr(2)
__188:
	;
	cc += uintptr(X_pcre2_OP_lengths_8[op])
	goto __8

	// Check a class for variable quantification

__108:
__109:
__110:
	// The original code caused an unsigned overflow in 64 bit systems,
	//     so now we use a conditional statement.
	if !(int32(op) == OP_XCLASS) {
		goto __189
	}
	cc += uintptr(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 2)))))
	goto __190
__189:
	cc += uintptr(X_pcre2_OP_lengths_8[OP_CLASS])
__190:
	;

	switch int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc))) {
	case OP_CRPLUS:
		goto __192
	case OP_CRMINPLUS:
		goto __193
	case OP_CRPOSPLUS:
		goto __194
	// Fall through

	case OP_CRSTAR:
		goto __195
	case OP_CRMINSTAR:
		goto __196
	case OP_CRQUERY:
		goto __197
	case OP_CRMINQUERY:
		goto __198
	case OP_CRPOSSTAR:
		goto __199
	case OP_CRPOSQUERY:
		goto __200

	case OP_CRRANGE:
		goto __201
	case OP_CRMINRANGE:
		goto __202
	case OP_CRPOSRANGE:
		goto __203

	default:
		goto __204
	}
	goto __191

__192:
__193:
__194:
	branchlength++
	// Fall through

__195:
__196:
__197:
__198:
__199:
__200:
	cc++
	goto __191

__201:
__202:
__203:
	branchlength = int32(uint32(branchlength) + uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 2)))))
	cc += uintptr(1 + 2*DIMM2_SIZE)
	goto __191

__204:
	branchlength++
	goto __191
__191:
	;
	goto __8

	// Backreferences and subroutine calls (OP_RECURSE) are treated in the same
	//     way: we find the minimum length for the subpattern. A recursion
	//     (backreference or subroutine) causes an a flag to be set that causes the
	//     length of this branch to be ignored. The logic is that a recursion can only
	//     make sense if there is another alternative that stops the recursing. That
	//     will provide the minimum length (when no recursion happens).
	//
	//     If PCRE2_MATCH_UNSET_BACKREF is set, a backreference to an unset bracket
	//     matches an empty string (by default it causes a matching failure), so in
	//     that case we must set the minimum length to zero.
	//
	//     For backreferenes, if duplicate numbers are present in the pattern we check
	//     for a reference to a duplicate. If it is, we don't know which version will
	//     be referenced, so we have to set the minimum length to zero.

	// Duplicate named pattern back reference.

__111:
__112:
	if !(!(dupcapused != 0) && (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_MATCH_UNSET_BACKREF == Tuint32_t(0)) {
		goto __205
	}

	count = int32(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 3)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 4)))))
	slot =
		re + uintptr(uint64(unsafe.Sizeof(Tpcre2_real_code_8{}))) + uintptr(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 2))))*uint32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fname_entry_size))

	d = 0x7fffffff

	// Scan all groups with the same name; find the shortest.

__207:
	if !(libc.PostDecInt32(&count, 1) > 0) {
		goto __208
	}

	recno = int32(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(slot)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(slot + 1)))))

	if !(recno <= *(*int32)(unsafe.Pointer(backref_cache)) && *(*int32)(unsafe.Pointer(backref_cache + uintptr(recno)*4)) >= 0) {
		goto __209
	}
	dd = *(*int32)(unsafe.Pointer(backref_cache + uintptr(recno)*4))
	goto __210
__209:

	ce = libc.AssignUintptr(&cs, X_pcre2_find_bracket_8(tls, startcode, utf, recno))
	if !(cs == uintptr(0)) {
		goto __211
	}
	return -2
__211:
	;
__212:
	ce += uintptr(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ce + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ce + 2)))))
	goto __213
__213:
	if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ce))) == OP_ALT {
		goto __212
	}
	goto __214
__214:
	;

	dd = 0
	if !(!(dupcapused != 0) || X_pcre2_find_bracket_8(tls, ce, utf, recno) == uintptr(0)) {
		goto __215
	}

	if !(cc > cs && cc < ce) {
		goto __216
	} /* Simple recursion */

	had_recurse = DTRUE
	goto __217
__216:

	r = recurses
	r = recurses
__218:
	if !(r != uintptr(0)) {
		goto __220
	}
	if !((*Trecurse_check)(unsafe.Pointer(r)).Fgroup == cs) {
		goto __221
	}
	goto __220
__221:
	;
	goto __219
__219:
	r = (*Trecurse_check)(unsafe.Pointer(r)).Fprev
	goto __218
	goto __220
__220:
	;
	if !(r != uintptr(0)) {
		goto __222
	} /* Mutual recursion */

	had_recurse = DTRUE
	goto __223
__222:

	(*Trecurse_check)(unsafe.Pointer(bp /* &this_recurse */)).Fprev = recurses // No recursion
	(*Trecurse_check)(unsafe.Pointer(bp /* &this_recurse */)).Fgroup = cs
	dd = find_minlength(tls, re, cs, startcode, utf, bp,
		countptr, backref_cache)
	if !(dd < 0) {
		goto __224
	}
	return dd
__224:
	;
__223:
	;
__217:
	;
__215:
	;

	*(*int32)(unsafe.Pointer(backref_cache + uintptr(recno)*4)) = dd
	i = *(*int32)(unsafe.Pointer(backref_cache)) + 1
__225:
	if !(i < recno) {
		goto __227
	}
	*(*int32)(unsafe.Pointer(backref_cache + uintptr(i)*4)) = -1
	goto __226
__226:
	i++
	goto __225
	goto __227
__227:
	;
	*(*int32)(unsafe.Pointer(backref_cache)) = recno
__210:
	;

	if !(dd < d) {
		goto __228
	}
	d = dd
__228:
	;
	if !(d <= 0) {
		goto __229
	}
	goto __208
__229:
	; // No point looking at any more
	slot += uintptr((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fname_entry_size)
	goto __207
__208:
	;
	goto __206
__205:
	d = 0
__206:
	;
	cc += uintptr(1 + 2*DIMM2_SIZE)
	goto REPEAT_BACK_REFERENCE

	// Single back reference by number. References by name are converted to by
	//     number when there is no duplication.

__113:
__114:
	recno = int32(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 2)))))
	if !(recno <= *(*int32)(unsafe.Pointer(backref_cache)) && *(*int32)(unsafe.Pointer(backref_cache + uintptr(recno)*4)) >= 0) {
		goto __230
	}
	d = *(*int32)(unsafe.Pointer(backref_cache + uintptr(recno)*4))
	goto __231
__230:

	d = 0

	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_MATCH_UNSET_BACKREF == Tuint32_t(0)) {
		goto __232
	}

	ce = libc.AssignUintptr(&cs, X_pcre2_find_bracket_8(tls, startcode, utf, recno))
	if !(cs == uintptr(0)) {
		goto __233
	}
	return -2
__233:
	;
__234:
	ce += uintptr(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ce + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ce + 2)))))
	goto __235
__235:
	if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ce))) == OP_ALT {
		goto __234
	}
	goto __236
__236:
	;

	if !(!(dupcapused != 0) || X_pcre2_find_bracket_8(tls, ce, utf, recno) == uintptr(0)) {
		goto __237
	}

	if !(cc > cs && cc < ce) {
		goto __238
	} /* Simple recursion */

	had_recurse = DTRUE
	goto __239
__238:

	r1 = recurses
	r1 = recurses
__240:
	if !(r1 != uintptr(0)) {
		goto __242
	}
	if !((*Trecurse_check)(unsafe.Pointer(r1)).Fgroup == cs) {
		goto __243
	}
	goto __242
__243:
	;
	goto __241
__241:
	r1 = (*Trecurse_check)(unsafe.Pointer(r1)).Fprev
	goto __240
	goto __242
__242:
	;
	if !(r1 != uintptr(0)) {
		goto __244
	} /* Mutual recursion */

	had_recurse = DTRUE
	goto __245
__244: /* No recursion */

	(*Trecurse_check)(unsafe.Pointer(bp /* &this_recurse */)).Fprev = recurses
	(*Trecurse_check)(unsafe.Pointer(bp /* &this_recurse */)).Fgroup = cs
	d = find_minlength(tls, re, cs, startcode, utf, bp, countptr,
		backref_cache)
	if !(d < 0) {
		goto __246
	}
	return d
__246:
	;
__245:
	;
__239:
	;
__237:
	;
__232:
	;

	*(*int32)(unsafe.Pointer(backref_cache + uintptr(recno)*4)) = d
	i1 = *(*int32)(unsafe.Pointer(backref_cache)) + 1
__247:
	if !(i1 < recno) {
		goto __249
	}
	*(*int32)(unsafe.Pointer(backref_cache + uintptr(i1)*4)) = -1
	goto __248
__248:
	i1++
	goto __247
	goto __249
__249:
	;
	*(*int32)(unsafe.Pointer(backref_cache)) = recno
__231:
	;

	cc += uintptr(1 + DIMM2_SIZE)

	// Handle repeated back references

REPEAT_BACK_REFERENCE:
	switch int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc))) {
	case OP_CRSTAR:
		goto __251
	case OP_CRMINSTAR:
		goto __252
	case OP_CRQUERY:
		goto __253
	case OP_CRMINQUERY:
		goto __254
	case OP_CRPOSSTAR:
		goto __255
	case OP_CRPOSQUERY:
		goto __256

	case OP_CRPLUS:
		goto __257
	case OP_CRMINPLUS:
		goto __258
	case OP_CRPOSPLUS:
		goto __259

	case OP_CRRANGE:
		goto __260
	case OP_CRMINRANGE:
		goto __261
	case OP_CRPOSRANGE:
		goto __262

	default:
		goto __263
	}
	goto __250

__251:
__252:
__253:
__254:
__255:
__256:
	min = 0
	cc++
	goto __250

__257:
__258:
__259:
	min = 1
	cc++
	goto __250

__260:
__261:
__262:
	min = int32(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 2)))))
	cc += uintptr(1 + 2*DIMM2_SIZE)
	goto __250

__263:
	min = 1
	goto __250
__250:
	;

	// Take care not to overflow: (1) min and d are ints, so check that their
	//      product is not greater than INT_MAX. (2) branchlength is limited to
	//      UINT16_MAX (checked at the top of the loop).

	if !(d > 0 && 0x7fffffff/d < min || 65535-branchlength < min*d) {
		goto __264
	}
	branchlength = 65535
	goto __265
__264:
	branchlength = branchlength + min*d
__265:
	;
	goto __8

	// Recursion always refers to the first occurrence of a subpattern with a
	//     given number. Therefore, we can always make use of caching, even when the
	//     pattern contains multiple subpatterns with the same number.

__115:
	cs = libc.AssignUintptr(&ce, startcode+uintptr(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 2))))))
	recno = int32(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cs + 3)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cs + 4)))))
	if !(recno == prev_recurse_recno) {
		goto __266
	}

	branchlength = branchlength + prev_recurse_d
	goto __267
__266:

__268:
	ce += uintptr(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ce + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ce + 2)))))
	goto __269
__269:
	if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(ce))) == OP_ALT {
		goto __268
	}
	goto __270
__270:
	;
	if !(cc > cs && cc < ce) {
		goto __271
	} // Simple recursion
	had_recurse = DTRUE
	goto __272
__271:

	r2 = recurses
	r2 = recurses
__273:
	if !(r2 != uintptr(0)) {
		goto __275
	}
	if !((*Trecurse_check)(unsafe.Pointer(r2)).Fgroup == cs) {
		goto __276
	}
	goto __275
__276:
	;
	goto __274
__274:
	r2 = (*Trecurse_check)(unsafe.Pointer(r2)).Fprev
	goto __273
	goto __275
__275:
	;
	if !(r2 != uintptr(0)) {
		goto __277
	} // Mutual recursion
	had_recurse = DTRUE
	goto __278
__277:

	(*Trecurse_check)(unsafe.Pointer(bp /* &this_recurse */)).Fprev = recurses
	(*Trecurse_check)(unsafe.Pointer(bp /* &this_recurse */)).Fgroup = cs
	prev_recurse_d = find_minlength(tls, re, cs, startcode, utf, bp,
		countptr, backref_cache)
	if !(prev_recurse_d < 0) {
		goto __279
	}
	return prev_recurse_d
__279:
	;
	prev_recurse_recno = recno
	branchlength = branchlength + prev_recurse_d
__278:
	;
__272:
	;
__267:
	;
	cc += uintptr(Tuint32_t(1+DLINK_SIZE) + once_fudge)
	once_fudge = Tuint32_t(0)
	goto __8

	// Anything else does not or need not match a character. We can get the
	//     item's length from the table, but for those that can match zero occurrences
	//     of a character, we must take special action for UTF-8 characters. As it
	//     happens, the "NOT" versions of these opcodes are used at present only for
	//     ASCII characters, so they could be omitted from this list. However, in
	//     future that may change, so we include them here so as not to leave a
	//     gotcha for a future maintainer.

__116:
__117:
__118:
__119:
__120:
__121:
__122:
__123:
__124:
__125:
__126:
__127:

__128:
__129:
__130:
__131:
__132:
__133:
__134:
__135:
__136:
__137:
__138:
__139:

__140:
__141:
__142:
__143:
__144:
__145:
__146:
__147:
__148:
__149:
__150:
__151:

	cc += uintptr(X_pcre2_OP_lengths_8[op])
	if !(utf != 0 && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + libc.UintptrFromInt32(-1)))) >= 0xc0) {
		goto __280
	}
	cc += uintptr(X_pcre2_utf8_table4[uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + libc.UintptrFromInt32(-1))))&0x3f])
__280:
	;
	goto __8

	// Skip these, but we need to add in the name length.

__152:
__153:
__154:
__155:
__156:
	cc += uintptr(int32(X_pcre2_OP_lengths_8[op]) + int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(cc + 1))))
	goto __8

	// The remaining opcodes are just skipped over.

__157:
__158:
__159:
__160:
__161:
__162:
__163:
	cc += uintptr(X_pcre2_OP_lengths_8[op])
	goto __8

	// This should not occur: we list all opcodes explicitly so that when
	//     new ones get added they are properly considered.

__164:
	return -3
__8:
	;
	goto __5
__5:
	goto __4
	goto __6
__6:
	;
	return int32(0)
	// Control never gets here
}

// ************************************************
//
//      Set a bit and maybe its alternate case    *
//

// Given a character, set its first code unit's bit in the table, and also the
// corresponding bit for the other version of a letter if we are caseless.
//
// Arguments:
//   re            points to the regex block
//   p             points to the first code unit of the character
//   caseless      TRUE if caseless
//   utf           TRUE for UTF mode
//   ucp           TRUE for UCP mode
//
// Returns:        pointer after the character

func set_table_bit(tls *libc.TLS, re uintptr, p TPCRE2_SPTR8, caseless TBOOL, utf TBOOL, ucp TBOOL) TPCRE2_SPTR8 { /* pcre2_study.c:781:1: */
	bp := tls.Alloc(6)
	defer tls.Free(6)

	var c Tuint32_t = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1)))) // First code unit

	_ = utf // Stop compiler warnings when UTF not supported
	_ = ucp

	// In 16-bit and 32-bit modes, code units greater than 0xff set the bit for
	// 0xff.

	*(*Tuint8_t)(unsafe.Pointer(re + 40 + uintptr(c/Tuint32_t(8)))) |= Tuint8_t(uint32(1) << (c & Tuint32_t(7)))

	// In UTF-8 or UTF-16 mode, pick up the remaining code units in order to find
	// the end of the character, even when caseless.

	if utf != 0 {
		if c >= Tuint32_t(0xc0) {
			if c&0x20 == Tuint32_t(0) {
				c = c&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))))&0x3f
			} else if c&0x10 == Tuint32_t(0) {
				c = c&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(p)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(p + 1)))&0x3f
				p += uintptr(2)
			} else if c&0x08 == Tuint32_t(0) {
				c = c&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(p)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(p + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(p + 2)))&0x3f
				p += uintptr(3)
			} else if c&0x04 == Tuint32_t(0) {
				c = c&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(p)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(p + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(p + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(p + 3)))&0x3f
				p += uintptr(4)
			} else {
				c = c&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(p)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(p + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(p + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(p + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(p + 4)))&0x3f
				p += uintptr(5)
			}
		}

	}

	// If caseless, handle the other case of the character.

	if caseless != 0 {
		if utf != 0 || ucp != 0 {
			c = Tuint32_t(int32(c) + (*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12)).Fother_case)
			if utf != 0 {
				// var buff [6]TPCRE2_UCHAR8 at bp, 6

				X_pcre2_ord2utf_8(tls, c, bp)
				*(*Tuint8_t)(unsafe.Pointer(re + 40 + uintptr(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bp)))/8))) |= Tuint8_t(uint32(1) << (int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bp))) & 7))
			} else if c < Tuint32_t(256) {
				*(*Tuint8_t)(unsafe.Pointer(re + 40 + uintptr(c/Tuint32_t(8)))) |= Tuint8_t(uint32(1) << (c & Tuint32_t(7)))
			}
		} else

		// Not UTF or UCP

		if 1 != 0 {
			*(*Tuint8_t)(unsafe.Pointer(re + 40 + uintptr(int32(*(*Tuint8_t)(unsafe.Pointer((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftables + uintptr(Tuint32_t(Dfcc_offset)+c))))/8))) |= Tuint8_t(uint32(1) << (int32(*(*Tuint8_t)(unsafe.Pointer((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftables + uintptr(Tuint32_t(Dfcc_offset)+c)))) & 7))
		}
	}

	return p
}

// ************************************************
//
//     Set bits for a positive character type     *
//

// This function sets starting bits for a character type. In UTF-8 mode, we can
// only do a direct setting for bytes less than 128, as otherwise there can be
// confusion with bytes in the middle of UTF-8 characters. In a "traditional"
// environment, the tables will only recognize ASCII characters anyway, but in at
// least one Windows environment, some higher bytes bits were set in the tables.
// So we deal with that case by considering the UTF-8 encoding.
//
// Arguments:
//   re             the regex block
//   cbit type      the type of character wanted
//   table_limit    32 for non-UTF-8; 16 for UTF-8
//
// Returns:         nothing

func set_type_bits(tls *libc.TLS, re uintptr, cbit_type int32, table_limit uint32) { /* pcre2_study.c:866:1: */
	bp := tls.Alloc(6)
	defer tls.Free(6)

	var c Tuint32_t
	for c = Tuint32_t(0); c < table_limit; c++ {
		*(*Tuint8_t)(unsafe.Pointer(re + 40 + uintptr(c))) |= Tuint8_t(int32(*(*Tuint8_t)(unsafe.Pointer((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftables + uintptr(c+Tuint32_t(Dcbits_offset)+Tuint32_t(cbit_type))))))
	}
	if table_limit == uint32(32) {
		return
	}
	for c = Tuint32_t(128); c < Tuint32_t(256); c++ {
		if uint32(*(*Tuint8_t)(unsafe.Pointer((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftables + uintptr(Tuint32_t(Dcbits_offset)+c/Tuint32_t(8)))))&(uint32(1)<<(c&Tuint32_t(7))) != uint32(0) {
			// var buff [6]TPCRE2_UCHAR8 at bp, 6

			X_pcre2_ord2utf_8(tls, c, bp)
			*(*Tuint8_t)(unsafe.Pointer(re + 40 + uintptr(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bp)))/8))) |= Tuint8_t(uint32(1) << (int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bp))) & 7))
		}
	}
}

// ************************************************
//
//     Set bits for a negative character type     *
//

// This function sets starting bits for a negative character type such as \D.
// In UTF-8 mode, we can only do a direct setting for bytes less than 128, as
// otherwise there can be confusion with bytes in the middle of UTF-8 characters.
// Unlike in the positive case, where we can set appropriate starting bits for
// specific high-valued UTF-8 characters, in this case we have to set the bits for
// all high-valued characters. The lowest is 0xc2, but we overkill by starting at
// 0xc0 (192) for simplicity.
//
// Arguments:
//   re             the regex block
//   cbit type      the type of character wanted
//   table_limit    32 for non-UTF-8; 16 for UTF-8
//
// Returns:         nothing

func set_nottype_bits(tls *libc.TLS, re uintptr, cbit_type int32, table_limit uint32) { /* pcre2_study.c:907:1: */
	var c Tuint32_t
	for c = Tuint32_t(0); c < table_limit; c++ {
		*(*Tuint8_t)(unsafe.Pointer(re + 40 + uintptr(c))) |= Tuint8_t(int32(Tuint8_t(^int32(*(*Tuint8_t)(unsafe.Pointer((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftables + uintptr(c+Tuint32_t(Dcbits_offset)+Tuint32_t(cbit_type))))))))
	}
	if table_limit != uint32(32) {
		for c = Tuint32_t(24); c < Tuint32_t(32); c++ {
			*(*Tuint8_t)(unsafe.Pointer(re + 40 + uintptr(c))) = Tuint8_t(0xff)
		}
	}
}

// ************************************************
//
//      Create bitmap of starting code units      *
//

// This function scans a compiled unanchored expression recursively and
// attempts to build a bitmap of the set of possible starting code units whose
// values are less than 256. In 16-bit and 32-bit mode, values above 255 all cause
// the 255 bit to be set. When calling set[_not]_type_bits() in UTF-8 (sic) mode
// we pass a value of 16 rather than 32 as the final argument. (See comments in
// those functions for the reason.)
//
// The SSB_CONTINUE return is useful for parenthesized groups in patterns such as
// (a*)b where the group provides some optional starting code units but scanning
// must continue at the outer level to find at least one mandatory code unit. At
// the outermost level, this function fails unless the result is SSB_DONE.
//
// We restrict recursion (for nested groups) to 1000 to avoid stack overflow
// issues.
//
// Arguments:
//   re           points to the compiled regex block
//   code         points to an expression
//   utf          TRUE if in UTF mode
//   ucp          TRUE if in UCP mode
//   depthptr     pointer to recurse depth
//
// Returns:       SSB_FAIL     => Failed to find any starting code units
//                SSB_DONE     => Found mandatory starting code units
//                SSB_CONTINUE => Found optional starting code units
//                SSB_UNKNOWN  => Hit an unrecognized opcode
//                SSB_TOODEEP  => Recursion is too deep

func set_start_bits(tls *libc.TLS, re uintptr, code TPCRE2_SPTR8, utf TBOOL, ucp TBOOL, depthptr uintptr) int32 { /* pcre2_study.c:953:1: */
	bp := tls.Alloc(6)
	defer tls.Free(6)

	var c Tuint32_t
	var yield int32
	var table_limit int32
	// var buff [6]TPCRE2_UCHAR8 at bp, 6

	var p uintptr
	var b TPCRE2_UCHAR8
	var e TPCRE2_UCHAR8
	var p1 TPCRE2_SPTR8
	var d int32
	var rc int32
	var classmap uintptr
	var xclassflags TPCRE2_UCHAR8
	var try_next TBOOL
	var tcode TPCRE2_SPTR8
	yield = SSB_DONE
	if utf != 0 {
		table_limit = 16
	} else {
		table_limit = 32
	}

	*(*int32)(unsafe.Pointer(depthptr)) += 1
	if !(*(*int32)(unsafe.Pointer(depthptr)) > 1000) {
		goto __1
	}
	return SSB_TOODEEP
__1:
	;

__2:
	try_next = DTRUE
	tcode = code + uintptr(1) + uintptr(DLINK_SIZE)

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code))) == OP_CBRA || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code))) == OP_SCBRA || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code))) == OP_CBRAPOS || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code))) == OP_SCBRAPOS) {
		goto __5
	}
	tcode += TPCRE2_SPTR8(DIMM2_SIZE)
__5:
	;

__6:
	if !(try_next != 0) {
		goto __7
	} /* Loop for items in this branch */
	classmap = uintptr(0)

	switch int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(tcode))) {
	// If we reach something we don't understand, it means a new opcode has
	//       been created that hasn't been added to this function. Hopefully this
	//       problem will be discovered during testing.

	default:
		goto __9

	// Fail for a valid opcode that implies no starting bits.

	case OP_ACCEPT:
		goto __10
	case OP_ASSERT_ACCEPT:
		goto __11
	case OP_ALLANY:
		goto __12
	case OP_ANY:
		goto __13
	case OP_ANYBYTE:
		goto __14
	case OP_CIRCM:
		goto __15
	case OP_CLOSE:
		goto __16
	case OP_COMMIT:
		goto __17
	case OP_COMMIT_ARG:
		goto __18
	case OP_COND:
		goto __19
	case OP_CREF:
		goto __20
	case OP_FALSE:
		goto __21
	case OP_TRUE:
		goto __22
	case OP_DNCREF:
		goto __23
	case OP_DNREF:
		goto __24
	case OP_DNREFI:
		goto __25
	case OP_DNRREF:
		goto __26
	case OP_DOLL:
		goto __27
	case OP_DOLLM:
		goto __28
	case OP_END:
		goto __29
	case OP_EOD:
		goto __30
	case OP_EODN:
		goto __31
	case OP_EXTUNI:
		goto __32
	case OP_FAIL:
		goto __33
	case OP_MARK:
		goto __34
	case OP_NOT:
		goto __35
	case OP_NOTEXACT:
		goto __36
	case OP_NOTEXACTI:
		goto __37
	case OP_NOTI:
		goto __38
	case OP_NOTMINPLUS:
		goto __39
	case OP_NOTMINPLUSI:
		goto __40
	case OP_NOTMINQUERY:
		goto __41
	case OP_NOTMINQUERYI:
		goto __42
	case OP_NOTMINSTAR:
		goto __43
	case OP_NOTMINSTARI:
		goto __44
	case OP_NOTMINUPTO:
		goto __45
	case OP_NOTMINUPTOI:
		goto __46
	case OP_NOTPLUS:
		goto __47
	case OP_NOTPLUSI:
		goto __48
	case OP_NOTPOSPLUS:
		goto __49
	case OP_NOTPOSPLUSI:
		goto __50
	case OP_NOTPOSQUERY:
		goto __51
	case OP_NOTPOSQUERYI:
		goto __52
	case OP_NOTPOSSTAR:
		goto __53
	case OP_NOTPOSSTARI:
		goto __54
	case OP_NOTPOSUPTO:
		goto __55
	case OP_NOTPOSUPTOI:
		goto __56
	case OP_NOTPROP:
		goto __57
	case OP_NOTQUERY:
		goto __58
	case OP_NOTQUERYI:
		goto __59
	case OP_NOTSTAR:
		goto __60
	case OP_NOTSTARI:
		goto __61
	case OP_NOTUPTO:
		goto __62
	case OP_NOTUPTOI:
		goto __63
	case OP_NOT_HSPACE:
		goto __64
	case OP_NOT_VSPACE:
		goto __65
	case OP_PRUNE:
		goto __66
	case OP_PRUNE_ARG:
		goto __67
	case OP_RECURSE:
		goto __68
	case OP_REF:
		goto __69
	case OP_REFI:
		goto __70
	case OP_REVERSE:
		goto __71
	case OP_RREF:
		goto __72
	case OP_SCOND:
		goto __73
	case OP_SET_SOM:
		goto __74
	case OP_SKIP:
		goto __75
	case OP_SKIP_ARG:
		goto __76
	case OP_SOD:
		goto __77
	case OP_SOM:
		goto __78
	case OP_THEN:
		goto __79
	case OP_THEN_ARG:
		goto __80

	// OP_CIRC happens only at the start of an anchored branch (multiline ^
	//       uses OP_CIRCM). Skip over it.

	case OP_CIRC:
		goto __81

	// A "real" property test implies no starting bits, but the fake property
	//       PT_CLIST identifies a list of characters. These lists are short, as they
	//       are used for characters with more than one "other case", so there is no
	//       point in recognizing them for OP_NOTPROP.

	case OP_PROP:
		goto __82

	// We can ignore word boundary tests.

	case OP_WORD_BOUNDARY:
		goto __83
	case OP_NOT_WORD_BOUNDARY:
		goto __84

	// If we hit a bracket or a positive lookahead assertion, recurse to set
	//       bits from within the subpattern. If it can't find anything, we have to
	//       give up. If it finds some mandatory character(s), we are done for this
	//       branch. Otherwise, carry on scanning after the subpattern.

	case OP_BRA:
		goto __85
	case OP_SBRA:
		goto __86
	case OP_CBRA:
		goto __87
	case OP_SCBRA:
		goto __88
	case OP_BRAPOS:
		goto __89
	case OP_SBRAPOS:
		goto __90
	case OP_CBRAPOS:
		goto __91
	case OP_SCBRAPOS:
		goto __92
	case OP_ONCE:
		goto __93
	case OP_SCRIPT_RUN:
		goto __94
	case OP_ASSERT:
		goto __95
	case OP_ASSERT_NA:
		goto __96

	// If we hit ALT or KET, it means we haven't found anything mandatory in
	//       this branch, though we might have found something optional. For ALT, we
	//       continue with the next alternative, but we have to arrange that the final
	//       result from subpattern is SSB_CONTINUE rather than SSB_DONE. For KET,
	//       return SSB_CONTINUE: if this is the top level, that indicates failure,
	//       but after a nested subpattern, it causes scanning to continue.

	case OP_ALT:
		goto __97

	case OP_KET:
		goto __98
	case OP_KETRMAX:
		goto __99
	case OP_KETRMIN:
		goto __100
	case OP_KETRPOS:
		goto __101

	// Skip over callout

	case OP_CALLOUT:
		goto __102

	case OP_CALLOUT_STR:
		goto __103

	// Skip over lookbehind and negative lookahead assertions

	case OP_ASSERT_NOT:
		goto __104
	case OP_ASSERTBACK:
		goto __105
	case OP_ASSERTBACK_NOT:
		goto __106
	case OP_ASSERTBACK_NA:
		goto __107

	// BRAZERO does the bracket, but carries on.

	case OP_BRAZERO:
		goto __108
	case OP_BRAMINZERO:
		goto __109
	case OP_BRAPOSZERO:
		goto __110

	// SKIPZERO skips the bracket.

	case OP_SKIPZERO:
		goto __111

	// Single-char * or ? sets the bit and tries the next item

	case OP_STAR:
		goto __112
	case OP_MINSTAR:
		goto __113
	case OP_POSSTAR:
		goto __114
	case OP_QUERY:
		goto __115
	case OP_MINQUERY:
		goto __116
	case OP_POSQUERY:
		goto __117

	case OP_STARI:
		goto __118
	case OP_MINSTARI:
		goto __119
	case OP_POSSTARI:
		goto __120
	case OP_QUERYI:
		goto __121
	case OP_MINQUERYI:
		goto __122
	case OP_POSQUERYI:
		goto __123

	// Single-char upto sets the bit and tries the next

	case OP_UPTO:
		goto __124
	case OP_MINUPTO:
		goto __125
	case OP_POSUPTO:
		goto __126

	case OP_UPTOI:
		goto __127
	case OP_MINUPTOI:
		goto __128
	case OP_POSUPTOI:
		goto __129

	// At least one single char sets the bit and stops

	case OP_EXACT:
		goto __130
	// Fall through
	case OP_CHAR:
		goto __131
	case OP_PLUS:
		goto __132
	case OP_MINPLUS:
		goto __133
	case OP_POSPLUS:
		goto __134

	case OP_EXACTI:
		goto __135
	// Fall through
	case OP_CHARI:
		goto __136
	case OP_PLUSI:
		goto __137
	case OP_MINPLUSI:
		goto __138
	case OP_POSPLUSI:
		goto __139

	// Special spacing and line-terminating items. These recognize specific
	//       lists of characters. The difference between VSPACE and ANYNL is that the
	//       latter can match the two-character CRLF sequence, but that is not
	//       relevant for finding the first character, so their code here is
	//       identical.

	case OP_HSPACE:
		goto __140

	case OP_ANYNL:
		goto __141
	case OP_VSPACE:
		goto __142

	// Single character types set the bits and stop. Note that if PCRE2_UCP
	//       is set, we do not see these opcodes because \d etc are converted to
	//       properties. Therefore, these apply in the case when only characters less
	//       than 256 are recognized to match the types.

	case OP_NOT_DIGIT:
		goto __143

	case OP_DIGIT:
		goto __144

	case OP_NOT_WHITESPACE:
		goto __145

	case OP_WHITESPACE:
		goto __146

	case OP_NOT_WORDCHAR:
		goto __147

	case OP_WORDCHAR:
		goto __148

	// One or more character type fudges the pointer and restarts, knowing
	//       it will hit a single character type and stop there.

	case OP_TYPEPLUS:
		goto __149
	case OP_TYPEMINPLUS:
		goto __150
	case OP_TYPEPOSPLUS:
		goto __151

	case OP_TYPEEXACT:
		goto __152

	// Zero or more repeats of character types set the bits and then
	//       try again.

	case OP_TYPEUPTO:
		goto __153
	case OP_TYPEMINUPTO:
		goto __154
	case OP_TYPEPOSUPTO:
		goto __155 // Fall through

	case OP_TYPESTAR:
		goto __156
	case OP_TYPEMINSTAR:
		goto __157
	case OP_TYPEPOSSTAR:
		goto __158
	case OP_TYPEQUERY:
		goto __159
	case OP_TYPEMINQUERY:
		goto __160
	case OP_TYPEPOSQUERY:
		goto __161

	// Extended class: if there are any property checks, or if this is a
	//       negative XCLASS without a map, give up. If there are no property checks,
	//       there must be wide characters on the XCLASS list, because otherwise an
	//       XCLASS would not have been created. This means that code points >= 255
	//       are potential starters. In the UTF-8 case we can scan them and set bits
	//       for the relevant leading bytes.

	case OP_XCLASS:
		goto __162

	// It seems that the fall through comment must be outside the #ifdef if
	//       it is to avoid the gcc compiler warning.

	// Fall through

	// Enter here for a negative non-XCLASS. In the 8-bit library, if we are
	//       in UTF mode, any byte with a value >= 0xc4 is a potentially valid starter
	//       because it starts a character with a value > 255. In 8-bit non-UTF mode,
	//       there is no difference between CLASS and NCLASS. In all other wide
	//       character modes, set the 0xFF bit to indicate code units >= 255.

	case OP_NCLASS:
		goto __163
	// Fall through

	// Enter here for a positive non-XCLASS. If we have fallen through from
	//       an XCLASS, classmap will already be set; just advance the code pointer.
	//       Otherwise, set up classmap for a a non-XCLASS and advance past it.

	case OP_CLASS:
		goto __164
	}
	goto __8

	// If we reach something we don't understand, it means a new opcode has
	//       been created that hasn't been added to this function. Hopefully this
	//       problem will be discovered during testing.

__9:
	return SSB_UNKNOWN

	// Fail for a valid opcode that implies no starting bits.

__10:
__11:
__12:
__13:
__14:
__15:
__16:
__17:
__18:
__19:
__20:
__21:
__22:
__23:
__24:
__25:
__26:
__27:
__28:
__29:
__30:
__31:
__32:
__33:
__34:
__35:
__36:
__37:
__38:
__39:
__40:
__41:
__42:
__43:
__44:
__45:
__46:
__47:
__48:
__49:
__50:
__51:
__52:
__53:
__54:
__55:
__56:
__57:
__58:
__59:
__60:
__61:
__62:
__63:
__64:
__65:
__66:
__67:
__68:
__69:
__70:
__71:
__72:
__73:
__74:
__75:
__76:
__77:
__78:
__79:
__80:
	return SSB_FAIL

	// OP_CIRC happens only at the start of an anchored branch (multiline ^
	//       uses OP_CIRCM). Skip over it.

__81:
	tcode += TPCRE2_SPTR8(X_pcre2_OP_lengths_8[OP_CIRC])
	goto __8

	// A "real" property test implies no starting bits, but the fake property
	//       PT_CLIST identifies a list of characters. These lists are short, as they
	//       are used for characters with more than one "other case", so there is no
	//       point in recognizing them for OP_NOTPROP.

__82:
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(tcode + 1))) != DPT_CLIST) {
		goto __165
	}
	return SSB_FAIL
__165:
	;

	p = uintptr(unsafe.Pointer(&X_pcre2_ucd_caseless_sets_8)) + uintptr(*(*TPCRE2_UCHAR8)(unsafe.Pointer(tcode + 2)))*4
__166:
	if !(libc.AssignUint32(&c, *(*Tuint32_t)(unsafe.Pointer(libc.PostIncUintptr(&p, 4)))) < DNOTACHAR) {
		goto __167
	}

	if !(utf != 0) {
		goto __168
	}

	X_pcre2_ord2utf_8(tls, c, bp)
	c = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(bp)))
__168:
	;
	if !(c > Tuint32_t(0xff)) {
		goto __169
	}
	*(*Tuint8_t)(unsafe.Pointer(re + 40 + 31)) |= uint8(uint32(1) << (0xff & 7))
	goto __170
__169:
	*(*Tuint8_t)(unsafe.Pointer(re + 40 + uintptr(c/Tuint32_t(8)))) |= Tuint8_t(uint32(1) << (c & Tuint32_t(7)))
__170:
	;
	goto __166
__167:
	;

	try_next = DFALSE
	goto __8

	// We can ignore word boundary tests.

__83:
__84:
	tcode++
	goto __8

	// If we hit a bracket or a positive lookahead assertion, recurse to set
	//       bits from within the subpattern. If it can't find anything, we have to
	//       give up. If it finds some mandatory character(s), we are done for this
	//       branch. Otherwise, carry on scanning after the subpattern.

__85:
__86:
__87:
__88:
__89:
__90:
__91:
__92:
__93:
__94:
__95:
__96:
	rc = set_start_bits(tls, re, tcode, utf, ucp, depthptr)
	if !(rc == SSB_DONE) {
		goto __171
	}

	try_next = DFALSE
	goto __172
__171:
	if !(rc == SSB_CONTINUE) {
		goto __173
	}

__175:
	tcode += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(tcode + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(tcode + 2)))))
	goto __176
__176:
	if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(tcode))) == OP_ALT {
		goto __175
	}
	goto __177
__177:
	;
	tcode += TPCRE2_SPTR8(1 + DLINK_SIZE)
	goto __174
__173:
	return rc
__174:
	;
__172:
	; // FAIL, UNKNOWN, or TOODEEP
	goto __8

	// If we hit ALT or KET, it means we haven't found anything mandatory in
	//       this branch, though we might have found something optional. For ALT, we
	//       continue with the next alternative, but we have to arrange that the final
	//       result from subpattern is SSB_CONTINUE rather than SSB_DONE. For KET,
	//       return SSB_CONTINUE: if this is the top level, that indicates failure,
	//       but after a nested subpattern, it causes scanning to continue.

__97:
	yield = SSB_CONTINUE
	try_next = DFALSE
	goto __8

__98:
__99:
__100:
__101:
	return SSB_CONTINUE

	// Skip over callout

__102:
	tcode += TPCRE2_SPTR8(X_pcre2_OP_lengths_8[OP_CALLOUT])
	goto __8

__103:
	tcode += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(tcode + 5)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(tcode + 6)))))
	goto __8

	// Skip over lookbehind and negative lookahead assertions

__104:
__105:
__106:
__107:
__178:
	tcode += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(tcode + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(tcode + 2)))))
	goto __179
__179:
	if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(tcode))) == OP_ALT {
		goto __178
	}
	goto __180
__180:
	;
	tcode += TPCRE2_SPTR8(1 + DLINK_SIZE)
	goto __8

	// BRAZERO does the bracket, but carries on.

__108:
__109:
__110:
	rc = set_start_bits(tls, re, libc.PreIncUintptr(&tcode, 1), utf, ucp, depthptr)
	if !(rc == SSB_FAIL || rc == SSB_UNKNOWN || rc == SSB_TOODEEP) {
		goto __181
	}
	return rc
__181:
	;
__182:
	tcode += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(tcode + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(tcode + 2)))))
	goto __183
__183:
	if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(tcode))) == OP_ALT {
		goto __182
	}
	goto __184
__184:
	;
	tcode += TPCRE2_SPTR8(1 + DLINK_SIZE)
	goto __8

	// SKIPZERO skips the bracket.

__111:
	tcode++
__185:
	tcode += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(tcode + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(tcode + 2)))))
	goto __186
__186:
	if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(tcode))) == OP_ALT {
		goto __185
	}
	goto __187
__187:
	;
	tcode += TPCRE2_SPTR8(1 + DLINK_SIZE)
	goto __8

	// Single-char * or ? sets the bit and tries the next item

__112:
__113:
__114:
__115:
__116:
__117:
	tcode = set_table_bit(tls, re, tcode+uintptr(1), DFALSE, utf, ucp)
	goto __8

__118:
__119:
__120:
__121:
__122:
__123:
	tcode = set_table_bit(tls, re, tcode+uintptr(1), DTRUE, utf, ucp)
	goto __8

	// Single-char upto sets the bit and tries the next

__124:
__125:
__126:
	tcode = set_table_bit(tls, re, tcode+uintptr(1)+uintptr(DIMM2_SIZE), DFALSE, utf, ucp)
	goto __8

__127:
__128:
__129:
	tcode = set_table_bit(tls, re, tcode+uintptr(1)+uintptr(DIMM2_SIZE), DTRUE, utf, ucp)
	goto __8

	// At least one single char sets the bit and stops

__130:
	tcode += TPCRE2_SPTR8(DIMM2_SIZE)
	// Fall through
__131:
__132:
__133:
__134:
	set_table_bit(tls, re, tcode+uintptr(1), DFALSE, utf, ucp)
	try_next = DFALSE
	goto __8

__135:
	tcode += TPCRE2_SPTR8(DIMM2_SIZE)
	// Fall through
__136:
__137:
__138:
__139:
	set_table_bit(tls, re, tcode+uintptr(1), DTRUE, utf, ucp)
	try_next = DFALSE
	goto __8

	// Special spacing and line-terminating items. These recognize specific
	//       lists of characters. The difference between VSPACE and ANYNL is that the
	//       latter can match the two-character CRLF sequence, but that is not
	//       relevant for finding the first character, so their code here is
	//       identical.

__140:
	*(*Tuint8_t)(unsafe.Pointer(re + 40 + 1)) |= uint8(uint32(1) << ('\011' & 7))
	*(*Tuint8_t)(unsafe.Pointer(re + 40 + 4)) |= uint8(uint32(1) << ('\040' & 7))

	// For the 16-bit and 32-bit libraries (which can never be EBCDIC), set
	//       the bits for 0xA0 and for code units >= 255, independently of UTF.

	// For the 8-bit library in UTF-8 mode, set the bits for the first code
	//       units of horizontal space characters.

	if !(utf != 0) {
		goto __188
	}

	*(*Tuint8_t)(unsafe.Pointer(re + 40 + 24)) |= uint8(uint32(1) << (0xC2 & 7)) // For U+00A0
	*(*Tuint8_t)(unsafe.Pointer(re + 40 + 28)) |= uint8(uint32(1) << (0xE1 & 7)) // For U+1680, U+180E
	*(*Tuint8_t)(unsafe.Pointer(re + 40 + 28)) |= uint8(uint32(1) << (0xE2 & 7)) // For U+2000 - U+200A, U+202F, U+205F
	*(*Tuint8_t)(unsafe.Pointer(re + 40 + 28)) |= uint8(uint32(1) << (0xE3 & 7)) // For U+3000
	goto __189
__188:
	/* For the 8-bit library not in UTF-8 mode, set the bit for 0xA0, unless
	   the code is EBCDIC. */

	*(*Tuint8_t)(unsafe.Pointer(re + 40 + 20)) |= uint8(uint32(1) << (0xA0 & 7))
__189:
	;

	try_next = DFALSE
	goto __8

__141:
__142:
	*(*Tuint8_t)(unsafe.Pointer(re + 40 + 1)) |= uint8(uint32(1) << ('\012' & 7))
	*(*Tuint8_t)(unsafe.Pointer(re + 40 + 1)) |= uint8(uint32(1) << ('\013' & 7))
	*(*Tuint8_t)(unsafe.Pointer(re + 40 + 1)) |= uint8(uint32(1) << ('\014' & 7))
	*(*Tuint8_t)(unsafe.Pointer(re + 40 + 1)) |= uint8(uint32(1) << ('\015' & 7))

	// For the 16-bit and 32-bit libraries (which can never be EBCDIC), set
	//       the bits for NEL and for code units >= 255, independently of UTF.

	// For the 8-bit library in UTF-8 mode, set the bits for the first code
	//       units of vertical space characters.

	if !(utf != 0) {
		goto __190
	}

	*(*Tuint8_t)(unsafe.Pointer(re + 40 + 24)) |= uint8(uint32(1) << (0xC2 & 7)) // For U+0085 (NEL)
	*(*Tuint8_t)(unsafe.Pointer(re + 40 + 28)) |= uint8(uint32(1) << (0xE2 & 7)) // For U+2028, U+2029
	goto __191
__190:
	/* For the 8-bit library not in UTF-8 mode, set the bit for NEL. */

	*(*Tuint8_t)(unsafe.Pointer(re + 40 + 16)) |= uint8(uint32(1) << (int32(uint8('\x85')) & 7))
__191:
	;

	try_next = DFALSE
	goto __8

	// Single character types set the bits and stop. Note that if PCRE2_UCP
	//       is set, we do not see these opcodes because \d etc are converted to
	//       properties. Therefore, these apply in the case when only characters less
	//       than 256 are recognized to match the types.

__143:
	set_nottype_bits(tls, re, Dcbit_digit, uint32(table_limit))
	try_next = DFALSE
	goto __8

__144:
	set_type_bits(tls, re, Dcbit_digit, uint32(table_limit))
	try_next = DFALSE
	goto __8

__145:
	set_nottype_bits(tls, re, Dcbit_space, uint32(table_limit))
	try_next = DFALSE
	goto __8

__146:
	set_type_bits(tls, re, Dcbit_space, uint32(table_limit))
	try_next = DFALSE
	goto __8

__147:
	set_nottype_bits(tls, re, Dcbit_word, uint32(table_limit))
	try_next = DFALSE
	goto __8

__148:
	set_type_bits(tls, re, Dcbit_word, uint32(table_limit))
	try_next = DFALSE
	goto __8

	// One or more character type fudges the pointer and restarts, knowing
	//       it will hit a single character type and stop there.

__149:
__150:
__151:
	tcode++
	goto __8

__152:
	tcode += TPCRE2_SPTR8(1 + DIMM2_SIZE)
	goto __8

	// Zero or more repeats of character types set the bits and then
	//       try again.

__153:
__154:
__155:
	tcode += TPCRE2_SPTR8(DIMM2_SIZE) // Fall through

__156:
__157:
__158:
__159:
__160:
__161:
	switch int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(tcode + 1))) {
	default:
		goto __193
	case OP_ANY:
		goto __194
	case OP_ALLANY:
		goto __195

	case OP_HSPACE:
		goto __196

	case OP_ANYNL:
		goto __197
	case OP_VSPACE:
		goto __198

	case OP_NOT_DIGIT:
		goto __199

	case OP_DIGIT:
		goto __200

	case OP_NOT_WHITESPACE:
		goto __201

	case OP_WHITESPACE:
		goto __202

	case OP_NOT_WORDCHAR:
		goto __203

	case OP_WORDCHAR:
		goto __204
	}
	goto __192

__193:
__194:
__195:
	return SSB_FAIL

__196:
	*(*Tuint8_t)(unsafe.Pointer(re + 40 + 1)) |= uint8(uint32(1) << ('\011' & 7))
	*(*Tuint8_t)(unsafe.Pointer(re + 40 + 4)) |= uint8(uint32(1) << ('\040' & 7))

	// For the 16-bit and 32-bit libraries (which can never be EBCDIC), set
	//         the bits for 0xA0 and for code units >= 255, independently of UTF.

	// For the 8-bit library in UTF-8 mode, set the bits for the first code
	//         units of horizontal space characters.

	if !(utf != 0) {
		goto __205
	}

	*(*Tuint8_t)(unsafe.Pointer(re + 40 + 24)) |= uint8(uint32(1) << (0xC2 & 7)) // For U+00A0
	*(*Tuint8_t)(unsafe.Pointer(re + 40 + 28)) |= uint8(uint32(1) << (0xE1 & 7)) // For U+1680, U+180E
	*(*Tuint8_t)(unsafe.Pointer(re + 40 + 28)) |= uint8(uint32(1) << (0xE2 & 7)) // For U+2000 - U+200A, U+202F, U+205F
	*(*Tuint8_t)(unsafe.Pointer(re + 40 + 28)) |= uint8(uint32(1) << (0xE3 & 7)) // For U+3000
	goto __206
__205:
	/* For the 8-bit library not in UTF-8 mode, set the bit for 0xA0, unless
	   the code is EBCDIC. */

	*(*Tuint8_t)(unsafe.Pointer(re + 40 + 20)) |= uint8(uint32(1) << (0xA0 & 7))
__206:
	;
	goto __192

__197:
__198:
	*(*Tuint8_t)(unsafe.Pointer(re + 40 + 1)) |= uint8(uint32(1) << ('\012' & 7))
	*(*Tuint8_t)(unsafe.Pointer(re + 40 + 1)) |= uint8(uint32(1) << ('\013' & 7))
	*(*Tuint8_t)(unsafe.Pointer(re + 40 + 1)) |= uint8(uint32(1) << ('\014' & 7))
	*(*Tuint8_t)(unsafe.Pointer(re + 40 + 1)) |= uint8(uint32(1) << ('\015' & 7))

	// For the 16-bit and 32-bit libraries (which can never be EBCDIC), set
	//         the bits for NEL and for code units >= 255, independently of UTF.

	// For the 8-bit library in UTF-8 mode, set the bits for the first code
	//         units of vertical space characters.

	if !(utf != 0) {
		goto __207
	}

	*(*Tuint8_t)(unsafe.Pointer(re + 40 + 24)) |= uint8(uint32(1) << (0xC2 & 7)) // For U+0085 (NEL)
	*(*Tuint8_t)(unsafe.Pointer(re + 40 + 28)) |= uint8(uint32(1) << (0xE2 & 7)) // For U+2028, U+2029
	goto __208
__207:
	/* For the 8-bit library not in UTF-8 mode, set the bit for NEL. */

	*(*Tuint8_t)(unsafe.Pointer(re + 40 + 16)) |= uint8(uint32(1) << (int32(uint8('\x85')) & 7))
__208:
	;
	goto __192

__199:
	set_nottype_bits(tls, re, Dcbit_digit, uint32(table_limit))
	goto __192

__200:
	set_type_bits(tls, re, Dcbit_digit, uint32(table_limit))
	goto __192

__201:
	set_nottype_bits(tls, re, Dcbit_space, uint32(table_limit))
	goto __192

__202:
	set_type_bits(tls, re, Dcbit_space, uint32(table_limit))
	goto __192

__203:
	set_nottype_bits(tls, re, Dcbit_word, uint32(table_limit))
	goto __192

__204:
	set_type_bits(tls, re, Dcbit_word, uint32(table_limit))
	goto __192
__192:
	;

	tcode += uintptr(2)
	goto __8

	// Extended class: if there are any property checks, or if this is a
	//       negative XCLASS without a map, give up. If there are no property checks,
	//       there must be wide characters on the XCLASS list, because otherwise an
	//       XCLASS would not have been created. This means that code points >= 255
	//       are potential starters. In the UTF-8 case we can scan them and set bits
	//       for the relevant leading bytes.

__162:
	xclassflags = *(*TPCRE2_UCHAR8)(unsafe.Pointer(tcode + 3))
	if !(int32(xclassflags)&DXCL_HASPROP != 0 || int32(xclassflags)&(DXCL_MAP|DXCL_NOT) == DXCL_NOT) {
		goto __209
	}
	return SSB_FAIL
__209:
	;

	// We have a positive XCLASS or a negative one without a map. Set up the
	//       map pointer if there is one, and fall through.

	if int32(xclassflags)&DXCL_MAP == 0 {
		classmap = uintptr(0)
	} else {
		classmap = tcode + uintptr(1) + uintptr(DLINK_SIZE) + uintptr(1)
	}

	// In UTF-8 mode, scan the character list and set bits for leading bytes,
	//       then jump to handle the map.

	if !(utf != 0 && int32(xclassflags)&DXCL_NOT == 0) {
		goto __210
	}

	p1 = tcode + uintptr(1) + uintptr(DLINK_SIZE) + uintptr(1) + uintptr(func() int32 {
		if classmap == uintptr(0) {
			return 0
		}
		return 32
	}())
	tcode += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(tcode + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(tcode + 2)))))

__211:
	switch int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&p1, 1)))) {
	case DXCL_SINGLE:
		goto __215

	case DXCL_RANGE:
		goto __216

	case DXCL_END:
		goto __217

	default:
		goto __218
	}
	goto __214

__215:
	b = *(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&p1, 1)))
__219:
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(p1)))&0xc0 == 0x80) {
		goto __220
	}
	p1++
	goto __219
__220:
	;
	*(*Tuint8_t)(unsafe.Pointer(re + 40 + uintptr(int32(b)/8))) |= Tuint8_t(uint32(1) << (int32(b) & 7))
	goto __214

__216:
	b = *(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&p1, 1)))
__221:
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(p1)))&0xc0 == 0x80) {
		goto __222
	}
	p1++
	goto __221
__222:
	;
	e = *(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&p1, 1)))
__223:
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(p1)))&0xc0 == 0x80) {
		goto __224
	}
	p1++
	goto __223
__224:
	;
__225:
	if !(int32(b) <= int32(e)) {
		goto __227
	}
	*(*Tuint8_t)(unsafe.Pointer(re + 40 + uintptr(int32(b)/8))) |= Tuint8_t(uint32(1) << (int32(b) & 7))
	goto __226
__226:
	b++
	goto __225
	goto __227
__227:
	;
	goto __214

__217:
	goto HANDLE_CLASSMAP

__218:
	return SSB_UNKNOWN // Internal error, should not occur
__214:
	;
	goto __212
__212:
	goto __211
	goto __213
__213:
	;
__210:
	;

	// It seems that the fall through comment must be outside the #ifdef if
	//       it is to avoid the gcc compiler warning.

	// Fall through

	// Enter here for a negative non-XCLASS. In the 8-bit library, if we are
	//       in UTF mode, any byte with a value >= 0xc4 is a potentially valid starter
	//       because it starts a character with a value > 255. In 8-bit non-UTF mode,
	//       there is no difference between CLASS and NCLASS. In all other wide
	//       character modes, set the 0xFF bit to indicate code units >= 255.

__163:
	if !(utf != 0) {
		goto __228
	}

	*(*Tuint8_t)(unsafe.Pointer(re + 40 + 24)) |= Tuint8_t(0xf0) // Bits for 0xc4 - 0xc8
	libc.Xmemset(tls, re+40+uintptr(25), 0xff, uint64(7))        // Bits for 0xc9 - 0xff
__228:
	;
	// Fall through

	// Enter here for a positive non-XCLASS. If we have fallen through from
	//       an XCLASS, classmap will already be set; just advance the code pointer.
	//       Otherwise, set up classmap for a a non-XCLASS and advance past it.

__164:
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(tcode))) == OP_XCLASS) {
		goto __229
	}
	tcode += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(tcode + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(tcode + 2)))))
	goto __230
__229:

	classmap = libc.PreIncUintptr(&tcode, 1)
	tcode += TPCRE2_SPTR8(uint64(32) / uint64(unsafe.Sizeof(TPCRE2_UCHAR8(0))))
__230:
	;

	// When wide characters are supported, classmap may be NULL. In UTF-8
	//       (sic) mode, the bits in a class bit map correspond to character values,
	//       not to byte values. However, the bit map we are constructing is for byte
	//       values. So we have to do a conversion for characters whose code point is
	//       greater than 127. In fact, there are only two possible starting bytes for
	//       characters in the range 128 - 255.

HANDLE_CLASSMAP:
	if !(classmap != uintptr(0)) {
		goto __231
	}

	if !(utf != 0) {
		goto __232
	}

	c = Tuint32_t(0)
__234:
	if !(c < Tuint32_t(16)) {
		goto __236
	}
	*(*Tuint8_t)(unsafe.Pointer(re + 40 + uintptr(c))) |= Tuint8_t(int32(*(*Tuint8_t)(unsafe.Pointer(classmap + uintptr(c)))))
	goto __235
__235:
	c++
	goto __234
	goto __236
__236:
	;
	c = Tuint32_t(128)
__237:
	if !(c < Tuint32_t(256)) {
		goto __239
	}

	if !(uint32(*(*Tuint8_t)(unsafe.Pointer(classmap + uintptr(c/Tuint32_t(8)))))&(uint32(1)<<(c&Tuint32_t(7))) != uint32(0)) {
		goto __240
	}

	d = int32(c>>6 | Tuint32_t(0xc0))                                                      // Set bit for this starter
	*(*Tuint8_t)(unsafe.Pointer(re + 40 + uintptr(d/8))) |= Tuint8_t(uint32(1) << (d & 7)) // and then skip on to the
	c = c&Tuint32_t(0xc0) + Tuint32_t(0x40) - Tuint32_t(1)                                 // next relevant character.
__240:
	;
	goto __238
__238:
	c++
	goto __237
	goto __239
__239:
	;
	goto __233
__232:
	/* In all modes except UTF-8, the two bit maps are compatible. */

	c = Tuint32_t(0)
__241:
	if !(c < Tuint32_t(32)) {
		goto __243
	}
	*(*Tuint8_t)(unsafe.Pointer(re + 40 + uintptr(c))) |= Tuint8_t(int32(*(*Tuint8_t)(unsafe.Pointer(classmap + uintptr(c)))))
	goto __242
__242:
	c++
	goto __241
	goto __243
__243:
	;
__233:
	;
__231:
	;

	// Act on what follows the class. For a zero minimum repeat, continue;
	//       otherwise stop processing.

	switch int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(tcode))) {
	case OP_CRSTAR:
		goto __245
	case OP_CRMINSTAR:
		goto __246
	case OP_CRQUERY:
		goto __247
	case OP_CRMINQUERY:
		goto __248
	case OP_CRPOSSTAR:
		goto __249
	case OP_CRPOSQUERY:
		goto __250

	case OP_CRRANGE:
		goto __251
	case OP_CRMINRANGE:
		goto __252
	case OP_CRPOSRANGE:
		goto __253

	default:
		goto __254
	}
	goto __244

__245:
__246:
__247:
__248:
__249:
__250:
	tcode++
	goto __244

__251:
__252:
__253:
	if !(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(tcode + 1)))<<8|int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(tcode + 2)))) == uint32(0)) {
		goto __255
	}
	tcode += TPCRE2_SPTR8(1 + 2*DIMM2_SIZE)
	goto __256
__255:
	try_next = DFALSE
__256:
	;
	goto __244

__254:
	try_next = DFALSE
	goto __244
__244:
	;
	goto __8 // End of class handling case
__8:
	; // End of switch for opcodes
	goto __6
__7:
	; // End of try_next loop

	code += TPCRE2_SPTR8(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 1)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code + 2))))) // Advance to next branch
	goto __3
__3:
	if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(code))) == OP_ALT {
		goto __2
	}
	goto __4
__4:
	;

	return yield
}

// ************************************************
//
//          Study a compiled expression           *
//

// This function is handed a compiled expression that it must study to produce
// information that will speed up the matching.
//
// Argument:
//   re       points to the compiled expression
//
// Returns:   0 normally; non-zero should never normally occur
//            1 unknown opcode in set_start_bits
//            2 missing capturing bracket
//            3 unknown opcode in find_minlength

func X_pcre2_study_8(tls *libc.TLS, re uintptr) int32 { /* pcre2_study.c:1672:1: */
	bp := tls.Alloc(524)
	defer tls.Free(524)

	// var count int32 at bp+520, 4

	var code uintptr
	var utf TBOOL
	var ucp TBOOL
	var d int32
	var c int32
	var y Tuint8_t
	var x Tuint8_t
	var i int32
	var a int32
	var b int32
	var p uintptr
	var flags Tuint32_t
	// var depth int32 at bp, 4

	var rc int32
	var min int32
	// var backref_cache [129]int32 at bp+4, 516
	*(*int32)(unsafe.Pointer(bp + 520 /* count */)) = 0
	utf = libc.Bool32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_UTF != Tuint32_t(0))
	ucp = libc.Bool32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_UCP != Tuint32_t(0))

	// Find start of compiled code

	code = re + uintptr(uint64(unsafe.Sizeof(Tpcre2_real_code_8{}))) + uintptr(int32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fname_entry_size)*int32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fname_count))

	// For a pattern that has a first code unit, or a multiline pattern that
	// matches only at "line start", there is no point in seeking a list of starting
	// code units.

	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&Tuint32_t(DPCRE2_FIRSTSET|DPCRE2_STARTLINE) == Tuint32_t(0)) {
		goto __1
	}
	*(*int32)(unsafe.Pointer(bp /* depth */)) = 0
	rc = set_start_bits(tls, re, code, utf, ucp, bp)
	if !(rc == SSB_UNKNOWN) {
		goto __2
	}
	return 1
__2:
	;

	// If a list of starting code units was set up, scan the list to see if only
	//   one or two were listed. Having only one listed is rare because usually a
	//   single starting code unit will have been recognized and PCRE2_FIRSTSET set.
	//   If two are listed, see if they are caseless versions of the same character;
	//   if so we can replace the list with a caseless first code unit. This gives
	//   better performance and is plausibly worth doing for patterns such as [Ww]ord
	//   or (word|WORD).

	if !(rc == SSB_DONE) {
		goto __3
	}
	a = -1
	b = -1
	p = re + 40 /* &.start_bitmap */
	flags = Tuint32_t(DPCRE2_FIRSTMAPSET)

	i = 0
__4:
	if !(i < 256) {
		goto __6
	}

	x = *(*Tuint8_t)(unsafe.Pointer(p))
	if !(int32(x) != 0) {
		goto __7
	}

	y = Tuint8_t(int32(x) & (^int32(x) + 1)) // Least significant bit
	if !(int32(y) != int32(x)) {
		goto __8
	}
	goto DONE
__8:
	; // More than one bit set

	// In the 16-bit and 32-bit libraries, the bit for 0xff means "0xff and
	//         all wide characters", so we cannot use it here.

	// Compute the character value

	c = i
	switch int32(x) {
	case 1:
		goto __10
	case 2:
		goto __11
	case 4:
		goto __12
	case 8:
		goto __13
	case 16:
		goto __14
	case 32:
		goto __15
	case 64:
		goto __16
	case 128:
		goto __17
	}
	goto __9

__10:
	goto __9
__11:
	c = c + 1
	goto __9
__12:
	c = c + 2
	goto __9
__13:
	c = c + 3
	goto __9
__14:
	c = c + 4
	goto __9
__15:
	c = c + 5
	goto __9
__16:
	c = c + 6
	goto __9
__17:
	c = c + 7
	goto __9
__9:
	;

	// c contains the code unit value, in the range 0-255. In 8-bit UTF
	//         mode, only values < 128 can be used. In all the other cases, c is a
	//         character value.

	if !(utf != 0 && c > 127) {
		goto __18
	}
	goto DONE
__18:
	;
	if !(a < 0) {
		goto __19
	}
	a = c
	goto __20
__19:
	if !(b < 0) {
		goto __21
	} /* Second one found */

	d = int32(*(*Tuint8_t)(unsafe.Pointer((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftables + uintptr(Dfcc_offset) + uintptr(uint32(c)))))

	if !(utf != 0 || ucp != 0) {
		goto __23
	}

	if !(int32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[c/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+c%DUCD_BLOCK_SIZE])*12)).Fcaseset) != 0) {
		goto __24
	}
	goto DONE
__24:
	; // Multiple case set
	if !(c > 127) {
		goto __25
	}
	d = int32(Tuint32_t(c + (*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[c/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+c%DUCD_BLOCK_SIZE])*12)).Fother_case))
__25:
	;
__23:
	;

	if !(d != a) {
		goto __26
	}
	goto DONE
__26:
	;     // Not the other case of a
	b = c // Save second in b
	goto __22
__21:
	goto DONE
__22:
	;
__20:
	; // More than two characters found
__7:
	;
	goto __5
__5:
	p++
	i = i + 8
	goto __4
	goto __6
__6:
	;

	// Replace the start code unit bits with a first code unit, but only if it
	//     is not the same as a required later code unit. This is because a search for
	//     a required code unit starts after an explicit first code unit, but at a
	//     code unit found from the bitmap. Patterns such as /a*a/ don't work
	//     if both the start unit and required unit are the same.

	if !(a >= 0 && ((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&Tuint32_t(DPCRE2_LASTSET) == Tuint32_t(0) || (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flast_codeunit != Tuint32_t(a) && (b < 0 || (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flast_codeunit != Tuint32_t(b)))) {
		goto __27
	}

	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ffirst_codeunit = Tuint32_t(a)
	flags = Tuint32_t(DPCRE2_FIRSTSET)
	if !(b >= 0) {
		goto __28
	}
	flags = flags | Tuint32_t(DPCRE2_FIRSTCASELESS)
__28:
	;
__27:
	;

DONE:
	*(*Tuint32_t)(unsafe.Pointer(re + 96)) |= flags
__3:
	;
__1:
	;

	// Find the minimum length of subject string. If the pattern can match an empty
	// string, the minimum length is already known. If the pattern contains (*ACCEPT)
	// all bets are off, and we don't even try to find a minimum length. If there are
	// more back references than the size of the vector we are going to cache them in,
	// do nothing. A pattern that complicated will probably take a long time to
	// analyze and may in any case turn out to be too complicated. Note that back
	// reference minima are held as 16-bit numbers.

	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&Tuint32_t(DPCRE2_MATCH_EMPTY|DPCRE2_HASACCEPT) == Tuint32_t(0) && int32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftop_backref) <= DMAX_CACHE_BACKREF) {
		goto __29
	}

	*(*int32)(unsafe.Pointer(bp + 4)) = 0 // Highest one that is set
	min = find_minlength(tls, re, code, code, utf, uintptr(0), bp+520, bp+4)
	switch min {
	case -1:
		goto __31 // Leave minlength unchanged (will be zero)

	case -2:
		goto __32 // missing capturing bracket

	case -3:
		goto __33 // unrecognized opcode

	default:
		goto __34
	}
	goto __30

__31: // \C in UTF mode or over-complex regex
	goto __30 // Leave minlength unchanged (will be zero)

__32:
	return 2 // missing capturing bracket

__33:
	return 3 // unrecognized opcode

__34:
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fminlength = func() uint16 {
		if min > 65535 {
			return uint16(65535)
		}
		return uint16(min)
	}()
	goto __30
__30:
	;
__29:
	;

	return 0
}

// End of pcre2_study.c

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// ************************************************
//
//           Find end of substitute text          *
//

// In extended mode, we recognize ${name:+set text:unset text} and similar
// constructions. This requires the identification of unescaped : and }
// characters. This function scans for such. It must deal with nested ${
// constructions. The pointer to the text is updated, either to the required end
// character, or to where an error was detected.
//
// Arguments:
//   code      points to the compiled expression (for options)
//   ptrptr    points to the pointer to the start of the text (updated)
//   ptrend    end of the whole string
//   last      TRUE if the last expected string (only } recognized)
//
// Returns:    0 on success
//             negative error code on failure

func find_text_end(tls *libc.TLS, code uintptr, ptrptr uintptr, ptrend TPCRE2_SPTR8, last TBOOL) int32 { /* pcre2_substitute.c:79:1: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var rc int32
	var nestlevel Tuint32_t
	var literal TBOOL
	// var ptr TPCRE2_SPTR8 at bp, 8

	var erc int32
	// var errorcode int32 at bp+12, 4

	// var ch Tuint32_t at bp+8, 4
	rc = 0
	nestlevel = Tuint32_t(0)
	literal = DFALSE
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp /* ptr */)) = *(*TPCRE2_SPTR8)(unsafe.Pointer(ptrptr))

__1:
	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp)) < ptrend) {
		goto __3
	}

	if !(literal != 0) {
		goto __4
	}

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp))))) == '\134' && *(*TPCRE2_SPTR8)(unsafe.Pointer(bp)) < ptrend-uintptr(1) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp)) + 1))) == '\105') {
		goto __6
	}

	literal = DFALSE
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp /* ptr */)) += uintptr(1)
__6:
	;
	goto __5
__4:
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp))))) == '\175') {
		goto __7
	}

	if !(nestlevel == Tuint32_t(0)) {
		goto __9
	}
	goto EXIT
__9:
	;
	nestlevel--
	goto __8
__7:
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp))))) == '\072' && !(last != 0) && nestlevel == Tuint32_t(0)) {
		goto __10
	}
	goto EXIT
	goto __11
__10:
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp))))) == '\044') {
		goto __12
	}

	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp)) < ptrend-uintptr(1) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp)) + 1))) == '\173') {
		goto __14
	}

	nestlevel++
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp /* ptr */)) += uintptr(1)
__14:
	;
	goto __13
__12:
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp))))) == '\134') {
		goto __15
	}

	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp)) < ptrend-uintptr(1)) {
		goto __16
	}
	switch int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp /* ptr */)) + 1))) {
	case '\114':
		goto __18
	case '\154':
		goto __19
	case '\125':
		goto __20
	case '\165':
		goto __21
	}
	goto __17

__18:
__19:
__20:
__21:
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp /* ptr */)) += uintptr(1)
	goto __2
__17:
	;
__16:
	;

	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp /* ptr */)) += uintptr(1) // Must point after \
	erc = X_pcre2_check_escape_8(tls, bp, ptrend, bp+8, bp+12,
		(*Tpcre2_code_8)(unsafe.Pointer(code)).Foverall_options, (*Tpcre2_code_8)(unsafe.Pointer(code)).Fextra_options, DFALSE, uintptr(0))
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp /* ptr */)) -= uintptr(1) // Back to last code unit of escape
	if !(*(*int32)(unsafe.Pointer(bp + 12)) != 0) {
		goto __22
	}

	rc = *(*int32)(unsafe.Pointer(bp + 12 /* errorcode */))
	goto EXIT
__22:
	;

	switch erc {
	case 0:
		goto __24 // Data character
	case ESC_E:
		goto __25

	case ESC_Q:
		goto __26

	default:
		goto __27
	}
	goto __23

__24: // Data character
__25: // Isolated \E is ignored
	goto __23

__26:
	literal = DTRUE
	goto __23

__27:
	rc = -57
	goto EXIT
__23:
	;
__15:
	;
__13:
	;
__11:
	;
__8:
	;
__5:
	;
	goto __2
__2:
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp /* ptr */))++
	goto __1
	goto __3
__3:
	;

	rc = -58 // Terminator not found

EXIT:
	*(*TPCRE2_SPTR8)(unsafe.Pointer(ptrptr)) = *(*TPCRE2_SPTR8)(unsafe.Pointer(bp /* ptr */))
	return rc
}

// ************************************************
//
//              Match and substitute              *
//

// This function applies a compiled re to a subject string and creates a new
// string with substitutions. The first 7 arguments are the same as for
// pcre2_match(). Either string length may be PCRE2_ZERO_TERMINATED.
//
// Arguments:
//   code            points to the compiled expression
//   subject         points to the subject string
//   length          length of subject string (may contain binary zeros)
//   start_offset    where to start in the subject string
//   options         option bits
//   match_data      points to a match_data block, or is NULL
//   context         points a PCRE2 context
//   replacement     points to the replacement string
//   rlength         length of replacement string
//   buffer          where to put the substituted string
//   blength         points to length of buffer; updated to length of string
//
// Returns:          >= 0 number of substitutions made
//                   < 0 an error code
//                   PCRE2_ERROR_BADREPLACEMENT means invalid use of $

// This macro checks for space in the buffer before copying into it. On
// overflow, either give an error immediately, or keep on, accumulating the
// length.

// Here's the function

func Xpcre2_substitute_8(tls *libc.TLS, code uintptr, subject TPCRE2_SPTR8, length Tsize_t, start_offset Tsize_t, options Tuint32_t, match_data uintptr, mcontext uintptr, replacement TPCRE2_SPTR8, rlength Tsize_t, buffer uintptr, blength uintptr) int32 { /* pcre2_substitute.c:220:1: */
	bp := tls.Alloc(328)
	defer tls.Free(328)

	var rc int32
	var subs int32
	var forcecase int32
	var forcecasereset int32
	var ovector_count Tuint32_t
	var goptions Tuint32_t
	var suboptions Tuint32_t
	var internal_match_data uintptr
	var escaped_literal TBOOL
	var overflowed TBOOL
	var use_existing_match TBOOL
	var replacement_only TBOOL
	var utf TBOOL
	var ucp TBOOL
	// var temp [6]TPCRE2_UCHAR8 at bp+312, 6

	// var ptr TPCRE2_SPTR8 at bp+280, 8

	var repend TPCRE2_SPTR8
	var extra_needed Tsize_t
	var buff_offset Tsize_t
	var buff_length Tsize_t
	var lengthleft Tsize_t
	var fraglength Tsize_t
	var ovector uintptr
	// var ovecsave [3]Tsize_t at bp, 24

	// var scb Tpcre2_substitute_callout_block_8 at bp+24, 56

	var gcontext uintptr
	var gcontext1 uintptr
	var pairs int32
	var save_start Tsize_t
	var ctypes uintptr
	var mark_start TPCRE2_SPTR8
	var mark TPCRE2_SPTR8
	var ng Tuint32_t
	// var first TPCRE2_SPTR8 at bp+288, 8

	// var last TPCRE2_SPTR8 at bp+296, 8

	var entry TPCRE2_SPTR8
	var type1 Tuint32_t
	var subptr TPCRE2_SPTR8
	var subptrend TPCRE2_SPTR8
	var group int32
	var n int32
	var special Tuint32_t
	var inparens TBOOL
	var star TBOOL
	// var sublength Tsize_t at bp+304, 8

	var text1_start TPCRE2_SPTR8
	var text1_end TPCRE2_SPTR8
	var text2_start TPCRE2_SPTR8
	var text2_end TPCRE2_SPTR8
	var next TPCRE2_UCHAR8
	// var name [33]TPCRE2_UCHAR8 at bp+240, 33

	// var errorcode int32 at bp+324, 4

	var type2 Tuint32_t
	// var ch Tuint32_t at bp+320, 4

	var chlen uint32
	var newlength Tsize_t
	var oldlength Tsize_t
	// var ptrstack [20]TPCRE2_SPTR8 at bp+80, 160

	var ptrstackptr Tuint32_t
	forcecase = 0
	forcecasereset = 0
	goptions = Tuint32_t(0)
	internal_match_data = uintptr(0)
	escaped_literal = DFALSE
	overflowed = DFALSE
	utf = libc.Bool32((*Tpcre2_code_8)(unsafe.Pointer(code)).Foverall_options&DPCRE2_UTF != Tuint32_t(0))
	ucp = libc.Bool32((*Tpcre2_code_8)(unsafe.Pointer(code)).Foverall_options&DPCRE2_UCP != Tuint32_t(0))
	extra_needed = uint64(0)

	// General initialization

	buff_offset = uint64(0)
	lengthleft = libc.AssignUint64(&buff_length, *(*Tsize_t)(unsafe.Pointer(blength)))
	*(*Tsize_t)(unsafe.Pointer(blength)) = libc.CplUint64(uint64(0))
	*(*Tsize_t)(unsafe.Pointer(bp)) = libc.AssignPtrUint64(bp+1*8, libc.AssignPtrUint64(bp+2*8, libc.CplUint64(uint64(0))))

	// Partial matching is not valid. This must come after setting *blength to
	// PCRE2_UNSET, so as not to imply an offset in the replacement.

	if !(options&(DPCRE2_PARTIAL_HARD|DPCRE2_PARTIAL_SOFT) != Tuint32_t(0)) {
		goto __1
	}
	return -34
__1:
	;

	// Validate length and find the end of the replacement. A NULL replacement of
	// zero length is interpreted as an empty string.

	if !(replacement == uintptr(0)) {
		goto __2
	}

	if !(rlength != uint64(0)) {
		goto __3
	}
	return -51
__3:
	;
	replacement = ts + 797 /* "" */
__2:
	;

	if !(rlength == libc.CplUint64(uint64(0))) {
		goto __4
	}
	rlength = X_pcre2_strlen_8(tls, replacement)
__4:
	;
	repend = replacement + uintptr(rlength)

	// Check for using a match that has already happened. Note that the subject
	// pointer in the match data may be NULL after a no-match.

	use_existing_match = libc.Bool32(options&DPCRE2_SUBSTITUTE_MATCHED != Tuint32_t(0))
	replacement_only = libc.Bool32(options&DPCRE2_SUBSTITUTE_REPLACEMENT_ONLY != Tuint32_t(0))

	// If starting from an existing match, there must be an externally provided
	// match data block. We create an internal match_data block in two cases: (a) an
	// external one is not supplied (and we are not starting from an existing match);
	// (b) an existing match is to be used for the first substitution. In the latter
	// case, we copy the existing match into the internal block. This ensures that no
	// changes are made to the existing match data block.

	if !(match_data == uintptr(0)) {
		goto __5
	}

	if !(use_existing_match != 0) {
		goto __7
	}
	return -51
__7:
	;
	if mcontext == uintptr(0) {
		gcontext = code
	} else {
		gcontext = mcontext
	}
	match_data = libc.AssignUintptr(&internal_match_data, Xpcre2_match_data_create_from_pattern_8(tls, code, gcontext))
	if !(internal_match_data == uintptr(0)) {
		goto __8
	}
	return -48
__8:
	;
	goto __6
__5:
	if !(use_existing_match != 0) {
		goto __9
	}

	if mcontext == uintptr(0) {
		gcontext1 = code
	} else {
		gcontext1 = mcontext
	}
	if int32((*Tpcre2_code_8)(unsafe.Pointer(code)).Ftop_bracket)+1 < int32((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Foveccount) {
		pairs = int32((*Tpcre2_code_8)(unsafe.Pointer(code)).Ftop_bracket) + 1
	} else {
		pairs = int32((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Foveccount)
	}
	internal_match_data = Xpcre2_match_data_create_8(tls, uint32((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Foveccount),
		gcontext1)
	if !(internal_match_data == uintptr(0)) {
		goto __10
	}
	return -48
__10:
	;
	libc.Xmemcpy(tls, internal_match_data, match_data, uint64(uintptr(0)+80)+
		uint64(2*pairs)*uint64(unsafe.Sizeof(Tsize_t(0))))
	match_data = internal_match_data
__9:
	;
__6:
	;

	// Remember ovector details

	ovector = Xpcre2_get_ovector_pointer_8(tls, match_data)
	ovector_count = Xpcre2_get_ovector_count_8(tls, match_data)

	// Fixed things in the callout block

	(*Tpcre2_substitute_callout_block_8)(unsafe.Pointer(bp + 24 /* &scb */)).Fversion = Tuint32_t(0)
	(*Tpcre2_substitute_callout_block_8)(unsafe.Pointer(bp + 24 /* &scb */)).Finput = subject
	(*Tpcre2_substitute_callout_block_8)(unsafe.Pointer(bp + 24 /* &scb */)).Foutput = buffer
	(*Tpcre2_substitute_callout_block_8)(unsafe.Pointer(bp + 24 /* &scb */)).Fovector = ovector

	// A NULL subject of zero length is treated as an empty string.

	if !(subject == uintptr(0)) {
		goto __11
	}

	if !(length != uint64(0)) {
		goto __12
	}
	return -51
__12:
	;
	subject = ts + 797 /* "" */
__11:
	;

	// Find length of zero-terminated subject

	if !(length == libc.CplUint64(uint64(0))) {
		goto __13
	}
	if subject != 0 {
		length = X_pcre2_strlen_8(tls, subject)
	} else {
		length = uint64(0)
	}
__13:
	;

	// Check UTF replacement string if necessary.

	if !(utf != 0 && options&DPCRE2_NO_UTF_CHECK == Tuint32_t(0)) {
		goto __14
	}

	rc = X_pcre2_valid_utf_8(tls, replacement, rlength, match_data+64)
	if !(rc != 0) {
		goto __15
	}

	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fleftchar = uint64(0)
	goto EXIT
__15:
	;
__14:
	;

	// Save the substitute options and remove them from the match options.

	suboptions = options & (DPCRE2_SUBSTITUTE_EXTENDED | DPCRE2_SUBSTITUTE_GLOBAL | DPCRE2_SUBSTITUTE_LITERAL | DPCRE2_SUBSTITUTE_MATCHED | DPCRE2_SUBSTITUTE_OVERFLOW_LENGTH | DPCRE2_SUBSTITUTE_REPLACEMENT_ONLY | DPCRE2_SUBSTITUTE_UNKNOWN_UNSET | DPCRE2_SUBSTITUTE_UNSET_EMPTY)
	options = options & libc.CplUint32(DPCRE2_SUBSTITUTE_EXTENDED|DPCRE2_SUBSTITUTE_GLOBAL|DPCRE2_SUBSTITUTE_LITERAL|DPCRE2_SUBSTITUTE_MATCHED|DPCRE2_SUBSTITUTE_OVERFLOW_LENGTH|DPCRE2_SUBSTITUTE_REPLACEMENT_ONLY|DPCRE2_SUBSTITUTE_UNKNOWN_UNSET|DPCRE2_SUBSTITUTE_UNSET_EMPTY)

	// Error if the start match offset is greater than the length of the subject.

	if !(start_offset > length) {
		goto __16
	}

	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fleftchar = uint64(0)
	rc = -33
	goto EXIT
__16:
	;

	// Copy up to the start offset, unless only the replacement is required.

	if !!(replacement_only != 0) {
		goto __17
	}
	if !(!(overflowed != 0) && lengthleft < start_offset) {
		goto __18
	}
	if !(suboptions&DPCRE2_SUBSTITUTE_OVERFLOW_LENGTH == Tuint32_t(0)) {
		goto __20
	}
	goto NOROOM
__20:
	;
	overflowed = DTRUE
	extra_needed = start_offset - lengthleft
	goto __19
__18:
	if !(overflowed != 0) {
		goto __21
	}
	extra_needed = extra_needed + start_offset
	goto __22
__21:
	libc.Xmemcpy(tls, buffer+uintptr(buff_offset), subject, start_offset*uint64(DPCRE2_CODE_UNIT_WIDTH/8))
	buff_offset = buff_offset + start_offset
	lengthleft = lengthleft - start_offset
__22:
	;
__19:
	;
__17:
	;

	// Loop for global substituting. If PCRE2_SUBSTITUTE_MATCHED is set, the first
	// match is taken from the match_data that was passed in.

	subs = 0
__23:
	ptrstackptr = Tuint32_t(0)

	if !(use_existing_match != 0) {
		goto __26
	}

	rc = (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Frc
	use_existing_match = DFALSE
	goto __27
__26:
	rc = Xpcre2_match_8(tls, code, subject, length, start_offset, options|goptions,
		match_data, mcontext)
__27:
	;

	if !(utf != 0) {
		goto __28
	}
	options = options | DPCRE2_NO_UTF_CHECK
__28:
	; // Only need to check once

	// Any error other than no match returns the error code. No match when not
	//   doing the special after-empty-match global rematch, or when at the end of the
	//   subject, breaks the global loop. Otherwise, advance the starting point by one
	//   character, copying it to the output, and try again.

	if !(rc < 0) {
		goto __29
	}

	if !(rc != -1) {
		goto __30
	}
	goto EXIT
__30:
	;
	if !(goptions == Tuint32_t(0) || start_offset >= length) {
		goto __31
	}
	goto __25
__31:
	;

	// Advance by one code point. Then, if CRLF is a valid newline sequence and
	//     we have advanced into the middle of it, advance one more code point. In
	//     other words, do not start in the middle of CRLF, even if CR and LF on their
	//     own are valid newlines.

	save_start = libc.PostIncUint64(&start_offset, 1)
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(subject + uintptr(start_offset-uint64(1))))) == '\015' && int32((*Tpcre2_code_8)(unsafe.Pointer(code)).Fnewline_convention) != DPCRE2_NEWLINE_CR && int32((*Tpcre2_code_8)(unsafe.Pointer(code)).Fnewline_convention) != DPCRE2_NEWLINE_LF && start_offset < length && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(subject + uintptr(start_offset)))) == '\012') {
		goto __32
	}
	start_offset++
	goto __33
__32:
	if !((*Tpcre2_code_8)(unsafe.Pointer(code)).Foverall_options&DPCRE2_UTF != Tuint32_t(0)) {
		goto __34
	}

__35:
	if !(start_offset < length && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(subject + uintptr(start_offset))))&0xc0 == 0x80) {
		goto __36
	}
	start_offset++
	goto __35
__36:
	;
__34:
	;
__33:
	;

	// Copy what we have advanced past (unless not required), reset the special
	//     global options, and continue to the next match.

	fraglength = start_offset - save_start
	if !!(replacement_only != 0) {
		goto __37
	}
	if !(!(overflowed != 0) && lengthleft < fraglength) {
		goto __38
	}
	if !(suboptions&DPCRE2_SUBSTITUTE_OVERFLOW_LENGTH == Tuint32_t(0)) {
		goto __40
	}
	goto NOROOM
__40:
	;
	overflowed = DTRUE
	extra_needed = fraglength - lengthleft
	goto __39
__38:
	if !(overflowed != 0) {
		goto __41
	}
	extra_needed = extra_needed + fraglength
	goto __42
__41:
	libc.Xmemcpy(tls, buffer+uintptr(buff_offset), subject+uintptr(save_start), fraglength*uint64(DPCRE2_CODE_UNIT_WIDTH/8))
	buff_offset = buff_offset + fraglength
	lengthleft = lengthleft - fraglength
__42:
	;
__39:
	;
__37:
	;

	goptions = Tuint32_t(0)
	goto __24
__29:
	;

	// Handle a successful match. Matches that use \K to end before they start
	//   or start before the current point in the subject are not supported.

	if !(*(*Tsize_t)(unsafe.Pointer(ovector + 1*8)) < *(*Tsize_t)(unsafe.Pointer(ovector)) || *(*Tsize_t)(unsafe.Pointer(ovector)) < start_offset) {
		goto __43
	}

	rc = -60
	goto EXIT
__43:
	;

	// Check for the same match as previous. This is legitimate after matching an
	//   empty string that starts after the initial match offset. We have tried again
	//   at the match point in case the pattern is one like /(?<=\G.)/ which can never
	//   match at its starting point, so running the match achieves the bumpalong. If
	//   we do get the same (null) match at the original match point, it isn't such a
	//   pattern, so we now do the empty string magic. In all other cases, a repeat
	//   match should never occur.

	if !(*(*Tsize_t)(unsafe.Pointer(bp)) == *(*Tsize_t)(unsafe.Pointer(ovector)) && *(*Tsize_t)(unsafe.Pointer(bp + 1*8)) == *(*Tsize_t)(unsafe.Pointer(ovector + 1*8))) {
		goto __44
	}

	if !(*(*Tsize_t)(unsafe.Pointer(ovector)) == *(*Tsize_t)(unsafe.Pointer(ovector + 1*8)) && *(*Tsize_t)(unsafe.Pointer(bp + 2*8)) != start_offset) {
		goto __45
	}

	goptions = DPCRE2_NOTEMPTY_ATSTART | DPCRE2_ANCHORED
	*(*Tsize_t)(unsafe.Pointer(bp + 2*8)) = start_offset
	goto __24 // Back to the top of the loop
__45:
	;
	rc = -65
	goto EXIT
__44:
	;

	// Count substitutions with a paranoid check for integer overflow; surely no
	//   real call to this function would ever hit this!

	if !(subs == 0x7fffffff) {
		goto __46
	}

	rc = -61
	goto EXIT
__46:
	;
	subs++

	// Copy the text leading up to the match (unless not required), and remember
	//   where the insert begins and how many ovector pairs are set.

	if !(rc == 0) {
		goto __47
	}
	rc = int32(ovector_count)
__47:
	;
	fraglength = *(*Tsize_t)(unsafe.Pointer(ovector)) - start_offset
	if !!(replacement_only != 0) {
		goto __48
	}
	if !(!(overflowed != 0) && lengthleft < fraglength) {
		goto __49
	}
	if !(suboptions&DPCRE2_SUBSTITUTE_OVERFLOW_LENGTH == Tuint32_t(0)) {
		goto __51
	}
	goto NOROOM
__51:
	;
	overflowed = DTRUE
	extra_needed = fraglength - lengthleft
	goto __50
__49:
	if !(overflowed != 0) {
		goto __52
	}
	extra_needed = extra_needed + fraglength
	goto __53
__52:
	libc.Xmemcpy(tls, buffer+uintptr(buff_offset), subject+uintptr(start_offset), fraglength*uint64(DPCRE2_CODE_UNIT_WIDTH/8))
	buff_offset = buff_offset + fraglength
	lengthleft = lengthleft - fraglength
__53:
	;
__50:
	;
__48:
	;

	*(*Tsize_t)(unsafe.Pointer(bp + 24 + 24)) = buff_offset
	(*Tpcre2_substitute_callout_block_8)(unsafe.Pointer(bp + 24 /* &scb */)).Foveccount = Tuint32_t(rc)

	// Process the replacement string. If the entire replacement is literal, just
	//   copy it with length check.

	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280 /* ptr */)) = replacement
	if !(suboptions&DPCRE2_SUBSTITUTE_LITERAL != Tuint32_t(0)) {
		goto __54
	}

	if !(!(overflowed != 0) && lengthleft < rlength) {
		goto __56
	}
	if !(suboptions&DPCRE2_SUBSTITUTE_OVERFLOW_LENGTH == Tuint32_t(0)) {
		goto __58
	}
	goto NOROOM
__58:
	;
	overflowed = DTRUE
	extra_needed = rlength - lengthleft
	goto __57
__56:
	if !(overflowed != 0) {
		goto __59
	}
	extra_needed = extra_needed + rlength
	goto __60
__59:
	libc.Xmemcpy(tls, buffer+uintptr(buff_offset), *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280 /* ptr */)), rlength*uint64(DPCRE2_CODE_UNIT_WIDTH/8))
	buff_offset = buff_offset + rlength
	lengthleft = lengthleft - rlength
__60:
	;
__57:
	;

	goto __55
__54:
__61:

	// If at the end of a nested substring, pop the stack.

	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280)) >= repend) {
		goto __64
	}

	if !(ptrstackptr == Tuint32_t(0)) {
		goto __65
	}
	goto __63
__65:
	; // End of replacement string
	repend = *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 80 + uintptr(libc.PreDecUint32(&ptrstackptr, 1))*8))
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280 /* ptr */)) = *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 80 + uintptr(libc.PreDecUint32(&ptrstackptr, 1))*8))
	goto __62
__64:
	;

	// Handle the next character

	if !(escaped_literal != 0) {
		goto __66
	}

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280))))) == '\134' && *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280)) < repend-uintptr(1) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280)) + 1))) == '\105') {
		goto __67
	}

	escaped_literal = DFALSE
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280 /* ptr */)) += uintptr(2)
	goto __62
__67:
	;
	goto LOADLITERAL
__66:
	;

	// Not in literal mode.

	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280))))) == '\044') {
		goto __68
	}
	special = Tuint32_t(0)
	text1_start = uintptr(0)
	text1_end = uintptr(0)
	text2_start = uintptr(0)
	text2_end = uintptr(0)

	if !(libc.PreIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280)), 1) >= repend) {
		goto __70
	}
	goto BAD
__70:
	;
	if !(int32(libc.AssignUint8(&next, *(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280)))))) == '\044') {
		goto __71
	}
	goto LOADLITERAL
__71:
	;

	group = -1
	n = 0
	inparens = DFALSE
	star = DFALSE

	if !(int32(next) == '\173') {
		goto __72
	}

	if !(libc.PreIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280)), 1) >= repend) {
		goto __73
	}
	goto BAD
__73:
	;
	next = *(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280 /* ptr */))))
	inparens = DTRUE
__72:
	;

	if !(int32(next) == '\052') {
		goto __74
	}

	if !(libc.PreIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280)), 1) >= repend) {
		goto __75
	}
	goto BAD
__75:
	;
	next = *(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280 /* ptr */))))
	star = DTRUE
__74:
	;

	if !(!(star != 0) && int32(next) >= '\060' && int32(next) <= '\071') {
		goto __76
	}

	group = int32(next) - '\060'
__78:
	if !(libc.PreIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280)), 1) < repend) {
		goto __79
	}

	next = *(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280 /* ptr */))))
	if !(int32(next) < '\060' || int32(next) > '\071') {
		goto __80
	}
	goto __79
__80:
	;
	group = group*10 + int32(next) - '\060'

	// A check for a number greater than the hightest captured group
	//           is sufficient here; no need for a separate overflow check. If unknown
	//           groups are to be treated as unset, just skip over any remaining
	//           digits and carry on.

	if !(group > int32((*Tpcre2_code_8)(unsafe.Pointer(code)).Ftop_bracket)) {
		goto __81
	}

	if !(suboptions&DPCRE2_SUBSTITUTE_UNKNOWN_UNSET != Tuint32_t(0)) {
		goto __82
	}

__84:
	if !(libc.PreIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280)), 1) < repend && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280))))) >= '\060' && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280))))) <= '\071') {
		goto __85
	}
	goto __84
__85:
	;
	goto __79
	goto __83
__82:

	rc = -49
	goto PTREXIT
__83:
	;
__81:
	;
	goto __78
__79:
	;
	goto __77
__76:

	ctypes = (*Tpcre2_code_8)(unsafe.Pointer(code)).Ftables + uintptr(Dcbits_offset+Dcbit_length)
__86:
	if !(1 != 0 && int32(*(*Tuint8_t)(unsafe.Pointer(ctypes + uintptr(next))))&Dctype_word != 0) {
		goto __87
	}

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(bp + 240 + uintptr(libc.PostIncInt32(&n, 1)))) = next
	if !(n > 32) {
		goto __88
	}
	goto BAD
__88:
	;
	if !(libc.PreIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280)), 1) >= repend) {
		goto __89
	}
	goto __87
__89:
	;
	next = *(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280 /* ptr */))))
	goto __86
__87:
	;
	if !(n == 0) {
		goto __90
	}
	goto BAD
__90:
	;
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(bp + 240 + uintptr(n))) = TPCRE2_UCHAR8(0)
__77:
	;

	// In extended mode we recognize ${name:+set text:unset text} and
	//       ${name:-default text}.

	if !(inparens != 0) {
		goto __91
	}

	if !(suboptions&DPCRE2_SUBSTITUTE_EXTENDED != Tuint32_t(0) && !(star != 0) && *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280)) < repend-uintptr(2) && int32(next) == '\072') {
		goto __92
	}

	special = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PreIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280)), 1))))
	if !(special != Tuint32_t('\053') && special != Tuint32_t('\055')) {
		goto __94
	}

	rc = -59
	goto PTREXIT
__94:
	;

	text1_start = libc.PreIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280 /* ptr */)), 1)
	rc = find_text_end(tls, code, bp+280, repend, libc.Bool32(special == Tuint32_t('\055')))
	if !(rc != 0) {
		goto __95
	}
	goto PTREXIT
__95:
	;
	text1_end = *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280 /* ptr */))

	if !(special == Tuint32_t('\053') && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280))))) == '\072') {
		goto __96
	}

	text2_start = libc.PreIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280 /* ptr */)), 1)
	rc = find_text_end(tls, code, bp+280, repend, DTRUE)
	if !(rc != 0) {
		goto __97
	}
	goto PTREXIT
__97:
	;
	text2_end = *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280 /* ptr */))
__96:
	;
	goto __93
__92:

	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280)) >= repend || int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280))))) != '\175') {
		goto __98
	}

	rc = -58
	goto PTREXIT
__98:
	;
__93:
	;

	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280 /* ptr */))++
__91:
	;

	// Have found a syntactically correct group number or name, or *name.
	//       Only *MARK is currently recognized.

	if !(star != 0) {
		goto __99
	}

	if !(X_pcre2_strcmp_c8_8(tls, bp+240, ts+7678) == 0) {
		goto __101
	}

	mark = Xpcre2_get_mark_8(tls, match_data)
	if !(mark != uintptr(0)) {
		goto __103
	}

	mark_start = mark
__104:
	if !(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(mark))) != 0) {
		goto __105
	}
	mark++
	goto __104
__105:
	;
	fraglength = Tsize_t((int64(mark) - int64(mark_start)) / 1)
	if !(!(overflowed != 0) && lengthleft < fraglength) {
		goto __106
	}
	if !(suboptions&DPCRE2_SUBSTITUTE_OVERFLOW_LENGTH == Tuint32_t(0)) {
		goto __108
	}
	goto NOROOM
__108:
	;
	overflowed = DTRUE
	extra_needed = fraglength - lengthleft
	goto __107
__106:
	if !(overflowed != 0) {
		goto __109
	}
	extra_needed = extra_needed + fraglength
	goto __110
__109:
	libc.Xmemcpy(tls, buffer+uintptr(buff_offset), mark_start, fraglength*uint64(DPCRE2_CODE_UNIT_WIDTH/8))
	buff_offset = buff_offset + fraglength
	lengthleft = lengthleft - fraglength
__110:
	;
__107:
	;

__103:
	;
	goto __102
__101:
	goto BAD
__102:
	;
	goto __100
__99:

	// Find a number for a named group. In case there are duplicate names,
	//         search for the first one that is set. If the name is not found when
	//         PCRE2_SUBSTITUTE_UNKNOWN_EMPTY is set, set the group number to a
	//         non-existent group.

	if !(group < 0) {
		goto __111
	}

	rc = Xpcre2_substring_nametable_scan_8(tls, code, bp+240, bp+288, bp+296)
	if !(rc == -49 && suboptions&DPCRE2_SUBSTITUTE_UNKNOWN_UNSET != Tuint32_t(0)) {
		goto __112
	}

	group = int32((*Tpcre2_code_8)(unsafe.Pointer(code)).Ftop_bracket) + 1
	goto __113
__112:

	if !(rc < 0) {
		goto __114
	}
	goto PTREXIT
__114:
	;
	entry = *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 288 /* first */))
__115:
	if !(entry <= *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 296))) {
		goto __117
	}

	ng = uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(entry)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(entry + 1))))
	if !(ng < ovector_count) {
		goto __118
	}

	if !(group < 0) {
		goto __119
	}
	group = int32(ng)
__119:
	; // First in ovector
	if !(*(*Tsize_t)(unsafe.Pointer(ovector + uintptr(ng*Tuint32_t(2))*8)) != libc.CplUint64(uint64(0))) {
		goto __120
	}

	group = int32(ng) // First that is set
	goto __117
__120:
	;
__118:
	;
	goto __116
__116:
	entry += TPCRE2_SPTR8(rc)
	goto __115
	goto __117
__117:
	;

	// If group is still negative, it means we did not find a group
	//             that is in the ovector. Just set the first group.

	if !(group < 0) {
		goto __121
	}
	group = int32(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 288)))))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 288)) + 1)))))
__121:
	;
__113:
	;
__111:
	;

	// We now have a group that is identified by number. Find the length of
	//         the captured string. If a group in a non-special substitution is unset
	//         when PCRE2_SUBSTITUTE_UNSET_EMPTY is set, substitute nothing.

	rc = Xpcre2_substring_length_bynumber_8(tls, match_data, uint32(group), bp+304)
	if !(rc < 0) {
		goto __122
	}

	if !(rc == -49 && suboptions&DPCRE2_SUBSTITUTE_UNKNOWN_UNSET != Tuint32_t(0)) {
		goto __123
	}

	rc = -55
__123:
	;
	if !(rc != -55) {
		goto __124
	}
	goto PTREXIT
__124:
	; // Non-unset errors
	if !(special == Tuint32_t(0)) {
		goto __125
	} /* Plain substitution */

	if !(suboptions&DPCRE2_SUBSTITUTE_UNSET_EMPTY != Tuint32_t(0)) {
		goto __126
	}
	goto __62
__126:
	;
	goto PTREXIT // Else error
__125:
	;
__122:
	;

	// If special is '+' we have a 'set' and possibly an 'unset' text,
	//         both of which are reprocessed when used. If special is '-' we have a
	//         default text for when the group is unset; it must be reprocessed.

	if !(special != Tuint32_t(0)) {
		goto __127
	}

	if !(special == Tuint32_t('\055')) {
		goto __128
	}

	if !(rc == 0) {
		goto __129
	}
	goto LITERAL_SUBSTITUTE
__129:
	;
	text2_start = text1_start
	text2_end = text1_end
__128:
	;

	if !(ptrstackptr >= Tuint32_t(DPTR_STACK_SIZE)) {
		goto __130
	}
	goto BAD
__130:
	;
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 80 + uintptr(libc.PostIncUint32(&ptrstackptr, 1))*8)) = *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280 /* ptr */))
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 80 + uintptr(libc.PostIncUint32(&ptrstackptr, 1))*8)) = repend

	if !(rc == 0) {
		goto __131
	}

	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280 /* ptr */)) = text1_start
	repend = text1_end
	goto __132
__131:

	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280 /* ptr */)) = text2_start
	repend = text2_end
__132:
	;
	goto __62
__127:
	;

	// Otherwise we have a literal substitution of a group's contents.

LITERAL_SUBSTITUTE:
	subptr = subject + uintptr(*(*Tsize_t)(unsafe.Pointer(ovector + uintptr(group*2)*8)))
	subptrend = subject + uintptr(*(*Tsize_t)(unsafe.Pointer(ovector + uintptr(group*2+1)*8)))

	// Substitute a literal string, possibly forcing alphabetic case.

__133:
	if !(subptr < subptrend) {
		goto __134
	}

	*(*Tuint32_t)(unsafe.Pointer(bp + 320 /* ch */)) = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&subptr, 1))))
	if !(utf != 0 && *(*Tuint32_t)(unsafe.Pointer(bp + 320)) >= 0xc0) {
		goto __135
	}
	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 320))&0x20 == Tuint32_t(0)) {
		goto __136
	}
	*(*Tuint32_t)(unsafe.Pointer(bp + 320 /* ch */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 320))&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&subptr, 1))))&0x3f
	goto __137
__136:
	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 320))&0x10 == Tuint32_t(0)) {
		goto __138
	}
	*(*Tuint32_t)(unsafe.Pointer(bp + 320 /* ch */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 320))&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(subptr)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(subptr + 1)))&0x3f
	subptr += uintptr(2)
	goto __139
__138:
	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 320))&0x08 == Tuint32_t(0)) {
		goto __140
	}
	*(*Tuint32_t)(unsafe.Pointer(bp + 320 /* ch */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 320))&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(subptr)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(subptr + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(subptr + 2)))&0x3f
	subptr += uintptr(3)
	goto __141
__140:
	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 320))&0x04 == Tuint32_t(0)) {
		goto __142
	}
	*(*Tuint32_t)(unsafe.Pointer(bp + 320 /* ch */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 320))&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(subptr)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(subptr + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(subptr + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(subptr + 3)))&0x3f
	subptr += uintptr(4)
	goto __143
__142:
	*(*Tuint32_t)(unsafe.Pointer(bp + 320 /* ch */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 320))&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(subptr)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(subptr + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(subptr + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(subptr + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(subptr + 4)))&0x3f
	subptr += uintptr(5)
__143:
	;
__141:
	;
__139:
	;
__137:
	;
__135:
	;

	if !(forcecase != 0) {
		goto __144
	}

	if !(utf != 0 || ucp != 0) {
		goto __145
	}

	type1 = Tuint32_t((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(*(*Tuint32_t)(unsafe.Pointer(bp + 320)))/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(*(*Tuint32_t)(unsafe.Pointer(bp + 320)))%DUCD_BLOCK_SIZE])*12)).Fchartype)
	if !(X_pcre2_ucp_gentype_8[type1] == ucp_L && type1 != func() uint32 {
		if forcecase > 0 {
			return ucp_Lu
		}
		return ucp_Ll
	}()) {
		goto __147
	}
	*(*Tuint32_t)(unsafe.Pointer(bp + 320 /* ch */)) = Tuint32_t(int32(*(*Tuint32_t)(unsafe.Pointer(bp + 320))) + (*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(*(*Tuint32_t)(unsafe.Pointer(bp + 320)))/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(*(*Tuint32_t)(unsafe.Pointer(bp + 320)))%DUCD_BLOCK_SIZE])*12)).Fother_case)
__147:
	;
	goto __146
__145:

	if !(uint32(*(*Tuint8_t)(unsafe.Pointer((*Tpcre2_code_8)(unsafe.Pointer(code)).Ftables + uintptr(Dcbits_offset) + uintptr(func() int32 {
		if forcecase > 0 {
			return Dcbit_upper
		}
		return Dcbit_lower
	}()) + uintptr(*(*Tuint32_t)(unsafe.Pointer(bp + 320))/Tuint32_t(8)))))&(uint32(1)<<(*(*Tuint32_t)(unsafe.Pointer(bp + 320))%Tuint32_t(8))) == uint32(0)) {
		goto __148
	}
	*(*Tuint32_t)(unsafe.Pointer(bp + 320 /* ch */)) = Tuint32_t(*(*Tuint8_t)(unsafe.Pointer((*Tpcre2_code_8)(unsafe.Pointer(code)).Ftables + uintptr(Dfcc_offset) + uintptr(*(*Tuint32_t)(unsafe.Pointer(bp + 320 /* ch */))))))
__148:
	;
__146:
	;
	forcecase = forcecasereset
__144:
	;

	if !(utf != 0) {
		goto __149
	}
	chlen = X_pcre2_ord2utf_8(tls, *(*Tuint32_t)(unsafe.Pointer(bp + 320 /* ch */)), bp+312)
	goto __150
__149:

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(bp + 312)) = TPCRE2_UCHAR8(*(*Tuint32_t)(unsafe.Pointer(bp + 320 /* ch */)))
	chlen = uint32(1)
__150:
	;
	if !(!(overflowed != 0) && lengthleft < Tsize_t(chlen)) {
		goto __151
	}
	if !(suboptions&DPCRE2_SUBSTITUTE_OVERFLOW_LENGTH == Tuint32_t(0)) {
		goto __153
	}
	goto NOROOM
__153:
	;
	overflowed = DTRUE
	extra_needed = Tsize_t(chlen) - lengthleft
	goto __152
__151:
	if !(overflowed != 0) {
		goto __154
	}
	extra_needed = extra_needed + Tsize_t(chlen)
	goto __155
__154:
	libc.Xmemcpy(tls, buffer+uintptr(buff_offset), bp+312, uint64(chlen*uint32(DPCRE2_CODE_UNIT_WIDTH/8)))
	buff_offset = buff_offset + Tsize_t(chlen)
	lengthleft = lengthleft - Tsize_t(chlen)
__155:
	;
__152:
	;

	goto __133
__134:
	;
__100:
	;
	goto __69
__68:
	if !(suboptions&DPCRE2_SUBSTITUTE_EXTENDED != Tuint32_t(0) && int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280))))) == '\134') {
		goto __156
	}

	if !(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280)) < repend-uintptr(1)) {
		goto __158
	}
	switch int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280 /* ptr */)) + 1))) {
	case '\114':
		goto __160

	case '\154':
		goto __161

	case '\125':
		goto __162

	case '\165':
		goto __163

	default:
		goto __164
	}
	goto __159

__160:
	forcecase = libc.AssignInt32(&forcecasereset, -1)
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280 /* ptr */)) += uintptr(2)
	goto __62

__161:
	forcecase = -1
	forcecasereset = 0
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280 /* ptr */)) += uintptr(2)
	goto __62

__162:
	forcecase = libc.AssignInt32(&forcecasereset, 1)
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280 /* ptr */)) += uintptr(2)
	goto __62

__163:
	forcecase = 1
	forcecasereset = 0
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280 /* ptr */)) += uintptr(2)
	goto __62

__164:
	goto __159
__159:
	;
__158:
	;

	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280 /* ptr */))++ // Point after \
	rc = X_pcre2_check_escape_8(tls, bp+280, repend, bp+320, bp+324,
		(*Tpcre2_code_8)(unsafe.Pointer(code)).Foverall_options, (*Tpcre2_code_8)(unsafe.Pointer(code)).Fextra_options, DFALSE, uintptr(0))
	if !(*(*int32)(unsafe.Pointer(bp + 324)) != 0) {
		goto __165
	}
	goto BADESCAPE
__165:
	;

	switch rc {
	case ESC_E:
		goto __167

	case ESC_Q:
		goto __168

	case 0:
		goto __169

	default:
		goto __170
	}
	goto __166

__167:
	forcecase = libc.AssignInt32(&forcecasereset, 0)
	goto __62

__168:
	escaped_literal = DTRUE
	goto __62

__169: // Data character
	goto LITERAL

__170:
	goto BADESCAPE
__166:
	;
	goto __157
__156:

LOADLITERAL:
	*(*Tuint32_t)(unsafe.Pointer(bp + 320 /* ch */)) = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280 /* ptr */)), 1))))
	if !(utf != 0 && *(*Tuint32_t)(unsafe.Pointer(bp + 320)) >= 0xc0) {
		goto __171
	}
	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 320))&0x20 == Tuint32_t(0)) {
		goto __172
	}
	*(*Tuint32_t)(unsafe.Pointer(bp + 320 /* ch */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 320))&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280)), 1))))&0x3f
	goto __173
__172:
	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 320))&0x10 == Tuint32_t(0)) {
		goto __174
	}
	*(*Tuint32_t)(unsafe.Pointer(bp + 320 /* ch */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 320))&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280)))))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280)) + 1)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280 /* ptr */)) += uintptr(2)
	goto __175
__174:
	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 320))&0x08 == Tuint32_t(0)) {
		goto __176
	}
	*(*Tuint32_t)(unsafe.Pointer(bp + 320 /* ch */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 320))&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280)))))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280)) + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280)) + 2)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280 /* ptr */)) += uintptr(3)
	goto __177
__176:
	if !(*(*Tuint32_t)(unsafe.Pointer(bp + 320))&0x04 == Tuint32_t(0)) {
		goto __178
	}
	*(*Tuint32_t)(unsafe.Pointer(bp + 320 /* ch */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 320))&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280)))))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280)) + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280)) + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280)) + 3)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280 /* ptr */)) += uintptr(4)
	goto __179
__178:
	*(*Tuint32_t)(unsafe.Pointer(bp + 320 /* ch */)) = *(*Tuint32_t)(unsafe.Pointer(bp + 320))&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280)))))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280)) + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280)) + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280)) + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280)) + 4)))&0x3f
	*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280 /* ptr */)) += uintptr(5)
__179:
	;
__177:
	;
__175:
	;
__173:
	;
__171:
	;

	// Get character value, increment pointer

LITERAL:
	if !(forcecase != 0) {
		goto __180
	}

	if !(utf != 0 || ucp != 0) {
		goto __181
	}

	type2 = Tuint32_t((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(*(*Tuint32_t)(unsafe.Pointer(bp + 320)))/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(*(*Tuint32_t)(unsafe.Pointer(bp + 320)))%DUCD_BLOCK_SIZE])*12)).Fchartype)
	if !(X_pcre2_ucp_gentype_8[type2] == ucp_L && type2 != func() uint32 {
		if forcecase > 0 {
			return ucp_Lu
		}
		return ucp_Ll
	}()) {
		goto __183
	}
	*(*Tuint32_t)(unsafe.Pointer(bp + 320 /* ch */)) = Tuint32_t(int32(*(*Tuint32_t)(unsafe.Pointer(bp + 320))) + (*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(*(*Tuint32_t)(unsafe.Pointer(bp + 320)))/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(*(*Tuint32_t)(unsafe.Pointer(bp + 320)))%DUCD_BLOCK_SIZE])*12)).Fother_case)
__183:
	;
	goto __182
__181:

	if !(uint32(*(*Tuint8_t)(unsafe.Pointer((*Tpcre2_code_8)(unsafe.Pointer(code)).Ftables + uintptr(Dcbits_offset) + uintptr(func() int32 {
		if forcecase > 0 {
			return Dcbit_upper
		}
		return Dcbit_lower
	}()) + uintptr(*(*Tuint32_t)(unsafe.Pointer(bp + 320))/Tuint32_t(8)))))&(uint32(1)<<(*(*Tuint32_t)(unsafe.Pointer(bp + 320))%Tuint32_t(8))) == uint32(0)) {
		goto __184
	}
	*(*Tuint32_t)(unsafe.Pointer(bp + 320 /* ch */)) = Tuint32_t(*(*Tuint8_t)(unsafe.Pointer((*Tpcre2_code_8)(unsafe.Pointer(code)).Ftables + uintptr(Dfcc_offset) + uintptr(*(*Tuint32_t)(unsafe.Pointer(bp + 320 /* ch */))))))
__184:
	;
__182:
	;
	forcecase = forcecasereset
__180:
	;

	if !(utf != 0) {
		goto __185
	}
	chlen = X_pcre2_ord2utf_8(tls, *(*Tuint32_t)(unsafe.Pointer(bp + 320 /* ch */)), bp+312)
	goto __186
__185:

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(bp + 312)) = TPCRE2_UCHAR8(*(*Tuint32_t)(unsafe.Pointer(bp + 320 /* ch */)))
	chlen = uint32(1)
__186:
	;
	if !(!(overflowed != 0) && lengthleft < Tsize_t(chlen)) {
		goto __187
	}
	if !(suboptions&DPCRE2_SUBSTITUTE_OVERFLOW_LENGTH == Tuint32_t(0)) {
		goto __189
	}
	goto NOROOM
__189:
	;
	overflowed = DTRUE
	extra_needed = Tsize_t(chlen) - lengthleft
	goto __188
__187:
	if !(overflowed != 0) {
		goto __190
	}
	extra_needed = extra_needed + Tsize_t(chlen)
	goto __191
__190:
	libc.Xmemcpy(tls, buffer+uintptr(buff_offset), bp+312, uint64(chlen*uint32(DPCRE2_CODE_UNIT_WIDTH/8)))
	buff_offset = buff_offset + Tsize_t(chlen)
	lengthleft = lengthleft - Tsize_t(chlen)
__191:
	;
__188:
	;

__157:
	;
__69:
	; // End handling a literal code unit
	goto __62
__62:
	goto __61
	goto __63
__63:
	;
__55:
	; // End of loop for scanning the replacement.

	// The replacement has been copied to the output, or its size has been
	//   remembered. Do the callout if there is one and we have done an actual
	//   replacement.

	if !(!(overflowed != 0) && mcontext != uintptr(0) && (*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fsubstitute_callout != uintptr(0)) {
		goto __192
	}

	(*Tpcre2_substitute_callout_block_8)(unsafe.Pointer(bp + 24 /* &scb */)).Fsubscount = Tuint32_t(subs)
	*(*Tsize_t)(unsafe.Pointer(bp + 24 + 24 + 1*8)) = buff_offset
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fsubstitute_callout})).f(tls, bp+24 /* &scb */, (*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fsubstitute_callout_data)

	// A non-zero return means cancel this substitution. Instead, copy the
	//     matched string fragment.

	if !(rc != 0) {
		goto __193
	}

	newlength = *(*Tsize_t)(unsafe.Pointer(bp + 24 + 24 + 1*8)) - *(*Tsize_t)(unsafe.Pointer(bp + 24 + 24))
	oldlength = *(*Tsize_t)(unsafe.Pointer(ovector + 1*8)) - *(*Tsize_t)(unsafe.Pointer(ovector))

	buff_offset = buff_offset - newlength
	lengthleft = lengthleft + newlength
	if !!(replacement_only != 0) {
		goto __194
	}
	if !(!(overflowed != 0) && lengthleft < oldlength) {
		goto __195
	}
	if !(suboptions&DPCRE2_SUBSTITUTE_OVERFLOW_LENGTH == Tuint32_t(0)) {
		goto __197
	}
	goto NOROOM
__197:
	;
	overflowed = DTRUE
	extra_needed = oldlength - lengthleft
	goto __196
__195:
	if !(overflowed != 0) {
		goto __198
	}
	extra_needed = extra_needed + oldlength
	goto __199
__198:
	libc.Xmemcpy(tls, buffer+uintptr(buff_offset), subject+uintptr(*(*Tsize_t)(unsafe.Pointer(ovector))), oldlength*uint64(DPCRE2_CODE_UNIT_WIDTH/8))
	buff_offset = buff_offset + oldlength
	lengthleft = lengthleft - oldlength
__199:
	;
__196:
	;
__194:
	;

	// A negative return means do not do any more.

	if !(rc < 0) {
		goto __200
	}
	suboptions = suboptions & libc.CplUint32(DPCRE2_SUBSTITUTE_GLOBAL)
__200:
	;
__193:
	;
__192:
	;

	// Save the details of this match. See above for how this data is used. If we
	//   matched an empty string, do the magic for global matches. Update the start
	//   offset to point to the rest of the subject string. If we re-used an existing
	//   match for the first match, switch to the internal match data block.

	*(*Tsize_t)(unsafe.Pointer(bp)) = *(*Tsize_t)(unsafe.Pointer(ovector))
	*(*Tsize_t)(unsafe.Pointer(bp + 1*8)) = *(*Tsize_t)(unsafe.Pointer(ovector + 1*8))
	*(*Tsize_t)(unsafe.Pointer(bp + 2*8)) = start_offset

	if *(*Tsize_t)(unsafe.Pointer(ovector)) != *(*Tsize_t)(unsafe.Pointer(ovector + 1*8)) || *(*Tsize_t)(unsafe.Pointer(ovector)) > start_offset {
		goptions = uint32(0)
	} else {
		goptions = DPCRE2_ANCHORED | DPCRE2_NOTEMPTY_ATSTART
	}
	start_offset = *(*Tsize_t)(unsafe.Pointer(ovector + 1*8))
	goto __24
__24:
	if suboptions&DPCRE2_SUBSTITUTE_GLOBAL != Tuint32_t(0) {
		goto __23
	}
	goto __25
__25:
	; // Repeat "do" loop

	// Copy the rest of the subject unless not required, and terminate the output
	// with a binary zero.

	if !!(replacement_only != 0) {
		goto __201
	}

	fraglength = length - start_offset
	if !(!(overflowed != 0) && lengthleft < fraglength) {
		goto __202
	}
	if !(suboptions&DPCRE2_SUBSTITUTE_OVERFLOW_LENGTH == Tuint32_t(0)) {
		goto __204
	}
	goto NOROOM
__204:
	;
	overflowed = DTRUE
	extra_needed = fraglength - lengthleft
	goto __203
__202:
	if !(overflowed != 0) {
		goto __205
	}
	extra_needed = extra_needed + fraglength
	goto __206
__205:
	libc.Xmemcpy(tls, buffer+uintptr(buff_offset), subject+uintptr(start_offset), fraglength*uint64(DPCRE2_CODE_UNIT_WIDTH/8))
	buff_offset = buff_offset + fraglength
	lengthleft = lengthleft - fraglength
__206:
	;
__203:
	;

__201:
	;

	*(*TPCRE2_UCHAR8)(unsafe.Pointer(bp + 312)) = TPCRE2_UCHAR8(0)
	if !(!(overflowed != 0) && lengthleft < uint64(1)) {
		goto __207
	}
	if !(suboptions&DPCRE2_SUBSTITUTE_OVERFLOW_LENGTH == Tuint32_t(0)) {
		goto __209
	}
	goto NOROOM
__209:
	;
	overflowed = DTRUE
	extra_needed = uint64(1) - lengthleft
	goto __208
__207:
	if !(overflowed != 0) {
		goto __210
	}
	extra_needed = extra_needed + uint64(1)
	goto __211
__210:
	libc.Xmemcpy(tls, buffer+uintptr(buff_offset), bp+312, uint64(1*(DPCRE2_CODE_UNIT_WIDTH/8)))
	buff_offset = buff_offset + uint64(1)
	lengthleft = lengthleft - uint64(1)
__211:
	;
__208:
	;

	// If overflowed is set it means the PCRE2_SUBSTITUTE_OVERFLOW_LENGTH is set,
	// and matching has carried on after a full buffer, in order to compute the length
	// needed. Otherwise, an overflow generates an immediate error return.

	if !(overflowed != 0) {
		goto __212
	}

	rc = -48
	*(*Tsize_t)(unsafe.Pointer(blength)) = buff_length + extra_needed
	goto __213
__212:

	rc = subs
	*(*Tsize_t)(unsafe.Pointer(blength)) = buff_offset - uint64(1)
__213:
	;

EXIT:
	if !(internal_match_data != uintptr(0)) {
		goto __214
	}
	Xpcre2_match_data_free_8(tls, internal_match_data)
	goto __215
__214:
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Frc = rc
__215:
	;
	return rc

NOROOM:
	rc = -48
	goto EXIT

BAD:
	rc = -35
	goto PTREXIT

BADESCAPE:
	rc = -57

PTREXIT:
	*(*Tsize_t)(unsafe.Pointer(blength)) = Tsize_t((int64(*(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 280))) - int64(replacement)) / 1)
	goto EXIT
	return int32(0)
}

// End of pcre2_substitute.c

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// ************************************************
//
//   Copy named captured string to given buffer   *
//

// This function copies a single captured substring into a given buffer,
// identifying it by name. If the regex permits duplicate names, the first
// substring that is set is chosen.
//
// Arguments:
//   match_data     points to the match data
//   stringname     the name of the required substring
//   buffer         where to put the substring
//   sizeptr        the size of the buffer, updated to the size of the substring
//
// Returns:         if successful: zero
//                  if not successful, a negative error code:
//                    (1) an error from nametable_scan()
//                    (2) an error from copy_bynumber()
//                    (3) PCRE2_ERROR_UNAVAILABLE: no group is in ovector
//                    (4) PCRE2_ERROR_UNSET: all named groups in ovector are unset

func Xpcre2_substring_copy_byname_8(tls *libc.TLS, match_data uintptr, stringname TPCRE2_SPTR8, buffer uintptr, sizeptr uintptr) int32 { /* pcre2_substring.c:73:1: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var first TPCRE2_SPTR8 at bp, 8

	// var last TPCRE2_SPTR8 at bp+8, 8

	var entry TPCRE2_SPTR8
	var failrc int32
	var entrysize int32
	if int32((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmatchedby) == PCRE2_MATCHEDBY_DFA_INTERPRETER {
		return -41
	}
	entrysize = Xpcre2_substring_nametable_scan_8(tls, (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fcode, stringname,
		bp, bp+8)
	if entrysize < 0 {
		return entrysize
	}
	failrc = -54
	for entry = *(*TPCRE2_SPTR8)(unsafe.Pointer(bp /* first */)); entry <= *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* last */)); entry += TPCRE2_SPTR8(entrysize) {
		var n Tuint32_t = uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(entry)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(entry + 1))))
		if n < Tuint32_t((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Foveccount) {
			if *(*Tsize_t)(unsafe.Pointer(match_data + 80 + uintptr(n*Tuint32_t(2))*8)) != libc.CplUint64(uint64(0)) {
				return Xpcre2_substring_copy_bynumber_8(tls, match_data, n, buffer, sizeptr)
			}
			failrc = -55
		}
	}
	return failrc
}

// ************************************************
//
//  Copy numbered captured string to given buffer *
//

// This function copies a single captured substring into a given buffer,
// identifying it by number.
//
// Arguments:
//   match_data     points to the match data
//   stringnumber   the number of the required substring
//   buffer         where to put the substring
//   sizeptr        the size of the buffer, updated to the size of the substring
//
// Returns:         if successful: 0
//                  if not successful, a negative error code:
//                    PCRE2_ERROR_NOMEMORY: buffer too small
//                    PCRE2_ERROR_NOSUBSTRING: no such substring
//                    PCRE2_ERROR_UNAVAILABLE: ovector too small
//                    PCRE2_ERROR_UNSET: substring is not set

func Xpcre2_substring_copy_bynumber_8(tls *libc.TLS, match_data uintptr, stringnumber Tuint32_t, buffer uintptr, sizeptr uintptr) int32 { /* pcre2_substring.c:121:1: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32
	// var size Tsize_t at bp, 8

	rc = Xpcre2_substring_length_bynumber_8(tls, match_data, stringnumber, bp)
	if rc < 0 {
		return rc
	}
	if *(*Tsize_t)(unsafe.Pointer(bp))+uint64(1) > *(*Tsize_t)(unsafe.Pointer(sizeptr)) {
		return -48
	}
	libc.Xmemcpy(tls, buffer, (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fsubject+uintptr(*(*Tsize_t)(unsafe.Pointer(match_data + 80 + uintptr(stringnumber*Tuint32_t(2))*8))),
		*(*Tsize_t)(unsafe.Pointer(bp))*uint64(DPCRE2_CODE_UNIT_WIDTH/8))
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(buffer + uintptr(*(*Tsize_t)(unsafe.Pointer(bp /* size */))))) = TPCRE2_UCHAR8(0)
	*(*Tsize_t)(unsafe.Pointer(sizeptr)) = *(*Tsize_t)(unsafe.Pointer(bp /* size */))
	return 0
}

// ************************************************
//
//          Extract named captured string         *
//

// This function copies a single captured substring, identified by name, into
// new memory. If the regex permits duplicate names, the first substring that is
// set is chosen.
//
// Arguments:
//   match_data     pointer to match_data
//   stringname     the name of the required substring
//   stringptr      where to put the pointer to the new memory
//   sizeptr        where to put the length of the substring
//
// Returns:         if successful: zero
//                  if not successful, a negative value:
//                    (1) an error from nametable_scan()
//                    (2) an error from get_bynumber()
//                    (3) PCRE2_ERROR_UNAVAILABLE: no group is in ovector
//                    (4) PCRE2_ERROR_UNSET: all named groups in ovector are unset

func Xpcre2_substring_get_byname_8(tls *libc.TLS, match_data uintptr, stringname TPCRE2_SPTR8, stringptr uintptr, sizeptr uintptr) int32 { /* pcre2_substring.c:161:1: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var first TPCRE2_SPTR8 at bp, 8

	// var last TPCRE2_SPTR8 at bp+8, 8

	var entry TPCRE2_SPTR8
	var failrc int32
	var entrysize int32
	if int32((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmatchedby) == PCRE2_MATCHEDBY_DFA_INTERPRETER {
		return -41
	}
	entrysize = Xpcre2_substring_nametable_scan_8(tls, (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fcode, stringname,
		bp, bp+8)
	if entrysize < 0 {
		return entrysize
	}
	failrc = -54
	for entry = *(*TPCRE2_SPTR8)(unsafe.Pointer(bp /* first */)); entry <= *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* last */)); entry += TPCRE2_SPTR8(entrysize) {
		var n Tuint32_t = uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(entry)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(entry + 1))))
		if n < Tuint32_t((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Foveccount) {
			if *(*Tsize_t)(unsafe.Pointer(match_data + 80 + uintptr(n*Tuint32_t(2))*8)) != libc.CplUint64(uint64(0)) {
				return Xpcre2_substring_get_bynumber_8(tls, match_data, n, stringptr, sizeptr)
			}
			failrc = -55
		}
	}
	return failrc
}

// ************************************************
//
//      Extract captured string to new memory     *
//

// This function copies a single captured substring into a piece of new
// memory.
//
// Arguments:
//   match_data     points to match data
//   stringnumber   the number of the required substring
//   stringptr      where to put a pointer to the new memory
//   sizeptr        where to put the size of the substring
//
// Returns:         if successful: 0
//                  if not successful, a negative error code:
//                    PCRE2_ERROR_NOMEMORY: failed to get memory
//                    PCRE2_ERROR_NOSUBSTRING: no such substring
//                    PCRE2_ERROR_UNAVAILABLE: ovector too small
//                    PCRE2_ERROR_UNSET: substring is not set

func Xpcre2_substring_get_bynumber_8(tls *libc.TLS, match_data uintptr, stringnumber Tuint32_t, stringptr uintptr, sizeptr uintptr) int32 { /* pcre2_substring.c:209:1: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32
	// var size Tsize_t at bp, 8

	var yield uintptr
	rc = Xpcre2_substring_length_bynumber_8(tls, match_data, stringnumber, bp)
	if rc < 0 {
		return rc
	}
	yield = X_pcre2_memctl_malloc_8(tls, uint64(unsafe.Sizeof(Tpcre2_memctl{}))+(*(*Tsize_t)(unsafe.Pointer(bp))+uint64(1))*uint64(DPCRE2_CODE_UNIT_WIDTH), match_data)
	if yield == uintptr(0) {
		return -48
	}
	yield = yield + uintptr(uint64(unsafe.Sizeof(Tpcre2_memctl{})))
	libc.Xmemcpy(tls, yield, (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fsubject+uintptr(*(*Tsize_t)(unsafe.Pointer(match_data + 80 + uintptr(stringnumber*Tuint32_t(2))*8))),
		*(*Tsize_t)(unsafe.Pointer(bp))*uint64(DPCRE2_CODE_UNIT_WIDTH/8))
	*(*TPCRE2_UCHAR8)(unsafe.Pointer(yield + uintptr(*(*Tsize_t)(unsafe.Pointer(bp /* size */))))) = TPCRE2_UCHAR8(0)
	*(*uintptr)(unsafe.Pointer(stringptr)) = yield
	*(*Tsize_t)(unsafe.Pointer(sizeptr)) = *(*Tsize_t)(unsafe.Pointer(bp /* size */))
	return 0
}

// ************************************************
//
//       Free memory obtained by get_substring    *
//

//
// Argument:     the result of a previous pcre2_substring_get_byxxx()
// Returns:      nothing

func Xpcre2_substring_free_8(tls *libc.TLS, string uintptr) { /* pcre2_substring.c:241:1: */
	if string != uintptr(0) {
		var memctl uintptr = string - uintptr(uint64(unsafe.Sizeof(Tpcre2_memctl{})))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_memctl)(unsafe.Pointer(memctl)).Ffree})).f(tls, memctl, (*Tpcre2_memctl)(unsafe.Pointer(memctl)).Fmemory_data)
	}
}

// ************************************************
//
//         Get length of a named substring        *
//

// This function returns the length of a named captured substring. If the regex
// permits duplicate names, the first substring that is set is chosen.
//
// Arguments:
//   match_data      pointer to match data
//   stringname      the name of the required substring
//   sizeptr         where to put the length
//
// Returns:          0 if successful, else a negative error number

func Xpcre2_substring_length_byname_8(tls *libc.TLS, match_data uintptr, stringname TPCRE2_SPTR8, sizeptr uintptr) int32 { /* pcre2_substring.c:268:1: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var first TPCRE2_SPTR8 at bp, 8

	// var last TPCRE2_SPTR8 at bp+8, 8

	var entry TPCRE2_SPTR8
	var failrc int32
	var entrysize int32
	if int32((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmatchedby) == PCRE2_MATCHEDBY_DFA_INTERPRETER {
		return -41
	}
	entrysize = Xpcre2_substring_nametable_scan_8(tls, (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fcode, stringname,
		bp, bp+8)
	if entrysize < 0 {
		return entrysize
	}
	failrc = -54
	for entry = *(*TPCRE2_SPTR8)(unsafe.Pointer(bp /* first */)); entry <= *(*TPCRE2_SPTR8)(unsafe.Pointer(bp + 8 /* last */)); entry += TPCRE2_SPTR8(entrysize) {
		var n Tuint32_t = uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(entry)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(entry + 1))))
		if n < Tuint32_t((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Foveccount) {
			if *(*Tsize_t)(unsafe.Pointer(match_data + 80 + uintptr(n*Tuint32_t(2))*8)) != libc.CplUint64(uint64(0)) {
				return Xpcre2_substring_length_bynumber_8(tls, match_data, n, sizeptr)
			}
			failrc = -55
		}
	}
	return failrc
}

// ************************************************
//
//        Get length of a numbered substring      *
//

// This function returns the length of a captured substring. If the start is
// beyond the end (which can happen when \K is used in an assertion), it sets the
// length to zero.
//
// Arguments:
//   match_data      pointer to match data
//   stringnumber    the number of the required substring
//   sizeptr         where to put the length, if not NULL
//
// Returns:         if successful: 0
//                  if not successful, a negative error code:
//                    PCRE2_ERROR_NOSUBSTRING: no such substring
//                    PCRE2_ERROR_UNAVAILABLE: ovector is too small
//                    PCRE2_ERROR_UNSET: substring is not set

func Xpcre2_substring_length_bynumber_8(tls *libc.TLS, match_data uintptr, stringnumber Tuint32_t, sizeptr uintptr) int32 { /* pcre2_substring.c:315:1: */
	var left Tsize_t
	var right Tsize_t
	var count int32 = (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Frc
	if count == -2 {
		if stringnumber > Tuint32_t(0) {
			return -2
		}
		count = 0
	} else if count < 0 {
		return count
	} // Match failed

	if int32((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmatchedby) != PCRE2_MATCHEDBY_DFA_INTERPRETER {
		if stringnumber > Tuint32_t((*Tpcre2_real_code_8)(unsafe.Pointer((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fcode)).Ftop_bracket) {
			return -49
		}
		if stringnumber >= Tuint32_t((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Foveccount) {
			return -54
		}
		if *(*Tsize_t)(unsafe.Pointer(match_data + 80 + uintptr(stringnumber*Tuint32_t(2))*8)) == libc.CplUint64(uint64(0)) {
			return -55
		}
	} else {
		if stringnumber >= Tuint32_t((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Foveccount) {
			return -54
		}
		if count != 0 && stringnumber >= Tuint32_t(count) {
			return -55
		}
	}

	left = *(*Tsize_t)(unsafe.Pointer(match_data + 80 + uintptr(stringnumber*Tuint32_t(2))*8))
	right = *(*Tsize_t)(unsafe.Pointer(match_data + 80 + uintptr(stringnumber*Tuint32_t(2)+Tuint32_t(1))*8))
	if sizeptr != uintptr(0) {
		*(*Tsize_t)(unsafe.Pointer(sizeptr)) = func() uint64 {
			if left > right {
				return uint64(0)
			}
			return right - left
		}()
	}
	return 0
}

// ************************************************
//
//    Extract all captured strings to new memory  *
//

// This function gets one chunk of memory and builds a list of pointers and all
// the captured substrings in it. A NULL pointer is put on the end of the list.
// The substrings are zero-terminated, but also, if the final argument is
// non-NULL, a list of lengths is also returned. This allows binary data to be
// handled.
//
// Arguments:
//   match_data     points to the match data
//   listptr        set to point to the list of pointers
//   lengthsptr     set to point to the list of lengths (may be NULL)
//
// Returns:         if successful: 0
//                  if not successful, a negative error code:
//                    PCRE2_ERROR_NOMEMORY: failed to get memory,
//                    or a match failure code

func Xpcre2_substring_list_get_8(tls *libc.TLS, match_data uintptr, listptr uintptr, lengthsptr uintptr) int32 { /* pcre2_substring.c:372:1: */
	var i int32
	var count int32
	var count2 int32
	var size Tsize_t
	var lensp uintptr
	var memp uintptr
	var listp uintptr
	var sp uintptr
	var ovector uintptr

	if libc.AssignInt32(&count, (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Frc) < 0 {
		return count
	} // Match failed
	if count == 0 {
		count = int32((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Foveccount)
	} // Ovector too small

	count2 = 2 * count
	ovector = match_data + 80                                                         /* &.ovector */
	size = uint64(unsafe.Sizeof(Tpcre2_memctl{})) + uint64(unsafe.Sizeof(uintptr(0))) // For final NULL
	if lengthsptr != uintptr(0) {
		size = size + uint64(unsafe.Sizeof(Tsize_t(0)))*uint64(count)
	} // For lengths

	for i = 0; i < count2; i = i + 2 {
		size = size + (uint64(unsafe.Sizeof(uintptr(0))) + uint64(1*(DPCRE2_CODE_UNIT_WIDTH/8)))
		if *(*Tsize_t)(unsafe.Pointer(ovector + uintptr(i+1)*8)) > *(*Tsize_t)(unsafe.Pointer(ovector + uintptr(i)*8)) {
			size = size + (*(*Tsize_t)(unsafe.Pointer(ovector + uintptr(i+1)*8))-*(*Tsize_t)(unsafe.Pointer(ovector + uintptr(i)*8)))*uint64(DPCRE2_CODE_UNIT_WIDTH/8)
		}
	}

	memp = X_pcre2_memctl_malloc_8(tls, size, match_data)
	if memp == uintptr(0) {
		return -48
	}

	*(*uintptr)(unsafe.Pointer(listptr)) = libc.AssignUintptr(&listp, memp+uintptr(uint64(unsafe.Sizeof(Tpcre2_memctl{}))))
	lensp = listp + uintptr(uint64(unsafe.Sizeof(uintptr(0)))*uint64(count+1))

	if lengthsptr == uintptr(0) {
		sp = lensp
		lensp = uintptr(0)
	} else {
		*(*uintptr)(unsafe.Pointer(lengthsptr)) = lensp
		sp = lensp + uintptr(uint64(unsafe.Sizeof(Tsize_t(0)))*uint64(count))
	}

	for i = 0; i < count2; i = i + 2 {
		if *(*Tsize_t)(unsafe.Pointer(ovector + uintptr(i+1)*8)) > *(*Tsize_t)(unsafe.Pointer(ovector + uintptr(i)*8)) {
			size = *(*Tsize_t)(unsafe.Pointer(ovector + uintptr(i+1)*8)) - *(*Tsize_t)(unsafe.Pointer(ovector + uintptr(i)*8))
		} else {
			size = uint64(0)
		}

		// Size == 0 includes the case when the capture is unset. Avoid adding
		//   PCRE2_UNSET to match_data->subject because it overflows, even though with
		//   zero size calling memcpy() is harmless.

		if size != uint64(0) {
			libc.Xmemcpy(tls, sp, (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fsubject+uintptr(*(*Tsize_t)(unsafe.Pointer(ovector + uintptr(i)*8))), size*uint64(DPCRE2_CODE_UNIT_WIDTH/8))
		}
		*(*uintptr)(unsafe.Pointer(libc.PostIncUintptr(&listp, 8))) = sp
		if lensp != uintptr(0) {
			*(*Tsize_t)(unsafe.Pointer(libc.PostIncUintptr(&lensp, 8))) = size
		}
		sp += uintptr(size)
		*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&sp, 1))) = TPCRE2_UCHAR8(0)
	}

	*(*uintptr)(unsafe.Pointer(listp)) = uintptr(0)
	return 0
}

// ************************************************
//
//   Free memory obtained by substring_list_get   *
//

//
// Argument:     the result of a previous pcre2_substring_list_get()
// Returns:      nothing

func Xpcre2_substring_list_free_8(tls *libc.TLS, list uintptr) { /* pcre2_substring.c:445:1: */
	if list != uintptr(0) {
		var memctl uintptr = list - uintptr(uint64(unsafe.Sizeof(Tpcre2_memctl{})))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_memctl)(unsafe.Pointer(memctl)).Ffree})).f(tls, memctl, (*Tpcre2_memctl)(unsafe.Pointer(memctl)).Fmemory_data)
	}
}

// ************************************************
//
//     Find (multiple) entries for named string   *
//

// This function scans the nametable for a given name, using binary chop. It
// returns either two pointers to the entries in the table, or, if no pointers are
// given, the number of a unique group with the given name. If duplicate names are
// permitted, and the name is not unique, an error is generated.
//
// Arguments:
//   code        the compiled regex
//   stringname  the name whose entries required
//   firstptr    where to put the pointer to the first entry
//   lastptr     where to put the pointer to the last entry
//
// Returns:      PCRE2_ERROR_NOSUBSTRING if the name is not found
//               otherwise, if firstptr and lastptr are NULL:
//                 a group number for a unique substring
//                 else PCRE2_ERROR_NOUNIQUESUBSTRING
//               otherwise:
//                 the length of each entry, having set firstptr and lastptr

func Xpcre2_substring_nametable_scan_8(tls *libc.TLS, code uintptr, stringname TPCRE2_SPTR8, firstptr uintptr, lastptr uintptr) int32 { /* pcre2_substring.c:480:1: */
	var bot Tuint16_t = Tuint16_t(0)
	var top Tuint16_t = (*Tpcre2_code_8)(unsafe.Pointer(code)).Fname_count
	var entrysize Tuint16_t = (*Tpcre2_code_8)(unsafe.Pointer(code)).Fname_entry_size
	var nametable TPCRE2_SPTR8 = code + uintptr(uint64(unsafe.Sizeof(Tpcre2_real_code_8{})))

	for int32(top) > int32(bot) {
		var mid Tuint16_t = Tuint16_t((int32(top) + int32(bot)) / 2)
		var entry TPCRE2_SPTR8 = nametable + uintptr(int32(entrysize)*int32(mid))
		var c int32 = X_pcre2_strcmp_8(tls, stringname, entry+uintptr(DIMM2_SIZE))
		if c == 0 {
			var first TPCRE2_SPTR8
			var last TPCRE2_SPTR8
			var lastentry TPCRE2_SPTR8
			lastentry = nametable + uintptr(int32(entrysize)*(int32((*Tpcre2_code_8)(unsafe.Pointer(code)).Fname_count)-1))
			first = libc.AssignUintptr(&last, entry)
			for first > nametable {
				if X_pcre2_strcmp_8(tls, stringname, first-uintptr(entrysize)+uintptr(DIMM2_SIZE)) != 0 {
					break
				}
				first -= TPCRE2_SPTR8(entrysize)
			}
			for last < lastentry {
				if X_pcre2_strcmp_8(tls, stringname, last+uintptr(entrysize)+uintptr(DIMM2_SIZE)) != 0 {
					break
				}
				last += TPCRE2_SPTR8(entrysize)
			}
			if firstptr == uintptr(0) {
				if first == last {
					return int32(uint32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(entry)))<<8 | int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(entry + 1)))))
				}
				return -50
			}
			*(*TPCRE2_SPTR8)(unsafe.Pointer(firstptr)) = first
			*(*TPCRE2_SPTR8)(unsafe.Pointer(lastptr)) = last
			return int32(entrysize)
		}
		if c > 0 {
			bot = Tuint16_t(int32(mid) + 1)
		} else {
			top = mid
		}
	}

	return -49
}

// ************************************************
//
//           Find number for named string         *
//

// This function is a convenience wrapper for pcre2_substring_nametable_scan()
// when it is known that names are unique. If there are duplicate names, it is not
// defined which number is returned.
//
// Arguments:
//   code        the compiled regex
//   stringname  the name whose number is required
//
// Returns:      the number of the named parenthesis, or a negative number
//                 PCRE2_ERROR_NOSUBSTRING if not found
//                 PCRE2_ERROR_NOUNIQUESUBSTRING if not unique

func Xpcre2_substring_number_from_name_8(tls *libc.TLS, code uintptr, stringname TPCRE2_SPTR8) int32 { /* pcre2_substring.c:541:1: */
	return Xpcre2_substring_nametable_scan_8(tls, code, stringname, uintptr(0), uintptr(0))
}

// End of pcre2_substring.c

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// Table of sizes for the fixed-length opcodes. It's defined in a macro so that
// the definition is next to the definition of the opcodes in pcre2_internal.h.
// This is mode-dependent, so it is skipped when this file is included by
// pcre2test.

var X_pcre2_OP_lengths_8 = [168]Tuint8_t{Tuint8_t(1) /* End                                    */, Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1) /* \A, \G, \K, \B, \b                     */, Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1) /* \D, \d, \S, \s, \W, \w                 */, Tuint8_t(1), Tuint8_t(1), Tuint8_t(1) /* Any, AllAny, Anybyte                   */, Tuint8_t(3), Tuint8_t(3) /* \P, \p                                 */, Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1) /* \R, \H, \h, \V, \v                     */, Tuint8_t(1) /* \X                                     */, Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1) /* \Z, \z, $, $M ^, ^M                    */, Tuint8_t(2) /* Char  - the minimum length             */, Tuint8_t(2) /* Chari  - the minimum length            */, Tuint8_t(2) /* not                                    */, Tuint8_t(2) /* noti                                   */ /* Positive single-char repeats                             ** These are */, Tuint8_t(2), Tuint8_t(2), Tuint8_t(2), Tuint8_t(2), Tuint8_t(2), Tuint8_t(2) /* *, *?, +, +?, ?, ??       ** minima in */, Tuint8_t(2 + DIMM2_SIZE), Tuint8_t(2 + DIMM2_SIZE), Tuint8_t(2 + DIMM2_SIZE), Tuint8_t(2), Tuint8_t(2), Tuint8_t(2), Tuint8_t(2 + DIMM2_SIZE), Tuint8_t(2), Tuint8_t(2), Tuint8_t(2), Tuint8_t(2), Tuint8_t(2), Tuint8_t(2) /* *I, *?I, +I, +?I, ?I, ??I ** UTF-8     */, Tuint8_t(2 + DIMM2_SIZE), Tuint8_t(2 + DIMM2_SIZE), Tuint8_t(2 + DIMM2_SIZE), Tuint8_t(2), Tuint8_t(2), Tuint8_t(2), Tuint8_t(2 + DIMM2_SIZE), Tuint8_t(2), Tuint8_t(2), Tuint8_t(2), Tuint8_t(2), Tuint8_t(2), Tuint8_t(2) /* NOT *, *?, +, +?, ?, ??                */, Tuint8_t(2 + DIMM2_SIZE), Tuint8_t(2 + DIMM2_SIZE), Tuint8_t(2 + DIMM2_SIZE), Tuint8_t(2), Tuint8_t(2), Tuint8_t(2), Tuint8_t(2 + DIMM2_SIZE), Tuint8_t(2), Tuint8_t(2), Tuint8_t(2), Tuint8_t(2), Tuint8_t(2), Tuint8_t(2) /* NOT *I, *?I, +I, +?I, ?I, ??I          */, Tuint8_t(2 + DIMM2_SIZE), Tuint8_t(2 + DIMM2_SIZE), Tuint8_t(2 + DIMM2_SIZE), Tuint8_t(2), Tuint8_t(2), Tuint8_t(2), Tuint8_t(2 + DIMM2_SIZE), Tuint8_t(2), Tuint8_t(2), Tuint8_t(2), Tuint8_t(2), Tuint8_t(2), Tuint8_t(2) /* Type *, *?, +, +?, ?, ??               */, Tuint8_t(2 + DIMM2_SIZE), Tuint8_t(2 + DIMM2_SIZE), Tuint8_t(2 + DIMM2_SIZE), Tuint8_t(2), Tuint8_t(2), Tuint8_t(2), Tuint8_t(2 + DIMM2_SIZE), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1) /* *, *?, +, +?, ?, ??                    */, Tuint8_t(1 + 2*DIMM2_SIZE), Tuint8_t(1 + 2*DIMM2_SIZE), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1 + 2*DIMM2_SIZE), uint8(uint64(1) + uint64(32)/uint64(unsafe.Sizeof(TPCRE2_UCHAR8(0)))), uint8(uint64(1) + uint64(32)/uint64(unsafe.Sizeof(TPCRE2_UCHAR8(0)))), Tuint8_t(0) /* XCLASS - variable length               */, Tuint8_t(1 + DIMM2_SIZE), Tuint8_t(1 + DIMM2_SIZE), Tuint8_t(1 + 2*DIMM2_SIZE), Tuint8_t(1 + 2*DIMM2_SIZE), Tuint8_t(1 + DLINK_SIZE), Tuint8_t(1 + 2*DLINK_SIZE + 1), Tuint8_t(0) /* CALLOUT_STR - variable length          */, Tuint8_t(1 + DLINK_SIZE), Tuint8_t(1 + DLINK_SIZE), Tuint8_t(1 + DLINK_SIZE), Tuint8_t(1 + DLINK_SIZE), Tuint8_t(1 + DLINK_SIZE), Tuint8_t(1 + DLINK_SIZE), Tuint8_t(1 + DLINK_SIZE), Tuint8_t(1 + DLINK_SIZE), Tuint8_t(1 + DLINK_SIZE), Tuint8_t(1 + DLINK_SIZE), Tuint8_t(1 + DLINK_SIZE), Tuint8_t(1 + DLINK_SIZE), Tuint8_t(1 + DLINK_SIZE), Tuint8_t(1 + DLINK_SIZE), Tuint8_t(1 + DLINK_SIZE), Tuint8_t(1 + DLINK_SIZE), Tuint8_t(1 + DLINK_SIZE + DIMM2_SIZE), Tuint8_t(1 + DLINK_SIZE + DIMM2_SIZE), Tuint8_t(1 + DLINK_SIZE), Tuint8_t(1 + DLINK_SIZE), Tuint8_t(1 + DLINK_SIZE), Tuint8_t(1 + DLINK_SIZE + DIMM2_SIZE), Tuint8_t(1 + DLINK_SIZE + DIMM2_SIZE), Tuint8_t(1 + DLINK_SIZE), Tuint8_t(1 + DIMM2_SIZE), Tuint8_t(1 + 2*DIMM2_SIZE), Tuint8_t(1 + DIMM2_SIZE), Tuint8_t(1 + 2*DIMM2_SIZE), Tuint8_t(1), Tuint8_t(1) /* FALSE, TRUE                            */, Tuint8_t(1), Tuint8_t(1), Tuint8_t(1) /* BRAZERO, BRAMINZERO, BRAPOSZERO        */, Tuint8_t(3), Tuint8_t(1), Tuint8_t(3) /* MARK, PRUNE, PRUNE_ARG                 */, Tuint8_t(1), Tuint8_t(3) /* SKIP, SKIP_ARG                         */, Tuint8_t(1), Tuint8_t(3) /* THEN, THEN_ARG                         */, Tuint8_t(1), Tuint8_t(3) /* COMMIT, COMMIT_ARG                     */, Tuint8_t(1), Tuint8_t(1), Tuint8_t(1) /* FAIL, ACCEPT, ASSERT_ACCEPT            */, Tuint8_t(1 + DIMM2_SIZE), Tuint8_t(1) /* CLOSE, SKIPZERO                        */, Tuint8_t(1)} /* pcre2_tables.c:60:15 */

// Tables of horizontal and vertical whitespace characters, suitable for
// adding to classes.

var X_pcre2_hspace_list_8 = [20]Tuint32_t{Tuint32_t('\011'), Tuint32_t('\040'), Tuint32_t(uint8('\xa0')), Tuint32_t(0x1680), Tuint32_t(0x180e), Tuint32_t(0x2000), Tuint32_t(0x2001), Tuint32_t(0x2002), Tuint32_t(0x2003), Tuint32_t(0x2004), Tuint32_t(0x2005), Tuint32_t(0x2006), Tuint32_t(0x2007), Tuint32_t(0x2008), Tuint32_t(0x2009), Tuint32_t(0x200A), Tuint32_t(0x202f), Tuint32_t(0x205f), Tuint32_t(0x3000), DNOTACHAR} /* pcre2_tables.c:66:16 */
var X_pcre2_vspace_list_8 = [8]Tuint32_t{Tuint32_t('\012'), Tuint32_t('\013'), Tuint32_t('\014'), Tuint32_t('\015'), Tuint32_t(uint8('\x85')), Tuint32_t(0x2028), Tuint32_t(0x2029), DNOTACHAR}                                                                                                                                                                                                                                      /* pcre2_tables.c:67:16 */

// These tables are the pairs of delimiters that are valid for callout string
// arguments. For each starting delimiter there must be a matching ending
// delimiter, which in fact is different only for bracket-like delimiters.

var X_pcre2_callout_start_delims_8 = [9]Tuint32_t{
	Tuint32_t('\140'), Tuint32_t('\047'), Tuint32_t('\042'),
	Tuint32_t('\136'), Tuint32_t('\045'), Tuint32_t('\043'),
	Tuint32_t('\044'), Tuint32_t('\173'), Tuint32_t(0)} /* pcre2_tables.c:73:16 */

var X_pcre2_callout_end_delims_8 = [9]Tuint32_t{
	Tuint32_t('\140'), Tuint32_t('\047'), Tuint32_t('\042'),
	Tuint32_t('\136'), Tuint32_t('\045'), Tuint32_t('\043'),
	Tuint32_t('\044'), Tuint32_t('\175'), Tuint32_t(0)} /* pcre2_tables.c:78:16 */

// ************************************************
//
//           Tables for UTF-8 support             *
//

// These tables are required by pcre2test in 16- or 32-bit mode, as well
// as for the library in 8-bit mode, because pcre2test uses UTF-8 internally for
// handling wide characters.

// These are the breakpoints for different numbers of bytes in a UTF-8
// character.

var X_pcre2_utf8_table1 = [6]int32{0x7f, 0x7ff, 0xffff, 0x1fffff, 0x3ffffff, 0x7fffffff} /* pcre2_tables.c:100:11 */

var X_pcre2_utf8_table1_size int32 = int32(uint64(unsafe.Sizeof(X_pcre2_utf8_table1)) / uint64(unsafe.Sizeof(int32(0)))) /* pcre2_tables.c:103:11 */

// These are the indicator bits and the mask for the data bits to set in the
// first byte of a character, indexed by the number of additional bytes.

var X_pcre2_utf8_table2 = [6]int32{0, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc}    /* pcre2_tables.c:108:11 */
var X_pcre2_utf8_table3 = [6]int32{0xff, 0x1f, 0x0f, 0x07, 0x03, 0x01} /* pcre2_tables.c:109:11 */

// Table of the number of extra bytes, indexed by the first byte masked with
// 0x3f. The highest number for a valid UTF-8 first byte is in fact 0x3d.

var X_pcre2_utf8_table4 = [64]Tuint8_t{
	Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1),
	Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1), Tuint8_t(1),
	Tuint8_t(2), Tuint8_t(2), Tuint8_t(2), Tuint8_t(2), Tuint8_t(2), Tuint8_t(2), Tuint8_t(2), Tuint8_t(2), Tuint8_t(2), Tuint8_t(2), Tuint8_t(2), Tuint8_t(2), Tuint8_t(2), Tuint8_t(2), Tuint8_t(2), Tuint8_t(2),
	Tuint8_t(3), Tuint8_t(3), Tuint8_t(3), Tuint8_t(3), Tuint8_t(3), Tuint8_t(3), Tuint8_t(3), Tuint8_t(3), Tuint8_t(4), Tuint8_t(4), Tuint8_t(4), Tuint8_t(4), Tuint8_t(5), Tuint8_t(5), Tuint8_t(5), Tuint8_t(5)} /* pcre2_tables.c:114:15 */

// Tables concerned with Unicode properties are relevant only when Unicode
// support is enabled. See also the pcre2_ucptables.c file, which is generated by
// a Python script from Unicode data files.

// Table to translate from particular type value to the general value.

var X_pcre2_ucp_gentype_8 = [30]Tuint32_t{
	ucp_C, ucp_C, ucp_C, ucp_C, ucp_C, // Cc, Cf, Cn, Co, Cs
	ucp_L, ucp_L, ucp_L, ucp_L, ucp_L, // Ll, Lu, Lm, Lo, Lt
	ucp_M, ucp_M, ucp_M, // Mc, Me, Mn
	ucp_N, ucp_N, ucp_N, // Nd, Nl, No
	ucp_P, ucp_P, ucp_P, ucp_P, ucp_P, // Pc, Pd, Pe, Pf, Pi
	ucp_P, ucp_P, // Ps, Po
	ucp_S, ucp_S, ucp_S, ucp_S, // Sc, Sk, Sm, So
	ucp_Z, ucp_Z, ucp_Z, // Zl, Zp, Zs
} /* pcre2_tables.c:130:16 */

// This table encodes the rules for finding the end of an extended grapheme
// cluster. Every code point has a grapheme break property which is one of the
// ucp_gbXX values defined in pcre2_ucp.h. These changed between Unicode versions
// 10 and 11. The 2-dimensional table is indexed by the properties of two adjacent
// code points. The left property selects a word from the table, and the right
// property selects a bit from that word like this:
//
//   PRIV(ucp_gbtable)[left-property] & (1u << right-property)
//
// The value is non-zero if a grapheme break is NOT permitted between the relevant
// two code points. The breaking rules are as follows:
//
// 1. Break at the start and end of text (pretty obviously).
//
// 2. Do not break between a CR and LF; otherwise, break before and after
//    controls.
//
// 3. Do not break Hangul syllable sequences, the rules for which are:
//
//     L may be followed by L, V, LV or LVT
//     LV or V may be followed by V or T
//     LVT or T may be followed by T
//
// 4. Do not break before extending characters or zero-width-joiner (ZWJ).
//
// The following rules are only for extended grapheme clusters (but that's what we
// are implementing).
//
// 5. Do not break before SpacingMarks.
//
// 6. Do not break after Prepend characters.
//
// 7. Do not break within emoji modifier sequences or emoji zwj sequences. That
//    is, do not break between characters with the Extended_Pictographic property.
//    Extend and ZWJ characters are allowed between the characters; this cannot be
//    represented in this table, the code has to deal with it.
//
// 8. Do not break within emoji flag sequences. That is, do not break between
//    regional indicator (RI) symbols if there are an odd number of RI characters
//    before the break point. This table encodes "join RI characters"; the code
//    has to deal with checking for previous adjoining RIs.
//
// 9. Otherwise, break everywhere.

var X_pcre2_ucp_gbtable_8 = [15]Tuint32_t{
	uint32(1) << ucp_gbLF,
	Tuint32_t(0), //  1 LF
	Tuint32_t(0), //  2 Control
	Tuint32_t(int32(1)<<ucp_gbExtend | int32(1)<<ucp_gbSpacingMark | int32(1)<<ucp_gbZWJ),
	uint32(int32(1)<<ucp_gbExtend|int32(1)<<ucp_gbSpacingMark|int32(1)<<ucp_gbZWJ) | uint32(1)<<ucp_gbPrepend | uint32(1)<<ucp_gbL | uint32(1)<<ucp_gbV | uint32(1)<<ucp_gbT | uint32(1)<<ucp_gbLV | uint32(1)<<ucp_gbLVT | uint32(1)<<ucp_gbOther | uint32(1)<<ucp_gbRegional_Indicator,
	Tuint32_t(int32(1)<<ucp_gbExtend | int32(1)<<ucp_gbSpacingMark | int32(1)<<ucp_gbZWJ),
	uint32(int32(1)<<ucp_gbExtend|int32(1)<<ucp_gbSpacingMark|int32(1)<<ucp_gbZWJ) | uint32(1)<<ucp_gbL | uint32(1)<<ucp_gbV | uint32(1)<<ucp_gbLV | uint32(1)<<ucp_gbLVT,
	uint32(int32(1)<<ucp_gbExtend|int32(1)<<ucp_gbSpacingMark|int32(1)<<ucp_gbZWJ) | uint32(1)<<ucp_gbV | uint32(1)<<ucp_gbT,
	uint32(int32(1)<<ucp_gbExtend|int32(1)<<ucp_gbSpacingMark|int32(1)<<ucp_gbZWJ) | uint32(1)<<ucp_gbT,
	uint32(int32(1)<<ucp_gbExtend|int32(1)<<ucp_gbSpacingMark|int32(1)<<ucp_gbZWJ) | uint32(1)<<ucp_gbV | uint32(1)<<ucp_gbT,
	uint32(int32(1)<<ucp_gbExtend|int32(1)<<ucp_gbSpacingMark|int32(1)<<ucp_gbZWJ) | uint32(1)<<ucp_gbT,
	uint32(1) << ucp_gbRegional_Indicator,
	Tuint32_t(int32(1)<<ucp_gbExtend | int32(1)<<ucp_gbSpacingMark | int32(1)<<ucp_gbZWJ),
	Tuint32_t(int32(1)<<ucp_gbExtend | int32(1)<<ucp_gbSpacingMark | int32(1)<<ucp_gbZWJ),
	uint32(int32(1)<<ucp_gbExtend|int32(1)<<ucp_gbSpacingMark|int32(1)<<ucp_gbZWJ) | uint32(1)<<ucp_gbExtended_Pictographic,
} /* pcre2_tables.c:188:16 */

// Finally, include the tables that are auto-generated from the Unicode data
// files.

// ************************************************
//
//      Perl-Compatible Regular Expressions       *
//

// PCRE is a library of functions to support regular expressions whose syntax
// and semantics are as close as possible to those of the Perl 5 language.
//
//                        Written by Philip Hazel
//      Original API code Copyright (c) 1997-2012 University of Cambridge
//           New API code Copyright (c) 2016-2022 University of Cambridge
//
// This module is auto-generated from Unicode data files. DO NOT EDIT MANUALLY!
// Instead, modify the maint/GenerateUcpTables.py script and run it to generate
// a new version of this code.
//
// -----------------------------------------------------------------------------
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//
//     * Neither the name of the University of Cambridge nor the names of its
//       contributors may be used to endorse or promote products derived from
//       this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
// -----------------------------------------------------------------------------

// The PRIV(utt)[] table below translates Unicode property names into type and
// code values. It is searched by binary chop, so must be in collating sequence of
// name. Originally, the table contained pointers to the name strings in the first
// field of each entry. However, that leads to a large number of relocations when
// a shared library is dynamically loaded. A significant reduction is made by
// putting all the names into a single, large string and using offsets instead.
// All letters are lower cased, and underscores are removed, in accordance with
// the "loose matching" rules that Unicode advises and Perl uses.

var X_pcre2_utt_names_8 = *(*[3569]uint8)(unsafe.Pointer(ts + 7683)) /* pcre2_ucptables.c:543:12 */

var X_pcre2_utt_8 = [486]Tucp_type_table{
	{Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Adlam},
	{Fname_offset: Tuint16_t(6), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Adlam},
	{Fname_offset: Tuint16_t(11), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Caucasian_Albanian},
	{Fname_offset: Tuint16_t(16), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_ASCII_Hex_Digit},
	{Fname_offset: Tuint16_t(21), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Ahom},
	{Fname_offset: Tuint16_t(26), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Alphabetic},
	{Fname_offset: Tuint16_t(32), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Alphabetic},
	{Fname_offset: Tuint16_t(43), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Anatolian_Hieroglyphs},
	{Fname_offset: Tuint16_t(64)},
	{Fname_offset: Tuint16_t(68), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Arabic},
	{Fname_offset: Tuint16_t(73), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Arabic},
	{Fname_offset: Tuint16_t(80), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Armenian},
	{Fname_offset: Tuint16_t(89), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Imperial_Aramaic},
	{Fname_offset: Tuint16_t(94), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Armenian},
	{Fname_offset: Tuint16_t(99), Ftype: Tuint16_t(DPT_BOOL)},
	{Fname_offset: Tuint16_t(105), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_ASCII_Hex_Digit},
	{Fname_offset: Tuint16_t(119), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Avestan},
	{Fname_offset: Tuint16_t(127), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Avestan},
	{Fname_offset: Tuint16_t(132), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Balinese},
	{Fname_offset: Tuint16_t(137), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Balinese},
	{Fname_offset: Tuint16_t(146), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Bamum},
	{Fname_offset: Tuint16_t(151), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Bamum},
	{Fname_offset: Tuint16_t(157), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Bassa_Vah},
	{Fname_offset: Tuint16_t(162), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Bassa_Vah},
	{Fname_offset: Tuint16_t(171), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Batak},
	{Fname_offset: Tuint16_t(177), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Batak},
	{Fname_offset: Tuint16_t(182), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Bengali},
	{Fname_offset: Tuint16_t(187), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Bengali},
	{Fname_offset: Tuint16_t(195), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Bhaiksuki},
	{Fname_offset: Tuint16_t(205), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Bhaiksuki},
	{Fname_offset: Tuint16_t(210), Ftype: Tuint16_t(DPT_BIDICL)},
	{Fname_offset: Tuint16_t(217), Ftype: Tuint16_t(DPT_BIDICL), Fvalue: ucp_bidiAN},
	{Fname_offset: Tuint16_t(224), Ftype: Tuint16_t(DPT_BIDICL), Fvalue: ucp_bidiB},
	{Fname_offset: Tuint16_t(230), Ftype: Tuint16_t(DPT_BIDICL), Fvalue: ucp_bidiBN},
	{Fname_offset: Tuint16_t(237), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Bidi_Control},
	{Fname_offset: Tuint16_t(243), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Bidi_Control},
	{Fname_offset: Tuint16_t(255), Ftype: Tuint16_t(DPT_BIDICL), Fvalue: ucp_bidiCS},
	{Fname_offset: Tuint16_t(262), Ftype: Tuint16_t(DPT_BIDICL), Fvalue: ucp_bidiEN},
	{Fname_offset: Tuint16_t(269), Ftype: Tuint16_t(DPT_BIDICL), Fvalue: ucp_bidiES},
	{Fname_offset: Tuint16_t(276), Ftype: Tuint16_t(DPT_BIDICL), Fvalue: ucp_bidiET},
	{Fname_offset: Tuint16_t(283), Ftype: Tuint16_t(DPT_BIDICL), Fvalue: ucp_bidiFSI},
	{Fname_offset: Tuint16_t(291), Ftype: Tuint16_t(DPT_BIDICL), Fvalue: ucp_bidiL},
	{Fname_offset: Tuint16_t(297), Ftype: Tuint16_t(DPT_BIDICL), Fvalue: ucp_bidiLRE},
	{Fname_offset: Tuint16_t(305), Ftype: Tuint16_t(DPT_BIDICL), Fvalue: ucp_bidiLRI},
	{Fname_offset: Tuint16_t(313), Ftype: Tuint16_t(DPT_BIDICL), Fvalue: ucp_bidiLRO},
	{Fname_offset: Tuint16_t(321), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Bidi_Mirrored},
	{Fname_offset: Tuint16_t(327), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Bidi_Mirrored},
	{Fname_offset: Tuint16_t(340), Ftype: Tuint16_t(DPT_BIDICL), Fvalue: ucp_bidiNSM},
	{Fname_offset: Tuint16_t(348), Ftype: Tuint16_t(DPT_BIDICL), Fvalue: ucp_bidiON},
	{Fname_offset: Tuint16_t(355), Ftype: Tuint16_t(DPT_BIDICL), Fvalue: ucp_bidiPDF},
	{Fname_offset: Tuint16_t(363), Ftype: Tuint16_t(DPT_BIDICL), Fvalue: ucp_bidiPDI},
	{Fname_offset: Tuint16_t(371), Ftype: Tuint16_t(DPT_BIDICL), Fvalue: ucp_bidiR},
	{Fname_offset: Tuint16_t(377), Ftype: Tuint16_t(DPT_BIDICL), Fvalue: ucp_bidiRLE},
	{Fname_offset: Tuint16_t(385), Ftype: Tuint16_t(DPT_BIDICL), Fvalue: ucp_bidiRLI},
	{Fname_offset: Tuint16_t(393), Ftype: Tuint16_t(DPT_BIDICL), Fvalue: ucp_bidiRLO},
	{Fname_offset: Tuint16_t(401), Ftype: Tuint16_t(DPT_BIDICL), Fvalue: ucp_bidiS},
	{Fname_offset: Tuint16_t(407), Ftype: Tuint16_t(DPT_BIDICL), Fvalue: ucp_bidiWS},
	{Fname_offset: Tuint16_t(414), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Bopomofo},
	{Fname_offset: Tuint16_t(419), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Bopomofo},
	{Fname_offset: Tuint16_t(428), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Brahmi},
	{Fname_offset: Tuint16_t(433), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Brahmi},
	{Fname_offset: Tuint16_t(440), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Braille},
	{Fname_offset: Tuint16_t(445), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Braille},
	{Fname_offset: Tuint16_t(453), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Buginese},
	{Fname_offset: Tuint16_t(458), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Buginese},
	{Fname_offset: Tuint16_t(467), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Buhid},
	{Fname_offset: Tuint16_t(472), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Buhid},
	{Fname_offset: Tuint16_t(478), Ftype: Tuint16_t(DPT_GC)},
	{Fname_offset: Tuint16_t(480), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Chakma},
	{Fname_offset: Tuint16_t(485), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Canadian_Aboriginal},
	{Fname_offset: Tuint16_t(504), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Canadian_Aboriginal},
	{Fname_offset: Tuint16_t(509), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Carian},
	{Fname_offset: Tuint16_t(514), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Carian},
	{Fname_offset: Tuint16_t(521), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Cased},
	{Fname_offset: Tuint16_t(527), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Case_Ignorable},
	{Fname_offset: Tuint16_t(541), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Caucasian_Albanian},
	{Fname_offset: Tuint16_t(559), Ftype: Tuint16_t(DPT_PC)},
	{Fname_offset: Tuint16_t(562), Ftype: Tuint16_t(DPT_PC), Fvalue: ucp_Cf},
	{Fname_offset: Tuint16_t(565), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Chakma},
	{Fname_offset: Tuint16_t(572), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Cham},
	{Fname_offset: Tuint16_t(577), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Changes_When_Casefolded},
	{Fname_offset: Tuint16_t(599), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Changes_When_Casemapped},
	{Fname_offset: Tuint16_t(621), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Changes_When_Lowercased},
	{Fname_offset: Tuint16_t(643), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Changes_When_Titlecased},
	{Fname_offset: Tuint16_t(665), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Changes_When_Uppercased},
	{Fname_offset: Tuint16_t(687), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Cherokee},
	{Fname_offset: Tuint16_t(692), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Cherokee},
	{Fname_offset: Tuint16_t(701), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Chorasmian},
	{Fname_offset: Tuint16_t(712), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Chorasmian},
	{Fname_offset: Tuint16_t(717), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Case_Ignorable},
	{Fname_offset: Tuint16_t(720), Ftype: Tuint16_t(DPT_PC), Fvalue: ucp_Cn},
	{Fname_offset: Tuint16_t(723), Ftype: Tuint16_t(DPT_PC), Fvalue: ucp_Co},
	{Fname_offset: Tuint16_t(726), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Common},
	{Fname_offset: Tuint16_t(733), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Coptic},
	{Fname_offset: Tuint16_t(738), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Coptic},
	{Fname_offset: Tuint16_t(745), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Cypro_Minoan},
	{Fname_offset: Tuint16_t(750), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Cypriot},
	{Fname_offset: Tuint16_t(755), Ftype: Tuint16_t(DPT_PC), Fvalue: ucp_Cs},
	{Fname_offset: Tuint16_t(758), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Cuneiform},
	{Fname_offset: Tuint16_t(768), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Changes_When_Casefolded},
	{Fname_offset: Tuint16_t(773), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Changes_When_Casemapped},
	{Fname_offset: Tuint16_t(778), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Changes_When_Lowercased},
	{Fname_offset: Tuint16_t(782), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Changes_When_Titlecased},
	{Fname_offset: Tuint16_t(786), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Changes_When_Uppercased},
	{Fname_offset: Tuint16_t(790), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Cypriot},
	{Fname_offset: Tuint16_t(798), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Cypro_Minoan},
	{Fname_offset: Tuint16_t(810), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Cyrillic},
	{Fname_offset: Tuint16_t(819), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Cyrillic},
	{Fname_offset: Tuint16_t(824), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Dash},
	{Fname_offset: Tuint16_t(829), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Default_Ignorable_Code_Point},
	{Fname_offset: Tuint16_t(855), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Deprecated},
	{Fname_offset: Tuint16_t(859), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Deprecated},
	{Fname_offset: Tuint16_t(870), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Deseret},
	{Fname_offset: Tuint16_t(878), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Devanagari},
	{Fname_offset: Tuint16_t(883), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Devanagari},
	{Fname_offset: Tuint16_t(894), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Default_Ignorable_Code_Point},
	{Fname_offset: Tuint16_t(897), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Diacritic},
	{Fname_offset: Tuint16_t(901), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Diacritic},
	{Fname_offset: Tuint16_t(911), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Dives_Akuru},
	{Fname_offset: Tuint16_t(916), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Dives_Akuru},
	{Fname_offset: Tuint16_t(927), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Dogra},
	{Fname_offset: Tuint16_t(932), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Dogra},
	{Fname_offset: Tuint16_t(938), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Deseret},
	{Fname_offset: Tuint16_t(943), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Duployan},
	{Fname_offset: Tuint16_t(948), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Duployan},
	{Fname_offset: Tuint16_t(957), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Emoji_Modifier_Base},
	{Fname_offset: Tuint16_t(963), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Emoji_Component},
	{Fname_offset: Tuint16_t(969), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Egyptian_Hieroglyphs},
	{Fname_offset: Tuint16_t(974), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Egyptian_Hieroglyphs},
	{Fname_offset: Tuint16_t(994), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Elbasan},
	{Fname_offset: Tuint16_t(999), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Elbasan},
	{Fname_offset: Tuint16_t(1007), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Elymaic},
	{Fname_offset: Tuint16_t(1012), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Elymaic},
	{Fname_offset: Tuint16_t(1020), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Emoji_Modifier},
	{Fname_offset: Tuint16_t(1025), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Emoji},
	{Fname_offset: Tuint16_t(1031), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Emoji_Component},
	{Fname_offset: Tuint16_t(1046), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Emoji_Modifier},
	{Fname_offset: Tuint16_t(1060), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Emoji_Modifier_Base},
	{Fname_offset: Tuint16_t(1078), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Emoji_Presentation},
	{Fname_offset: Tuint16_t(1096), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Emoji_Presentation},
	{Fname_offset: Tuint16_t(1102), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Ethiopic},
	{Fname_offset: Tuint16_t(1107), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Ethiopic},
	{Fname_offset: Tuint16_t(1116), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Extender},
	{Fname_offset: Tuint16_t(1120), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Extended_Pictographic},
	{Fname_offset: Tuint16_t(1141), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Extender},
	{Fname_offset: Tuint16_t(1150), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Extended_Pictographic},
	{Fname_offset: Tuint16_t(1158), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Georgian},
	{Fname_offset: Tuint16_t(1163), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Georgian},
	{Fname_offset: Tuint16_t(1172), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Glagolitic},
	{Fname_offset: Tuint16_t(1177), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Glagolitic},
	{Fname_offset: Tuint16_t(1188), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Gunjala_Gondi},
	{Fname_offset: Tuint16_t(1193), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Masaram_Gondi},
	{Fname_offset: Tuint16_t(1198), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Gothic},
	{Fname_offset: Tuint16_t(1203), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Gothic},
	{Fname_offset: Tuint16_t(1210), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Grantha},
	{Fname_offset: Tuint16_t(1215), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Grantha},
	{Fname_offset: Tuint16_t(1223), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Grapheme_Base},
	{Fname_offset: Tuint16_t(1236), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Grapheme_Extend},
	{Fname_offset: Tuint16_t(1251), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Grapheme_Link},
	{Fname_offset: Tuint16_t(1264), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Grapheme_Base},
	{Fname_offset: Tuint16_t(1271), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Greek},
	{Fname_offset: Tuint16_t(1277), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Greek},
	{Fname_offset: Tuint16_t(1282), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Grapheme_Extend},
	{Fname_offset: Tuint16_t(1288), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Grapheme_Link},
	{Fname_offset: Tuint16_t(1295), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Gujarati},
	{Fname_offset: Tuint16_t(1304), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Gujarati},
	{Fname_offset: Tuint16_t(1309), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Gunjala_Gondi},
	{Fname_offset: Tuint16_t(1322), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Gurmukhi},
	{Fname_offset: Tuint16_t(1331), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Gurmukhi},
	{Fname_offset: Tuint16_t(1336), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Han},
	{Fname_offset: Tuint16_t(1340), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Hangul},
	{Fname_offset: Tuint16_t(1345), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Hangul},
	{Fname_offset: Tuint16_t(1352), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Han},
	{Fname_offset: Tuint16_t(1357), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Hanifi_Rohingya},
	{Fname_offset: Tuint16_t(1372), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Hanunoo},
	{Fname_offset: Tuint16_t(1377), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Hanunoo},
	{Fname_offset: Tuint16_t(1385), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Hatran},
	{Fname_offset: Tuint16_t(1390), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Hatran},
	{Fname_offset: Tuint16_t(1397), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Hebrew},
	{Fname_offset: Tuint16_t(1402), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Hebrew},
	{Fname_offset: Tuint16_t(1409), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Hex_Digit},
	{Fname_offset: Tuint16_t(1413), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Hex_Digit},
	{Fname_offset: Tuint16_t(1422), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Hiragana},
	{Fname_offset: Tuint16_t(1427), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Hiragana},
	{Fname_offset: Tuint16_t(1436), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Anatolian_Hieroglyphs},
	{Fname_offset: Tuint16_t(1441), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Pahawh_Hmong},
	{Fname_offset: Tuint16_t(1446), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Nyiakeng_Puachue_Hmong},
	{Fname_offset: Tuint16_t(1451), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Old_Hungarian},
	{Fname_offset: Tuint16_t(1456), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_ID_Continue},
	{Fname_offset: Tuint16_t(1460), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_ID_Continue},
	{Fname_offset: Tuint16_t(1471), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Ideographic},
	{Fname_offset: Tuint16_t(1476), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Ideographic},
	{Fname_offset: Tuint16_t(1488), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_ID_Start},
	{Fname_offset: Tuint16_t(1492), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_IDS_Binary_Operator},
	{Fname_offset: Tuint16_t(1497), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_IDS_Binary_Operator},
	{Fname_offset: Tuint16_t(1515), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_IDS_Trinary_Operator},
	{Fname_offset: Tuint16_t(1520), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_ID_Start},
	{Fname_offset: Tuint16_t(1528), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_IDS_Trinary_Operator},
	{Fname_offset: Tuint16_t(1547), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Imperial_Aramaic},
	{Fname_offset: Tuint16_t(1563), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Inherited},
	{Fname_offset: Tuint16_t(1573), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Inscriptional_Pahlavi},
	{Fname_offset: Tuint16_t(1594), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Inscriptional_Parthian},
	{Fname_offset: Tuint16_t(1616), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Old_Italic},
	{Fname_offset: Tuint16_t(1621), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Javanese},
	{Fname_offset: Tuint16_t(1626), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Javanese},
	{Fname_offset: Tuint16_t(1635), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Join_Control},
	{Fname_offset: Tuint16_t(1641), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Join_Control},
	{Fname_offset: Tuint16_t(1653), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Kaithi},
	{Fname_offset: Tuint16_t(1660), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Kayah_Li},
	{Fname_offset: Tuint16_t(1665), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Katakana},
	{Fname_offset: Tuint16_t(1670), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Kannada},
	{Fname_offset: Tuint16_t(1678), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Katakana},
	{Fname_offset: Tuint16_t(1687), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Kayah_Li},
	{Fname_offset: Tuint16_t(1695), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Kharoshthi},
	{Fname_offset: Tuint16_t(1700), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Kharoshthi},
	{Fname_offset: Tuint16_t(1711), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Khitan_Small_Script},
	{Fname_offset: Tuint16_t(1729), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Khmer},
	{Fname_offset: Tuint16_t(1735), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Khmer},
	{Fname_offset: Tuint16_t(1740), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Khojki},
	{Fname_offset: Tuint16_t(1745), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Khojki},
	{Fname_offset: Tuint16_t(1752), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Khudawadi},
	{Fname_offset: Tuint16_t(1762), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Khitan_Small_Script},
	{Fname_offset: Tuint16_t(1767), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Kannada},
	{Fname_offset: Tuint16_t(1772), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Kaithi},
	{Fname_offset: Tuint16_t(1777), Ftype: Tuint16_t(DPT_GC), Fvalue: ucp_L},
	{Fname_offset: Tuint16_t(1779), Ftype: Tuint16_t(DPT_LAMP)},
	{Fname_offset: Tuint16_t(1782), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Tai_Tham},
	{Fname_offset: Tuint16_t(1787), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Lao},
	{Fname_offset: Tuint16_t(1791), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Lao},
	{Fname_offset: Tuint16_t(1796), Ftype: Tuint16_t(DPT_SCX)},
	{Fname_offset: Tuint16_t(1802), Ftype: Tuint16_t(DPT_SCX)},
	{Fname_offset: Tuint16_t(1807), Ftype: Tuint16_t(DPT_LAMP)},
	{Fname_offset: Tuint16_t(1810), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Lepcha},
	{Fname_offset: Tuint16_t(1815), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Lepcha},
	{Fname_offset: Tuint16_t(1822), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Limbu},
	{Fname_offset: Tuint16_t(1827), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Limbu},
	{Fname_offset: Tuint16_t(1833), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Linear_A},
	{Fname_offset: Tuint16_t(1838), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Linear_B},
	{Fname_offset: Tuint16_t(1843), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Linear_A},
	{Fname_offset: Tuint16_t(1851), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Linear_B},
	{Fname_offset: Tuint16_t(1859), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Lisu},
	{Fname_offset: Tuint16_t(1864), Ftype: Tuint16_t(DPT_PC), Fvalue: ucp_Ll},
	{Fname_offset: Tuint16_t(1867), Ftype: Tuint16_t(DPT_PC), Fvalue: ucp_Lm},
	{Fname_offset: Tuint16_t(1870), Ftype: Tuint16_t(DPT_PC), Fvalue: ucp_Lo},
	{Fname_offset: Tuint16_t(1873), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Logical_Order_Exception},
	{Fname_offset: Tuint16_t(1877), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Logical_Order_Exception},
	{Fname_offset: Tuint16_t(1899), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Lowercase},
	{Fname_offset: Tuint16_t(1905), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Lowercase},
	{Fname_offset: Tuint16_t(1915), Ftype: Tuint16_t(DPT_PC), Fvalue: ucp_Lt},
	{Fname_offset: Tuint16_t(1918), Ftype: Tuint16_t(DPT_PC), Fvalue: ucp_Lu},
	{Fname_offset: Tuint16_t(1921), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Lycian},
	{Fname_offset: Tuint16_t(1926), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Lycian},
	{Fname_offset: Tuint16_t(1933), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Lydian},
	{Fname_offset: Tuint16_t(1938), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Lydian},
	{Fname_offset: Tuint16_t(1945), Ftype: Tuint16_t(DPT_GC), Fvalue: ucp_M},
	{Fname_offset: Tuint16_t(1947), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Mahajani},
	{Fname_offset: Tuint16_t(1956), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Mahajani},
	{Fname_offset: Tuint16_t(1961), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Makasar},
	{Fname_offset: Tuint16_t(1966), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Makasar},
	{Fname_offset: Tuint16_t(1974), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Malayalam},
	{Fname_offset: Tuint16_t(1984), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Mandaic},
	{Fname_offset: Tuint16_t(1989), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Mandaic},
	{Fname_offset: Tuint16_t(1997), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Manichaean},
	{Fname_offset: Tuint16_t(2002), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Manichaean},
	{Fname_offset: Tuint16_t(2013), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Marchen},
	{Fname_offset: Tuint16_t(2018), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Marchen},
	{Fname_offset: Tuint16_t(2026), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Masaram_Gondi},
	{Fname_offset: Tuint16_t(2039), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Math},
	{Fname_offset: Tuint16_t(2044), Ftype: Tuint16_t(DPT_PC), Fvalue: ucp_Mc},
	{Fname_offset: Tuint16_t(2047), Ftype: Tuint16_t(DPT_PC), Fvalue: ucp_Me},
	{Fname_offset: Tuint16_t(2050), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Medefaidrin},
	{Fname_offset: Tuint16_t(2062), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Medefaidrin},
	{Fname_offset: Tuint16_t(2067), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Meetei_Mayek},
	{Fname_offset: Tuint16_t(2079), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Mende_Kikakui},
	{Fname_offset: Tuint16_t(2084), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Mende_Kikakui},
	{Fname_offset: Tuint16_t(2097), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Meroitic_Cursive},
	{Fname_offset: Tuint16_t(2102), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Meroitic_Hieroglyphs},
	{Fname_offset: Tuint16_t(2107), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Meroitic_Cursive},
	{Fname_offset: Tuint16_t(2123), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Meroitic_Hieroglyphs},
	{Fname_offset: Tuint16_t(2143), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Miao},
	{Fname_offset: Tuint16_t(2148), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Malayalam},
	{Fname_offset: Tuint16_t(2153), Ftype: Tuint16_t(DPT_PC), Fvalue: ucp_Mn},
	{Fname_offset: Tuint16_t(2156), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Modi},
	{Fname_offset: Tuint16_t(2161), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Mongolian},
	{Fname_offset: Tuint16_t(2166), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Mongolian},
	{Fname_offset: Tuint16_t(2176), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Mro},
	{Fname_offset: Tuint16_t(2180), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Mro},
	{Fname_offset: Tuint16_t(2185), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Meetei_Mayek},
	{Fname_offset: Tuint16_t(2190), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Multani},
	{Fname_offset: Tuint16_t(2195), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Multani},
	{Fname_offset: Tuint16_t(2203), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Myanmar},
	{Fname_offset: Tuint16_t(2211), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Myanmar},
	{Fname_offset: Tuint16_t(2216), Ftype: Tuint16_t(DPT_GC), Fvalue: ucp_N},
	{Fname_offset: Tuint16_t(2218), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Nabataean},
	{Fname_offset: Tuint16_t(2228), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Nandinagari},
	{Fname_offset: Tuint16_t(2233), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Nandinagari},
	{Fname_offset: Tuint16_t(2245), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Old_North_Arabian},
	{Fname_offset: Tuint16_t(2250), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Nabataean},
	{Fname_offset: Tuint16_t(2255), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Noncharacter_Code_Point},
	{Fname_offset: Tuint16_t(2261), Ftype: Tuint16_t(DPT_PC), Fvalue: ucp_Nd},
	{Fname_offset: Tuint16_t(2264), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Newa},
	{Fname_offset: Tuint16_t(2269), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_New_Tai_Lue},
	{Fname_offset: Tuint16_t(2279), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Nko},
	{Fname_offset: Tuint16_t(2283), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Nko},
	{Fname_offset: Tuint16_t(2288), Ftype: Tuint16_t(DPT_PC), Fvalue: ucp_Nl},
	{Fname_offset: Tuint16_t(2291), Ftype: Tuint16_t(DPT_PC), Fvalue: ucp_No},
	{Fname_offset: Tuint16_t(2294), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Noncharacter_Code_Point},
	{Fname_offset: Tuint16_t(2316), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Nushu},
	{Fname_offset: Tuint16_t(2321), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Nushu},
	{Fname_offset: Tuint16_t(2327), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Nyiakeng_Puachue_Hmong},
	{Fname_offset: Tuint16_t(2348), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Ogham},
	{Fname_offset: Tuint16_t(2353), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Ogham},
	{Fname_offset: Tuint16_t(2359), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Ol_Chiki},
	{Fname_offset: Tuint16_t(2367), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Ol_Chiki},
	{Fname_offset: Tuint16_t(2372), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Old_Hungarian},
	{Fname_offset: Tuint16_t(2385), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Old_Italic},
	{Fname_offset: Tuint16_t(2395), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Old_North_Arabian},
	{Fname_offset: Tuint16_t(2411), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Old_Permic},
	{Fname_offset: Tuint16_t(2421), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Old_Persian},
	{Fname_offset: Tuint16_t(2432), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Old_Sogdian},
	{Fname_offset: Tuint16_t(2443), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Old_South_Arabian},
	{Fname_offset: Tuint16_t(2459), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Old_Turkic},
	{Fname_offset: Tuint16_t(2469), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Old_Uyghur},
	{Fname_offset: Tuint16_t(2479), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Oriya},
	{Fname_offset: Tuint16_t(2485), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Old_Turkic},
	{Fname_offset: Tuint16_t(2490), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Oriya},
	{Fname_offset: Tuint16_t(2495), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Osage},
	{Fname_offset: Tuint16_t(2501), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Osage},
	{Fname_offset: Tuint16_t(2506), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Osmanya},
	{Fname_offset: Tuint16_t(2511), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Osmanya},
	{Fname_offset: Tuint16_t(2519), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Old_Uyghur},
	{Fname_offset: Tuint16_t(2524), Ftype: Tuint16_t(DPT_GC), Fvalue: ucp_P},
	{Fname_offset: Tuint16_t(2526), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Pahawh_Hmong},
	{Fname_offset: Tuint16_t(2538), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Palmyrene},
	{Fname_offset: Tuint16_t(2543), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Palmyrene},
	{Fname_offset: Tuint16_t(2553), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Pattern_Syntax},
	{Fname_offset: Tuint16_t(2560), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Pattern_Syntax},
	{Fname_offset: Tuint16_t(2574), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Pattern_White_Space},
	{Fname_offset: Tuint16_t(2592), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Pattern_White_Space},
	{Fname_offset: Tuint16_t(2598), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Pau_Cin_Hau},
	{Fname_offset: Tuint16_t(2603), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Pau_Cin_Hau},
	{Fname_offset: Tuint16_t(2613), Ftype: Tuint16_t(DPT_PC), Fvalue: ucp_Pc},
	{Fname_offset: Tuint16_t(2616), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Prepended_Concatenation_Mark},
	{Fname_offset: Tuint16_t(2620), Ftype: Tuint16_t(DPT_PC), Fvalue: ucp_Pd},
	{Fname_offset: Tuint16_t(2623), Ftype: Tuint16_t(DPT_PC), Fvalue: ucp_Pe},
	{Fname_offset: Tuint16_t(2626), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Old_Permic},
	{Fname_offset: Tuint16_t(2631), Ftype: Tuint16_t(DPT_PC), Fvalue: ucp_Pf},
	{Fname_offset: Tuint16_t(2634), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Phags_Pa},
	{Fname_offset: Tuint16_t(2639), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Phags_Pa},
	{Fname_offset: Tuint16_t(2647), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Inscriptional_Pahlavi},
	{Fname_offset: Tuint16_t(2652), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Psalter_Pahlavi},
	{Fname_offset: Tuint16_t(2657), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Phoenician},
	{Fname_offset: Tuint16_t(2662), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Phoenician},
	{Fname_offset: Tuint16_t(2673), Ftype: Tuint16_t(DPT_PC), Fvalue: ucp_Pi},
	{Fname_offset: Tuint16_t(2676), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Miao},
	{Fname_offset: Tuint16_t(2681), Ftype: Tuint16_t(DPT_PC), Fvalue: ucp_Po},
	{Fname_offset: Tuint16_t(2684), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Prepended_Concatenation_Mark},
	{Fname_offset: Tuint16_t(2711), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Inscriptional_Parthian},
	{Fname_offset: Tuint16_t(2716), Ftype: Tuint16_t(DPT_PC), Fvalue: ucp_Ps},
	{Fname_offset: Tuint16_t(2719), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Psalter_Pahlavi},
	{Fname_offset: Tuint16_t(2734), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Coptic},
	{Fname_offset: Tuint16_t(2739), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Inherited},
	{Fname_offset: Tuint16_t(2744), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Quotation_Mark},
	{Fname_offset: Tuint16_t(2750), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Quotation_Mark},
	{Fname_offset: Tuint16_t(2764), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Radical},
	{Fname_offset: Tuint16_t(2772), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Regional_Indicator},
	{Fname_offset: Tuint16_t(2790), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Rejang},
	{Fname_offset: Tuint16_t(2797), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Regional_Indicator},
	{Fname_offset: Tuint16_t(2800), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Rejang},
	{Fname_offset: Tuint16_t(2805), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Hanifi_Rohingya},
	{Fname_offset: Tuint16_t(2810), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Runic},
	{Fname_offset: Tuint16_t(2816), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Runic},
	{Fname_offset: Tuint16_t(2821), Ftype: Tuint16_t(DPT_GC), Fvalue: ucp_S},
	{Fname_offset: Tuint16_t(2823), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Samaritan},
	{Fname_offset: Tuint16_t(2833), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Samaritan},
	{Fname_offset: Tuint16_t(2838), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Old_South_Arabian},
	{Fname_offset: Tuint16_t(2843), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Saurashtra},
	{Fname_offset: Tuint16_t(2848), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Saurashtra},
	{Fname_offset: Tuint16_t(2859), Ftype: Tuint16_t(DPT_PC), Fvalue: ucp_Sc},
	{Fname_offset: Tuint16_t(2862), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Soft_Dotted},
	{Fname_offset: Tuint16_t(2865), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Sentence_Terminal},
	{Fname_offset: Tuint16_t(2882), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_SignWriting},
	{Fname_offset: Tuint16_t(2887), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Sharada},
	{Fname_offset: Tuint16_t(2895), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Shavian},
	{Fname_offset: Tuint16_t(2903), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Shavian},
	{Fname_offset: Tuint16_t(2908), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Sharada},
	{Fname_offset: Tuint16_t(2913), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Siddham},
	{Fname_offset: Tuint16_t(2918), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Siddham},
	{Fname_offset: Tuint16_t(2926), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_SignWriting},
	{Fname_offset: Tuint16_t(2938), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Khudawadi},
	{Fname_offset: Tuint16_t(2943), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Sinhala},
	{Fname_offset: Tuint16_t(2948), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Sinhala},
	{Fname_offset: Tuint16_t(2956), Ftype: Tuint16_t(DPT_PC), Fvalue: ucp_Sk},
	{Fname_offset: Tuint16_t(2959), Ftype: Tuint16_t(DPT_PC), Fvalue: ucp_Sm},
	{Fname_offset: Tuint16_t(2962), Ftype: Tuint16_t(DPT_PC), Fvalue: ucp_So},
	{Fname_offset: Tuint16_t(2965), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Soft_Dotted},
	{Fname_offset: Tuint16_t(2976), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Sogdian},
	{Fname_offset: Tuint16_t(2981), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Sogdian},
	{Fname_offset: Tuint16_t(2989), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Old_Sogdian},
	{Fname_offset: Tuint16_t(2994), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Sora_Sompeng},
	{Fname_offset: Tuint16_t(2999), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Sora_Sompeng},
	{Fname_offset: Tuint16_t(3011), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Soyombo},
	{Fname_offset: Tuint16_t(3016), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Soyombo},
	{Fname_offset: Tuint16_t(3024), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_White_Space},
	{Fname_offset: Tuint16_t(3030), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Sentence_Terminal},
	{Fname_offset: Tuint16_t(3036), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Sundanese},
	{Fname_offset: Tuint16_t(3041), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Sundanese},
	{Fname_offset: Tuint16_t(3051), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Syloti_Nagri},
	{Fname_offset: Tuint16_t(3056), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Syloti_Nagri},
	{Fname_offset: Tuint16_t(3068), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Syriac},
	{Fname_offset: Tuint16_t(3073), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Syriac},
	{Fname_offset: Tuint16_t(3080), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Tagalog},
	{Fname_offset: Tuint16_t(3088), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Tagbanwa},
	{Fname_offset: Tuint16_t(3093), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Tagbanwa},
	{Fname_offset: Tuint16_t(3102), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Tai_Le},
	{Fname_offset: Tuint16_t(3108), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Tai_Tham},
	{Fname_offset: Tuint16_t(3116), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Tai_Viet},
	{Fname_offset: Tuint16_t(3124), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Takri},
	{Fname_offset: Tuint16_t(3129), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Takri},
	{Fname_offset: Tuint16_t(3135), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Tai_Le},
	{Fname_offset: Tuint16_t(3140), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_New_Tai_Lue},
	{Fname_offset: Tuint16_t(3145), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Tamil},
	{Fname_offset: Tuint16_t(3151), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Tamil},
	{Fname_offset: Tuint16_t(3156), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Tangut},
	{Fname_offset: Tuint16_t(3161), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Tangsa},
	{Fname_offset: Tuint16_t(3168), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Tangut},
	{Fname_offset: Tuint16_t(3175), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Tai_Viet},
	{Fname_offset: Tuint16_t(3180), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Telugu},
	{Fname_offset: Tuint16_t(3185), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Telugu},
	{Fname_offset: Tuint16_t(3192), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Terminal_Punctuation},
	{Fname_offset: Tuint16_t(3197), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Terminal_Punctuation},
	{Fname_offset: Tuint16_t(3217), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Tifinagh},
	{Fname_offset: Tuint16_t(3222), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Tagalog},
	{Fname_offset: Tuint16_t(3227), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Thaana},
	{Fname_offset: Tuint16_t(3232), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Thaana},
	{Fname_offset: Tuint16_t(3239), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Thai},
	{Fname_offset: Tuint16_t(3244), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Tibetan},
	{Fname_offset: Tuint16_t(3252), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Tibetan},
	{Fname_offset: Tuint16_t(3257), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Tifinagh},
	{Fname_offset: Tuint16_t(3266), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Tirhuta},
	{Fname_offset: Tuint16_t(3271), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Tirhuta},
	{Fname_offset: Tuint16_t(3279), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Tangsa},
	{Fname_offset: Tuint16_t(3284), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Toto},
	{Fname_offset: Tuint16_t(3289), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Ugaritic},
	{Fname_offset: Tuint16_t(3294), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Ugaritic},
	{Fname_offset: Tuint16_t(3303), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Unified_Ideograph},
	{Fname_offset: Tuint16_t(3309), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Unified_Ideograph},
	{Fname_offset: Tuint16_t(3326), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Unknown},
	{Fname_offset: Tuint16_t(3334), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Uppercase},
	{Fname_offset: Tuint16_t(3340), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Uppercase},
	{Fname_offset: Tuint16_t(3350), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Vai},
	{Fname_offset: Tuint16_t(3354), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Vai},
	{Fname_offset: Tuint16_t(3359), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Variation_Selector},
	{Fname_offset: Tuint16_t(3377), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Vithkuqi},
	{Fname_offset: Tuint16_t(3382), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Vithkuqi},
	{Fname_offset: Tuint16_t(3391), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_Variation_Selector},
	{Fname_offset: Tuint16_t(3394), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Wancho},
	{Fname_offset: Tuint16_t(3401), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Warang_Citi},
	{Fname_offset: Tuint16_t(3406), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Warang_Citi},
	{Fname_offset: Tuint16_t(3417), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Wancho},
	{Fname_offset: Tuint16_t(3422), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_White_Space},
	{Fname_offset: Tuint16_t(3433), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_White_Space},
	{Fname_offset: Tuint16_t(3440), Ftype: Tuint16_t(DPT_ALNUM)},
	{Fname_offset: Tuint16_t(3444), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_XID_Continue},
	{Fname_offset: Tuint16_t(3449), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_XID_Continue},
	{Fname_offset: Tuint16_t(3461), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_XID_Start},
	{Fname_offset: Tuint16_t(3466), Ftype: Tuint16_t(DPT_BOOL), Fvalue: ucp_XID_Start},
	{Fname_offset: Tuint16_t(3475), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Old_Persian},
	{Fname_offset: Tuint16_t(3480), Ftype: Tuint16_t(DPT_PXSPACE)},
	{Fname_offset: Tuint16_t(3484), Ftype: Tuint16_t(DPT_SPACE)},
	{Fname_offset: Tuint16_t(3488), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Cuneiform},
	{Fname_offset: Tuint16_t(3493), Ftype: Tuint16_t(DPT_UCNC)},
	{Fname_offset: Tuint16_t(3497), Ftype: Tuint16_t(DPT_WORD)},
	{Fname_offset: Tuint16_t(3501), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Yezidi},
	{Fname_offset: Tuint16_t(3506), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Yezidi},
	{Fname_offset: Tuint16_t(3513), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Yi},
	{Fname_offset: Tuint16_t(3516), Ftype: Tuint16_t(DPT_SCX), Fvalue: ucp_Yi},
	{Fname_offset: Tuint16_t(3521), Ftype: Tuint16_t(DPT_GC), Fvalue: ucp_Z},
	{Fname_offset: Tuint16_t(3523), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Zanabazar_Square},
	{Fname_offset: Tuint16_t(3539), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Zanabazar_Square},
	{Fname_offset: Tuint16_t(3544), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Inherited},
	{Fname_offset: Tuint16_t(3549), Ftype: Tuint16_t(DPT_PC), Fvalue: ucp_Zl},
	{Fname_offset: Tuint16_t(3552), Ftype: Tuint16_t(DPT_PC), Fvalue: ucp_Zp},
	{Fname_offset: Tuint16_t(3555), Ftype: Tuint16_t(DPT_PC), Fvalue: ucp_Zs},
	{Fname_offset: Tuint16_t(3558), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Common},
	{Fname_offset: Tuint16_t(3563), Ftype: Tuint16_t(DPT_SC), Fvalue: ucp_Unknown},
} /* pcre2_ucptables.c:1031:22 */

var X_pcre2_utt_size_8 Tsize_t = uint64(unsafe.Sizeof(X_pcre2_utt_8)) / uint64(unsafe.Sizeof(Tucp_type_table{})) /* pcre2_ucptables.c:1520:14 */

// End of pcre2_ucptables.c

// End of pcre2_tables.c

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// The tables herein are needed only when UCP support is built, and in PCRE2
// that happens automatically with UTF support. This module should not be
// referenced otherwise, so it should not matter whether it is compiled or not.
// However a comment was received about space saving - maybe the guy linked all
// the modules rather than using a library - so we include a condition to cut out
// the tables when not needed. But don't leave a totally empty module because some
// compilers barf at that. Instead, just supply some small dummy tables.

// Total size: 111116 bytes, block size: 128.

var X_pcre2_unicode_version_8 uintptr = ts + 11252 /* "14.0.0" */ /* pcre2_ucd.c:79:12 */

// When recompiling tables with a new Unicode version, please check the types
// in this structure definition with those in pcre2_internal.h (the actual field
// names will be different).
//
// typedef struct {
// uint8_t property_0;
// uint8_t property_1;
// uint8_t property_2;
// uint8_t property_3;
// int32_t property_4;
// uint16_t property_5;
// uint16_t property_6;
// } ucd_record;

// If the 32-bit library is run in non-32-bit mode, character values greater
// than 0x10ffff may be encountered. For these we set up a special record.

// This table contains lists of characters that are caseless sets of
// more than one character. Each list is terminated by NOTACHAR.

var X_pcre2_ucd_caseless_sets_8 = [112]Tuint32_t{
	DNOTACHAR,
	Tuint32_t(0x0053), Tuint32_t(0x0073), Tuint32_t(0x017f), DNOTACHAR,
	Tuint32_t(0x01c4), Tuint32_t(0x01c5), Tuint32_t(0x01c6), DNOTACHAR,
	Tuint32_t(0x01c7), Tuint32_t(0x01c8), Tuint32_t(0x01c9), DNOTACHAR,
	Tuint32_t(0x01ca), Tuint32_t(0x01cb), Tuint32_t(0x01cc), DNOTACHAR,
	Tuint32_t(0x01f1), Tuint32_t(0x01f2), Tuint32_t(0x01f3), DNOTACHAR,
	Tuint32_t(0x0345), Tuint32_t(0x0399), Tuint32_t(0x03b9), Tuint32_t(0x1fbe), DNOTACHAR,
	Tuint32_t(0x00b5), Tuint32_t(0x039c), Tuint32_t(0x03bc), DNOTACHAR,
	Tuint32_t(0x03a3), Tuint32_t(0x03c2), Tuint32_t(0x03c3), DNOTACHAR,
	Tuint32_t(0x0392), Tuint32_t(0x03b2), Tuint32_t(0x03d0), DNOTACHAR,
	Tuint32_t(0x0398), Tuint32_t(0x03b8), Tuint32_t(0x03d1), Tuint32_t(0x03f4), DNOTACHAR,
	Tuint32_t(0x03a6), Tuint32_t(0x03c6), Tuint32_t(0x03d5), DNOTACHAR,
	Tuint32_t(0x03a0), Tuint32_t(0x03c0), Tuint32_t(0x03d6), DNOTACHAR,
	Tuint32_t(0x039a), Tuint32_t(0x03ba), Tuint32_t(0x03f0), DNOTACHAR,
	Tuint32_t(0x03a1), Tuint32_t(0x03c1), Tuint32_t(0x03f1), DNOTACHAR,
	Tuint32_t(0x0395), Tuint32_t(0x03b5), Tuint32_t(0x03f5), DNOTACHAR,
	Tuint32_t(0x0412), Tuint32_t(0x0432), Tuint32_t(0x1c80), DNOTACHAR,
	Tuint32_t(0x0414), Tuint32_t(0x0434), Tuint32_t(0x1c81), DNOTACHAR,
	Tuint32_t(0x041e), Tuint32_t(0x043e), Tuint32_t(0x1c82), DNOTACHAR,
	Tuint32_t(0x0421), Tuint32_t(0x0441), Tuint32_t(0x1c83), DNOTACHAR,
	Tuint32_t(0x0422), Tuint32_t(0x0442), Tuint32_t(0x1c84), Tuint32_t(0x1c85), DNOTACHAR,
	Tuint32_t(0x042a), Tuint32_t(0x044a), Tuint32_t(0x1c86), DNOTACHAR,
	Tuint32_t(0x0462), Tuint32_t(0x0463), Tuint32_t(0x1c87), DNOTACHAR,
	Tuint32_t(0x1e60), Tuint32_t(0x1e61), Tuint32_t(0x1e9b), DNOTACHAR,
	Tuint32_t(0x03a9), Tuint32_t(0x03c9), Tuint32_t(0x2126), DNOTACHAR,
	Tuint32_t(0x004b), Tuint32_t(0x006b), Tuint32_t(0x212a), DNOTACHAR,
	Tuint32_t(0x00c5), Tuint32_t(0x00e5), Tuint32_t(0x212b), DNOTACHAR,
	Tuint32_t(0x1c88), Tuint32_t(0xa64a), Tuint32_t(0xa64b), DNOTACHAR,
} /* pcre2_ucd.c:114:16 */

// When #included in pcre2test, we don't need the table of digit sets, nor the
// the large main UCD tables.

// This table lists the code points for the '9' characters in each set of
// decimal digits. It is used to ensure that all the digits in a script run come
// from the same set.

var X_pcre2_ucd_digit_sets_8 = [67]Tuint32_t{
	Tuint32_t(66), // Number of subsequent values
	Tuint32_t(0x00039), Tuint32_t(0x00669), Tuint32_t(0x006f9), Tuint32_t(0x007c9), Tuint32_t(0x0096f), Tuint32_t(0x009ef), Tuint32_t(0x00a6f), Tuint32_t(0x00aef),
	Tuint32_t(0x00b6f), Tuint32_t(0x00bef), Tuint32_t(0x00c6f), Tuint32_t(0x00cef), Tuint32_t(0x00d6f), Tuint32_t(0x00def), Tuint32_t(0x00e59), Tuint32_t(0x00ed9),
	Tuint32_t(0x00f29), Tuint32_t(0x01049), Tuint32_t(0x01099), Tuint32_t(0x017e9), Tuint32_t(0x01819), Tuint32_t(0x0194f), Tuint32_t(0x019d9), Tuint32_t(0x01a89),
	Tuint32_t(0x01a99), Tuint32_t(0x01b59), Tuint32_t(0x01bb9), Tuint32_t(0x01c49), Tuint32_t(0x01c59), Tuint32_t(0x0a629), Tuint32_t(0x0a8d9), Tuint32_t(0x0a909),
	Tuint32_t(0x0a9d9), Tuint32_t(0x0a9f9), Tuint32_t(0x0aa59), Tuint32_t(0x0abf9), Tuint32_t(0x0ff19), Tuint32_t(0x104a9), Tuint32_t(0x10d39), Tuint32_t(0x1106f),
	Tuint32_t(0x110f9), Tuint32_t(0x1113f), Tuint32_t(0x111d9), Tuint32_t(0x112f9), Tuint32_t(0x11459), Tuint32_t(0x114d9), Tuint32_t(0x11659), Tuint32_t(0x116c9),
	Tuint32_t(0x11739), Tuint32_t(0x118e9), Tuint32_t(0x11959), Tuint32_t(0x11c59), Tuint32_t(0x11d59), Tuint32_t(0x11da9), Tuint32_t(0x16a69), Tuint32_t(0x16ac9),
	Tuint32_t(0x16b59), Tuint32_t(0x1d7d7), Tuint32_t(0x1d7e1), Tuint32_t(0x1d7eb), Tuint32_t(0x1d7f5), Tuint32_t(0x1d7ff), Tuint32_t(0x1e149), Tuint32_t(0x1e2f9),
	Tuint32_t(0x1e959), Tuint32_t(0x1fbf9),
} /* pcre2_ucd.c:154:16 */

// This vector is a list of script bitsets for the Script Extension property.
// The number of 32-bit words in each bitset is #defined in pcre2_ucp.h as
// ucd_script_sets_item_size.

var X_pcre2_ucd_script_sets_8 = [189]Tuint32_t{
	0x00000000, 0x00000000, 0x00000000,
	0x00000080, 0x00000000, 0x00000000,
	0x00000040, 0x00000000, 0x00000000,
	0x00000000, 0x00004000, 0x00000000,
	0x00000002, 0x00000000, 0x00000000,
	0x00800000, 0x00000000, 0x00000000,
	0x00000001, 0x00000000, 0x00000000,
	0x00000000, 0x00000000, 0x00000001,
	0x00000010, 0x00000000, 0x00000000,
	0x00000008, 0x00000004, 0x00000000,
	0x00000008, 0x40000000, 0x00000000,
	0x00000008, 0x00000040, 0x00000000,
	0x00000018, 0x00000000, 0x00000000,
	0x00000028, 0x00000000, 0x00000000,
	0x000000c0, 0x00000000, 0x00000000,
	0x00c00000, 0x00000000, 0x00000000,
	0x00000000, 0x00000102, 0x00000000,
	0x80000000, 0x00000001, 0x00000000,
	0x00000004, 0x00000008, 0x00000000,
	0x00000005, 0x00000000, 0x00000000,
	0x00000004, 0x00200000, 0x00000000,
	0x00000014, 0x00000000, 0x00000000,
	0x00000040, 0x00008000, 0x00000000,
	0x00000040, 0x00000000, 0x00000001,
	0x00000040, 0x00001000, 0x00000000,
	0x00000840, 0x00000000, 0x00000000,
	0x00020001, 0x00000000, 0x00000000,
	0x00000800, 0x00008000, 0x00000000,
	0x00000200, 0x00010000, 0x00000000,
	0x00000100, 0x02000000, 0x00000000,
	0x00800001, 0x00000000, 0x00000000,
	0x00300000, 0x00000000, 0x00000000,
	0x00002000, 0x00000000, 0x00000001,
	0x00080001, 0x00000000, 0x00000000,
	0x00000000, 0x00080000, 0x00000008,
	0x00080000, 0x00000020, 0x00000000,
	0x00000038, 0x00000000, 0x00000000,
	0x00000028, 0x00000000, 0x00000002,
	0x00000080, 0x00000810, 0x00000000,
	0x40010000, 0x00000800, 0x00000000,
	0x80000000, 0x00000001, 0x00000004,
	0x80000000, 0x00020001, 0x00000000,
	0x00002040, 0x00008000, 0x00000000,
	0x00000041, 0x00008000, 0x00000000,
	0x00b00000, 0x00000000, 0x00000000,
	0x00010001, 0x00000080, 0x00000000,
	0x000020c0, 0x00008000, 0x00000000,
	0x1e000000, 0x00000000, 0x00000000,
	0x00000040, 0x10040200, 0x00000000,
	0x00f40000, 0x00000000, 0x00000000,
	0x00000038, 0x40000040, 0x00000002,
	0x01f40000, 0x00000000, 0x00000000,
	0x00007c40, 0x00000000, 0x00000000,
	0x00000038, 0x44000040, 0x00000002,
	0x000034c0, 0x01008000, 0x00000001,
	0x00000018, 0xc4480400, 0x00000008,
	0x00000340, 0x11952200, 0x00000000,
	0x00007fc1, 0x01008000, 0x00000000,
	0x00007fc1, 0x01009000, 0x00000000,
	0x00002340, 0x11952200, 0x00000001,
	0x00006340, 0x11952200, 0x00000001,
	0x0000ffc0, 0x3984a010, 0x00000001,
	0x2000ffc0, 0x3984a010, 0x00000001,
} /* pcre2_ucd.c:171:16 */

// This vector is a list of bitsets for Boolean properties. The number of
// 32_bit words in each bitset is #defined as ucd_boolprop_sets_item_size in
// pcre2_ucp.h.

var X_pcre2_ucd_boolprop_sets_8 = [354]Tuint32_t{
	0x00000000, 0x00000000,
	0x00000001, 0x00000000,
	0x00000001, 0x00020040,
	0x00800001, 0x00020040,
	0x00800001, 0x00002820,
	0x00800001, 0x00000120,
	0x00830001, 0x00000020,
	0x00800001, 0x00000020,
	0x00800021, 0x00000120,
	0x00800011, 0x00000020,
	0x00800001, 0x00000028,
	0x00800001, 0x00002020,
	0x00801001, 0x00000020,
	0x00800021, 0x00002820,
	0x24830003, 0x00040000,
	0x00800021, 0x00002020,
	0x00800011, 0x00000028,
	0x648003c7, 0x000c8000,
	0x608003c5, 0x000c8000,
	0x00808021, 0x00000028,
	0x20800001, 0x00040000,
	0x00808021, 0x00000020,
	0x64800d47, 0x000c0004,
	0x60800d45, 0x000c0004,
	0x60800d45, 0x000c1004,
	0x00000000, 0x00020040,
	0x00800000, 0x00020000,
	0x00800000, 0x00000020,
	0x00808020, 0x00000000,
	0x00a10000, 0x00000020,
	0x60800044, 0x000c0004,
	0x00800010, 0x00000120,
	0x00800000, 0x00000028,
	0x00002020, 0x00000000,
	0x00800000, 0x00000000,
	0x60800dc4, 0x000c0004,
	0x20c08020, 0x00040000,
	0x608003c4, 0x000c8000,
	0x60800d44, 0x000c0004,
	0x60800d44, 0x000c1004,
	0x60804dc4, 0x000c0004,
	0x60800004, 0x000c0000,
	0x608007c4, 0x000c8000,
	0x60800bc4, 0x000c0000,
	0x60808064, 0x000c0004,
	0x60808064, 0x000c1004,
	0x60808024, 0x000c0000,
	0x60c08024, 0x000c0000,
	0x21008020, 0x00040000,
	0x21008de4, 0x00040004,
	0x21002020, 0x00040000,
	0x21000020, 0x00040000,
	0x60808064, 0x00000004,
	0x00800000, 0x00002000,
	0x20800020, 0x00042000,
	0x60800dc4, 0x000c000c,
	0x60800044, 0x000c8008,
	0x60800044, 0x000c8000,
	0x608003c4, 0x000c8008,
	0x00800000, 0x00000008,
	0x01000020, 0x00000000,
	0x00800020, 0x00000000,
	0x00800000, 0x00002800,
	0x00801000, 0x00000000,
	0x21008024, 0x00040000,
	0x21000024, 0x00040000,
	0x00000020, 0x00000080,
	0x00002028, 0x00000000,
	0x60c00024, 0x000c0000,
	0x20800000, 0x00040000,
	0x60804004, 0x000c0000,
	0x60800024, 0x000c0000,
	0x20800004, 0x00040000,
	0x23008020, 0x00040000,
	0x21000004, 0x00040000,
	0x21408020, 0x00040000,
	0x60800004, 0x00040000,
	0x23000024, 0x00040000,
	0x60800004, 0x000c0002,
	0x00800010, 0x00000000,
	0x20808000, 0x00040000,
	0x21004024, 0x00040000,
	0x20808004, 0x00040000,
	0x60800944, 0x000c0004,
	0x60802004, 0x000c0000,
	0x60800344, 0x000c8000,
	0x22808000, 0x00040000,
	0x22800000, 0x00040000,
	0x00c00000, 0x00000000,
	0x21002020, 0x00050000,
	0x61000024, 0x000c0000,
	0x23000020, 0x00040000,
	0x01008020, 0x00000000,
	0x21408024, 0x00040000,
	0x00808000, 0x00000000,
	0x60800064, 0x000c0004,
	0x60800044, 0x000c1004,
	0x60800064, 0x000c1004,
	0x01002020, 0x00000001,
	0x00022020, 0x00000001,
	0x00002028, 0x00000040,
	0x00801000, 0x00000020,
	0x00800020, 0x00000120,
	0x00800000, 0x00000120,
	0x00800020, 0x00000020,
	0x00a10000, 0x00002820,
	0x00800000, 0x00002820,
	0x20800000, 0x00040008,
	0x00800010, 0x00000020,
	0x00002020, 0x00000008,
	0x00002000, 0x00000000,
	0x00006020, 0x00000000,
	0x00801000, 0x00000008,
	0x00800010, 0x00000008,
	0x21000020, 0x00040008,
	0x01020020, 0x00000000,
	0x60800044, 0x000c000c,
	0x60800000, 0x000c0008,
	0x00a10000, 0x00000000,
	0x60800000, 0x000c0000,
	0x60800004, 0x000c0008,
	0x60a10044, 0x000c0004,
	0x60800044, 0x000c100c,
	0x00a10000, 0x00000028,
	0x00800010, 0x00000028,
	0x00801000, 0x00000028,
	0x00b10000, 0x00000020,
	0x00804010, 0x00000020,
	0x00a00000, 0x00000020,
	0x00000000, 0x00000020,
	0x008003c4, 0x00008000,
	0x00a103c4, 0x00008000,
	0x00800d44, 0x00000004,
	0x00b10000, 0x00000028,
	0x00a00000, 0x00000028,
	0x00a90000, 0x00000020,
	0x00b90000, 0x00000020,
	0x00808024, 0x00000020,
	0x00800000, 0x00002020,
	0x00800000, 0x00000200,
	0x08800000, 0x00000000,
	0x10800000, 0x00000000,
	0xe0800004, 0x000c0000,
	0x21008000, 0x00040000,
	0x00a11000, 0x00000020,
	0x60808020, 0x00000000,
	0xe0800004, 0x000c4000,
	0x60808004, 0x000c0000,
	0x60800004, 0x00000000,
	0x00000000, 0x00000010,
	0x21022020, 0x00050000,
	0x00800000, 0x00000100,
	0x00800020, 0x00002800,
	0x00800020, 0x00002000,
	0x00800020, 0x00000100,
	0x24800000, 0x00040000,
	0x648003c4, 0x000c8000,
	0x00808020, 0x00000008,
	0x64800d44, 0x000c0004,
	0x00800010, 0x00000100,
	0x61008024, 0x00040000,
	0x00000020, 0x00000000,
	0x60c00004, 0x000c0000,
	0x21400020, 0x00040000,
	0xa1000020, 0x00040000,
	0x21000000, 0x00040000,
	0x00a00000, 0x00000000,
	0x00b10000, 0x00000000,
	0x00200000, 0x00000000,
	0x00800044, 0x00008000,
	0x00a10044, 0x00008000,
	0x00930000, 0x00000400,
	0x00b90000, 0x00000000,
	0x00a90000, 0x00000000,
	0x00970020, 0x00000000,
	0x00b30000, 0x00000000,
	0x01022020, 0x00000000,
} /* pcre2_ucd.c:241:16 */

// These are the main two-stage UCD tables. The fields in each record are:
// script (8 bits), character type (8 bits), grapheme break property (8 bits),
// offset to multichar other cases or zero (8 bits), offset to other case or zero
// (32 bits, signed), bidi class (5 bits) and script extension (11 bits) packed
// into a 16-bit field, and offset in binary properties table (16 bits).

var X_pcre2_ucd_records_8 = [1409]Tucd_record{ // 16908 bytes, record size 12
	{Fscript: Tuint8_t(69), Fgbprop: Tuint8_t(2), Fscriptx_bidiclass: Tuint16_t(6144), Fbprops: Tuint16_t(2)},                                                                         //   0
	{Fscript: Tuint8_t(69), Fgbprop: Tuint8_t(2), Fscriptx_bidiclass: Tuint16_t(43008), Fbprops: Tuint16_t(4)},                                                                        //   1
	{Fscript: Tuint8_t(69), Fgbprop: Tuint8_t(1), Fscriptx_bidiclass: Tuint16_t(4096), Fbprops: Tuint16_t(4)},                                                                         //   2
	{Fscript: Tuint8_t(69), Fgbprop: Tuint8_t(2), Fscriptx_bidiclass: Tuint16_t(45056), Fbprops: Tuint16_t(4)},                                                                        //   3
	{Fscript: Tuint8_t(69), Fscriptx_bidiclass: Tuint16_t(4096), Fbprops: Tuint16_t(4)},                                                                                               //   4
	{Fscript: Tuint8_t(69), Fgbprop: Tuint8_t(2), Fscriptx_bidiclass: Tuint16_t(4096), Fbprops: Tuint16_t(2)},                                                                         //   5
	{Fscript: Tuint8_t(69), Fgbprop: Tuint8_t(2), Fscriptx_bidiclass: Tuint16_t(43008), Fbprops: Tuint16_t(2)},                                                                        //   6
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(29), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(45056), Fbprops: Tuint16_t(6)},                                              //   7
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(8)},                                              //   8
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(10)},                                             //   9
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(14336), Fbprops: Tuint16_t(12)},                                             //  10
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(23), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(14336), Fbprops: Tuint16_t(14)},                                             //  11
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(14336), Fbprops: Tuint16_t(14)},                                             //  12
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(14)},                                             //  13
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(16)},                                             //  14
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(22), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(18)},                                             //  15
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(18), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(18)},                                             //  16
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(12)},                                             //  17
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(25), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(12288), Fbprops: Tuint16_t(20)},                                             //  18
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(8192), Fbprops: Tuint16_t(22)},                                              //  19
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(17), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(12288), Fbprops: Tuint16_t(24)},                                             //  20
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(8192), Fbprops: Tuint16_t(26)},                                              //  21
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(8192), Fbprops: Tuint16_t(14)},                                              //  22
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(10240), Fbprops: Tuint16_t(28)},                                             //  23
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(8192), Fbprops: Tuint16_t(30)},                                              //  24
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(22)},                                             //  25
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(25), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(32)},                                             //  26
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(25), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(20)},                                             //  27
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(34)},                                                    //  28
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(36)},                                                    //  29
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(100), Fother_case: 32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(36)},                           //  30
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(1), Fother_case: 32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(36)},                             //  31
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(24), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(38)},                                             //  32
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(16), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(40)},                                             //  33
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(24), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(42)},                                             //  34
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(44)},                                                   //  35
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(46)},                                                   //  36
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(48)},                                                   //  37
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(100), Fother_case: -32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(46)},                          //  38
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(1), Fother_case: -32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(46)},                            //  39
	{Fscript: Tuint8_t(69), Fgbprop: Tuint8_t(2), Fscriptx_bidiclass: Tuint16_t(6144)},                                                                                                //  40
	{Fscript: Tuint8_t(69), Fgbprop: Tuint8_t(2), Fscriptx_bidiclass: Tuint16_t(4096), Fbprops: Tuint16_t(50)},                                                                        //  41
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(29), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(8192), Fbprops: Tuint16_t(52)},                                              //  42
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(54)},                                             //  43
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(23), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(14336), Fbprops: Tuint16_t(54)},                                             //  44
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(54)},                                             //  45
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(24), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(56)},                                             //  46
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(14), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(58)},                                             //  47
	{Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(60)},                                                                     //  48
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(20), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(62)},                                             //  49
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(25), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(64)},                                             //  50
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(1), Fgbprop: Tuint8_t(2), Fscriptx_bidiclass: Tuint16_t(6144), Fbprops: Tuint16_t(66)},                                                //  51
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(14336), Fbprops: Tuint16_t(54)},                                             //  52
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(25), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(14336), Fbprops: Tuint16_t(64)},                                             //  53
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(10240), Fbprops: Tuint16_t(68)},                                             //  54
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(26), Fother_case: 775, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(70)},    //  55
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(72)},                                             //  56
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(19), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(62)},                                             //  57
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(68)},                                             //  58
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                    //  59
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(104), Fother_case: 32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                           //  60
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: 7615, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(70)},                                                  //  61
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                   //  62
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(104), Fother_case: -32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                          //  63
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: 121, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                   //  64
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 1, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                     //  65
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -1, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                    //  66
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -1, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(78)},                                                    //  67
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                                     //  68
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                                     //  69
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(60)},                                                                     //  70
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(80)},                                                                     //  71
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: -121, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                  //  72
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(1), Fother_case: -268, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(70)},                           //  73
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: 195, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                   //  74
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 210, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                   //  75
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 206, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                   //  76
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 205, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                   //  77
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 79, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                    //  78
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 202, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                   //  79
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 203, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                   //  80
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 207, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                   //  81
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: 97, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                    //  82
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 211, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                   //  83
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 209, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                   //  84
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: 163, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                   //  85
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 213, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                   //  86
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: 130, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                   //  87
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 214, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                   //  88
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 218, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                   //  89
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 217, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                   //  90
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 219, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                   //  91
	{Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                                                     //  92
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: 56, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                    //  93
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(5), Fother_case: 2, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(84)},                              //  94
	{Fchartype: Tuint8_t(8), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(5), Fother_case: 1, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(86)},                              //  95
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(5), Fother_case: -2, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                             //  96
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(9), Fother_case: 2, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(84)},                              //  97
	{Fchartype: Tuint8_t(8), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(9), Fother_case: 1, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(86)},                              //  98
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(9), Fother_case: -2, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                             //  99
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(13), Fother_case: 2, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(84)},                             // 100
	{Fchartype: Tuint8_t(8), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(13), Fother_case: 1, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(86)},                             // 101
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(13), Fother_case: -2, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                            // 102
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -79, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                   // 103
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(17), Fother_case: 2, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(84)},                             // 104
	{Fchartype: Tuint8_t(8), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(17), Fother_case: 1, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(86)},                             // 105
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(17), Fother_case: -2, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                            // 106
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: -97, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                   // 107
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: -56, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                   // 108
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: -130, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                  // 109
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 10795, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                 // 110
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: -163, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                  // 111
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 10792, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                 // 112
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: 10815, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                 // 113
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: -195, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                  // 114
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 69, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                    // 115
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 71, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                    // 116
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: 10783, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                 // 117
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: 10780, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                 // 118
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: 10782, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                 // 119
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -210, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                  // 120
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -206, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                  // 121
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -205, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                  // 122
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -202, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                  // 123
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -203, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                  // 124
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: 42319, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                 // 125
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: 42315, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                 // 126
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -207, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                  // 127
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: 42280, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                 // 128
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: 42308, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                 // 129
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -209, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(78)},                                                  // 130
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -211, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                  // 131
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: 10743, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                 // 132
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: 42305, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                 // 133
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: 10749, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                 // 134
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -213, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                  // 135
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -214, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                  // 136
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: 10727, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                 // 137
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -218, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                  // 138
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: 42307, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                 // 139
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: 42282, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                 // 140
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -69, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                   // 141
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -217, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                  // 142
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -71, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                   // 143
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -219, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                  // 144
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: 42261, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(78)},                                                 // 145
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: 42258, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                 // 146
	{Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(88)},                                                                     // 147
	{Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(90)},                                                                     // 148
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(92)},                                              // 149
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(92)},                                              // 150
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(88)},                                              // 151
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(94)},                                              // 152
	{Fscript: Tuint8_t(22), Fchartype: Tuint8_t(24), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(56)},                                             // 153
	{Fscript: Tuint8_t(84), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                              // 154
	{Fscript: Tuint8_t(84), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26636), Fbprops: Tuint16_t(96)},                                              // 155
	{Fscript: Tuint8_t(84), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fcaseset: Tuint8_t(21), Fother_case: 116, Fscriptx_bidiclass: Tuint16_t(26636), Fbprops: Tuint16_t(98)},    // 156
	{Fscript: Tuint8_t(84), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(100)},                                             // 157
	{Fscript: Tuint8_t(84), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(102)},                                             // 158
	{Fscript: Tuint8_t(84), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26642), Fbprops: Tuint16_t(102)},                                             // 159
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 1, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                               // 160
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -1, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                              // 161
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(24), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(56)},                                              // 162
	{Fscript: Tuint8_t(68), Fchartype: Tuint8_t(2), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432)},                                                                      // 163
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(104)},                                              // 164
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: 130, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                             // 165
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(106)},                                            // 166
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 116, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                             // 167
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 38, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                              // 168
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(108)},                                            // 169
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 37, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                              // 170
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 64, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                              // 171
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 63, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                              // 172
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                               // 173
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                              // 174
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(34), Fother_case: 32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},      // 175
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(59), Fother_case: 32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},      // 176
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(38), Fother_case: 32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},      // 177
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(21), Fother_case: 32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},      // 178
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(51), Fother_case: 32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},      // 179
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(26), Fother_case: 32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},      // 180
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(47), Fother_case: 32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},      // 181
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(55), Fother_case: 32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},      // 182
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(30), Fother_case: 32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},      // 183
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(43), Fother_case: 32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},      // 184
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(96), Fother_case: 32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},      // 185
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -38, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                             // 186
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -37, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                             // 187
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                             // 188
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(34), Fother_case: -32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},     // 189
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(59), Fother_case: -32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},     // 190
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(38), Fother_case: -32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},     // 191
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(21), Fother_case: -116, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},    // 192
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(51), Fother_case: -32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},     // 193
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(26), Fother_case: -775, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},    // 194
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(47), Fother_case: -32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},     // 195
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(55), Fother_case: -32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},     // 196
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(30), Fother_case: 1, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(70)},       // 197
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(30), Fother_case: -32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},     // 198
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(43), Fother_case: -32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},     // 199
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(96), Fother_case: -32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},     // 200
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -64, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                             // 201
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -63, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                             // 202
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 8, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                               // 203
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(34), Fother_case: -30, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(110)},    // 204
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(38), Fother_case: -25, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(110)},    // 205
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(112)},                                              // 206
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(114)},                                              // 207
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(43), Fother_case: -15, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(110)},    // 208
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(47), Fother_case: -22, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(70)},     // 209
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -8, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                              // 210
	{Fscript: Tuint8_t(34), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 1, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                              // 211
	{Fscript: Tuint8_t(34), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -1, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                             // 212
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(51), Fother_case: -54, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(110)},    // 213
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(55), Fother_case: -48, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(110)},    // 214
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: 7, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                               // 215
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -116, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(78)},                            // 216
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(38), Fother_case: -60, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(116)},    // 217
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(59), Fother_case: -64, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(110)},    // 218
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(25), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(118)},                                             // 219
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: -7, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                              // 220
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(60)},                                               // 221
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: -130, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                            // 222
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 80, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                              // 223
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                              // 224
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(63), Fother_case: 32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},      // 225
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(67), Fother_case: 32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},      // 226
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(71), Fother_case: 32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},      // 227
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(75), Fother_case: 32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},      // 228
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(79), Fother_case: 32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},      // 229
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(84), Fother_case: 32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},      // 230
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                             // 231
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(63), Fother_case: -32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},     // 232
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(67), Fother_case: -32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},     // 233
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(71), Fother_case: -32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},     // 234
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(75), Fother_case: -32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},     // 235
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(79), Fother_case: -32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},     // 236
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(84), Fother_case: -32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},     // 237
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -80, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                             // 238
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -80, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(78)},                             // 239
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 1, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                               // 240
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -1, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                              // 241
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(88), Fother_case: 1, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},       // 242
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(88), Fother_case: -1, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},      // 243
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                              // 244
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26684), Fbprops: Tuint16_t(96)},                                               // 245
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26678), Fbprops: Tuint16_t(96)},                                               // 246
	{Fscript: Tuint8_t(84), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26681), Fbprops: Tuint16_t(96)},                                              // 247
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(11), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(120)},                                              // 248
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 15, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                              // 249
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -15, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                             // 250
	{Fscript: Tuint8_t(70), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 48, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                             // 251
	{Fscript: Tuint8_t(70), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(92)},                                              // 252
	{Fscript: Tuint8_t(70), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 253
	{Fscript: Tuint8_t(70), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(122)},                                            // 254
	{Fscript: Tuint8_t(70), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(60)},                                              // 255
	{Fscript: Tuint8_t(70), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -48, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                            // 256
	{Fscript: Tuint8_t(70), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(70)},                                              // 257
	{Fscript: Tuint8_t(70), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(124)},                                            // 258
	{Fscript: Tuint8_t(70), Fchartype: Tuint8_t(17), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(126)},                                            // 259
	{Fscript: Tuint8_t(70), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(68)},                                             // 260
	{Fscript: Tuint8_t(70), Fchartype: Tuint8_t(23), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(14336), Fbprops: Tuint16_t(68)},                                             // 261
	{Fscript: Tuint8_t(68), Fchartype: Tuint8_t(2), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816)},                                                                      // 262
	{Fscript: Tuint8_t(71), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                              // 263
	{Fscript: Tuint8_t(71), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(102)},                                             // 264
	{Fscript: Tuint8_t(71), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(128)},                                             // 265
	{Fscript: Tuint8_t(71), Fchartype: Tuint8_t(17), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(126)},                                            // 266
	{Fscript: Tuint8_t(71), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(68)},                                             // 267
	{Fscript: Tuint8_t(71), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(106)},                                            // 268
	{Fscript: Tuint8_t(71), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 269
	{Fscript: Tuint8_t(71), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(82)},                                              // 270
	{Fscript: Tuint8_t(71), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(122)},                                            // 271
	{Fscript: Tuint8_t(3), Fchartype: Tuint8_t(1), Fgbprop: Tuint8_t(4), Fscriptx_bidiclass: Tuint16_t(2048), Fbprops: Tuint16_t(132)},                                                // 272
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(1), Fgbprop: Tuint8_t(4), Fscriptx_bidiclass: Tuint16_t(2048), Fbprops: Tuint16_t(132)},                                               // 273
	{Fscript: Tuint8_t(3), Fchartype: Tuint8_t(25), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(118)},                                             // 274
	{Fscript: Tuint8_t(3), Fchartype: Tuint8_t(25), Fgbprop: Tuint8_t(12), Fbprops: Tuint16_t(118)},                                                                                   // 275
	{Fscript: Tuint8_t(3), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(14336), Fbprops: Tuint16_t(68)},                                              // 276
	{Fscript: Tuint8_t(3), Fchartype: Tuint8_t(23), Fgbprop: Tuint8_t(12), Fbprops: Tuint16_t(68)},                                                                                    // 277
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(8342), Fbprops: Tuint16_t(106)},                                             // 278
	{Fscript: Tuint8_t(3), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fbprops: Tuint16_t(68)},                                                                                    // 279
	{Fscript: Tuint8_t(3), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(68)},                                              // 280
	{Fscript: Tuint8_t(3), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                              // 281
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(150), Fbprops: Tuint16_t(106)},                                              // 282
	{Fscript: Tuint8_t(3), Fchartype: Tuint8_t(1), Fgbprop: Tuint8_t(2), Fscriptx_bidiclass: Tuint16_t(108), Fbprops: Tuint16_t(134)},                                                 // 283
	{Fscript: Tuint8_t(3), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fbprops: Tuint16_t(124)},                                                                                   // 284
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(159), Fbprops: Tuint16_t(124)},                                              // 285
	{Fscript: Tuint8_t(3), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fbprops: Tuint16_t(82)},                                                                                     // 286
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(165), Fbprops: Tuint16_t(136)},                                               // 287
	{Fscript: Tuint8_t(84), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26660), Fbprops: Tuint16_t(128)},                                             // 288
	{Fscript: Tuint8_t(84), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26660), Fbprops: Tuint16_t(130)},                                             // 289
	{Fscript: Tuint8_t(3), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(128)},                                              // 290
	{Fscript: Tuint8_t(3), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                               // 291
	{Fscript: Tuint8_t(3), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(2159), Fbprops: Tuint16_t(138)},                                              // 292
	{Fscript: Tuint8_t(3), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(2048), Fbprops: Tuint16_t(68)},                                               // 293
	{Fscript: Tuint8_t(3), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fbprops: Tuint16_t(140)},                                                                                    // 294
	{Fscript: Tuint8_t(3), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(30), Fbprops: Tuint16_t(124)},                                                // 295
	{Fscript: Tuint8_t(3), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fbprops: Tuint16_t(92)},                                                                                     // 296
	{Fscript: Tuint8_t(3), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(10240), Fbprops: Tuint16_t(138)},                                             // 297
	{Fscript: Tuint8_t(3), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fbprops: Tuint16_t(68)},                                                                                    // 298
	{Fscript: Tuint8_t(4), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fbprops: Tuint16_t(124)},                                                                                   // 299
	{Fscript: Tuint8_t(4), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fbprops: Tuint16_t(106)},                                                                                   // 300
	{Fscript: Tuint8_t(4), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fbprops: Tuint16_t(68)},                                                                                    // 301
	{Fscript: Tuint8_t(68), Fchartype: Tuint8_t(2), Fgbprop: Tuint8_t(12)},                                                                                                            // 302
	{Fscript: Tuint8_t(4), Fchartype: Tuint8_t(1), Fgbprop: Tuint8_t(4), Fbprops: Tuint16_t(132)},                                                                                     // 303
	{Fscript: Tuint8_t(4), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fbprops: Tuint16_t(82)},                                                                                     // 304
	{Fscript: Tuint8_t(4), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                              // 305
	{Fscript: Tuint8_t(4), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(128)},                                              // 306
	{Fscript: Tuint8_t(4), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                               // 307
	{Fscript: Tuint8_t(5), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fbprops: Tuint16_t(82)},                                                                                     // 308
	{Fscript: Tuint8_t(5), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(128)},                                              // 309
	{Fscript: Tuint8_t(38), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(138)},                                            // 310
	{Fscript: Tuint8_t(38), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(82)},                                              // 311
	{Fscript: Tuint8_t(38), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                              // 312
	{Fscript: Tuint8_t(38), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(92)},                                              // 313
	{Fscript: Tuint8_t(38), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(68)},                                             // 314
	{Fscript: Tuint8_t(38), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(68)},                                             // 315
	{Fscript: Tuint8_t(38), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(106)},                                            // 316
	{Fscript: Tuint8_t(38), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(124)},                                            // 317
	{Fscript: Tuint8_t(38), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(136)},                                             // 318
	{Fscript: Tuint8_t(38), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(102)},                                             // 319
	{Fscript: Tuint8_t(38), Fchartype: Tuint8_t(23), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(68)},                                             // 320
	{Fscript: Tuint8_t(110), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(82)},                                             // 321
	{Fscript: Tuint8_t(110), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                            // 322
	{Fscript: Tuint8_t(110), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                             // 323
	{Fscript: Tuint8_t(110), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(142)},                                            // 324
	{Fscript: Tuint8_t(110), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(102)},                                            // 325
	{Fscript: Tuint8_t(110), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(106)},                                           // 326
	{Fscript: Tuint8_t(110), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(124)},                                           // 327
	{Fscript: Tuint8_t(42), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(82)},                                              // 328
	{Fscript: Tuint8_t(42), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(102)},                                             // 329
	{Fscript: Tuint8_t(42), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(106)},                                            // 330
	{Fscript: Tuint8_t(3), Fchartype: Tuint8_t(24), Fgbprop: Tuint8_t(12), Fbprops: Tuint16_t(122)},                                                                                   // 331
	{Fscript: Tuint8_t(3), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(102)},                                              // 332
	{Fscript: Tuint8_t(6), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                              // 333
	{Fscript: Tuint8_t(6), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                              // 334
	{Fscript: Tuint8_t(6), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                               // 335
	{Fscript: Tuint8_t(6), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                               // 336
	{Fscript: Tuint8_t(6), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(146)},                                              // 337
	{Fscript: Tuint8_t(84), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26798), Fbprops: Tuint16_t(96)},                                              // 338
	{Fscript: Tuint8_t(84), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26795), Fbprops: Tuint16_t(96)},                                              // 339
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18615), Fbprops: Tuint16_t(124)},                                            // 340
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18618), Fbprops: Tuint16_t(124)},                                            // 341
	{Fscript: Tuint8_t(6), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18576), Fbprops: Tuint16_t(138)},                                             // 342
	{Fscript: Tuint8_t(6), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                              // 343
	{Fscript: Tuint8_t(6), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(92)},                                               // 344
	{Fscript: Tuint8_t(7), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                               // 345
	{Fscript: Tuint8_t(7), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                              // 346
	{Fscript: Tuint8_t(7), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                              // 347
	{Fscript: Tuint8_t(7), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                               // 348
	{Fscript: Tuint8_t(7), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(148)},                                              // 349
	{Fscript: Tuint8_t(7), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(146)},                                              // 350
	{Fscript: Tuint8_t(7), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18546), Fbprops: Tuint16_t(138)},                                             // 351
	{Fscript: Tuint8_t(7), Fchartype: Tuint8_t(23), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(14336), Fbprops: Tuint16_t(68)},                                              // 352
	{Fscript: Tuint8_t(7), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                              // 353
	{Fscript: Tuint8_t(7), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                              // 354
	{Fscript: Tuint8_t(7), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                              // 355
	{Fscript: Tuint8_t(7), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(102)},                                              // 356
	{Fscript: Tuint8_t(8), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                              // 357
	{Fscript: Tuint8_t(8), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                              // 358
	{Fscript: Tuint8_t(8), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                               // 359
	{Fscript: Tuint8_t(8), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                               // 360
	{Fscript: Tuint8_t(8), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(146)},                                              // 361
	{Fscript: Tuint8_t(8), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18519), Fbprops: Tuint16_t(138)},                                             // 362
	{Fscript: Tuint8_t(8), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                              // 363
	{Fscript: Tuint8_t(9), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                              // 364
	{Fscript: Tuint8_t(9), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                              // 365
	{Fscript: Tuint8_t(9), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                               // 366
	{Fscript: Tuint8_t(9), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                               // 367
	{Fscript: Tuint8_t(9), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(146)},                                              // 368
	{Fscript: Tuint8_t(9), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18516), Fbprops: Tuint16_t(138)},                                             // 369
	{Fscript: Tuint8_t(9), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                              // 370
	{Fscript: Tuint8_t(9), Fchartype: Tuint8_t(23), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(14336), Fbprops: Tuint16_t(68)},                                              // 371
	{Fscript: Tuint8_t(10), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 372
	{Fscript: Tuint8_t(10), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                             // 373
	{Fscript: Tuint8_t(10), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 374
	{Fscript: Tuint8_t(10), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                              // 375
	{Fscript: Tuint8_t(10), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(148)},                                             // 376
	{Fscript: Tuint8_t(10), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(146)},                                             // 377
	{Fscript: Tuint8_t(10), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(150)},                                             // 378
	{Fscript: Tuint8_t(10), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                            // 379
	{Fscript: Tuint8_t(10), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 380
	{Fscript: Tuint8_t(10), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 381
	{Fscript: Tuint8_t(11), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 382
	{Fscript: Tuint8_t(11), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 383
	{Fscript: Tuint8_t(11), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(148)},                                             // 384
	{Fscript: Tuint8_t(11), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                             // 385
	{Fscript: Tuint8_t(11), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(146)},                                             // 386
	{Fscript: Tuint8_t(11), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18513), Fbprops: Tuint16_t(138)},                                            // 387
	{Fscript: Tuint8_t(11), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18513), Fbprops: Tuint16_t(68)},                                             // 388
	{Fscript: Tuint8_t(11), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28753), Fbprops: Tuint16_t(68)},                                             // 389
	{Fscript: Tuint8_t(11), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(68)},                                             // 390
	{Fscript: Tuint8_t(11), Fchartype: Tuint8_t(23), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(14336), Fbprops: Tuint16_t(68)},                                             // 391
	{Fscript: Tuint8_t(12), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 392
	{Fscript: Tuint8_t(12), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                             // 393
	{Fscript: Tuint8_t(12), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(102)},                                             // 394
	{Fscript: Tuint8_t(12), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 395
	{Fscript: Tuint8_t(12), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                              // 396
	{Fscript: Tuint8_t(12), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(146)},                                             // 397
	{Fscript: Tuint8_t(12), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                            // 398
	{Fscript: Tuint8_t(12), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 399
	{Fscript: Tuint8_t(12), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(68)},                                             // 400
	{Fscript: Tuint8_t(12), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 401
	{Fscript: Tuint8_t(13), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 402
	{Fscript: Tuint8_t(13), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 403
	{Fscript: Tuint8_t(13), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                             // 404
	{Fscript: Tuint8_t(13), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 405
	{Fscript: Tuint8_t(13), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                              // 406
	{Fscript: Tuint8_t(13), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(130)},                                             // 407
	{Fscript: Tuint8_t(13), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(148)},                                             // 408
	{Fscript: Tuint8_t(13), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(146)},                                             // 409
	{Fscript: Tuint8_t(13), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18528), Fbprops: Tuint16_t(138)},                                            // 410
	{Fscript: Tuint8_t(14), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 411
	{Fscript: Tuint8_t(14), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                             // 412
	{Fscript: Tuint8_t(14), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 413
	{Fscript: Tuint8_t(14), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(146)},                                             // 414
	{Fscript: Tuint8_t(14), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(148)},                                             // 415
	{Fscript: Tuint8_t(14), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(4), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                               // 416
	{Fscript: Tuint8_t(14), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 417
	{Fscript: Tuint8_t(14), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 418
	{Fscript: Tuint8_t(14), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                            // 419
	{Fscript: Tuint8_t(15), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 420
	{Fscript: Tuint8_t(15), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                             // 421
	{Fscript: Tuint8_t(15), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 422
	{Fscript: Tuint8_t(15), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(146)},                                             // 423
	{Fscript: Tuint8_t(15), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(148)},                                             // 424
	{Fscript: Tuint8_t(15), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                            // 425
	{Fscript: Tuint8_t(15), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 426
	{Fscript: Tuint8_t(72), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 427
	{Fscript: Tuint8_t(72), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 428
	{Fscript: Tuint8_t(72), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(152)},                                              // 429
	{Fscript: Tuint8_t(72), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(154)},                                             // 430
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(23), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(14336), Fbprops: Tuint16_t(68)},                                             // 431
	{Fscript: Tuint8_t(72), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(156)},                                             // 432
	{Fscript: Tuint8_t(72), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(136)},                                             // 433
	{Fscript: Tuint8_t(72), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                              // 434
	{Fscript: Tuint8_t(72), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 435
	{Fscript: Tuint8_t(72), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                            // 436
	{Fscript: Tuint8_t(72), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(106)},                                            // 437
	{Fscript: Tuint8_t(73), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 438
	{Fscript: Tuint8_t(73), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 439
	{Fscript: Tuint8_t(73), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(152)},                                              // 440
	{Fscript: Tuint8_t(73), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(146)},                                             // 441
	{Fscript: Tuint8_t(73), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(156)},                                             // 442
	{Fscript: Tuint8_t(73), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(136)},                                             // 443
	{Fscript: Tuint8_t(73), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                              // 444
	{Fscript: Tuint8_t(73), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                            // 445
	{Fscript: Tuint8_t(74), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 446
	{Fscript: Tuint8_t(74), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 447
	{Fscript: Tuint8_t(74), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 448
	{Fscript: Tuint8_t(74), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(106)},                                            // 449
	{Fscript: Tuint8_t(74), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                              // 450
	{Fscript: Tuint8_t(74), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                            // 451
	{Fscript: Tuint8_t(74), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 452
	{Fscript: Tuint8_t(74), Fchartype: Tuint8_t(22), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(158)},                                            // 453
	{Fscript: Tuint8_t(74), Fchartype: Tuint8_t(18), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(158)},                                            // 454
	{Fscript: Tuint8_t(74), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(160)},                                             // 455
	{Fscript: Tuint8_t(74), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 456
	{Fscript: Tuint8_t(74), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(162)},                                             // 457
	{Fscript: Tuint8_t(74), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                             // 458
	{Fscript: Tuint8_t(74), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(146)},                                             // 459
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 460
	{Fscript: Tuint8_t(16), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 461
	{Fscript: Tuint8_t(16), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                            // 462
	{Fscript: Tuint8_t(16), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 463
	{Fscript: Tuint8_t(16), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                             // 464
	{Fscript: Tuint8_t(16), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                              // 465
	{Fscript: Tuint8_t(16), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(146)},                                             // 466
	{Fscript: Tuint8_t(16), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18549), Fbprops: Tuint16_t(138)},                                            // 467
	{Fscript: Tuint8_t(16), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(124)},                                            // 468
	{Fscript: Tuint8_t(16), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 469
	{Fscript: Tuint8_t(16), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(164)},                                            // 470
	{Fscript: Tuint8_t(16), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(128)},                                             // 471
	{Fscript: Tuint8_t(16), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                            // 472
	{Fscript: Tuint8_t(16), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 473
	{Fscript: Tuint8_t(17), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 7264, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                           // 474
	{Fscript: Tuint8_t(17), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: 3008, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(166)},                          // 475
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18510), Fbprops: Tuint16_t(68)},                                             // 476
	{Fscript: Tuint8_t(17), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(142)},                                             // 477
	{Fscript: Tuint8_t(18), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(6), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                               // 478
	{Fscript: Tuint8_t(18), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(6), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(168)},                                              // 479
	{Fscript: Tuint8_t(18), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(7), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(168)},                                              // 480
	{Fscript: Tuint8_t(18), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(7), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                               // 481
	{Fscript: Tuint8_t(18), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(8), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                               // 482
	{Fscript: Tuint8_t(75), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 483
	{Fscript: Tuint8_t(75), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                              // 484
	{Fscript: Tuint8_t(75), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 485
	{Fscript: Tuint8_t(75), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(106)},                                            // 486
	{Fscript: Tuint8_t(75), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(124)},                                            // 487
	{Fscript: Tuint8_t(75), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                            // 488
	{Fscript: Tuint8_t(75), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 489
	{Fscript: Tuint8_t(75), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(68)},                                             // 490
	{Fscript: Tuint8_t(76), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 38864, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(170)},                         // 491
	{Fscript: Tuint8_t(76), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 8, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(170)},                             // 492
	{Fscript: Tuint8_t(76), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -8, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(70)},                             // 493
	{Fscript: Tuint8_t(77), Fchartype: Tuint8_t(17), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(126)},                                            // 494
	{Fscript: Tuint8_t(77), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 495
	{Fscript: Tuint8_t(77), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 496
	{Fscript: Tuint8_t(77), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(124)},                                            // 497
	{Fscript: Tuint8_t(78), Fchartype: Tuint8_t(29), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(45056), Fbprops: Tuint16_t(52)},                                             // 498
	{Fscript: Tuint8_t(78), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 499
	{Fscript: Tuint8_t(78), Fchartype: Tuint8_t(22), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(158)},                                            // 500
	{Fscript: Tuint8_t(78), Fchartype: Tuint8_t(18), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(158)},                                            // 501
	{Fscript: Tuint8_t(79), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 502
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(106)},                                            // 503
	{Fscript: Tuint8_t(79), Fchartype: Tuint8_t(14), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                             // 504
	{Fscript: Tuint8_t(25), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 505
	{Fscript: Tuint8_t(25), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 506
	{Fscript: Tuint8_t(25), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(146)},                                             // 507
	{Fscript: Tuint8_t(25), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(172)},                                             // 508
	{Fscript: Tuint8_t(26), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 509
	{Fscript: Tuint8_t(26), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 510
	{Fscript: Tuint8_t(26), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(174)},                                             // 511
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18573), Fbprops: Tuint16_t(124)},                                            // 512
	{Fscript: Tuint8_t(27), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 513
	{Fscript: Tuint8_t(27), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 514
	{Fscript: Tuint8_t(28), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 515
	{Fscript: Tuint8_t(28), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 516
	{Fscript: Tuint8_t(80), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 517
	{Fscript: Tuint8_t(80), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(140)},                                             // 518
	{Fscript: Tuint8_t(80), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(100)},                                             // 519
	{Fscript: Tuint8_t(80), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                             // 520
	{Fscript: Tuint8_t(80), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 521
	{Fscript: Tuint8_t(80), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                              // 522
	{Fscript: Tuint8_t(80), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(146)},                                             // 523
	{Fscript: Tuint8_t(80), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(106)},                                            // 524
	{Fscript: Tuint8_t(80), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(142)},                                             // 525
	{Fscript: Tuint8_t(80), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 526
	{Fscript: Tuint8_t(80), Fchartype: Tuint8_t(23), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(14336), Fbprops: Tuint16_t(68)},                                             // 527
	{Fscript: Tuint8_t(80), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                            // 528
	{Fscript: Tuint8_t(80), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(68)},                                             // 529
	{Fscript: Tuint8_t(19), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(68)},                                             // 530
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28777), Fbprops: Tuint16_t(106)},                                            // 531
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28777), Fbprops: Tuint16_t(124)},                                            // 532
	{Fscript: Tuint8_t(19), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(106)},                                            // 533
	{Fscript: Tuint8_t(19), Fchartype: Tuint8_t(17), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(126)},                                            // 534
	{Fscript: Tuint8_t(19), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(124)},                                            // 535
	{Fscript: Tuint8_t(19), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(176)},                                            // 536
	{Fscript: Tuint8_t(19), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(178)},                                             // 537
	{Fscript: Tuint8_t(19), Fchartype: Tuint8_t(1), Fgbprop: Tuint8_t(2), Fscriptx_bidiclass: Tuint16_t(6144), Fbprops: Tuint16_t(66)},                                                // 538
	{Fscript: Tuint8_t(19), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                            // 539
	{Fscript: Tuint8_t(19), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 540
	{Fscript: Tuint8_t(19), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(136)},                                             // 541
	{Fscript: Tuint8_t(19), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(180)},                                             // 542
	{Fscript: Tuint8_t(19), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 543
	{Fscript: Tuint8_t(29), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 544
	{Fscript: Tuint8_t(29), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 545
	{Fscript: Tuint8_t(29), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                             // 546
	{Fscript: Tuint8_t(29), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                              // 547
	{Fscript: Tuint8_t(29), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(68)},                                             // 548
	{Fscript: Tuint8_t(29), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(124)},                                            // 549
	{Fscript: Tuint8_t(29), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                            // 550
	{Fscript: Tuint8_t(30), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 551
	{Fscript: Tuint8_t(89), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 552
	{Fscript: Tuint8_t(89), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(156)},                                             // 553
	{Fscript: Tuint8_t(89), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                            // 554
	{Fscript: Tuint8_t(89), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                            // 555
	{Fscript: Tuint8_t(89), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(68)},                                             // 556
	{Fscript: Tuint8_t(80), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(68)},                                             // 557
	{Fscript: Tuint8_t(33), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 558
	{Fscript: Tuint8_t(33), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 559
	{Fscript: Tuint8_t(33), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                             // 560
	{Fscript: Tuint8_t(33), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 561
	{Fscript: Tuint8_t(106), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                             // 562
	{Fscript: Tuint8_t(106), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                            // 563
	{Fscript: Tuint8_t(106), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                            // 564
	{Fscript: Tuint8_t(106), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(182)},                                            // 565
	{Fscript: Tuint8_t(106), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                           // 566
	{Fscript: Tuint8_t(106), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                             // 567
	{Fscript: Tuint8_t(106), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                           // 568
	{Fscript: Tuint8_t(106), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                            // 569
	{Fscript: Tuint8_t(106), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(136)},                                            // 570
	{Fscript: Tuint8_t(106), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(124)},                                           // 571
	{Fscript: Tuint8_t(84), Fchartype: Tuint8_t(11), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(184)},                                             // 572
	{Fscript: Tuint8_t(84), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 573
	{Fscript: Tuint8_t(93), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 574
	{Fscript: Tuint8_t(93), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                             // 575
	{Fscript: Tuint8_t(93), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 576
	{Fscript: Tuint8_t(93), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                              // 577
	{Fscript: Tuint8_t(93), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(148)},                                             // 578
	{Fscript: Tuint8_t(93), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(172)},                                             // 579
	{Fscript: Tuint8_t(93), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                            // 580
	{Fscript: Tuint8_t(93), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(124)},                                            // 581
	{Fscript: Tuint8_t(93), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 582
	{Fscript: Tuint8_t(93), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(106)},                                            // 583
	{Fscript: Tuint8_t(93), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 584
	{Fscript: Tuint8_t(96), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 585
	{Fscript: Tuint8_t(96), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                             // 586
	{Fscript: Tuint8_t(96), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 587
	{Fscript: Tuint8_t(96), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(172)},                                             // 588
	{Fscript: Tuint8_t(96), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(146)},                                             // 589
	{Fscript: Tuint8_t(96), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                            // 590
	{Fscript: Tuint8_t(119), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                             // 591
	{Fscript: Tuint8_t(119), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(102)},                                            // 592
	{Fscript: Tuint8_t(119), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                            // 593
	{Fscript: Tuint8_t(119), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                            // 594
	{Fscript: Tuint8_t(119), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(174)},                                            // 595
	{Fscript: Tuint8_t(119), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                            // 596
	{Fscript: Tuint8_t(97), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 597
	{Fscript: Tuint8_t(97), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                             // 598
	{Fscript: Tuint8_t(97), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 599
	{Fscript: Tuint8_t(97), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(186)},                                             // 600
	{Fscript: Tuint8_t(97), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                              // 601
	{Fscript: Tuint8_t(97), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(124)},                                            // 602
	{Fscript: Tuint8_t(97), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(106)},                                            // 603
	{Fscript: Tuint8_t(97), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                            // 604
	{Fscript: Tuint8_t(98), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                            // 605
	{Fscript: Tuint8_t(98), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 606
	{Fscript: Tuint8_t(98), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(92)},                                              // 607
	{Fscript: Tuint8_t(98), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(94)},                                              // 608
	{Fscript: Tuint8_t(98), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(124)},                                            // 609
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(63), Fother_case: -6222, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(70)},   // 610
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(67), Fother_case: -6221, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(70)},   // 611
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(71), Fother_case: -6212, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(70)},   // 612
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(75), Fother_case: -6210, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(70)},   // 613
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(79), Fother_case: -6210, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(70)},   // 614
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(79), Fother_case: -6211, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(70)},   // 615
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(84), Fother_case: -6204, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(70)},   // 616
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(88), Fother_case: -6180, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(70)},   // 617
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(108), Fother_case: 35267, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(70)},  // 618
	{Fscript: Tuint8_t(17), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: -3008, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                          // 619
	{Fscript: Tuint8_t(96), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 620
	{Fscript: Tuint8_t(84), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26762), Fbprops: Tuint16_t(96)},                                              // 621
	{Fscript: Tuint8_t(84), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26630), Fbprops: Tuint16_t(96)},                                              // 622
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18498), Fbprops: Tuint16_t(188)},                                            // 623
	{Fscript: Tuint8_t(84), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26666), Fbprops: Tuint16_t(96)},                                              // 624
	{Fscript: Tuint8_t(84), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26696), Fbprops: Tuint16_t(96)},                                              // 625
	{Fscript: Tuint8_t(84), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26780), Fbprops: Tuint16_t(96)},                                              // 626
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18474), Fbprops: Tuint16_t(160)},                                             // 627
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18501), Fbprops: Tuint16_t(82)},                                              // 628
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18474), Fbprops: Tuint16_t(82)},                                              // 629
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18438), Fbprops: Tuint16_t(82)},                                              // 630
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18594), Fbprops: Tuint16_t(82)},                                              // 631
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18498), Fbprops: Tuint16_t(82)},                                              // 632
	{Fscript: Tuint8_t(84), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26750), Fbprops: Tuint16_t(96)},                                              // 633
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18435), Fbprops: Tuint16_t(160)},                                             // 634
	{Fscript: Tuint8_t(84), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26690), Fbprops: Tuint16_t(96)},                                              // 635
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18453), Fbprops: Tuint16_t(82)},                                              // 636
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(60)},                                               // 637
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(88)},                                               // 638
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(190)},                                              // 639
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: 35332, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                 // 640
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: 3814, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                  // 641
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: 35384, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                 // 642
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(192)},                                                                    // 643
	{Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(190)},                                                                    // 644
	{Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(194)},                                                                    // 645
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(190)},                                              // 646
	{Fscript: Tuint8_t(84), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26636), Fbprops: Tuint16_t(102)},                                             // 647
	{Fscript: Tuint8_t(84), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26687), Fbprops: Tuint16_t(96)},                                              // 648
	{Fscript: Tuint8_t(84), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26648), Fbprops: Tuint16_t(96)},                                              // 649
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(92), Fother_case: 1, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                             // 650
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(92), Fother_case: -1, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                            // 651
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(70)},                                                                     // 652
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(92), Fother_case: -58, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(70)},                           // 653
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: -7615, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                 // 654
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: 8, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                               // 655
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: -8, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                              // 656
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: 74, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                              // 657
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: 86, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                              // 658
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: 100, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                             // 659
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: 128, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                             // 660
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: 112, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                             // 661
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: 126, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                             // 662
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: 8, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(70)},                               // 663
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(8), Fgbprop: Tuint8_t(12), Fother_case: -8, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(86)},                              // 664
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(70)},                                               // 665
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: 9, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(70)},                               // 666
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: -74, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                             // 667
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(8), Fgbprop: Tuint8_t(12), Fother_case: -9, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(86)},                              // 668
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(21), Fother_case: -7173, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},   // 669
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: -86, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                             // 670
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: -100, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                            // 671
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: -112, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                            // 672
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: -128, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                            // 673
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: -126, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                            // 674
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(29), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(45056), Fbprops: Tuint16_t(52)},                                             // 675
	{Fscript: Tuint8_t(84), Fchartype: Tuint8_t(1), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(6144), Fbprops: Tuint16_t(196)},                                               // 676
	{Fscript: Tuint8_t(84), Fchartype: Tuint8_t(1), Fgbprop: Tuint8_t(13), Fscriptx_bidiclass: Tuint16_t(6144), Fbprops: Tuint16_t(198)},                                              // 677
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(1), Fgbprop: Tuint8_t(2), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(200)},                                              // 678
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(1), Fgbprop: Tuint8_t(2), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(200)},                                              // 679
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(17), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(202)},                                            // 680
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(64)},                                             // 681
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(20), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(204)},                                            // 682
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(19), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(204)},                                            // 683
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(22), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(206)},                                            // 684
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(20), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(206)},                                            // 685
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(19), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(206)},                                            // 686
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(208)},                                            // 687
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(27), Fgbprop: Tuint8_t(2), Fscriptx_bidiclass: Tuint16_t(45056), Fbprops: Tuint16_t(50)},                                              // 688
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(28), Fgbprop: Tuint8_t(2), Fscriptx_bidiclass: Tuint16_t(4096), Fbprops: Tuint16_t(50)},                                               // 689
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(1), Fgbprop: Tuint8_t(2), Fscriptx_bidiclass: Tuint16_t(20480), Fbprops: Tuint16_t(134)},                                              // 690
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(1), Fgbprop: Tuint8_t(2), Fscriptx_bidiclass: Tuint16_t(36864), Fbprops: Tuint16_t(134)},                                              // 691
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(1), Fgbprop: Tuint8_t(2), Fscriptx_bidiclass: Tuint16_t(30720), Fbprops: Tuint16_t(134)},                                              // 692
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(1), Fgbprop: Tuint8_t(2), Fscriptx_bidiclass: Tuint16_t(24576), Fbprops: Tuint16_t(134)},                                              // 693
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(1), Fgbprop: Tuint8_t(2), Fscriptx_bidiclass: Tuint16_t(40960), Fbprops: Tuint16_t(134)},                                              // 694
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(29), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(8291), Fbprops: Tuint16_t(52)},                                              // 695
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(14336), Fbprops: Tuint16_t(54)},                                             // 696
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(14336), Fbprops: Tuint16_t(64)},                                             // 697
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(14), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(210)},                                            // 698
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(212)},                                            // 699
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(16), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(138)},                                            // 700
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(16), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(214)},                                            // 701
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(25), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(8192), Fbprops: Tuint16_t(64)},                                              // 702
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(22), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(216)},                                            // 703
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(18), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(216)},                                            // 704
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(202)},                                            // 705
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(1), Fgbprop: Tuint8_t(2), Fscriptx_bidiclass: Tuint16_t(6144), Fbprops: Tuint16_t(218)},                                               // 706
	{Fscript: Tuint8_t(68), Fchartype: Tuint8_t(2), Fgbprop: Tuint8_t(2), Fscriptx_bidiclass: Tuint16_t(6144), Fbprops: Tuint16_t(220)},                                               // 707
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(1), Fgbprop: Tuint8_t(2), Fscriptx_bidiclass: Tuint16_t(22528), Fbprops: Tuint16_t(134)},                                              // 708
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(1), Fgbprop: Tuint8_t(2), Fscriptx_bidiclass: Tuint16_t(38912), Fbprops: Tuint16_t(134)},                                              // 709
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(1), Fgbprop: Tuint8_t(2), Fscriptx_bidiclass: Tuint16_t(16384), Fbprops: Tuint16_t(134)},                                              // 710
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(1), Fgbprop: Tuint8_t(2), Fscriptx_bidiclass: Tuint16_t(32768), Fbprops: Tuint16_t(134)},                                              // 711
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(1), Fgbprop: Tuint8_t(2), Fscriptx_bidiclass: Tuint16_t(6144), Fbprops: Tuint16_t(222)},                                               // 712
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(25), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(12288), Fbprops: Tuint16_t(118)},                                            // 713
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(25), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(12288), Fbprops: Tuint16_t(224)},                                            // 714
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(25), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(118)},                                            // 715
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(22), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(226)},                                            // 716
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(18), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(226)},                                            // 717
	{Fscript: Tuint8_t(68), Fchartype: Tuint8_t(2), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(14336)},                                                                      // 718
	{Fscript: Tuint8_t(84), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(228)},                                             // 719
	{Fscript: Tuint8_t(84), Fchartype: Tuint8_t(11), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(120)},                                             // 720
	{Fscript: Tuint8_t(84), Fchartype: Tuint8_t(11), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(230)},                                             // 721
	{Fscript: Tuint8_t(84), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26753), Fbprops: Tuint16_t(102)},                                             // 722
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(68)},                                             // 723
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(112)},                                             // 724
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(232)},                                             // 725
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(25), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(234)},                                            // 726
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(14), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(236)},                                            // 727
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(96), Fother_case: -7517, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},   // 728
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(118)},                                            // 729
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(100), Fother_case: -8383, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                        // 730
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(104), Fother_case: -8262, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                        // 731
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(14336), Fbprops: Tuint16_t(238)},                                            // 732
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 28, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                    // 733
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(240)},                                             // 734
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(14), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(242)},                                             // 735
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(244)},                                             // 736
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -28, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                   // 737
	{Fchartype: Tuint8_t(14), Fgbprop: Tuint8_t(12), Fother_case: 16, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                   // 738
	{Fchartype: Tuint8_t(14), Fgbprop: Tuint8_t(12), Fother_case: -16, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                  // 739
	{Fchartype: Tuint8_t(14), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                                                    // 740
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(25), Fgbprop: Tuint8_t(14), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(246)},                                            // 741
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(14), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(246)},                                            // 742
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(64)},                                             // 743
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(25), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(248)},                                            // 744
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(25), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(12288), Fbprops: Tuint16_t(250)},                                            // 745
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(22), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(248)},                                            // 746
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(18), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(248)},                                            // 747
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(14), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(252)},                                            // 748
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(22), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(254)},                                            // 749
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(18), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(254)},                                            // 750
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(54)},                                             // 751
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(14), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(256)},                                            // 752
	{Fscript: Tuint8_t(68), Fchartype: Tuint8_t(2), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(258)},                                             // 753
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fother_case: 26, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(260)},                           // 754
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(14), Fother_case: 26, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(262)},                           // 755
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fother_case: -26, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(264)},                          // 756
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(25), Fgbprop: Tuint8_t(14), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(266)},                                            // 757
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(14), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(268)},                                            // 758
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(14), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(270)},                                            // 759
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(25), Fgbprop: Tuint8_t(14), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(268)},                                            // 760
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(14), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(256)},                                            // 761
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(14), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(272)},                                            // 762
	{Fscript: Tuint8_t(88), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(54)},                                             // 763
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(216)},                                            // 764
	{Fscript: Tuint8_t(35), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 48, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                             // 765
	{Fscript: Tuint8_t(35), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -48, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                            // 766
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: -10743, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                // 767
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: -3814, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                 // 768
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: -10727, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                // 769
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -10795, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                // 770
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -10792, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                // 771
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: -10780, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                // 772
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: -10749, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                // 773
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: -10783, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                // 774
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: -10782, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                // 775
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: -10815, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                // 776
	{Fscript: Tuint8_t(34), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(60)},                                              // 777
	{Fscript: Tuint8_t(34), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(68)},                                             // 778
	{Fscript: Tuint8_t(34), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                              // 779
	{Fscript: Tuint8_t(34), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(68)},                                             // 780
	{Fscript: Tuint8_t(34), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(68)},                                             // 781
	{Fscript: Tuint8_t(17), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -7264, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                          // 782
	{Fscript: Tuint8_t(90), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 783
	{Fscript: Tuint8_t(90), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(142)},                                             // 784
	{Fscript: Tuint8_t(90), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 785
	{Fscript: Tuint8_t(90), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(182)},                                             // 786
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                              // 787
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(20), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(216)},                                            // 788
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(19), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(216)},                                            // 789
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(274)},                                             // 790
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(276)},                                            // 791
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28726), Fbprops: Tuint16_t(54)},                                             // 792
	{Fscript: Tuint8_t(23), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(278)},                                            // 793
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(280)},                                            // 794
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(282)},                                            // 795
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28825), Fbprops: Tuint16_t(276)},                                            // 796
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28825), Fbprops: Tuint16_t(212)},                                            // 797
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28819), Fbprops: Tuint16_t(54)},                                             // 798
	{Fscript: Tuint8_t(23), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(136)},                                             // 799
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18447), Fbprops: Tuint16_t(284)},                                             // 800
	{Fscript: Tuint8_t(23), Fchartype: Tuint8_t(14), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(284)},                                            // 801
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(22), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28825), Fbprops: Tuint16_t(216)},                                            // 802
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(18), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28825), Fbprops: Tuint16_t(216)},                                            // 803
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(22), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28825), Fbprops: Tuint16_t(62)},                                             // 804
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(18), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28825), Fbprops: Tuint16_t(62)},                                             // 805
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28819), Fbprops: Tuint16_t(54)},                                             // 806
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(17), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28819), Fbprops: Tuint16_t(202)},                                            // 807
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(22), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28819), Fbprops: Tuint16_t(206)},                                            // 808
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(18), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28819), Fbprops: Tuint16_t(206)},                                            // 809
	{Fscript: Tuint8_t(84), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26669), Fbprops: Tuint16_t(96)},                                              // 810
	{Fscript: Tuint8_t(18), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(286)},                                             // 811
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(17), Fgbprop: Tuint8_t(14), Fscriptx_bidiclass: Tuint16_t(28819), Fbprops: Tuint16_t(288)},                                            // 812
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18525), Fbprops: Tuint16_t(136)},                                             // 813
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28819), Fbprops: Tuint16_t(68)},                                             // 814
	{Fscript: Tuint8_t(23), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(142)},                                             // 815
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18564), Fbprops: Tuint16_t(82)},                                              // 816
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(14), Fscriptx_bidiclass: Tuint16_t(28804), Fbprops: Tuint16_t(236)},                                            // 817
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28687), Fbprops: Tuint16_t(68)},                                             // 818
	{Fscript: Tuint8_t(20), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 819
	{Fscript: Tuint8_t(84), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26717), Fbprops: Tuint16_t(96)},                                              // 820
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(24), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28765), Fbprops: Tuint16_t(290)},                                            // 821
	{Fscript: Tuint8_t(20), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(136)},                                             // 822
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(17), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28765), Fbprops: Tuint16_t(126)},                                            // 823
	{Fscript: Tuint8_t(21), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 824
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28825), Fbprops: Tuint16_t(68)},                                             // 825
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18525), Fbprops: Tuint16_t(94)},                                              // 826
	{Fscript: Tuint8_t(21), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(136)},                                             // 827
	{Fscript: Tuint8_t(22), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 828
	{Fscript: Tuint8_t(18), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 829
	{Fscript: Tuint8_t(18), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(168)},                                             // 830
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18447), Fbprops: Tuint16_t(68)},                                             // 831
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18447), Fbprops: Tuint16_t(68)},                                             // 832
	{Fscript: Tuint8_t(18), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 833
	{Fscript: Tuint8_t(18), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(68)},                                             // 834
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 835
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(14), Fscriptx_bidiclass: Tuint16_t(18447), Fbprops: Tuint16_t(236)},                                            // 836
	{Fscript: Tuint8_t(21), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 837
	{Fscript: Tuint8_t(23), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(292)},                                             // 838
	{Fscript: Tuint8_t(24), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 839
	{Fscript: Tuint8_t(24), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(136)},                                             // 840
	{Fscript: Tuint8_t(24), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(68)},                                             // 841
	{Fscript: Tuint8_t(111), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                             // 842
	{Fscript: Tuint8_t(111), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(142)},                                            // 843
	{Fscript: Tuint8_t(111), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(106)},                                           // 844
	{Fscript: Tuint8_t(111), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(124)},                                           // 845
	{Fscript: Tuint8_t(99), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 846
	{Fscript: Tuint8_t(99), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(136)},                                             // 847
	{Fscript: Tuint8_t(99), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(106)},                                            // 848
	{Fscript: Tuint8_t(99), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(124)},                                            // 849
	{Fscript: Tuint8_t(99), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                            // 850
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(108), Fother_case: 1, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},      // 851
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fcaseset: Tuint8_t(108), Fother_case: -35267, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)}, // 852
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                               // 853
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(68)},                                              // 854
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                               // 855
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(92)},                                               // 856
	{Fscript: Tuint8_t(2), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(88)},                                               // 857
	{Fscript: Tuint8_t(112), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                             // 858
	{Fscript: Tuint8_t(112), Fchartype: Tuint8_t(14), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                            // 859
	{Fscript: Tuint8_t(112), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                             // 860
	{Fscript: Tuint8_t(112), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                            // 861
	{Fscript: Tuint8_t(112), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(124)},                                           // 862
	{Fscript: Tuint8_t(112), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(106)},                                           // 863
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(24), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28762), Fbprops: Tuint16_t(56)},                                             // 864
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: -35332, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                // 865
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(24), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(56)},                                             // 866
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: -42280, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                // 867
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: 48, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                    // 868
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: -42308, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                // 869
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: -42319, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                // 870
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: -42315, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                // 871
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: -42305, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                // 872
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: -42258, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                // 873
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: -42282, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                // 874
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: -42261, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                // 875
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 928, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                   // 876
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: -48, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                   // 877
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: -42307, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                // 878
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: -35384, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                                                // 879
	{Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(142)},                                                                    // 880
	{Fscript: Tuint8_t(36), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 881
	{Fscript: Tuint8_t(36), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 882
	{Fscript: Tuint8_t(36), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(182)},                                             // 883
	{Fscript: Tuint8_t(36), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                             // 884
	{Fscript: Tuint8_t(36), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(68)},                                             // 885
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18612), Fbprops: Tuint16_t(68)},                                             // 886
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18609), Fbprops: Tuint16_t(68)},                                             // 887
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18600), Fbprops: Tuint16_t(68)},                                             // 888
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(23), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(14504), Fbprops: Tuint16_t(68)},                                             // 889
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(14504), Fbprops: Tuint16_t(68)},                                             // 890
	{Fscript: Tuint8_t(37), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 891
	{Fscript: Tuint8_t(37), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(68)},                                             // 892
	{Fscript: Tuint8_t(37), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(124)},                                            // 893
	{Fscript: Tuint8_t(100), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                            // 894
	{Fscript: Tuint8_t(100), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                             // 895
	{Fscript: Tuint8_t(100), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(146)},                                            // 896
	{Fscript: Tuint8_t(100), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                            // 897
	{Fscript: Tuint8_t(100), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(124)},                                           // 898
	{Fscript: Tuint8_t(100), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                           // 899
	{Fscript: Tuint8_t(6), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26666), Fbprops: Tuint16_t(96)},                                               // 900
	{Fscript: Tuint8_t(6), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18507), Fbprops: Tuint16_t(82)},                                               // 901
	{Fscript: Tuint8_t(39), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                            // 902
	{Fscript: Tuint8_t(39), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 903
	{Fscript: Tuint8_t(39), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 904
	{Fscript: Tuint8_t(39), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                              // 905
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18567), Fbprops: Tuint16_t(188)},                                            // 906
	{Fscript: Tuint8_t(39), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(124)},                                            // 907
	{Fscript: Tuint8_t(101), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                             // 908
	{Fscript: Tuint8_t(101), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                            // 909
	{Fscript: Tuint8_t(101), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                            // 910
	{Fscript: Tuint8_t(101), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(172)},                                            // 911
	{Fscript: Tuint8_t(101), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                            // 912
	{Fscript: Tuint8_t(40), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 913
	{Fscript: Tuint8_t(40), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                             // 914
	{Fscript: Tuint8_t(40), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 915
	{Fscript: Tuint8_t(40), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                              // 916
	{Fscript: Tuint8_t(40), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(172)},                                             // 917
	{Fscript: Tuint8_t(40), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 918
	{Fscript: Tuint8_t(40), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(106)},                                            // 919
	{Fscript: Tuint8_t(40), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(124)},                                            // 920
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18480), Fbprops: Tuint16_t(136)},                                             // 921
	{Fscript: Tuint8_t(40), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                            // 922
	{Fscript: Tuint8_t(16), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(136)},                                             // 923
	{Fscript: Tuint8_t(105), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                             // 924
	{Fscript: Tuint8_t(105), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                            // 925
	{Fscript: Tuint8_t(105), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                            // 926
	{Fscript: Tuint8_t(105), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                           // 927
	{Fscript: Tuint8_t(105), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                            // 928
	{Fscript: Tuint8_t(105), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(124)},                                           // 929
	{Fscript: Tuint8_t(107), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                             // 930
	{Fscript: Tuint8_t(107), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                            // 931
	{Fscript: Tuint8_t(107), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(156)},                                            // 932
	{Fscript: Tuint8_t(107), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                             // 933
	{Fscript: Tuint8_t(107), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(294)},                                            // 934
	{Fscript: Tuint8_t(107), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(136)},                                            // 935
	{Fscript: Tuint8_t(107), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                            // 936
	{Fscript: Tuint8_t(107), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(106)},                                           // 937
	{Fscript: Tuint8_t(113), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                             // 938
	{Fscript: Tuint8_t(113), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                            // 939
	{Fscript: Tuint8_t(113), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                            // 940
	{Fscript: Tuint8_t(113), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(124)},                                           // 941
	{Fscript: Tuint8_t(113), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(136)},                                            // 942
	{Fscript: Tuint8_t(113), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(146)},                                            // 943
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -928, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                                                  // 944
	{Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(92)},                                                                     // 945
	{Fscript: Tuint8_t(76), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -38864, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(70)},                         // 946
	{Fscript: Tuint8_t(113), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(160)},                                            // 947
	{Fscript: Tuint8_t(113), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                           // 948
	{Fscript: Tuint8_t(18), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(9), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                               // 949
	{Fscript: Tuint8_t(18), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(10), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 950
	{Fscript: Tuint8_t(68), Fchartype: Tuint8_t(4), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432)},                                                                      // 951
	{Fscript: Tuint8_t(68), Fchartype: Tuint8_t(3), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432)},                                                                      // 952
	{Fscript: Tuint8_t(23), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(284)},                                             // 953
	{Fscript: Tuint8_t(71), Fchartype: Tuint8_t(25), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(12288), Fbprops: Tuint16_t(118)},                                            // 954
	{Fscript: Tuint8_t(3), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fbprops: Tuint16_t(296)},                                                                                    // 955
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(18), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28705), Fbprops: Tuint16_t(54)},                                             // 956
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(22), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28705), Fbprops: Tuint16_t(54)},                                             // 957
	{Fscript: Tuint8_t(68), Fchartype: Tuint8_t(2), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(6144), Fbprops: Tuint16_t(298)},                                              // 958
	{Fscript: Tuint8_t(3), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(39), Fbprops: Tuint16_t(82)},                                                  // 959
	{Fscript: Tuint8_t(3), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28711), Fbprops: Tuint16_t(68)},                                              // 960
	{Fscript: Tuint8_t(84), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(178)},                                             // 961
	{Fscript: Tuint8_t(84), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(300)},                                             // 962
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(68)},                                             // 963
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(122)},                                            // 964
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(22), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(68)},                                             // 965
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(18), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(68)},                                             // 966
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(17), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(126)},                                            // 967
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(22), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(302)},                                            // 968
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(18), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(302)},                                            // 969
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(8192), Fbprops: Tuint16_t(106)},                                             // 970
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(8192), Fbprops: Tuint16_t(304)},                                             // 971
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(8192), Fbprops: Tuint16_t(306)},                                             // 972
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(124)},                                            // 973
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(22), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(158)},                                            // 974
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(18), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(158)},                                            // 975
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(14336), Fbprops: Tuint16_t(68)},                                             // 976
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(118)},                                            // 977
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(17), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(12288), Fbprops: Tuint16_t(224)},                                            // 978
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(25), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(226)},                                            // 979
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(302)},                                            // 980
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(308)},                                            // 981
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(17), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(12288), Fbprops: Tuint16_t(126)},                                            // 982
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(8192), Fbprops: Tuint16_t(68)},                                              // 983
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(10240), Fbprops: Tuint16_t(310)},                                            // 984
	{Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(312)},                                                   // 985
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(24), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(314)},                                            // 986
	{Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(316)},                                                  // 987
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28825), Fbprops: Tuint16_t(124)},                                            // 988
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(22), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28825), Fbprops: Tuint16_t(318)},                                            // 989
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(18), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28825), Fbprops: Tuint16_t(318)},                                            // 990
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28825), Fbprops: Tuint16_t(106)},                                            // 991
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(18525), Fbprops: Tuint16_t(320)},                                              // 992
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(1), Fgbprop: Tuint8_t(2), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(322)},                                              // 993
	{Fscript: Tuint8_t(31), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 994
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18552), Fbprops: Tuint16_t(68)},                                             // 995
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28792), Fbprops: Tuint16_t(68)},                                             // 996
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18483), Fbprops: Tuint16_t(68)},                                             // 997
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18555), Fbprops: Tuint16_t(68)},                                             // 998
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18483), Fbprops: Tuint16_t(68)},                                             // 999
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(14), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(82)},                                              // 1000
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(68)},                                              // 1001
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(68)},                                              // 1002
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                              // 1003
	{Fscript: Tuint8_t(102), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                             // 1004
	{Fscript: Tuint8_t(103), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                             // 1005
	{Fscript: Tuint8_t(84), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26651), Fbprops: Tuint16_t(96)},                                              // 1006
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(10267), Fbprops: Tuint16_t(68)},                                             // 1007
	{Fscript: Tuint8_t(81), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 1008
	{Fscript: Tuint8_t(81), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 1009
	{Fscript: Tuint8_t(82), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 1010
	{Fscript: Tuint8_t(82), Fchartype: Tuint8_t(14), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                             // 1011
	{Fscript: Tuint8_t(53), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 1012
	{Fscript: Tuint8_t(53), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 1013
	{Fscript: Tuint8_t(85), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 1014
	{Fscript: Tuint8_t(85), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(106)},                                            // 1015
	{Fscript: Tuint8_t(91), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 1016
	{Fscript: Tuint8_t(91), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(106)},                                            // 1017
	{Fscript: Tuint8_t(91), Fchartype: Tuint8_t(14), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                             // 1018
	{Fscript: Tuint8_t(83), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 40, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                             // 1019
	{Fscript: Tuint8_t(83), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -40, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                            // 1020
	{Fscript: Tuint8_t(86), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 1021
	{Fscript: Tuint8_t(87), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 1022
	{Fscript: Tuint8_t(87), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                            // 1023
	{Fscript: Tuint8_t(145), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 40, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                            // 1024
	{Fscript: Tuint8_t(145), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -40, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                           // 1025
	{Fscript: Tuint8_t(127), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                             // 1026
	{Fscript: Tuint8_t(125), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                             // 1027
	{Fscript: Tuint8_t(125), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                            // 1028
	{Fscript: Tuint8_t(161), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 39, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                            // 1029
	{Fscript: Tuint8_t(161), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -39, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                           // 1030
	{Fscript: Tuint8_t(49), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 1031
	{Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(94)},                                                                     // 1032
	{Fscript: Tuint8_t(32), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(82)},                                              // 1033
	{Fscript: Tuint8_t(114), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(82)},                                             // 1034
	{Fscript: Tuint8_t(114), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(106)},                                           // 1035
	{Fscript: Tuint8_t(114), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(68)},                                            // 1036
	{Fscript: Tuint8_t(133), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(82)},                                             // 1037
	{Fscript: Tuint8_t(133), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(68)},                                            // 1038
	{Fscript: Tuint8_t(133), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(68)},                                            // 1039
	{Fscript: Tuint8_t(132), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(82)},                                             // 1040
	{Fscript: Tuint8_t(132), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(68)},                                            // 1041
	{Fscript: Tuint8_t(139), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(82)},                                             // 1042
	{Fscript: Tuint8_t(139), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(68)},                                            // 1043
	{Fscript: Tuint8_t(95), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(82)},                                              // 1044
	{Fscript: Tuint8_t(95), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(68)},                                             // 1045
	{Fscript: Tuint8_t(95), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(106)},                                            // 1046
	{Fscript: Tuint8_t(104), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(82)},                                             // 1047
	{Fscript: Tuint8_t(104), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(68)},                                            // 1048
	{Fscript: Tuint8_t(122), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(82)},                                             // 1049
	{Fscript: Tuint8_t(121), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(82)},                                             // 1050
	{Fscript: Tuint8_t(121), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(68)},                                            // 1051
	{Fscript: Tuint8_t(92), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(82)},                                              // 1052
	{Fscript: Tuint8_t(92), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 1053
	{Fscript: Tuint8_t(92), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(102)},                                             // 1054
	{Fscript: Tuint8_t(92), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(182)},                                             // 1055
	{Fscript: Tuint8_t(92), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(68)},                                             // 1056
	{Fscript: Tuint8_t(92), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(68)},                                             // 1057
	{Fscript: Tuint8_t(92), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(124)},                                            // 1058
	{Fscript: Tuint8_t(115), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(82)},                                             // 1059
	{Fscript: Tuint8_t(115), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(68)},                                            // 1060
	{Fscript: Tuint8_t(115), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(68)},                                            // 1061
	{Fscript: Tuint8_t(131), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(82)},                                             // 1062
	{Fscript: Tuint8_t(131), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(68)},                                            // 1063
	{Fscript: Tuint8_t(51), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(82)},                                              // 1064
	{Fscript: Tuint8_t(51), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(68)},                                             // 1065
	{Fscript: Tuint8_t(51), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                              // 1066
	{Fscript: Tuint8_t(51), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(68)},                                             // 1067
	{Fscript: Tuint8_t(51), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(106)},                                            // 1068
	{Fscript: Tuint8_t(51), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34918), Fbprops: Tuint16_t(106)},                                            // 1069
	{Fscript: Tuint8_t(51), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(68)},                                             // 1070
	{Fscript: Tuint8_t(108), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(82)},                                             // 1071
	{Fscript: Tuint8_t(108), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(68)},                                            // 1072
	{Fscript: Tuint8_t(108), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(106)},                                           // 1073
	{Fscript: Tuint8_t(116), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(82)},                                             // 1074
	{Fscript: Tuint8_t(116), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(68)},                                            // 1075
	{Fscript: Tuint8_t(117), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(82)},                                             // 1076
	{Fscript: Tuint8_t(117), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(68)},                                            // 1077
	{Fscript: Tuint8_t(54), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(82)},                                              // 1078
	{Fscript: Tuint8_t(54), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(106)},                                            // 1079
	{Fscript: Tuint8_t(54), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(68)},                                             // 1080
	{Fscript: Tuint8_t(118), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(82)},                                             // 1081
	{Fscript: Tuint8_t(140), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 64, Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(74)},                            // 1082
	{Fscript: Tuint8_t(140), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -64, Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(76)},                           // 1083
	{Fscript: Tuint8_t(140), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(68)},                                            // 1084
	{Fscript: Tuint8_t(62), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fbprops: Tuint16_t(82)},                                                                                    // 1085
	{Fscript: Tuint8_t(62), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fbprops: Tuint16_t(294)},                                                                                   // 1086
	{Fscript: Tuint8_t(62), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(128)},                                             // 1087
	{Fscript: Tuint8_t(62), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(2048), Fbprops: Tuint16_t(138)},                                             // 1088
	{Fscript: Tuint8_t(3), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(2048), Fbprops: Tuint16_t(68)},                                               // 1089
	{Fscript: Tuint8_t(65), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(82)},                                              // 1090
	{Fscript: Tuint8_t(65), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 1091
	{Fscript: Tuint8_t(65), Fchartype: Tuint8_t(17), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(126)},                                            // 1092
	{Fscript: Tuint8_t(152), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(82)},                                             // 1093
	{Fscript: Tuint8_t(152), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(68)},                                            // 1094
	{Fscript: Tuint8_t(63), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fbprops: Tuint16_t(82)},                                                                                    // 1095
	{Fscript: Tuint8_t(63), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                              // 1096
	{Fscript: Tuint8_t(63), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fbprops: Tuint16_t(68)},                                                                                   // 1097
	{Fscript: Tuint8_t(63), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fbprops: Tuint16_t(124)},                                                                                  // 1098
	{Fscript: Tuint8_t(67), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(82)},                                              // 1099
	{Fscript: Tuint8_t(67), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                              // 1100
	{Fscript: Tuint8_t(67), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(124)},                                            // 1101
	{Fscript: Tuint8_t(156), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(82)},                                             // 1102
	{Fscript: Tuint8_t(156), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(68)},                                            // 1103
	{Fscript: Tuint8_t(153), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(82)},                                             // 1104
	{Fscript: Tuint8_t(120), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                            // 1105
	{Fscript: Tuint8_t(120), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                            // 1106
	{Fscript: Tuint8_t(120), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                             // 1107
	{Fscript: Tuint8_t(120), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(146)},                                            // 1108
	{Fscript: Tuint8_t(120), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(124)},                                           // 1109
	{Fscript: Tuint8_t(120), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(106)},                                           // 1110
	{Fscript: Tuint8_t(120), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(68)},                                            // 1111
	{Fscript: Tuint8_t(120), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                           // 1112
	{Fscript: Tuint8_t(120), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(182)},                                            // 1113
	{Fscript: Tuint8_t(41), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(102)},                                             // 1114
	{Fscript: Tuint8_t(41), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                             // 1115
	{Fscript: Tuint8_t(41), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 1116
	{Fscript: Tuint8_t(41), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 1117
	{Fscript: Tuint8_t(41), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(146)},                                             // 1118
	{Fscript: Tuint8_t(41), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                              // 1119
	{Fscript: Tuint8_t(41), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 1120
	{Fscript: Tuint8_t(41), Fchartype: Tuint8_t(1), Fgbprop: Tuint8_t(4), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(132)},                                              // 1121
	{Fscript: Tuint8_t(41), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(124)},                                            // 1122
	{Fscript: Tuint8_t(124), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                             // 1123
	{Fscript: Tuint8_t(124), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                           // 1124
	{Fscript: Tuint8_t(43), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 1125
	{Fscript: Tuint8_t(43), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 1126
	{Fscript: Tuint8_t(43), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                             // 1127
	{Fscript: Tuint8_t(43), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(146)},                                             // 1128
	{Fscript: Tuint8_t(43), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                            // 1129
	{Fscript: Tuint8_t(43), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 1130
	{Fscript: Tuint8_t(43), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(124)},                                            // 1131
	{Fscript: Tuint8_t(50), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 1132
	{Fscript: Tuint8_t(50), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                              // 1133
	{Fscript: Tuint8_t(50), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 1134
	{Fscript: Tuint8_t(44), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 1135
	{Fscript: Tuint8_t(44), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                             // 1136
	{Fscript: Tuint8_t(44), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 1137
	{Fscript: Tuint8_t(44), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(172)},                                             // 1138
	{Fscript: Tuint8_t(44), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(4), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                               // 1139
	{Fscript: Tuint8_t(44), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(124)},                                            // 1140
	{Fscript: Tuint8_t(44), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 1141
	{Fscript: Tuint8_t(44), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(102)},                                             // 1142
	{Fscript: Tuint8_t(44), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                              // 1143
	{Fscript: Tuint8_t(44), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                            // 1144
	{Fscript: Tuint8_t(15), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 1145
	{Fscript: Tuint8_t(48), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 1146
	{Fscript: Tuint8_t(48), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                             // 1147
	{Fscript: Tuint8_t(48), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 1148
	{Fscript: Tuint8_t(48), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(172)},                                             // 1149
	{Fscript: Tuint8_t(48), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                              // 1150
	{Fscript: Tuint8_t(48), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(124)},                                            // 1151
	{Fscript: Tuint8_t(48), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(106)},                                            // 1152
	{Fscript: Tuint8_t(48), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 1153
	{Fscript: Tuint8_t(57), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 1154
	{Fscript: Tuint8_t(57), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(124)},                                            // 1155
	{Fscript: Tuint8_t(55), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 1156
	{Fscript: Tuint8_t(55), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 1157
	{Fscript: Tuint8_t(55), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                             // 1158
	{Fscript: Tuint8_t(55), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                              // 1159
	{Fscript: Tuint8_t(55), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(146)},                                             // 1160
	{Fscript: Tuint8_t(55), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                            // 1161
	{Fscript: Tuint8_t(47), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 1162
	{Fscript: Tuint8_t(47), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26705), Fbprops: Tuint16_t(130)},                                             // 1163
	{Fscript: Tuint8_t(47), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                             // 1164
	{Fscript: Tuint8_t(47), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18513), Fbprops: Tuint16_t(144)},                                             // 1165
	{Fscript: Tuint8_t(47), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 1166
	{Fscript: Tuint8_t(84), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26705), Fbprops: Tuint16_t(102)},                                             // 1167
	{Fscript: Tuint8_t(47), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26705), Fbprops: Tuint16_t(96)},                                              // 1168
	{Fscript: Tuint8_t(47), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(148)},                                             // 1169
	{Fscript: Tuint8_t(47), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(172)},                                             // 1170
	{Fscript: Tuint8_t(47), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(324)},                                             // 1171
	{Fscript: Tuint8_t(47), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                              // 1172
	{Fscript: Tuint8_t(144), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                             // 1173
	{Fscript: Tuint8_t(144), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                            // 1174
	{Fscript: Tuint8_t(144), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                            // 1175
	{Fscript: Tuint8_t(144), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(146)},                                            // 1176
	{Fscript: Tuint8_t(144), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                             // 1177
	{Fscript: Tuint8_t(144), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(124)},                                           // 1178
	{Fscript: Tuint8_t(144), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(106)},                                           // 1179
	{Fscript: Tuint8_t(144), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                            // 1180
	{Fscript: Tuint8_t(144), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                           // 1181
	{Fscript: Tuint8_t(144), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(102)},                                            // 1182
	{Fscript: Tuint8_t(56), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 1183
	{Fscript: Tuint8_t(56), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(148)},                                             // 1184
	{Fscript: Tuint8_t(56), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                             // 1185
	{Fscript: Tuint8_t(56), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 1186
	{Fscript: Tuint8_t(56), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(146)},                                             // 1187
	{Fscript: Tuint8_t(56), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                              // 1188
	{Fscript: Tuint8_t(56), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 1189
	{Fscript: Tuint8_t(56), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                            // 1190
	{Fscript: Tuint8_t(135), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                             // 1191
	{Fscript: Tuint8_t(135), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(148)},                                            // 1192
	{Fscript: Tuint8_t(135), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                            // 1193
	{Fscript: Tuint8_t(135), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                            // 1194
	{Fscript: Tuint8_t(135), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(146)},                                            // 1195
	{Fscript: Tuint8_t(135), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                             // 1196
	{Fscript: Tuint8_t(135), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                            // 1197
	{Fscript: Tuint8_t(135), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(124)},                                           // 1198
	{Fscript: Tuint8_t(135), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(106)},                                           // 1199
	{Fscript: Tuint8_t(135), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(176)},                                           // 1200
	{Fscript: Tuint8_t(52), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 1201
	{Fscript: Tuint8_t(52), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                             // 1202
	{Fscript: Tuint8_t(52), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 1203
	{Fscript: Tuint8_t(52), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(146)},                                             // 1204
	{Fscript: Tuint8_t(52), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(124)},                                            // 1205
	{Fscript: Tuint8_t(52), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 1206
	{Fscript: Tuint8_t(52), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                            // 1207
	{Fscript: Tuint8_t(45), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 1208
	{Fscript: Tuint8_t(45), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 1209
	{Fscript: Tuint8_t(45), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                             // 1210
	{Fscript: Tuint8_t(45), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(172)},                                             // 1211
	{Fscript: Tuint8_t(45), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                              // 1212
	{Fscript: Tuint8_t(45), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 1213
	{Fscript: Tuint8_t(45), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                            // 1214
	{Fscript: Tuint8_t(137), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                             // 1215
	{Fscript: Tuint8_t(137), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                            // 1216
	{Fscript: Tuint8_t(137), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                           // 1217
	{Fscript: Tuint8_t(137), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                            // 1218
	{Fscript: Tuint8_t(137), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(146)},                                            // 1219
	{Fscript: Tuint8_t(137), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                           // 1220
	{Fscript: Tuint8_t(137), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                            // 1221
	{Fscript: Tuint8_t(137), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(124)},                                           // 1222
	{Fscript: Tuint8_t(137), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                            // 1223
	{Fscript: Tuint8_t(60), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 1224
	{Fscript: Tuint8_t(60), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                             // 1225
	{Fscript: Tuint8_t(60), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 1226
	{Fscript: Tuint8_t(60), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(146)},                                             // 1227
	{Fscript: Tuint8_t(60), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                              // 1228
	{Fscript: Tuint8_t(60), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 1229
	{Fscript: Tuint8_t(136), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                            // 1230
	{Fscript: Tuint8_t(136), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                           // 1231
	{Fscript: Tuint8_t(136), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                           // 1232
	{Fscript: Tuint8_t(136), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                            // 1233
	{Fscript: Tuint8_t(136), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                             // 1234
	{Fscript: Tuint8_t(157), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                             // 1235
	{Fscript: Tuint8_t(157), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(148)},                                            // 1236
	{Fscript: Tuint8_t(157), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                            // 1237
	{Fscript: Tuint8_t(157), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                            // 1238
	{Fscript: Tuint8_t(157), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(172)},                                            // 1239
	{Fscript: Tuint8_t(157), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(146)},                                            // 1240
	{Fscript: Tuint8_t(157), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(4), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 1241
	{Fscript: Tuint8_t(157), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                             // 1242
	{Fscript: Tuint8_t(157), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(124)},                                           // 1243
	{Fscript: Tuint8_t(157), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                            // 1244
	{Fscript: Tuint8_t(157), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                           // 1245
	{Fscript: Tuint8_t(64), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 1246
	{Fscript: Tuint8_t(64), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                             // 1247
	{Fscript: Tuint8_t(64), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 1248
	{Fscript: Tuint8_t(64), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(146)},                                             // 1249
	{Fscript: Tuint8_t(64), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 1250
	{Fscript: Tuint8_t(149), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                             // 1251
	{Fscript: Tuint8_t(149), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                            // 1252
	{Fscript: Tuint8_t(149), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(130)},                                            // 1253
	{Fscript: Tuint8_t(149), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(102)},                                            // 1254
	{Fscript: Tuint8_t(149), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(146)},                                            // 1255
	{Fscript: Tuint8_t(149), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                            // 1256
	{Fscript: Tuint8_t(149), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(4), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 1257
	{Fscript: Tuint8_t(149), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                            // 1258
	{Fscript: Tuint8_t(149), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(124)},                                           // 1259
	{Fscript: Tuint8_t(148), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                             // 1260
	{Fscript: Tuint8_t(148), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                            // 1261
	{Fscript: Tuint8_t(148), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                            // 1262
	{Fscript: Tuint8_t(148), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(4), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 1263
	{Fscript: Tuint8_t(148), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(326)},                                            // 1264
	{Fscript: Tuint8_t(148), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(146)},                                            // 1265
	{Fscript: Tuint8_t(148), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                            // 1266
	{Fscript: Tuint8_t(148), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(124)},                                           // 1267
	{Fscript: Tuint8_t(148), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(106)},                                           // 1268
	{Fscript: Tuint8_t(134), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                             // 1269
	{Fscript: Tuint8_t(142), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                             // 1270
	{Fscript: Tuint8_t(142), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                            // 1271
	{Fscript: Tuint8_t(142), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                            // 1272
	{Fscript: Tuint8_t(142), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(146)},                                            // 1273
	{Fscript: Tuint8_t(142), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(124)},                                           // 1274
	{Fscript: Tuint8_t(142), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(106)},                                           // 1275
	{Fscript: Tuint8_t(142), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                            // 1276
	{Fscript: Tuint8_t(142), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                           // 1277
	{Fscript: Tuint8_t(142), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                            // 1278
	{Fscript: Tuint8_t(143), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                            // 1279
	{Fscript: Tuint8_t(143), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(106)},                                           // 1280
	{Fscript: Tuint8_t(143), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                             // 1281
	{Fscript: Tuint8_t(143), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                            // 1282
	{Fscript: Tuint8_t(143), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                            // 1283
	{Fscript: Tuint8_t(59), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 1284
	{Fscript: Tuint8_t(59), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 1285
	{Fscript: Tuint8_t(59), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                              // 1286
	{Fscript: Tuint8_t(59), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(146)},                                             // 1287
	{Fscript: Tuint8_t(59), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(4), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                               // 1288
	{Fscript: Tuint8_t(59), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                            // 1289
	{Fscript: Tuint8_t(61), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 1290
	{Fscript: Tuint8_t(61), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                             // 1291
	{Fscript: Tuint8_t(61), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 1292
	{Fscript: Tuint8_t(61), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(146)},                                             // 1293
	{Fscript: Tuint8_t(61), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                            // 1294
	{Fscript: Tuint8_t(150), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                             // 1295
	{Fscript: Tuint8_t(150), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                            // 1296
	{Fscript: Tuint8_t(150), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                            // 1297
	{Fscript: Tuint8_t(150), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(124)},                                           // 1298
	{Fscript: Tuint8_t(11), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 1299
	{Fscript: Tuint8_t(11), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 1300
	{Fscript: Tuint8_t(94), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 1301
	{Fscript: Tuint8_t(94), Fchartype: Tuint8_t(14), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                             // 1302
	{Fscript: Tuint8_t(94), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(106)},                                            // 1303
	{Fscript: Tuint8_t(66), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 1304
	{Fscript: Tuint8_t(66), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 1305
	{Fscript: Tuint8_t(109), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                             // 1306
	{Fscript: Tuint8_t(109), Fchartype: Tuint8_t(1), Fgbprop: Tuint8_t(2), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(322)},                                             // 1307
	{Fscript: Tuint8_t(138), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                             // 1308
	{Fscript: Tuint8_t(130), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                             // 1309
	{Fscript: Tuint8_t(130), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                           // 1310
	{Fscript: Tuint8_t(130), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(124)},                                           // 1311
	{Fscript: Tuint8_t(159), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                             // 1312
	{Fscript: Tuint8_t(159), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                           // 1313
	{Fscript: Tuint8_t(126), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                             // 1314
	{Fscript: Tuint8_t(126), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                             // 1315
	{Fscript: Tuint8_t(126), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(124)},                                           // 1316
	{Fscript: Tuint8_t(128), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                             // 1317
	{Fscript: Tuint8_t(128), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                             // 1318
	{Fscript: Tuint8_t(128), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(124)},                                           // 1319
	{Fscript: Tuint8_t(128), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(106)},                                           // 1320
	{Fscript: Tuint8_t(128), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                            // 1321
	{Fscript: Tuint8_t(128), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                            // 1322
	{Fscript: Tuint8_t(128), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(142)},                                            // 1323
	{Fscript: Tuint8_t(128), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(136)},                                            // 1324
	{Fscript: Tuint8_t(128), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                           // 1325
	{Fscript: Tuint8_t(128), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                            // 1326
	{Fscript: Tuint8_t(151), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(74)},                            // 1327
	{Fscript: Tuint8_t(151), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -32, Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(76)},                           // 1328
	{Fscript: Tuint8_t(151), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                            // 1329
	{Fscript: Tuint8_t(151), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(106)},                                           // 1330
	{Fscript: Tuint8_t(151), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(124)},                                           // 1331
	{Fscript: Tuint8_t(151), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                            // 1332
	{Fscript: Tuint8_t(123), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                             // 1333
	{Fscript: Tuint8_t(123), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                            // 1334
	{Fscript: Tuint8_t(123), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(144)},                                            // 1335
	{Fscript: Tuint8_t(123), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(128)},                                            // 1336
	{Fscript: Tuint8_t(123), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(92)},                                             // 1337
	{Fscript: Tuint8_t(146), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(136)},                                            // 1338
	{Fscript: Tuint8_t(147), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(136)},                                            // 1339
	{Fscript: Tuint8_t(23), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(68)},                                             // 1340
	{Fscript: Tuint8_t(158), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(328)},                                            // 1341
	{Fscript: Tuint8_t(23), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(164)},                                             // 1342
	{Fscript: Tuint8_t(146), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(284)},                                            // 1343
	{Fscript: Tuint8_t(158), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(284)},                                            // 1344
	{Fscript: Tuint8_t(21), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(92)},                                              // 1345
	{Fscript: Tuint8_t(147), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(284)},                                            // 1346
	{Fscript: Tuint8_t(46), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                              // 1347
	{Fscript: Tuint8_t(46), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 1348
	{Fscript: Tuint8_t(46), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(102)},                                             // 1349
	{Fscript: Tuint8_t(46), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 1350
	{Fscript: Tuint8_t(46), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(124)},                                            // 1351
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(1), Fgbprop: Tuint8_t(2), Fscriptx_bidiclass: Tuint16_t(6153), Fbprops: Tuint16_t(66)},                                                // 1352
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(330)},                                             // 1353
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                             // 1354
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(5), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(160)},                                             // 1355
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(10), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(286)},                                             // 1356
	{Fscript: Tuint8_t(1), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(102)},                                              // 1357
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(25), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(118)},                                            // 1358
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(10240), Fbprops: Tuint16_t(214)},                                            // 1359
	{Fscript: Tuint8_t(141), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                            // 1360
	{Fscript: Tuint8_t(141), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(102)},                                            // 1361
	{Fscript: Tuint8_t(141), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(106)},                                           // 1362
	{Fscript: Tuint8_t(141), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(124)},                                           // 1363
	{Fscript: Tuint8_t(141), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                            // 1364
	{Fscript: Tuint8_t(35), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 1365
	{Fscript: Tuint8_t(154), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                             // 1366
	{Fscript: Tuint8_t(154), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                             // 1367
	{Fscript: Tuint8_t(154), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(142)},                                            // 1368
	{Fscript: Tuint8_t(154), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(136)},                                            // 1369
	{Fscript: Tuint8_t(154), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                           // 1370
	{Fscript: Tuint8_t(154), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                            // 1371
	{Fscript: Tuint8_t(160), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                             // 1372
	{Fscript: Tuint8_t(160), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                             // 1373
	{Fscript: Tuint8_t(155), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(82)},                                             // 1374
	{Fscript: Tuint8_t(155), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                             // 1375
	{Fscript: Tuint8_t(155), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(138)},                                           // 1376
	{Fscript: Tuint8_t(155), Fchartype: Tuint8_t(23), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(14336), Fbprops: Tuint16_t(68)},                                            // 1377
	{Fscript: Tuint8_t(129), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(82)},                                             // 1378
	{Fscript: Tuint8_t(129), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(68)},                                            // 1379
	{Fscript: Tuint8_t(129), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                             // 1380
	{Fscript: Tuint8_t(58), Fchartype: Tuint8_t(9), Fgbprop: Tuint8_t(12), Fother_case: 34, Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(74)},                             // 1381
	{Fscript: Tuint8_t(58), Fchartype: Tuint8_t(5), Fgbprop: Tuint8_t(12), Fother_case: -34, Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(76)},                            // 1382
	{Fscript: Tuint8_t(58), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(150)},                                             // 1383
	{Fscript: Tuint8_t(58), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(130)},                                             // 1384
	{Fscript: Tuint8_t(58), Fchartype: Tuint8_t(12), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(26624), Fbprops: Tuint16_t(96)},                                              // 1385
	{Fscript: Tuint8_t(58), Fchartype: Tuint8_t(6), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(142)},                                             // 1386
	{Fscript: Tuint8_t(58), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(138)},                                            // 1387
	{Fscript: Tuint8_t(58), Fchartype: Tuint8_t(21), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(34816), Fbprops: Tuint16_t(68)},                                             // 1388
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(15), Fgbprop: Tuint8_t(12), Fbprops: Tuint16_t(68)},                                                                                   // 1389
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fbprops: Tuint16_t(68)},                                                                                   // 1390
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(23), Fgbprop: Tuint8_t(12), Fbprops: Tuint16_t(68)},                                                                                   // 1391
	{Fscript: Tuint8_t(3), Fchartype: Tuint8_t(7), Fgbprop: Tuint8_t(12), Fbprops: Tuint16_t(240)},                                                                                    // 1392
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(14), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(332)},                                            // 1393
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(14), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(334)},                                            // 1394
	{Fscript: Tuint8_t(68), Fchartype: Tuint8_t(2), Fgbprop: Tuint8_t(14), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(336)},                                             // 1395
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(338)},                                            // 1396
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(14), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(340)},                                            // 1397
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(14), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(334)},                                            // 1398
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(11), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(342)},                                            // 1399
	{Fscript: Tuint8_t(20), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(68)},                                             // 1400
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(14), Fscriptx_bidiclass: Tuint16_t(18432), Fbprops: Tuint16_t(236)},                                            // 1401
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(14), Fscriptx_bidiclass: Tuint16_t(18447), Fbprops: Tuint16_t(334)},                                            // 1402
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(14), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(344)},                                            // 1403
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(14), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(346)},                                            // 1404
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(24), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(348)},                                             // 1405
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(26), Fgbprop: Tuint8_t(14), Fscriptx_bidiclass: Tuint16_t(28672), Fbprops: Tuint16_t(350)},                                            // 1406
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(13), Fgbprop: Tuint8_t(12), Fscriptx_bidiclass: Tuint16_t(10240), Fbprops: Tuint16_t(138)},                                            // 1407
	{Fscript: Tuint8_t(69), Fchartype: Tuint8_t(1), Fgbprop: Tuint8_t(3), Fscriptx_bidiclass: Tuint16_t(6144), Fbprops: Tuint16_t(352)},                                               // 1408
} /* pcre2_ucd.c:427:18 */

var X_pcre2_ucd_stage1_8 = [8704]Tuint16_t{ // 17408 bytes
	Tuint16_t(0), Tuint16_t(1), Tuint16_t(2), Tuint16_t(3), Tuint16_t(4), Tuint16_t(5), Tuint16_t(6), Tuint16_t(7), Tuint16_t(8), Tuint16_t(9), Tuint16_t(10), Tuint16_t(11), Tuint16_t(12), Tuint16_t(13), Tuint16_t(14), Tuint16_t(15), // U+0000
	Tuint16_t(16), Tuint16_t(17), Tuint16_t(18), Tuint16_t(19), Tuint16_t(20), Tuint16_t(21), Tuint16_t(22), Tuint16_t(23), Tuint16_t(24), Tuint16_t(25), Tuint16_t(26), Tuint16_t(27), Tuint16_t(28), Tuint16_t(29), Tuint16_t(30), Tuint16_t(31), // U+0800
	Tuint16_t(32), Tuint16_t(33), Tuint16_t(34), Tuint16_t(35), Tuint16_t(36), Tuint16_t(37), Tuint16_t(38), Tuint16_t(39), Tuint16_t(40), Tuint16_t(41), Tuint16_t(41), Tuint16_t(41), Tuint16_t(42), Tuint16_t(43), Tuint16_t(44), Tuint16_t(45), // U+1000
	Tuint16_t(46), Tuint16_t(47), Tuint16_t(48), Tuint16_t(49), Tuint16_t(50), Tuint16_t(51), Tuint16_t(52), Tuint16_t(53), Tuint16_t(54), Tuint16_t(55), Tuint16_t(56), Tuint16_t(57), Tuint16_t(58), Tuint16_t(59), Tuint16_t(60), Tuint16_t(61), // U+1800
	Tuint16_t(62), Tuint16_t(63), Tuint16_t(64), Tuint16_t(65), Tuint16_t(66), Tuint16_t(67), Tuint16_t(68), Tuint16_t(69), Tuint16_t(70), Tuint16_t(71), Tuint16_t(72), Tuint16_t(73), Tuint16_t(74), Tuint16_t(75), Tuint16_t(76), Tuint16_t(77), // U+2000
	Tuint16_t(78), Tuint16_t(78), Tuint16_t(79), Tuint16_t(80), Tuint16_t(81), Tuint16_t(82), Tuint16_t(83), Tuint16_t(84), Tuint16_t(85), Tuint16_t(86), Tuint16_t(87), Tuint16_t(88), Tuint16_t(89), Tuint16_t(90), Tuint16_t(91), Tuint16_t(92), // U+2800
	Tuint16_t(93), Tuint16_t(94), Tuint16_t(95), Tuint16_t(96), Tuint16_t(97), Tuint16_t(98), Tuint16_t(99), Tuint16_t(100), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), // U+3000
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), // U+3800
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), // U+4000
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(102), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), // U+4800
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), // U+5000
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), // U+5800
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), // U+6000
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), // U+6800
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), // U+7000
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), // U+7800
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), // U+8000
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), // U+8800
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), // U+9000
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), // U+9800
	Tuint16_t(103), Tuint16_t(104), Tuint16_t(104), Tuint16_t(104), Tuint16_t(104), Tuint16_t(104), Tuint16_t(104), Tuint16_t(104), Tuint16_t(104), Tuint16_t(105), Tuint16_t(106), Tuint16_t(106), Tuint16_t(107), Tuint16_t(108), Tuint16_t(109), Tuint16_t(110), // U+A000
	Tuint16_t(111), Tuint16_t(112), Tuint16_t(113), Tuint16_t(114), Tuint16_t(115), Tuint16_t(116), Tuint16_t(117), Tuint16_t(118), Tuint16_t(119), Tuint16_t(120), Tuint16_t(121), Tuint16_t(122), Tuint16_t(123), Tuint16_t(124), Tuint16_t(125), Tuint16_t(119), // U+A800
	Tuint16_t(120), Tuint16_t(121), Tuint16_t(122), Tuint16_t(123), Tuint16_t(124), Tuint16_t(125), Tuint16_t(119), Tuint16_t(120), Tuint16_t(121), Tuint16_t(122), Tuint16_t(123), Tuint16_t(124), Tuint16_t(125), Tuint16_t(119), Tuint16_t(120), Tuint16_t(121), // U+B000
	Tuint16_t(122), Tuint16_t(123), Tuint16_t(124), Tuint16_t(125), Tuint16_t(119), Tuint16_t(120), Tuint16_t(121), Tuint16_t(122), Tuint16_t(123), Tuint16_t(124), Tuint16_t(125), Tuint16_t(119), Tuint16_t(120), Tuint16_t(121), Tuint16_t(122), Tuint16_t(123), // U+B800
	Tuint16_t(124), Tuint16_t(125), Tuint16_t(119), Tuint16_t(120), Tuint16_t(121), Tuint16_t(122), Tuint16_t(123), Tuint16_t(124), Tuint16_t(125), Tuint16_t(119), Tuint16_t(120), Tuint16_t(121), Tuint16_t(122), Tuint16_t(123), Tuint16_t(124), Tuint16_t(125), // U+C000
	Tuint16_t(119), Tuint16_t(120), Tuint16_t(121), Tuint16_t(122), Tuint16_t(123), Tuint16_t(124), Tuint16_t(125), Tuint16_t(119), Tuint16_t(120), Tuint16_t(121), Tuint16_t(122), Tuint16_t(123), Tuint16_t(124), Tuint16_t(125), Tuint16_t(119), Tuint16_t(120), // U+C800
	Tuint16_t(121), Tuint16_t(122), Tuint16_t(123), Tuint16_t(124), Tuint16_t(125), Tuint16_t(119), Tuint16_t(120), Tuint16_t(121), Tuint16_t(122), Tuint16_t(123), Tuint16_t(124), Tuint16_t(125), Tuint16_t(119), Tuint16_t(120), Tuint16_t(121), Tuint16_t(126), // U+D000
	Tuint16_t(127), Tuint16_t(127), Tuint16_t(127), Tuint16_t(127), Tuint16_t(127), Tuint16_t(127), Tuint16_t(127), Tuint16_t(127), Tuint16_t(127), Tuint16_t(127), Tuint16_t(127), Tuint16_t(127), Tuint16_t(127), Tuint16_t(127), Tuint16_t(127), Tuint16_t(127), // U+D800
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+E000
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+E800
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+F000
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(129), Tuint16_t(129), Tuint16_t(130), Tuint16_t(131), Tuint16_t(132), Tuint16_t(133), Tuint16_t(134), Tuint16_t(135), Tuint16_t(136), Tuint16_t(137), Tuint16_t(138), Tuint16_t(139), Tuint16_t(140), Tuint16_t(141), // U+F800
	Tuint16_t(142), Tuint16_t(143), Tuint16_t(144), Tuint16_t(145), Tuint16_t(146), Tuint16_t(147), Tuint16_t(148), Tuint16_t(149), Tuint16_t(150), Tuint16_t(151), Tuint16_t(152), Tuint16_t(153), Tuint16_t(154), Tuint16_t(154), Tuint16_t(155), Tuint16_t(156), // U+10000
	Tuint16_t(157), Tuint16_t(158), Tuint16_t(159), Tuint16_t(160), Tuint16_t(161), Tuint16_t(162), Tuint16_t(163), Tuint16_t(164), Tuint16_t(165), Tuint16_t(166), Tuint16_t(167), Tuint16_t(168), Tuint16_t(169), Tuint16_t(170), Tuint16_t(171), Tuint16_t(172), // U+10800
	Tuint16_t(173), Tuint16_t(174), Tuint16_t(175), Tuint16_t(176), Tuint16_t(177), Tuint16_t(178), Tuint16_t(179), Tuint16_t(146), Tuint16_t(180), Tuint16_t(181), Tuint16_t(146), Tuint16_t(182), Tuint16_t(183), Tuint16_t(184), Tuint16_t(185), Tuint16_t(146), // U+11000
	Tuint16_t(186), Tuint16_t(187), Tuint16_t(188), Tuint16_t(189), Tuint16_t(190), Tuint16_t(191), Tuint16_t(146), Tuint16_t(146), Tuint16_t(192), Tuint16_t(193), Tuint16_t(194), Tuint16_t(195), Tuint16_t(146), Tuint16_t(196), Tuint16_t(146), Tuint16_t(197), // U+11800
	Tuint16_t(198), Tuint16_t(198), Tuint16_t(198), Tuint16_t(198), Tuint16_t(198), Tuint16_t(198), Tuint16_t(198), Tuint16_t(199), Tuint16_t(200), Tuint16_t(198), Tuint16_t(201), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+12000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(202), // U+12800
	Tuint16_t(203), Tuint16_t(203), Tuint16_t(203), Tuint16_t(203), Tuint16_t(203), Tuint16_t(203), Tuint16_t(203), Tuint16_t(203), Tuint16_t(204), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+13000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+13800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(205), Tuint16_t(205), Tuint16_t(205), Tuint16_t(205), Tuint16_t(206), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+14000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+14800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+15000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+15800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+16000
	Tuint16_t(207), Tuint16_t(207), Tuint16_t(207), Tuint16_t(207), Tuint16_t(208), Tuint16_t(209), Tuint16_t(210), Tuint16_t(211), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(212), Tuint16_t(213), Tuint16_t(214), Tuint16_t(215), // U+16800
	Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), // U+17000
	Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), // U+17800
	Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(217), // U+18000
	Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(216), Tuint16_t(218), Tuint16_t(218), Tuint16_t(218), Tuint16_t(219), Tuint16_t(220), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+18800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+19000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+19800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+1A000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(221), // U+1A800
	Tuint16_t(222), Tuint16_t(223), Tuint16_t(224), Tuint16_t(225), Tuint16_t(225), Tuint16_t(226), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+1B000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(227), Tuint16_t(228), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+1B800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+1C000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(229), Tuint16_t(230), // U+1C800
	Tuint16_t(231), Tuint16_t(232), Tuint16_t(233), Tuint16_t(234), Tuint16_t(235), Tuint16_t(236), Tuint16_t(237), Tuint16_t(146), Tuint16_t(238), Tuint16_t(239), Tuint16_t(240), Tuint16_t(241), Tuint16_t(242), Tuint16_t(243), Tuint16_t(244), Tuint16_t(245), // U+1D000
	Tuint16_t(246), Tuint16_t(246), Tuint16_t(246), Tuint16_t(246), Tuint16_t(247), Tuint16_t(248), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(249), Tuint16_t(146), // U+1D800
	Tuint16_t(250), Tuint16_t(146), Tuint16_t(251), Tuint16_t(146), Tuint16_t(146), Tuint16_t(252), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(253), // U+1E000
	Tuint16_t(254), Tuint16_t(255), Tuint16_t(256), Tuint16_t(168), Tuint16_t(168), Tuint16_t(168), Tuint16_t(168), Tuint16_t(168), Tuint16_t(257), Tuint16_t(258), Tuint16_t(259), Tuint16_t(168), Tuint16_t(260), Tuint16_t(261), Tuint16_t(168), Tuint16_t(168), // U+1E800
	Tuint16_t(262), Tuint16_t(263), Tuint16_t(264), Tuint16_t(265), Tuint16_t(266), Tuint16_t(267), Tuint16_t(268), Tuint16_t(269), Tuint16_t(270), Tuint16_t(271), Tuint16_t(272), Tuint16_t(273), Tuint16_t(274), Tuint16_t(275), Tuint16_t(276), Tuint16_t(277), // U+1F000
	Tuint16_t(278), Tuint16_t(279), Tuint16_t(280), Tuint16_t(281), Tuint16_t(282), Tuint16_t(283), Tuint16_t(284), Tuint16_t(285), Tuint16_t(267), Tuint16_t(267), Tuint16_t(267), Tuint16_t(267), Tuint16_t(267), Tuint16_t(267), Tuint16_t(267), Tuint16_t(286), // U+1F800
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), // U+20000
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), // U+20800
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), // U+21000
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), // U+21800
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), // U+22000
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), // U+22800
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), // U+23000
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), // U+23800
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), // U+24000
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), // U+24800
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), // U+25000
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), // U+25800
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), // U+26000
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), // U+26800
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), // U+27000
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), // U+27800
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), // U+28000
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), // U+28800
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), // U+29000
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), // U+29800
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(287), Tuint16_t(101), Tuint16_t(101), // U+2A000
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), // U+2A800
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(288), Tuint16_t(101), // U+2B000
	Tuint16_t(289), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), // U+2B800
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), // U+2C000
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(290), Tuint16_t(101), Tuint16_t(101), // U+2C800
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), // U+2D000
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), // U+2D800
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), // U+2E000
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(291), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+2E800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+2F000
	Tuint16_t(129), Tuint16_t(129), Tuint16_t(129), Tuint16_t(129), Tuint16_t(292), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(293), // U+2F800
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), // U+30000
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), // U+30800
	Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(101), Tuint16_t(294), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+31000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+31800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+32000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+32800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+33000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+33800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+34000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+34800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+35000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+35800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+36000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+36800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+37000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+37800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+38000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+38800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+39000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+39800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+3A000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+3A800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+3B000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+3B800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+3C000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+3C800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+3D000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+3D800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+3E000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+3E800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+3F000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(293), // U+3F800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+40000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+40800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+41000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+41800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+42000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+42800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+43000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+43800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+44000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+44800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+45000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+45800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+46000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+46800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+47000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+47800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+48000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+48800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+49000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+49800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+4A000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+4A800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+4B000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+4B800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+4C000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+4C800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+4D000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+4D800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+4E000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+4E800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+4F000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(293), // U+4F800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+50000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+50800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+51000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+51800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+52000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+52800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+53000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+53800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+54000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+54800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+55000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+55800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+56000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+56800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+57000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+57800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+58000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+58800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+59000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+59800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+5A000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+5A800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+5B000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+5B800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+5C000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+5C800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+5D000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+5D800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+5E000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+5E800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+5F000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(293), // U+5F800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+60000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+60800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+61000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+61800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+62000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+62800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+63000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+63800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+64000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+64800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+65000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+65800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+66000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+66800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+67000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+67800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+68000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+68800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+69000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+69800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+6A000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+6A800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+6B000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+6B800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+6C000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+6C800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+6D000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+6D800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+6E000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+6E800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+6F000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(293), // U+6F800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+70000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+70800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+71000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+71800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+72000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+72800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+73000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+73800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+74000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+74800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+75000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+75800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+76000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+76800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+77000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+77800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+78000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+78800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+79000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+79800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+7A000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+7A800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+7B000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+7B800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+7C000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+7C800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+7D000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+7D800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+7E000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+7E800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+7F000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(293), // U+7F800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+80000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+80800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+81000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+81800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+82000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+82800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+83000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+83800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+84000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+84800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+85000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+85800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+86000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+86800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+87000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+87800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+88000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+88800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+89000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+89800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+8A000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+8A800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+8B000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+8B800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+8C000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+8C800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+8D000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+8D800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+8E000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+8E800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+8F000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(293), // U+8F800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+90000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+90800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+91000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+91800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+92000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+92800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+93000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+93800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+94000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+94800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+95000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+95800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+96000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+96800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+97000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+97800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+98000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+98800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+99000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+99800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+9A000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+9A800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+9B000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+9B800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+9C000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+9C800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+9D000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+9D800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+9E000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+9E800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+9F000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(293), // U+9F800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+A0000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+A0800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+A1000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+A1800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+A2000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+A2800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+A3000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+A3800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+A4000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+A4800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+A5000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+A5800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+A6000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+A6800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+A7000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+A7800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+A8000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+A8800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+A9000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+A9800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+AA000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+AA800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+AB000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+AB800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+AC000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+AC800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+AD000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+AD800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+AE000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+AE800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+AF000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(293), // U+AF800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+B0000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+B0800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+B1000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+B1800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+B2000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+B2800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+B3000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+B3800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+B4000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+B4800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+B5000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+B5800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+B6000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+B6800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+B7000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+B7800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+B8000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+B8800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+B9000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+B9800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+BA000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+BA800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+BB000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+BB800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+BC000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+BC800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+BD000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+BD800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+BE000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+BE800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+BF000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(293), // U+BF800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+C0000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+C0800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+C1000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+C1800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+C2000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+C2800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+C3000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+C3800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+C4000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+C4800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+C5000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+C5800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+C6000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+C6800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+C7000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+C7800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+C8000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+C8800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+C9000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+C9800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+CA000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+CA800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+CB000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+CB800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+CC000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+CC800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+CD000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+CD800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+CE000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+CE800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+CF000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(293), // U+CF800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+D0000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+D0800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+D1000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+D1800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+D2000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+D2800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+D3000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+D3800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+D4000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+D4800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+D5000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+D5800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+D6000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+D6800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+D7000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+D7800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+D8000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+D8800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+D9000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+D9800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+DA000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+DA800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+DB000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+DB800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+DC000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+DC800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+DD000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+DD800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+DE000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+DE800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+DF000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(293), // U+DF800
	Tuint16_t(295), Tuint16_t(296), Tuint16_t(297), Tuint16_t(298), Tuint16_t(296), Tuint16_t(296), Tuint16_t(296), Tuint16_t(296), Tuint16_t(296), Tuint16_t(296), Tuint16_t(296), Tuint16_t(296), Tuint16_t(296), Tuint16_t(296), Tuint16_t(296), Tuint16_t(296), // U+E0000
	Tuint16_t(296), Tuint16_t(296), Tuint16_t(296), Tuint16_t(296), Tuint16_t(296), Tuint16_t(296), Tuint16_t(296), Tuint16_t(296), Tuint16_t(296), Tuint16_t(296), Tuint16_t(296), Tuint16_t(296), Tuint16_t(296), Tuint16_t(296), Tuint16_t(296), Tuint16_t(296), // U+E0800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+E1000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+E1800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+E2000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+E2800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+E3000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+E3800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+E4000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+E4800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+E5000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+E5800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+E6000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+E6800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+E7000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+E7800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+E8000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+E8800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+E9000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+E9800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+EA000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+EA800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+EB000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+EB800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+EC000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+EC800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+ED000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+ED800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+EE000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+EE800
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), // U+EF000
	Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(146), Tuint16_t(293), // U+EF800
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+F0000
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+F0800
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+F1000
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+F1800
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+F2000
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+F2800
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+F3000
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+F3800
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+F4000
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+F4800
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+F5000
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+F5800
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+F6000
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+F6800
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+F7000
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+F7800
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+F8000
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+F8800
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+F9000
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+F9800
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+FA000
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+FA800
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+FB000
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+FB800
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+FC000
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+FC800
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+FD000
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+FD800
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+FE000
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+FE800
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+FF000
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(299), // U+FF800
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+100000
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+100800
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+101000
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+101800
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+102000
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+102800
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+103000
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+103800
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+104000
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+104800
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+105000
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+105800
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+106000
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+106800
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+107000
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+107800
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+108000
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+108800
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+109000
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+109800
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+10A000
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+10A800
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+10B000
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+10B800
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+10C000
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+10C800
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+10D000
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+10D800
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+10E000
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+10E800
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), // U+10F000
	Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(128), Tuint16_t(299), // U+10F800
} /* pcre2_ucd.c:1839:16 */

var X_pcre2_ucd_stage2_8 = [38400]Tuint16_t{ // 76800 bytes, block = 128

	// block 0
	Tuint16_t(0), Tuint16_t(0), Tuint16_t(0), Tuint16_t(0), Tuint16_t(0), Tuint16_t(0), Tuint16_t(0), Tuint16_t(0), Tuint16_t(0), Tuint16_t(1), Tuint16_t(2), Tuint16_t(1), Tuint16_t(3), Tuint16_t(4), Tuint16_t(0), Tuint16_t(0),
	Tuint16_t(0), Tuint16_t(0), Tuint16_t(0), Tuint16_t(0), Tuint16_t(0), Tuint16_t(0), Tuint16_t(0), Tuint16_t(0), Tuint16_t(0), Tuint16_t(0), Tuint16_t(0), Tuint16_t(0), Tuint16_t(5), Tuint16_t(5), Tuint16_t(5), Tuint16_t(6),
	Tuint16_t(7), Tuint16_t(8), Tuint16_t(9), Tuint16_t(10), Tuint16_t(11), Tuint16_t(12), Tuint16_t(13), Tuint16_t(14), Tuint16_t(15), Tuint16_t(16), Tuint16_t(17), Tuint16_t(18), Tuint16_t(19), Tuint16_t(20), Tuint16_t(21), Tuint16_t(22),
	Tuint16_t(23), Tuint16_t(23), Tuint16_t(23), Tuint16_t(23), Tuint16_t(23), Tuint16_t(23), Tuint16_t(23), Tuint16_t(23), Tuint16_t(23), Tuint16_t(23), Tuint16_t(24), Tuint16_t(25), Tuint16_t(26), Tuint16_t(27), Tuint16_t(26), Tuint16_t(8),
	Tuint16_t(13), Tuint16_t(28), Tuint16_t(28), Tuint16_t(28), Tuint16_t(28), Tuint16_t(28), Tuint16_t(28), Tuint16_t(29), Tuint16_t(29), Tuint16_t(29), Tuint16_t(29), Tuint16_t(30), Tuint16_t(29), Tuint16_t(29), Tuint16_t(29), Tuint16_t(29),
	Tuint16_t(29), Tuint16_t(29), Tuint16_t(29), Tuint16_t(31), Tuint16_t(29), Tuint16_t(29), Tuint16_t(29), Tuint16_t(29), Tuint16_t(29), Tuint16_t(29), Tuint16_t(29), Tuint16_t(15), Tuint16_t(13), Tuint16_t(16), Tuint16_t(32), Tuint16_t(33),
	Tuint16_t(34), Tuint16_t(35), Tuint16_t(35), Tuint16_t(35), Tuint16_t(35), Tuint16_t(35), Tuint16_t(35), Tuint16_t(36), Tuint16_t(36), Tuint16_t(37), Tuint16_t(37), Tuint16_t(38), Tuint16_t(36), Tuint16_t(36), Tuint16_t(36), Tuint16_t(36),
	Tuint16_t(36), Tuint16_t(36), Tuint16_t(36), Tuint16_t(39), Tuint16_t(36), Tuint16_t(36), Tuint16_t(36), Tuint16_t(36), Tuint16_t(36), Tuint16_t(36), Tuint16_t(36), Tuint16_t(15), Tuint16_t(27), Tuint16_t(16), Tuint16_t(27), Tuint16_t(0),

	// block 1
	Tuint16_t(40), Tuint16_t(40), Tuint16_t(40), Tuint16_t(40), Tuint16_t(40), Tuint16_t(41), Tuint16_t(40), Tuint16_t(40), Tuint16_t(40), Tuint16_t(40), Tuint16_t(40), Tuint16_t(40), Tuint16_t(40), Tuint16_t(40), Tuint16_t(40), Tuint16_t(40),
	Tuint16_t(40), Tuint16_t(40), Tuint16_t(40), Tuint16_t(40), Tuint16_t(40), Tuint16_t(40), Tuint16_t(40), Tuint16_t(40), Tuint16_t(40), Tuint16_t(40), Tuint16_t(40), Tuint16_t(40), Tuint16_t(40), Tuint16_t(40), Tuint16_t(40), Tuint16_t(40),
	Tuint16_t(42), Tuint16_t(43), Tuint16_t(44), Tuint16_t(44), Tuint16_t(44), Tuint16_t(44), Tuint16_t(45), Tuint16_t(43), Tuint16_t(46), Tuint16_t(47), Tuint16_t(48), Tuint16_t(49), Tuint16_t(50), Tuint16_t(51), Tuint16_t(47), Tuint16_t(46),
	Tuint16_t(52), Tuint16_t(53), Tuint16_t(54), Tuint16_t(54), Tuint16_t(46), Tuint16_t(55), Tuint16_t(43), Tuint16_t(56), Tuint16_t(46), Tuint16_t(54), Tuint16_t(48), Tuint16_t(57), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(43),
	Tuint16_t(59), Tuint16_t(59), Tuint16_t(59), Tuint16_t(59), Tuint16_t(59), Tuint16_t(60), Tuint16_t(59), Tuint16_t(59), Tuint16_t(59), Tuint16_t(59), Tuint16_t(59), Tuint16_t(59), Tuint16_t(59), Tuint16_t(59), Tuint16_t(59), Tuint16_t(59),
	Tuint16_t(59), Tuint16_t(59), Tuint16_t(59), Tuint16_t(59), Tuint16_t(59), Tuint16_t(59), Tuint16_t(59), Tuint16_t(50), Tuint16_t(59), Tuint16_t(59), Tuint16_t(59), Tuint16_t(59), Tuint16_t(59), Tuint16_t(59), Tuint16_t(59), Tuint16_t(61),
	Tuint16_t(62), Tuint16_t(62), Tuint16_t(62), Tuint16_t(62), Tuint16_t(62), Tuint16_t(63), Tuint16_t(62), Tuint16_t(62), Tuint16_t(62), Tuint16_t(62), Tuint16_t(62), Tuint16_t(62), Tuint16_t(62), Tuint16_t(62), Tuint16_t(62), Tuint16_t(62),
	Tuint16_t(62), Tuint16_t(62), Tuint16_t(62), Tuint16_t(62), Tuint16_t(62), Tuint16_t(62), Tuint16_t(62), Tuint16_t(50), Tuint16_t(62), Tuint16_t(62), Tuint16_t(62), Tuint16_t(62), Tuint16_t(62), Tuint16_t(62), Tuint16_t(62), Tuint16_t(64),

	// block 2
	Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66),
	Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66),
	Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(67),
	Tuint16_t(68), Tuint16_t(69), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(70), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65),
	Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(71), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66),
	Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66),
	Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66),
	Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(72), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(73),

	// block 3
	Tuint16_t(74), Tuint16_t(75), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(76), Tuint16_t(65), Tuint16_t(66), Tuint16_t(77), Tuint16_t(77), Tuint16_t(65), Tuint16_t(66), Tuint16_t(70), Tuint16_t(78), Tuint16_t(79),
	Tuint16_t(80), Tuint16_t(65), Tuint16_t(66), Tuint16_t(77), Tuint16_t(81), Tuint16_t(82), Tuint16_t(83), Tuint16_t(84), Tuint16_t(65), Tuint16_t(66), Tuint16_t(85), Tuint16_t(70), Tuint16_t(83), Tuint16_t(86), Tuint16_t(87), Tuint16_t(88),
	Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(89), Tuint16_t(65), Tuint16_t(66), Tuint16_t(89), Tuint16_t(70), Tuint16_t(70), Tuint16_t(65), Tuint16_t(66), Tuint16_t(89), Tuint16_t(65),
	Tuint16_t(66), Tuint16_t(90), Tuint16_t(90), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(91), Tuint16_t(65), Tuint16_t(66), Tuint16_t(70), Tuint16_t(92), Tuint16_t(65), Tuint16_t(66), Tuint16_t(70), Tuint16_t(93),
	Tuint16_t(92), Tuint16_t(92), Tuint16_t(92), Tuint16_t(92), Tuint16_t(94), Tuint16_t(95), Tuint16_t(96), Tuint16_t(97), Tuint16_t(98), Tuint16_t(99), Tuint16_t(100), Tuint16_t(101), Tuint16_t(102), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65),
	Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(103), Tuint16_t(65), Tuint16_t(66),
	Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66),
	Tuint16_t(69), Tuint16_t(104), Tuint16_t(105), Tuint16_t(106), Tuint16_t(65), Tuint16_t(66), Tuint16_t(107), Tuint16_t(108), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66),

	// block 4
	Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66),
	Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66),
	Tuint16_t(109), Tuint16_t(70), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66),
	Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(110), Tuint16_t(65), Tuint16_t(66), Tuint16_t(111), Tuint16_t(112), Tuint16_t(113),
	Tuint16_t(113), Tuint16_t(65), Tuint16_t(66), Tuint16_t(114), Tuint16_t(115), Tuint16_t(116), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(67), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66),
	Tuint16_t(117), Tuint16_t(118), Tuint16_t(119), Tuint16_t(120), Tuint16_t(121), Tuint16_t(70), Tuint16_t(122), Tuint16_t(122), Tuint16_t(70), Tuint16_t(123), Tuint16_t(70), Tuint16_t(124), Tuint16_t(125), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70),
	Tuint16_t(122), Tuint16_t(126), Tuint16_t(70), Tuint16_t(127), Tuint16_t(70), Tuint16_t(128), Tuint16_t(129), Tuint16_t(70), Tuint16_t(130), Tuint16_t(131), Tuint16_t(129), Tuint16_t(132), Tuint16_t(133), Tuint16_t(70), Tuint16_t(70), Tuint16_t(131),
	Tuint16_t(70), Tuint16_t(134), Tuint16_t(135), Tuint16_t(70), Tuint16_t(70), Tuint16_t(136), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(137), Tuint16_t(70), Tuint16_t(70),

	// block 5
	Tuint16_t(138), Tuint16_t(70), Tuint16_t(139), Tuint16_t(138), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(140), Tuint16_t(138), Tuint16_t(141), Tuint16_t(142), Tuint16_t(142), Tuint16_t(143), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70),
	Tuint16_t(70), Tuint16_t(70), Tuint16_t(144), Tuint16_t(70), Tuint16_t(92), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(145), Tuint16_t(146), Tuint16_t(70),
	Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70),
	Tuint16_t(147), Tuint16_t(147), Tuint16_t(148), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(149), Tuint16_t(149), Tuint16_t(150), Tuint16_t(150), Tuint16_t(150), Tuint16_t(150), Tuint16_t(150),
	Tuint16_t(151), Tuint16_t(151), Tuint16_t(46), Tuint16_t(46), Tuint16_t(46), Tuint16_t(46), Tuint16_t(149), Tuint16_t(149), Tuint16_t(149), Tuint16_t(149), Tuint16_t(149), Tuint16_t(149), Tuint16_t(149), Tuint16_t(149), Tuint16_t(149), Tuint16_t(149),
	Tuint16_t(152), Tuint16_t(152), Tuint16_t(46), Tuint16_t(46), Tuint16_t(46), Tuint16_t(46), Tuint16_t(46), Tuint16_t(46), Tuint16_t(46), Tuint16_t(46), Tuint16_t(46), Tuint16_t(46), Tuint16_t(46), Tuint16_t(46), Tuint16_t(46), Tuint16_t(46),
	Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(46), Tuint16_t(46), Tuint16_t(46), Tuint16_t(46), Tuint16_t(46), Tuint16_t(153), Tuint16_t(153), Tuint16_t(149), Tuint16_t(46), Tuint16_t(150), Tuint16_t(46),
	Tuint16_t(46), Tuint16_t(46), Tuint16_t(46), Tuint16_t(46), Tuint16_t(46), Tuint16_t(46), Tuint16_t(46), Tuint16_t(46), Tuint16_t(46), Tuint16_t(46), Tuint16_t(46), Tuint16_t(46), Tuint16_t(46), Tuint16_t(46), Tuint16_t(46), Tuint16_t(46),

	// block 6
	Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154),
	Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154),
	Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154),
	Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154),
	Tuint16_t(154), Tuint16_t(154), Tuint16_t(155), Tuint16_t(154), Tuint16_t(154), Tuint16_t(156), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(157),
	Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(158), Tuint16_t(158), Tuint16_t(158), Tuint16_t(158), Tuint16_t(158), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154),
	Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(159), Tuint16_t(159), Tuint16_t(159), Tuint16_t(159), Tuint16_t(159), Tuint16_t(159), Tuint16_t(159), Tuint16_t(159), Tuint16_t(159), Tuint16_t(159), Tuint16_t(159), Tuint16_t(159), Tuint16_t(159),
	Tuint16_t(160), Tuint16_t(161), Tuint16_t(160), Tuint16_t(161), Tuint16_t(149), Tuint16_t(162), Tuint16_t(160), Tuint16_t(161), Tuint16_t(163), Tuint16_t(163), Tuint16_t(164), Tuint16_t(165), Tuint16_t(165), Tuint16_t(165), Tuint16_t(166), Tuint16_t(167),

	// block 7
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(162), Tuint16_t(46), Tuint16_t(168), Tuint16_t(169), Tuint16_t(170), Tuint16_t(170), Tuint16_t(170), Tuint16_t(163), Tuint16_t(171), Tuint16_t(163), Tuint16_t(172), Tuint16_t(172),
	Tuint16_t(173), Tuint16_t(174), Tuint16_t(175), Tuint16_t(174), Tuint16_t(174), Tuint16_t(176), Tuint16_t(174), Tuint16_t(174), Tuint16_t(177), Tuint16_t(178), Tuint16_t(179), Tuint16_t(174), Tuint16_t(180), Tuint16_t(174), Tuint16_t(174), Tuint16_t(174),
	Tuint16_t(181), Tuint16_t(182), Tuint16_t(163), Tuint16_t(183), Tuint16_t(174), Tuint16_t(174), Tuint16_t(184), Tuint16_t(174), Tuint16_t(174), Tuint16_t(185), Tuint16_t(174), Tuint16_t(174), Tuint16_t(186), Tuint16_t(187), Tuint16_t(187), Tuint16_t(187),
	Tuint16_t(173), Tuint16_t(188), Tuint16_t(189), Tuint16_t(188), Tuint16_t(188), Tuint16_t(190), Tuint16_t(188), Tuint16_t(188), Tuint16_t(191), Tuint16_t(192), Tuint16_t(193), Tuint16_t(188), Tuint16_t(194), Tuint16_t(188), Tuint16_t(188), Tuint16_t(188),
	Tuint16_t(195), Tuint16_t(196), Tuint16_t(197), Tuint16_t(198), Tuint16_t(188), Tuint16_t(188), Tuint16_t(199), Tuint16_t(188), Tuint16_t(188), Tuint16_t(200), Tuint16_t(188), Tuint16_t(188), Tuint16_t(201), Tuint16_t(202), Tuint16_t(202), Tuint16_t(203),
	Tuint16_t(204), Tuint16_t(205), Tuint16_t(206), Tuint16_t(207), Tuint16_t(207), Tuint16_t(208), Tuint16_t(209), Tuint16_t(210), Tuint16_t(160), Tuint16_t(161), Tuint16_t(160), Tuint16_t(161), Tuint16_t(160), Tuint16_t(161), Tuint16_t(160), Tuint16_t(161),
	Tuint16_t(160), Tuint16_t(161), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212),
	Tuint16_t(213), Tuint16_t(214), Tuint16_t(215), Tuint16_t(216), Tuint16_t(217), Tuint16_t(218), Tuint16_t(219), Tuint16_t(160), Tuint16_t(161), Tuint16_t(220), Tuint16_t(160), Tuint16_t(161), Tuint16_t(221), Tuint16_t(222), Tuint16_t(222), Tuint16_t(222),

	// block 8
	Tuint16_t(223), Tuint16_t(223), Tuint16_t(223), Tuint16_t(223), Tuint16_t(223), Tuint16_t(223), Tuint16_t(223), Tuint16_t(223), Tuint16_t(223), Tuint16_t(223), Tuint16_t(223), Tuint16_t(223), Tuint16_t(223), Tuint16_t(223), Tuint16_t(223), Tuint16_t(223),
	Tuint16_t(224), Tuint16_t(224), Tuint16_t(225), Tuint16_t(224), Tuint16_t(226), Tuint16_t(224), Tuint16_t(224), Tuint16_t(224), Tuint16_t(224), Tuint16_t(224), Tuint16_t(224), Tuint16_t(224), Tuint16_t(224), Tuint16_t(224), Tuint16_t(227), Tuint16_t(224),
	Tuint16_t(224), Tuint16_t(228), Tuint16_t(229), Tuint16_t(224), Tuint16_t(224), Tuint16_t(224), Tuint16_t(224), Tuint16_t(224), Tuint16_t(224), Tuint16_t(224), Tuint16_t(230), Tuint16_t(224), Tuint16_t(224), Tuint16_t(224), Tuint16_t(224), Tuint16_t(224),
	Tuint16_t(231), Tuint16_t(231), Tuint16_t(232), Tuint16_t(231), Tuint16_t(233), Tuint16_t(231), Tuint16_t(231), Tuint16_t(231), Tuint16_t(231), Tuint16_t(231), Tuint16_t(231), Tuint16_t(231), Tuint16_t(231), Tuint16_t(231), Tuint16_t(234), Tuint16_t(231),
	Tuint16_t(231), Tuint16_t(235), Tuint16_t(236), Tuint16_t(231), Tuint16_t(231), Tuint16_t(231), Tuint16_t(231), Tuint16_t(231), Tuint16_t(231), Tuint16_t(231), Tuint16_t(237), Tuint16_t(231), Tuint16_t(231), Tuint16_t(231), Tuint16_t(231), Tuint16_t(231),
	Tuint16_t(238), Tuint16_t(238), Tuint16_t(238), Tuint16_t(238), Tuint16_t(238), Tuint16_t(238), Tuint16_t(239), Tuint16_t(238), Tuint16_t(239), Tuint16_t(238), Tuint16_t(238), Tuint16_t(238), Tuint16_t(238), Tuint16_t(238), Tuint16_t(238), Tuint16_t(238),
	Tuint16_t(240), Tuint16_t(241), Tuint16_t(242), Tuint16_t(243), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241),
	Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241),

	// block 9
	Tuint16_t(240), Tuint16_t(241), Tuint16_t(244), Tuint16_t(245), Tuint16_t(246), Tuint16_t(247), Tuint16_t(247), Tuint16_t(246), Tuint16_t(248), Tuint16_t(248), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241),
	Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241),
	Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241),
	Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241),
	Tuint16_t(249), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(250),
	Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241),
	Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241),
	Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241),

	// block 10
	Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241),
	Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241),
	Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241),
	Tuint16_t(163), Tuint16_t(251), Tuint16_t(251), Tuint16_t(251), Tuint16_t(251), Tuint16_t(251), Tuint16_t(251), Tuint16_t(251), Tuint16_t(251), Tuint16_t(251), Tuint16_t(251), Tuint16_t(251), Tuint16_t(251), Tuint16_t(251), Tuint16_t(251), Tuint16_t(251),
	Tuint16_t(251), Tuint16_t(251), Tuint16_t(251), Tuint16_t(251), Tuint16_t(251), Tuint16_t(251), Tuint16_t(251), Tuint16_t(251), Tuint16_t(251), Tuint16_t(251), Tuint16_t(251), Tuint16_t(251), Tuint16_t(251), Tuint16_t(251), Tuint16_t(251), Tuint16_t(251),
	Tuint16_t(251), Tuint16_t(251), Tuint16_t(251), Tuint16_t(251), Tuint16_t(251), Tuint16_t(251), Tuint16_t(251), Tuint16_t(163), Tuint16_t(163), Tuint16_t(252), Tuint16_t(253), Tuint16_t(253), Tuint16_t(253), Tuint16_t(253), Tuint16_t(253), Tuint16_t(254),
	Tuint16_t(255), Tuint16_t(256), Tuint16_t(256), Tuint16_t(256), Tuint16_t(256), Tuint16_t(256), Tuint16_t(256), Tuint16_t(256), Tuint16_t(256), Tuint16_t(256), Tuint16_t(256), Tuint16_t(256), Tuint16_t(256), Tuint16_t(256), Tuint16_t(256), Tuint16_t(256),
	Tuint16_t(256), Tuint16_t(256), Tuint16_t(256), Tuint16_t(256), Tuint16_t(256), Tuint16_t(256), Tuint16_t(256), Tuint16_t(256), Tuint16_t(256), Tuint16_t(256), Tuint16_t(256), Tuint16_t(256), Tuint16_t(256), Tuint16_t(256), Tuint16_t(256), Tuint16_t(256),

	// block 11
	Tuint16_t(256), Tuint16_t(256), Tuint16_t(256), Tuint16_t(256), Tuint16_t(256), Tuint16_t(256), Tuint16_t(256), Tuint16_t(257), Tuint16_t(255), Tuint16_t(258), Tuint16_t(259), Tuint16_t(163), Tuint16_t(163), Tuint16_t(260), Tuint16_t(260), Tuint16_t(261),
	Tuint16_t(262), Tuint16_t(263), Tuint16_t(263), Tuint16_t(263), Tuint16_t(263), Tuint16_t(263), Tuint16_t(263), Tuint16_t(263), Tuint16_t(263), Tuint16_t(263), Tuint16_t(263), Tuint16_t(263), Tuint16_t(263), Tuint16_t(263), Tuint16_t(263), Tuint16_t(263),
	Tuint16_t(263), Tuint16_t(263), Tuint16_t(264), Tuint16_t(263), Tuint16_t(263), Tuint16_t(263), Tuint16_t(263), Tuint16_t(263), Tuint16_t(263), Tuint16_t(263), Tuint16_t(263), Tuint16_t(263), Tuint16_t(263), Tuint16_t(263), Tuint16_t(263), Tuint16_t(263),
	Tuint16_t(265), Tuint16_t(265), Tuint16_t(265), Tuint16_t(265), Tuint16_t(265), Tuint16_t(265), Tuint16_t(265), Tuint16_t(265), Tuint16_t(265), Tuint16_t(265), Tuint16_t(265), Tuint16_t(265), Tuint16_t(265), Tuint16_t(265), Tuint16_t(266), Tuint16_t(265),
	Tuint16_t(267), Tuint16_t(265), Tuint16_t(265), Tuint16_t(268), Tuint16_t(265), Tuint16_t(269), Tuint16_t(267), Tuint16_t(269), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270),
	Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(270),
	Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(267), Tuint16_t(271), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),

	// block 12
	Tuint16_t(272), Tuint16_t(272), Tuint16_t(272), Tuint16_t(272), Tuint16_t(272), Tuint16_t(273), Tuint16_t(274), Tuint16_t(274), Tuint16_t(275), Tuint16_t(276), Tuint16_t(276), Tuint16_t(277), Tuint16_t(278), Tuint16_t(279), Tuint16_t(280), Tuint16_t(280),
	Tuint16_t(281), Tuint16_t(281), Tuint16_t(281), Tuint16_t(281), Tuint16_t(281), Tuint16_t(281), Tuint16_t(281), Tuint16_t(281), Tuint16_t(281), Tuint16_t(281), Tuint16_t(281), Tuint16_t(282), Tuint16_t(283), Tuint16_t(284), Tuint16_t(284), Tuint16_t(285),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(287), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(288), Tuint16_t(288), Tuint16_t(288), Tuint16_t(288), Tuint16_t(288),
	Tuint16_t(288), Tuint16_t(288), Tuint16_t(288), Tuint16_t(289), Tuint16_t(289), Tuint16_t(289), Tuint16_t(281), Tuint16_t(290), Tuint16_t(291), Tuint16_t(281), Tuint16_t(281), Tuint16_t(281), Tuint16_t(281), Tuint16_t(281), Tuint16_t(281), Tuint16_t(281),
	Tuint16_t(292), Tuint16_t(292), Tuint16_t(292), Tuint16_t(292), Tuint16_t(292), Tuint16_t(292), Tuint16_t(292), Tuint16_t(292), Tuint16_t(292), Tuint16_t(292), Tuint16_t(276), Tuint16_t(293), Tuint16_t(293), Tuint16_t(279), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(289), Tuint16_t(286), Tuint16_t(286), Tuint16_t(294), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),

	// block 13
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(295), Tuint16_t(286), Tuint16_t(281), Tuint16_t(281), Tuint16_t(281), Tuint16_t(281), Tuint16_t(281), Tuint16_t(281), Tuint16_t(281), Tuint16_t(273), Tuint16_t(280), Tuint16_t(291),
	Tuint16_t(291), Tuint16_t(281), Tuint16_t(281), Tuint16_t(281), Tuint16_t(281), Tuint16_t(296), Tuint16_t(296), Tuint16_t(281), Tuint16_t(281), Tuint16_t(280), Tuint16_t(291), Tuint16_t(291), Tuint16_t(291), Tuint16_t(281), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(297), Tuint16_t(297), Tuint16_t(297), Tuint16_t(297), Tuint16_t(297), Tuint16_t(297), Tuint16_t(297), Tuint16_t(297), Tuint16_t(297), Tuint16_t(297), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(298), Tuint16_t(298), Tuint16_t(286),

	// block 14
	Tuint16_t(299), Tuint16_t(299), Tuint16_t(299), Tuint16_t(300), Tuint16_t(300), Tuint16_t(300), Tuint16_t(300), Tuint16_t(300), Tuint16_t(300), Tuint16_t(300), Tuint16_t(300), Tuint16_t(301), Tuint16_t(300), Tuint16_t(301), Tuint16_t(302), Tuint16_t(303),
	Tuint16_t(304), Tuint16_t(305), Tuint16_t(304), Tuint16_t(304), Tuint16_t(304), Tuint16_t(304), Tuint16_t(304), Tuint16_t(304), Tuint16_t(304), Tuint16_t(304), Tuint16_t(304), Tuint16_t(304), Tuint16_t(304), Tuint16_t(304), Tuint16_t(304), Tuint16_t(304),
	Tuint16_t(304), Tuint16_t(304), Tuint16_t(304), Tuint16_t(304), Tuint16_t(304), Tuint16_t(304), Tuint16_t(304), Tuint16_t(304), Tuint16_t(304), Tuint16_t(304), Tuint16_t(304), Tuint16_t(304), Tuint16_t(304), Tuint16_t(304), Tuint16_t(304), Tuint16_t(304),
	Tuint16_t(306), Tuint16_t(306), Tuint16_t(306), Tuint16_t(306), Tuint16_t(306), Tuint16_t(306), Tuint16_t(306), Tuint16_t(306), Tuint16_t(306), Tuint16_t(306), Tuint16_t(306), Tuint16_t(306), Tuint16_t(306), Tuint16_t(306), Tuint16_t(306), Tuint16_t(306),
	Tuint16_t(307), Tuint16_t(307), Tuint16_t(307), Tuint16_t(307), Tuint16_t(307), Tuint16_t(307), Tuint16_t(307), Tuint16_t(307), Tuint16_t(307), Tuint16_t(307), Tuint16_t(307), Tuint16_t(302), Tuint16_t(302), Tuint16_t(304), Tuint16_t(304), Tuint16_t(304),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),

	// block 15
	Tuint16_t(308), Tuint16_t(308), Tuint16_t(308), Tuint16_t(308), Tuint16_t(308), Tuint16_t(308), Tuint16_t(308), Tuint16_t(308), Tuint16_t(308), Tuint16_t(308), Tuint16_t(308), Tuint16_t(308), Tuint16_t(308), Tuint16_t(308), Tuint16_t(308), Tuint16_t(308),
	Tuint16_t(308), Tuint16_t(308), Tuint16_t(308), Tuint16_t(308), Tuint16_t(308), Tuint16_t(308), Tuint16_t(308), Tuint16_t(308), Tuint16_t(308), Tuint16_t(308), Tuint16_t(308), Tuint16_t(308), Tuint16_t(308), Tuint16_t(308), Tuint16_t(308), Tuint16_t(308),
	Tuint16_t(308), Tuint16_t(308), Tuint16_t(308), Tuint16_t(308), Tuint16_t(308), Tuint16_t(308), Tuint16_t(309), Tuint16_t(309), Tuint16_t(309), Tuint16_t(309), Tuint16_t(309), Tuint16_t(309), Tuint16_t(309), Tuint16_t(309), Tuint16_t(309), Tuint16_t(309),
	Tuint16_t(309), Tuint16_t(308), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302),
	Tuint16_t(310), Tuint16_t(310), Tuint16_t(310), Tuint16_t(310), Tuint16_t(310), Tuint16_t(310), Tuint16_t(310), Tuint16_t(310), Tuint16_t(310), Tuint16_t(310), Tuint16_t(311), Tuint16_t(311), Tuint16_t(311), Tuint16_t(311), Tuint16_t(311), Tuint16_t(311),
	Tuint16_t(311), Tuint16_t(311), Tuint16_t(311), Tuint16_t(311), Tuint16_t(311), Tuint16_t(311), Tuint16_t(311), Tuint16_t(311), Tuint16_t(311), Tuint16_t(311), Tuint16_t(311), Tuint16_t(311), Tuint16_t(311), Tuint16_t(311), Tuint16_t(311), Tuint16_t(311),
	Tuint16_t(311), Tuint16_t(311), Tuint16_t(311), Tuint16_t(311), Tuint16_t(311), Tuint16_t(311), Tuint16_t(311), Tuint16_t(311), Tuint16_t(311), Tuint16_t(311), Tuint16_t(311), Tuint16_t(312), Tuint16_t(312), Tuint16_t(312), Tuint16_t(312), Tuint16_t(312),
	Tuint16_t(312), Tuint16_t(312), Tuint16_t(312), Tuint16_t(312), Tuint16_t(313), Tuint16_t(313), Tuint16_t(314), Tuint16_t(315), Tuint16_t(316), Tuint16_t(317), Tuint16_t(318), Tuint16_t(262), Tuint16_t(262), Tuint16_t(319), Tuint16_t(320), Tuint16_t(320),

	// block 16
	Tuint16_t(321), Tuint16_t(321), Tuint16_t(321), Tuint16_t(321), Tuint16_t(321), Tuint16_t(321), Tuint16_t(321), Tuint16_t(321), Tuint16_t(321), Tuint16_t(321), Tuint16_t(321), Tuint16_t(321), Tuint16_t(321), Tuint16_t(321), Tuint16_t(321), Tuint16_t(321),
	Tuint16_t(321), Tuint16_t(321), Tuint16_t(321), Tuint16_t(321), Tuint16_t(321), Tuint16_t(321), Tuint16_t(322), Tuint16_t(322), Tuint16_t(323), Tuint16_t(323), Tuint16_t(324), Tuint16_t(322), Tuint16_t(322), Tuint16_t(322), Tuint16_t(322), Tuint16_t(322),
	Tuint16_t(322), Tuint16_t(322), Tuint16_t(322), Tuint16_t(322), Tuint16_t(324), Tuint16_t(322), Tuint16_t(322), Tuint16_t(322), Tuint16_t(324), Tuint16_t(322), Tuint16_t(322), Tuint16_t(322), Tuint16_t(322), Tuint16_t(325), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(326), Tuint16_t(326), Tuint16_t(326), Tuint16_t(326), Tuint16_t(326), Tuint16_t(326), Tuint16_t(326), Tuint16_t(327), Tuint16_t(326), Tuint16_t(327), Tuint16_t(326), Tuint16_t(326), Tuint16_t(326), Tuint16_t(327), Tuint16_t(327), Tuint16_t(262),
	Tuint16_t(328), Tuint16_t(328), Tuint16_t(328), Tuint16_t(328), Tuint16_t(328), Tuint16_t(328), Tuint16_t(328), Tuint16_t(328), Tuint16_t(328), Tuint16_t(328), Tuint16_t(328), Tuint16_t(328), Tuint16_t(328), Tuint16_t(328), Tuint16_t(328), Tuint16_t(328),
	Tuint16_t(328), Tuint16_t(328), Tuint16_t(328), Tuint16_t(328), Tuint16_t(328), Tuint16_t(328), Tuint16_t(328), Tuint16_t(328), Tuint16_t(328), Tuint16_t(329), Tuint16_t(329), Tuint16_t(329), Tuint16_t(262), Tuint16_t(262), Tuint16_t(330), Tuint16_t(262),
	Tuint16_t(304), Tuint16_t(304), Tuint16_t(304), Tuint16_t(304), Tuint16_t(304), Tuint16_t(304), Tuint16_t(304), Tuint16_t(304), Tuint16_t(304), Tuint16_t(304), Tuint16_t(304), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),

	// block 17
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(331), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(302),
	Tuint16_t(272), Tuint16_t(272), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(291), Tuint16_t(291), Tuint16_t(291), Tuint16_t(291), Tuint16_t(291), Tuint16_t(291), Tuint16_t(291), Tuint16_t(291),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(296), Tuint16_t(291), Tuint16_t(291), Tuint16_t(291), Tuint16_t(291), Tuint16_t(291), Tuint16_t(291),
	Tuint16_t(291), Tuint16_t(291), Tuint16_t(291), Tuint16_t(332), Tuint16_t(281), Tuint16_t(281), Tuint16_t(281), Tuint16_t(281), Tuint16_t(281), Tuint16_t(281), Tuint16_t(281), Tuint16_t(281), Tuint16_t(281), Tuint16_t(281), Tuint16_t(281), Tuint16_t(281),
	Tuint16_t(332), Tuint16_t(332), Tuint16_t(273), Tuint16_t(290), Tuint16_t(290), Tuint16_t(290), Tuint16_t(290), Tuint16_t(290), Tuint16_t(290), Tuint16_t(290), Tuint16_t(291), Tuint16_t(291), Tuint16_t(291), Tuint16_t(291), Tuint16_t(291), Tuint16_t(291),
	Tuint16_t(290), Tuint16_t(290), Tuint16_t(290), Tuint16_t(290), Tuint16_t(290), Tuint16_t(290), Tuint16_t(290), Tuint16_t(290), Tuint16_t(290), Tuint16_t(290), Tuint16_t(290), Tuint16_t(290), Tuint16_t(290), Tuint16_t(290), Tuint16_t(290), Tuint16_t(281),

	// block 18
	Tuint16_t(333), Tuint16_t(333), Tuint16_t(333), Tuint16_t(334), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335),
	Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335),
	Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335),
	Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(333), Tuint16_t(334), Tuint16_t(336), Tuint16_t(335), Tuint16_t(334), Tuint16_t(334),
	Tuint16_t(334), Tuint16_t(333), Tuint16_t(333), Tuint16_t(333), Tuint16_t(333), Tuint16_t(333), Tuint16_t(333), Tuint16_t(333), Tuint16_t(333), Tuint16_t(334), Tuint16_t(334), Tuint16_t(334), Tuint16_t(334), Tuint16_t(337), Tuint16_t(334), Tuint16_t(334),
	Tuint16_t(335), Tuint16_t(338), Tuint16_t(339), Tuint16_t(154), Tuint16_t(154), Tuint16_t(333), Tuint16_t(333), Tuint16_t(333), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335),
	Tuint16_t(335), Tuint16_t(335), Tuint16_t(333), Tuint16_t(333), Tuint16_t(340), Tuint16_t(341), Tuint16_t(342), Tuint16_t(342), Tuint16_t(342), Tuint16_t(342), Tuint16_t(342), Tuint16_t(342), Tuint16_t(342), Tuint16_t(342), Tuint16_t(342), Tuint16_t(342),
	Tuint16_t(343), Tuint16_t(344), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335),

	// block 19
	Tuint16_t(345), Tuint16_t(346), Tuint16_t(347), Tuint16_t(347), Tuint16_t(163), Tuint16_t(345), Tuint16_t(345), Tuint16_t(345), Tuint16_t(345), Tuint16_t(345), Tuint16_t(345), Tuint16_t(345), Tuint16_t(345), Tuint16_t(163), Tuint16_t(163), Tuint16_t(345),
	Tuint16_t(345), Tuint16_t(163), Tuint16_t(163), Tuint16_t(345), Tuint16_t(345), Tuint16_t(345), Tuint16_t(345), Tuint16_t(345), Tuint16_t(345), Tuint16_t(345), Tuint16_t(345), Tuint16_t(345), Tuint16_t(345), Tuint16_t(345), Tuint16_t(345), Tuint16_t(345),
	Tuint16_t(345), Tuint16_t(345), Tuint16_t(345), Tuint16_t(345), Tuint16_t(345), Tuint16_t(345), Tuint16_t(345), Tuint16_t(345), Tuint16_t(345), Tuint16_t(163), Tuint16_t(345), Tuint16_t(345), Tuint16_t(345), Tuint16_t(345), Tuint16_t(345), Tuint16_t(345),
	Tuint16_t(345), Tuint16_t(163), Tuint16_t(345), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(345), Tuint16_t(345), Tuint16_t(345), Tuint16_t(345), Tuint16_t(163), Tuint16_t(163), Tuint16_t(348), Tuint16_t(345), Tuint16_t(349), Tuint16_t(347),
	Tuint16_t(347), Tuint16_t(346), Tuint16_t(346), Tuint16_t(346), Tuint16_t(346), Tuint16_t(163), Tuint16_t(163), Tuint16_t(347), Tuint16_t(347), Tuint16_t(163), Tuint16_t(163), Tuint16_t(347), Tuint16_t(347), Tuint16_t(350), Tuint16_t(345), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(349), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(345), Tuint16_t(345), Tuint16_t(163), Tuint16_t(345),
	Tuint16_t(345), Tuint16_t(345), Tuint16_t(346), Tuint16_t(346), Tuint16_t(163), Tuint16_t(163), Tuint16_t(351), Tuint16_t(351), Tuint16_t(351), Tuint16_t(351), Tuint16_t(351), Tuint16_t(351), Tuint16_t(351), Tuint16_t(351), Tuint16_t(351), Tuint16_t(351),
	Tuint16_t(345), Tuint16_t(345), Tuint16_t(352), Tuint16_t(352), Tuint16_t(353), Tuint16_t(353), Tuint16_t(353), Tuint16_t(353), Tuint16_t(353), Tuint16_t(353), Tuint16_t(354), Tuint16_t(352), Tuint16_t(345), Tuint16_t(355), Tuint16_t(356), Tuint16_t(163),

	// block 20
	Tuint16_t(163), Tuint16_t(357), Tuint16_t(357), Tuint16_t(358), Tuint16_t(163), Tuint16_t(359), Tuint16_t(359), Tuint16_t(359), Tuint16_t(359), Tuint16_t(359), Tuint16_t(359), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(359),
	Tuint16_t(359), Tuint16_t(163), Tuint16_t(163), Tuint16_t(359), Tuint16_t(359), Tuint16_t(359), Tuint16_t(359), Tuint16_t(359), Tuint16_t(359), Tuint16_t(359), Tuint16_t(359), Tuint16_t(359), Tuint16_t(359), Tuint16_t(359), Tuint16_t(359), Tuint16_t(359),
	Tuint16_t(359), Tuint16_t(359), Tuint16_t(359), Tuint16_t(359), Tuint16_t(359), Tuint16_t(359), Tuint16_t(359), Tuint16_t(359), Tuint16_t(359), Tuint16_t(163), Tuint16_t(359), Tuint16_t(359), Tuint16_t(359), Tuint16_t(359), Tuint16_t(359), Tuint16_t(359),
	Tuint16_t(359), Tuint16_t(163), Tuint16_t(359), Tuint16_t(359), Tuint16_t(163), Tuint16_t(359), Tuint16_t(359), Tuint16_t(163), Tuint16_t(359), Tuint16_t(359), Tuint16_t(163), Tuint16_t(163), Tuint16_t(360), Tuint16_t(163), Tuint16_t(358), Tuint16_t(358),
	Tuint16_t(358), Tuint16_t(357), Tuint16_t(357), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(357), Tuint16_t(357), Tuint16_t(163), Tuint16_t(163), Tuint16_t(357), Tuint16_t(357), Tuint16_t(361), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(357), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(359), Tuint16_t(359), Tuint16_t(359), Tuint16_t(359), Tuint16_t(163), Tuint16_t(359), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(362), Tuint16_t(362), Tuint16_t(362), Tuint16_t(362), Tuint16_t(362), Tuint16_t(362), Tuint16_t(362), Tuint16_t(362), Tuint16_t(362), Tuint16_t(362),
	Tuint16_t(357), Tuint16_t(357), Tuint16_t(359), Tuint16_t(359), Tuint16_t(359), Tuint16_t(357), Tuint16_t(363), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 21
	Tuint16_t(163), Tuint16_t(364), Tuint16_t(364), Tuint16_t(365), Tuint16_t(163), Tuint16_t(366), Tuint16_t(366), Tuint16_t(366), Tuint16_t(366), Tuint16_t(366), Tuint16_t(366), Tuint16_t(366), Tuint16_t(366), Tuint16_t(366), Tuint16_t(163), Tuint16_t(366),
	Tuint16_t(366), Tuint16_t(366), Tuint16_t(163), Tuint16_t(366), Tuint16_t(366), Tuint16_t(366), Tuint16_t(366), Tuint16_t(366), Tuint16_t(366), Tuint16_t(366), Tuint16_t(366), Tuint16_t(366), Tuint16_t(366), Tuint16_t(366), Tuint16_t(366), Tuint16_t(366),
	Tuint16_t(366), Tuint16_t(366), Tuint16_t(366), Tuint16_t(366), Tuint16_t(366), Tuint16_t(366), Tuint16_t(366), Tuint16_t(366), Tuint16_t(366), Tuint16_t(163), Tuint16_t(366), Tuint16_t(366), Tuint16_t(366), Tuint16_t(366), Tuint16_t(366), Tuint16_t(366),
	Tuint16_t(366), Tuint16_t(163), Tuint16_t(366), Tuint16_t(366), Tuint16_t(163), Tuint16_t(366), Tuint16_t(366), Tuint16_t(366), Tuint16_t(366), Tuint16_t(366), Tuint16_t(163), Tuint16_t(163), Tuint16_t(367), Tuint16_t(366), Tuint16_t(365), Tuint16_t(365),
	Tuint16_t(365), Tuint16_t(364), Tuint16_t(364), Tuint16_t(364), Tuint16_t(364), Tuint16_t(364), Tuint16_t(163), Tuint16_t(364), Tuint16_t(364), Tuint16_t(365), Tuint16_t(163), Tuint16_t(365), Tuint16_t(365), Tuint16_t(368), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(366), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(366), Tuint16_t(366), Tuint16_t(364), Tuint16_t(364), Tuint16_t(163), Tuint16_t(163), Tuint16_t(369), Tuint16_t(369), Tuint16_t(369), Tuint16_t(369), Tuint16_t(369), Tuint16_t(369), Tuint16_t(369), Tuint16_t(369), Tuint16_t(369), Tuint16_t(369),
	Tuint16_t(370), Tuint16_t(371), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(366), Tuint16_t(364), Tuint16_t(364), Tuint16_t(364), Tuint16_t(367), Tuint16_t(367), Tuint16_t(367),

	// block 22
	Tuint16_t(163), Tuint16_t(372), Tuint16_t(373), Tuint16_t(373), Tuint16_t(163), Tuint16_t(374), Tuint16_t(374), Tuint16_t(374), Tuint16_t(374), Tuint16_t(374), Tuint16_t(374), Tuint16_t(374), Tuint16_t(374), Tuint16_t(163), Tuint16_t(163), Tuint16_t(374),
	Tuint16_t(374), Tuint16_t(163), Tuint16_t(163), Tuint16_t(374), Tuint16_t(374), Tuint16_t(374), Tuint16_t(374), Tuint16_t(374), Tuint16_t(374), Tuint16_t(374), Tuint16_t(374), Tuint16_t(374), Tuint16_t(374), Tuint16_t(374), Tuint16_t(374), Tuint16_t(374),
	Tuint16_t(374), Tuint16_t(374), Tuint16_t(374), Tuint16_t(374), Tuint16_t(374), Tuint16_t(374), Tuint16_t(374), Tuint16_t(374), Tuint16_t(374), Tuint16_t(163), Tuint16_t(374), Tuint16_t(374), Tuint16_t(374), Tuint16_t(374), Tuint16_t(374), Tuint16_t(374),
	Tuint16_t(374), Tuint16_t(163), Tuint16_t(374), Tuint16_t(374), Tuint16_t(163), Tuint16_t(374), Tuint16_t(374), Tuint16_t(374), Tuint16_t(374), Tuint16_t(374), Tuint16_t(163), Tuint16_t(163), Tuint16_t(375), Tuint16_t(374), Tuint16_t(376), Tuint16_t(372),
	Tuint16_t(373), Tuint16_t(372), Tuint16_t(372), Tuint16_t(372), Tuint16_t(372), Tuint16_t(163), Tuint16_t(163), Tuint16_t(373), Tuint16_t(373), Tuint16_t(163), Tuint16_t(163), Tuint16_t(373), Tuint16_t(373), Tuint16_t(377), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(378), Tuint16_t(372), Tuint16_t(376), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(374), Tuint16_t(374), Tuint16_t(163), Tuint16_t(374),
	Tuint16_t(374), Tuint16_t(374), Tuint16_t(372), Tuint16_t(372), Tuint16_t(163), Tuint16_t(163), Tuint16_t(379), Tuint16_t(379), Tuint16_t(379), Tuint16_t(379), Tuint16_t(379), Tuint16_t(379), Tuint16_t(379), Tuint16_t(379), Tuint16_t(379), Tuint16_t(379),
	Tuint16_t(380), Tuint16_t(374), Tuint16_t(381), Tuint16_t(381), Tuint16_t(381), Tuint16_t(381), Tuint16_t(381), Tuint16_t(381), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 23
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(382), Tuint16_t(383), Tuint16_t(163), Tuint16_t(383), Tuint16_t(383), Tuint16_t(383), Tuint16_t(383), Tuint16_t(383), Tuint16_t(383), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(383), Tuint16_t(383),
	Tuint16_t(383), Tuint16_t(163), Tuint16_t(383), Tuint16_t(383), Tuint16_t(383), Tuint16_t(383), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(383), Tuint16_t(383), Tuint16_t(163), Tuint16_t(383), Tuint16_t(163), Tuint16_t(383), Tuint16_t(383),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(383), Tuint16_t(383), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(383), Tuint16_t(383), Tuint16_t(383), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(383), Tuint16_t(383),
	Tuint16_t(383), Tuint16_t(383), Tuint16_t(383), Tuint16_t(383), Tuint16_t(383), Tuint16_t(383), Tuint16_t(383), Tuint16_t(383), Tuint16_t(383), Tuint16_t(383), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(384), Tuint16_t(385),
	Tuint16_t(382), Tuint16_t(385), Tuint16_t(385), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(385), Tuint16_t(385), Tuint16_t(385), Tuint16_t(163), Tuint16_t(385), Tuint16_t(385), Tuint16_t(385), Tuint16_t(386), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(383), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(384), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(387), Tuint16_t(387), Tuint16_t(387), Tuint16_t(387), Tuint16_t(387), Tuint16_t(387), Tuint16_t(387), Tuint16_t(387), Tuint16_t(387), Tuint16_t(387),
	Tuint16_t(388), Tuint16_t(388), Tuint16_t(388), Tuint16_t(389), Tuint16_t(390), Tuint16_t(390), Tuint16_t(390), Tuint16_t(390), Tuint16_t(390), Tuint16_t(391), Tuint16_t(390), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 24
	Tuint16_t(392), Tuint16_t(393), Tuint16_t(393), Tuint16_t(393), Tuint16_t(394), Tuint16_t(395), Tuint16_t(395), Tuint16_t(395), Tuint16_t(395), Tuint16_t(395), Tuint16_t(395), Tuint16_t(395), Tuint16_t(395), Tuint16_t(163), Tuint16_t(395), Tuint16_t(395),
	Tuint16_t(395), Tuint16_t(163), Tuint16_t(395), Tuint16_t(395), Tuint16_t(395), Tuint16_t(395), Tuint16_t(395), Tuint16_t(395), Tuint16_t(395), Tuint16_t(395), Tuint16_t(395), Tuint16_t(395), Tuint16_t(395), Tuint16_t(395), Tuint16_t(395), Tuint16_t(395),
	Tuint16_t(395), Tuint16_t(395), Tuint16_t(395), Tuint16_t(395), Tuint16_t(395), Tuint16_t(395), Tuint16_t(395), Tuint16_t(395), Tuint16_t(395), Tuint16_t(163), Tuint16_t(395), Tuint16_t(395), Tuint16_t(395), Tuint16_t(395), Tuint16_t(395), Tuint16_t(395),
	Tuint16_t(395), Tuint16_t(395), Tuint16_t(395), Tuint16_t(395), Tuint16_t(395), Tuint16_t(395), Tuint16_t(395), Tuint16_t(395), Tuint16_t(395), Tuint16_t(395), Tuint16_t(163), Tuint16_t(163), Tuint16_t(396), Tuint16_t(395), Tuint16_t(392), Tuint16_t(392),
	Tuint16_t(392), Tuint16_t(393), Tuint16_t(393), Tuint16_t(393), Tuint16_t(393), Tuint16_t(163), Tuint16_t(392), Tuint16_t(392), Tuint16_t(392), Tuint16_t(163), Tuint16_t(392), Tuint16_t(392), Tuint16_t(392), Tuint16_t(397), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(392), Tuint16_t(392), Tuint16_t(163), Tuint16_t(395), Tuint16_t(395), Tuint16_t(395), Tuint16_t(163), Tuint16_t(163), Tuint16_t(395), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(395), Tuint16_t(395), Tuint16_t(392), Tuint16_t(392), Tuint16_t(163), Tuint16_t(163), Tuint16_t(398), Tuint16_t(398), Tuint16_t(398), Tuint16_t(398), Tuint16_t(398), Tuint16_t(398), Tuint16_t(398), Tuint16_t(398), Tuint16_t(398), Tuint16_t(398),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(399), Tuint16_t(400), Tuint16_t(400), Tuint16_t(400), Tuint16_t(400), Tuint16_t(400), Tuint16_t(400), Tuint16_t(400), Tuint16_t(401),

	// block 25
	Tuint16_t(402), Tuint16_t(403), Tuint16_t(404), Tuint16_t(404), Tuint16_t(405), Tuint16_t(402), Tuint16_t(402), Tuint16_t(402), Tuint16_t(402), Tuint16_t(402), Tuint16_t(402), Tuint16_t(402), Tuint16_t(402), Tuint16_t(163), Tuint16_t(402), Tuint16_t(402),
	Tuint16_t(402), Tuint16_t(163), Tuint16_t(402), Tuint16_t(402), Tuint16_t(402), Tuint16_t(402), Tuint16_t(402), Tuint16_t(402), Tuint16_t(402), Tuint16_t(402), Tuint16_t(402), Tuint16_t(402), Tuint16_t(402), Tuint16_t(402), Tuint16_t(402), Tuint16_t(402),
	Tuint16_t(402), Tuint16_t(402), Tuint16_t(402), Tuint16_t(402), Tuint16_t(402), Tuint16_t(402), Tuint16_t(402), Tuint16_t(402), Tuint16_t(402), Tuint16_t(163), Tuint16_t(402), Tuint16_t(402), Tuint16_t(402), Tuint16_t(402), Tuint16_t(402), Tuint16_t(402),
	Tuint16_t(402), Tuint16_t(402), Tuint16_t(402), Tuint16_t(402), Tuint16_t(163), Tuint16_t(402), Tuint16_t(402), Tuint16_t(402), Tuint16_t(402), Tuint16_t(402), Tuint16_t(163), Tuint16_t(163), Tuint16_t(406), Tuint16_t(402), Tuint16_t(404), Tuint16_t(407),
	Tuint16_t(404), Tuint16_t(404), Tuint16_t(408), Tuint16_t(404), Tuint16_t(404), Tuint16_t(163), Tuint16_t(407), Tuint16_t(404), Tuint16_t(404), Tuint16_t(163), Tuint16_t(404), Tuint16_t(404), Tuint16_t(403), Tuint16_t(409), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(408), Tuint16_t(408), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(402), Tuint16_t(402), Tuint16_t(163),
	Tuint16_t(402), Tuint16_t(402), Tuint16_t(403), Tuint16_t(403), Tuint16_t(163), Tuint16_t(163), Tuint16_t(410), Tuint16_t(410), Tuint16_t(410), Tuint16_t(410), Tuint16_t(410), Tuint16_t(410), Tuint16_t(410), Tuint16_t(410), Tuint16_t(410), Tuint16_t(410),
	Tuint16_t(163), Tuint16_t(402), Tuint16_t(402), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 26
	Tuint16_t(411), Tuint16_t(411), Tuint16_t(412), Tuint16_t(412), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(163), Tuint16_t(413), Tuint16_t(413),
	Tuint16_t(413), Tuint16_t(163), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413),
	Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413),
	Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(414), Tuint16_t(414), Tuint16_t(413), Tuint16_t(415), Tuint16_t(412),
	Tuint16_t(412), Tuint16_t(411), Tuint16_t(411), Tuint16_t(411), Tuint16_t(411), Tuint16_t(163), Tuint16_t(412), Tuint16_t(412), Tuint16_t(412), Tuint16_t(163), Tuint16_t(412), Tuint16_t(412), Tuint16_t(412), Tuint16_t(414), Tuint16_t(416), Tuint16_t(417),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(415), Tuint16_t(418), Tuint16_t(418), Tuint16_t(418), Tuint16_t(418), Tuint16_t(418), Tuint16_t(418), Tuint16_t(418), Tuint16_t(413),
	Tuint16_t(413), Tuint16_t(413), Tuint16_t(411), Tuint16_t(411), Tuint16_t(163), Tuint16_t(163), Tuint16_t(419), Tuint16_t(419), Tuint16_t(419), Tuint16_t(419), Tuint16_t(419), Tuint16_t(419), Tuint16_t(419), Tuint16_t(419), Tuint16_t(419), Tuint16_t(419),
	Tuint16_t(418), Tuint16_t(418), Tuint16_t(418), Tuint16_t(418), Tuint16_t(418), Tuint16_t(418), Tuint16_t(418), Tuint16_t(418), Tuint16_t(418), Tuint16_t(417), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413), Tuint16_t(413),

	// block 27
	Tuint16_t(163), Tuint16_t(420), Tuint16_t(421), Tuint16_t(421), Tuint16_t(163), Tuint16_t(422), Tuint16_t(422), Tuint16_t(422), Tuint16_t(422), Tuint16_t(422), Tuint16_t(422), Tuint16_t(422), Tuint16_t(422), Tuint16_t(422), Tuint16_t(422), Tuint16_t(422),
	Tuint16_t(422), Tuint16_t(422), Tuint16_t(422), Tuint16_t(422), Tuint16_t(422), Tuint16_t(422), Tuint16_t(422), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(422), Tuint16_t(422), Tuint16_t(422), Tuint16_t(422), Tuint16_t(422), Tuint16_t(422),
	Tuint16_t(422), Tuint16_t(422), Tuint16_t(422), Tuint16_t(422), Tuint16_t(422), Tuint16_t(422), Tuint16_t(422), Tuint16_t(422), Tuint16_t(422), Tuint16_t(422), Tuint16_t(422), Tuint16_t(422), Tuint16_t(422), Tuint16_t(422), Tuint16_t(422), Tuint16_t(422),
	Tuint16_t(422), Tuint16_t(422), Tuint16_t(163), Tuint16_t(422), Tuint16_t(422), Tuint16_t(422), Tuint16_t(422), Tuint16_t(422), Tuint16_t(422), Tuint16_t(422), Tuint16_t(422), Tuint16_t(422), Tuint16_t(163), Tuint16_t(422), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(422), Tuint16_t(422), Tuint16_t(422), Tuint16_t(422), Tuint16_t(422), Tuint16_t(422), Tuint16_t(422), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(423), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(424),
	Tuint16_t(421), Tuint16_t(421), Tuint16_t(420), Tuint16_t(420), Tuint16_t(420), Tuint16_t(163), Tuint16_t(420), Tuint16_t(163), Tuint16_t(421), Tuint16_t(421), Tuint16_t(421), Tuint16_t(421), Tuint16_t(421), Tuint16_t(421), Tuint16_t(421), Tuint16_t(424),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(425), Tuint16_t(425), Tuint16_t(425), Tuint16_t(425), Tuint16_t(425), Tuint16_t(425), Tuint16_t(425), Tuint16_t(425), Tuint16_t(425), Tuint16_t(425),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(421), Tuint16_t(421), Tuint16_t(426), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 28
	Tuint16_t(163), Tuint16_t(427), Tuint16_t(427), Tuint16_t(427), Tuint16_t(427), Tuint16_t(427), Tuint16_t(427), Tuint16_t(427), Tuint16_t(427), Tuint16_t(427), Tuint16_t(427), Tuint16_t(427), Tuint16_t(427), Tuint16_t(427), Tuint16_t(427), Tuint16_t(427),
	Tuint16_t(427), Tuint16_t(427), Tuint16_t(427), Tuint16_t(427), Tuint16_t(427), Tuint16_t(427), Tuint16_t(427), Tuint16_t(427), Tuint16_t(427), Tuint16_t(427), Tuint16_t(427), Tuint16_t(427), Tuint16_t(427), Tuint16_t(427), Tuint16_t(427), Tuint16_t(427),
	Tuint16_t(427), Tuint16_t(427), Tuint16_t(427), Tuint16_t(427), Tuint16_t(427), Tuint16_t(427), Tuint16_t(427), Tuint16_t(427), Tuint16_t(427), Tuint16_t(427), Tuint16_t(427), Tuint16_t(427), Tuint16_t(427), Tuint16_t(427), Tuint16_t(427), Tuint16_t(427),
	Tuint16_t(427), Tuint16_t(428), Tuint16_t(427), Tuint16_t(429), Tuint16_t(428), Tuint16_t(428), Tuint16_t(428), Tuint16_t(428), Tuint16_t(428), Tuint16_t(428), Tuint16_t(430), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(431),
	Tuint16_t(432), Tuint16_t(432), Tuint16_t(432), Tuint16_t(432), Tuint16_t(432), Tuint16_t(427), Tuint16_t(433), Tuint16_t(434), Tuint16_t(434), Tuint16_t(434), Tuint16_t(434), Tuint16_t(434), Tuint16_t(434), Tuint16_t(428), Tuint16_t(434), Tuint16_t(435),
	Tuint16_t(436), Tuint16_t(436), Tuint16_t(436), Tuint16_t(436), Tuint16_t(436), Tuint16_t(436), Tuint16_t(436), Tuint16_t(436), Tuint16_t(436), Tuint16_t(436), Tuint16_t(437), Tuint16_t(437), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 29
	Tuint16_t(163), Tuint16_t(438), Tuint16_t(438), Tuint16_t(163), Tuint16_t(438), Tuint16_t(163), Tuint16_t(438), Tuint16_t(438), Tuint16_t(438), Tuint16_t(438), Tuint16_t(438), Tuint16_t(163), Tuint16_t(438), Tuint16_t(438), Tuint16_t(438), Tuint16_t(438),
	Tuint16_t(438), Tuint16_t(438), Tuint16_t(438), Tuint16_t(438), Tuint16_t(438), Tuint16_t(438), Tuint16_t(438), Tuint16_t(438), Tuint16_t(438), Tuint16_t(438), Tuint16_t(438), Tuint16_t(438), Tuint16_t(438), Tuint16_t(438), Tuint16_t(438), Tuint16_t(438),
	Tuint16_t(438), Tuint16_t(438), Tuint16_t(438), Tuint16_t(438), Tuint16_t(163), Tuint16_t(438), Tuint16_t(163), Tuint16_t(438), Tuint16_t(438), Tuint16_t(438), Tuint16_t(438), Tuint16_t(438), Tuint16_t(438), Tuint16_t(438), Tuint16_t(438), Tuint16_t(438),
	Tuint16_t(438), Tuint16_t(439), Tuint16_t(438), Tuint16_t(440), Tuint16_t(439), Tuint16_t(439), Tuint16_t(439), Tuint16_t(439), Tuint16_t(439), Tuint16_t(439), Tuint16_t(441), Tuint16_t(439), Tuint16_t(439), Tuint16_t(438), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(442), Tuint16_t(442), Tuint16_t(442), Tuint16_t(442), Tuint16_t(442), Tuint16_t(163), Tuint16_t(443), Tuint16_t(163), Tuint16_t(444), Tuint16_t(444), Tuint16_t(444), Tuint16_t(444), Tuint16_t(444), Tuint16_t(439), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(445), Tuint16_t(445), Tuint16_t(445), Tuint16_t(445), Tuint16_t(445), Tuint16_t(445), Tuint16_t(445), Tuint16_t(445), Tuint16_t(445), Tuint16_t(445), Tuint16_t(163), Tuint16_t(163), Tuint16_t(438), Tuint16_t(438), Tuint16_t(438), Tuint16_t(438),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 30
	Tuint16_t(446), Tuint16_t(447), Tuint16_t(447), Tuint16_t(447), Tuint16_t(448), Tuint16_t(448), Tuint16_t(448), Tuint16_t(448), Tuint16_t(449), Tuint16_t(448), Tuint16_t(448), Tuint16_t(448), Tuint16_t(448), Tuint16_t(449), Tuint16_t(449), Tuint16_t(449),
	Tuint16_t(449), Tuint16_t(449), Tuint16_t(449), Tuint16_t(447), Tuint16_t(448), Tuint16_t(447), Tuint16_t(447), Tuint16_t(447), Tuint16_t(450), Tuint16_t(450), Tuint16_t(447), Tuint16_t(447), Tuint16_t(447), Tuint16_t(447), Tuint16_t(447), Tuint16_t(447),
	Tuint16_t(451), Tuint16_t(451), Tuint16_t(451), Tuint16_t(451), Tuint16_t(451), Tuint16_t(451), Tuint16_t(451), Tuint16_t(451), Tuint16_t(451), Tuint16_t(451), Tuint16_t(452), Tuint16_t(452), Tuint16_t(452), Tuint16_t(452), Tuint16_t(452), Tuint16_t(452),
	Tuint16_t(452), Tuint16_t(452), Tuint16_t(452), Tuint16_t(452), Tuint16_t(447), Tuint16_t(450), Tuint16_t(447), Tuint16_t(450), Tuint16_t(447), Tuint16_t(450), Tuint16_t(453), Tuint16_t(454), Tuint16_t(453), Tuint16_t(454), Tuint16_t(455), Tuint16_t(455),
	Tuint16_t(446), Tuint16_t(446), Tuint16_t(446), Tuint16_t(446), Tuint16_t(446), Tuint16_t(446), Tuint16_t(446), Tuint16_t(446), Tuint16_t(163), Tuint16_t(446), Tuint16_t(446), Tuint16_t(446), Tuint16_t(446), Tuint16_t(446), Tuint16_t(446), Tuint16_t(446),
	Tuint16_t(446), Tuint16_t(446), Tuint16_t(446), Tuint16_t(446), Tuint16_t(446), Tuint16_t(446), Tuint16_t(446), Tuint16_t(446), Tuint16_t(446), Tuint16_t(446), Tuint16_t(446), Tuint16_t(446), Tuint16_t(446), Tuint16_t(446), Tuint16_t(446), Tuint16_t(446),
	Tuint16_t(446), Tuint16_t(446), Tuint16_t(446), Tuint16_t(446), Tuint16_t(446), Tuint16_t(446), Tuint16_t(446), Tuint16_t(446), Tuint16_t(446), Tuint16_t(446), Tuint16_t(446), Tuint16_t(446), Tuint16_t(446), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(456), Tuint16_t(456), Tuint16_t(456), Tuint16_t(456), Tuint16_t(456), Tuint16_t(456), Tuint16_t(457), Tuint16_t(456), Tuint16_t(457), Tuint16_t(456), Tuint16_t(456), Tuint16_t(456), Tuint16_t(456), Tuint16_t(456), Tuint16_t(458),

	// block 31
	Tuint16_t(456), Tuint16_t(456), Tuint16_t(450), Tuint16_t(450), Tuint16_t(459), Tuint16_t(448), Tuint16_t(450), Tuint16_t(450), Tuint16_t(446), Tuint16_t(446), Tuint16_t(446), Tuint16_t(446), Tuint16_t(446), Tuint16_t(456), Tuint16_t(456), Tuint16_t(456),
	Tuint16_t(456), Tuint16_t(456), Tuint16_t(456), Tuint16_t(456), Tuint16_t(456), Tuint16_t(456), Tuint16_t(456), Tuint16_t(456), Tuint16_t(163), Tuint16_t(456), Tuint16_t(456), Tuint16_t(456), Tuint16_t(456), Tuint16_t(456), Tuint16_t(456), Tuint16_t(456),
	Tuint16_t(456), Tuint16_t(456), Tuint16_t(456), Tuint16_t(456), Tuint16_t(456), Tuint16_t(456), Tuint16_t(456), Tuint16_t(456), Tuint16_t(456), Tuint16_t(456), Tuint16_t(456), Tuint16_t(456), Tuint16_t(456), Tuint16_t(456), Tuint16_t(456), Tuint16_t(456),
	Tuint16_t(456), Tuint16_t(456), Tuint16_t(456), Tuint16_t(456), Tuint16_t(456), Tuint16_t(456), Tuint16_t(456), Tuint16_t(456), Tuint16_t(456), Tuint16_t(456), Tuint16_t(456), Tuint16_t(456), Tuint16_t(456), Tuint16_t(163), Tuint16_t(447), Tuint16_t(447),
	Tuint16_t(447), Tuint16_t(447), Tuint16_t(447), Tuint16_t(447), Tuint16_t(447), Tuint16_t(447), Tuint16_t(450), Tuint16_t(447), Tuint16_t(447), Tuint16_t(447), Tuint16_t(447), Tuint16_t(447), Tuint16_t(447), Tuint16_t(163), Tuint16_t(447), Tuint16_t(447),
	Tuint16_t(448), Tuint16_t(448), Tuint16_t(448), Tuint16_t(448), Tuint16_t(448), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(448), Tuint16_t(448), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 32
	Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461),
	Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461),
	Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(462), Tuint16_t(462), Tuint16_t(463), Tuint16_t(463), Tuint16_t(463),
	Tuint16_t(463), Tuint16_t(464), Tuint16_t(463), Tuint16_t(463), Tuint16_t(463), Tuint16_t(463), Tuint16_t(463), Tuint16_t(465), Tuint16_t(462), Tuint16_t(466), Tuint16_t(466), Tuint16_t(464), Tuint16_t(464), Tuint16_t(463), Tuint16_t(463), Tuint16_t(461),
	Tuint16_t(467), Tuint16_t(467), Tuint16_t(467), Tuint16_t(467), Tuint16_t(467), Tuint16_t(467), Tuint16_t(467), Tuint16_t(467), Tuint16_t(467), Tuint16_t(467), Tuint16_t(468), Tuint16_t(468), Tuint16_t(469), Tuint16_t(469), Tuint16_t(469), Tuint16_t(469),
	Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(464), Tuint16_t(464), Tuint16_t(463), Tuint16_t(463), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(463), Tuint16_t(463),
	Tuint16_t(463), Tuint16_t(461), Tuint16_t(462), Tuint16_t(470), Tuint16_t(470), Tuint16_t(461), Tuint16_t(461), Tuint16_t(462), Tuint16_t(462), Tuint16_t(470), Tuint16_t(470), Tuint16_t(470), Tuint16_t(470), Tuint16_t(470), Tuint16_t(461), Tuint16_t(461),
	Tuint16_t(461), Tuint16_t(463), Tuint16_t(463), Tuint16_t(463), Tuint16_t(463), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461),

	// block 33
	Tuint16_t(461), Tuint16_t(461), Tuint16_t(463), Tuint16_t(462), Tuint16_t(464), Tuint16_t(463), Tuint16_t(463), Tuint16_t(470), Tuint16_t(470), Tuint16_t(470), Tuint16_t(470), Tuint16_t(470), Tuint16_t(470), Tuint16_t(471), Tuint16_t(461), Tuint16_t(470),
	Tuint16_t(472), Tuint16_t(472), Tuint16_t(472), Tuint16_t(472), Tuint16_t(472), Tuint16_t(472), Tuint16_t(472), Tuint16_t(472), Tuint16_t(472), Tuint16_t(472), Tuint16_t(470), Tuint16_t(470), Tuint16_t(462), Tuint16_t(463), Tuint16_t(473), Tuint16_t(473),
	Tuint16_t(474), Tuint16_t(474), Tuint16_t(474), Tuint16_t(474), Tuint16_t(474), Tuint16_t(474), Tuint16_t(474), Tuint16_t(474), Tuint16_t(474), Tuint16_t(474), Tuint16_t(474), Tuint16_t(474), Tuint16_t(474), Tuint16_t(474), Tuint16_t(474), Tuint16_t(474),
	Tuint16_t(474), Tuint16_t(474), Tuint16_t(474), Tuint16_t(474), Tuint16_t(474), Tuint16_t(474), Tuint16_t(474), Tuint16_t(474), Tuint16_t(474), Tuint16_t(474), Tuint16_t(474), Tuint16_t(474), Tuint16_t(474), Tuint16_t(474), Tuint16_t(474), Tuint16_t(474),
	Tuint16_t(474), Tuint16_t(474), Tuint16_t(474), Tuint16_t(474), Tuint16_t(474), Tuint16_t(474), Tuint16_t(163), Tuint16_t(474), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(474), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(475), Tuint16_t(475), Tuint16_t(475), Tuint16_t(475), Tuint16_t(475), Tuint16_t(475), Tuint16_t(475), Tuint16_t(475), Tuint16_t(475), Tuint16_t(475), Tuint16_t(475), Tuint16_t(475), Tuint16_t(475), Tuint16_t(475), Tuint16_t(475), Tuint16_t(475),
	Tuint16_t(475), Tuint16_t(475), Tuint16_t(475), Tuint16_t(475), Tuint16_t(475), Tuint16_t(475), Tuint16_t(475), Tuint16_t(475), Tuint16_t(475), Tuint16_t(475), Tuint16_t(475), Tuint16_t(475), Tuint16_t(475), Tuint16_t(475), Tuint16_t(475), Tuint16_t(475),
	Tuint16_t(475), Tuint16_t(475), Tuint16_t(475), Tuint16_t(475), Tuint16_t(475), Tuint16_t(475), Tuint16_t(475), Tuint16_t(475), Tuint16_t(475), Tuint16_t(475), Tuint16_t(475), Tuint16_t(476), Tuint16_t(477), Tuint16_t(475), Tuint16_t(475), Tuint16_t(475),

	// block 34
	Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478),
	Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478),
	Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478),
	Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478),
	Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478),
	Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(479),
	Tuint16_t(480), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481),
	Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481),

	// block 35
	Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481),
	Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481),
	Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482),
	Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482),
	Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482),
	Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482),
	Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482),
	Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482),

	// block 36
	Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483),
	Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483),
	Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483),
	Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483),
	Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(163), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(163), Tuint16_t(483), Tuint16_t(163), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483),
	Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483),

	// block 37
	Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(163), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483),
	Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483),
	Tuint16_t(483), Tuint16_t(163), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(163), Tuint16_t(163), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(163),
	Tuint16_t(483), Tuint16_t(163), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(163), Tuint16_t(163), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483),
	Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(163), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483),
	Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483),
	Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483),

	// block 38
	Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483),
	Tuint16_t(483), Tuint16_t(163), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(163), Tuint16_t(163), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483),
	Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483),
	Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483),
	Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483),
	Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(163), Tuint16_t(163), Tuint16_t(484), Tuint16_t(484), Tuint16_t(484),
	Tuint16_t(485), Tuint16_t(486), Tuint16_t(487), Tuint16_t(486), Tuint16_t(486), Tuint16_t(486), Tuint16_t(486), Tuint16_t(487), Tuint16_t(487), Tuint16_t(488), Tuint16_t(488), Tuint16_t(488), Tuint16_t(488), Tuint16_t(488), Tuint16_t(488), Tuint16_t(488),
	Tuint16_t(488), Tuint16_t(488), Tuint16_t(489), Tuint16_t(489), Tuint16_t(489), Tuint16_t(489), Tuint16_t(489), Tuint16_t(489), Tuint16_t(489), Tuint16_t(489), Tuint16_t(489), Tuint16_t(489), Tuint16_t(489), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 39
	Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483),
	Tuint16_t(490), Tuint16_t(490), Tuint16_t(490), Tuint16_t(490), Tuint16_t(490), Tuint16_t(490), Tuint16_t(490), Tuint16_t(490), Tuint16_t(490), Tuint16_t(490), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491),
	Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491),
	Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491),
	Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491),
	Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491), Tuint16_t(491),
	Tuint16_t(492), Tuint16_t(492), Tuint16_t(492), Tuint16_t(492), Tuint16_t(492), Tuint16_t(492), Tuint16_t(163), Tuint16_t(163), Tuint16_t(493), Tuint16_t(493), Tuint16_t(493), Tuint16_t(493), Tuint16_t(493), Tuint16_t(493), Tuint16_t(163), Tuint16_t(163),

	// block 40
	Tuint16_t(494), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495),
	Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495),
	Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495),
	Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495),
	Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495),
	Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495),
	Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495),
	Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495),

	// block 41
	Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495),
	Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495),
	Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495),
	Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495),
	Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495),
	Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495),
	Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495),
	Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495),

	// block 42
	Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495),
	Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495),
	Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495),
	Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495),
	Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495),
	Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495),
	Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(496), Tuint16_t(497), Tuint16_t(495),
	Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495),

	// block 43
	Tuint16_t(498), Tuint16_t(499), Tuint16_t(499), Tuint16_t(499), Tuint16_t(499), Tuint16_t(499), Tuint16_t(499), Tuint16_t(499), Tuint16_t(499), Tuint16_t(499), Tuint16_t(499), Tuint16_t(499), Tuint16_t(499), Tuint16_t(499), Tuint16_t(499), Tuint16_t(499),
	Tuint16_t(499), Tuint16_t(499), Tuint16_t(499), Tuint16_t(499), Tuint16_t(499), Tuint16_t(499), Tuint16_t(499), Tuint16_t(499), Tuint16_t(499), Tuint16_t(499), Tuint16_t(499), Tuint16_t(500), Tuint16_t(501), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502),
	Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502),
	Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502),
	Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502),
	Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(503), Tuint16_t(503), Tuint16_t(503), Tuint16_t(504), Tuint16_t(504),
	Tuint16_t(504), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(502), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 44
	Tuint16_t(505), Tuint16_t(505), Tuint16_t(505), Tuint16_t(505), Tuint16_t(505), Tuint16_t(505), Tuint16_t(505), Tuint16_t(505), Tuint16_t(505), Tuint16_t(505), Tuint16_t(505), Tuint16_t(505), Tuint16_t(505), Tuint16_t(505), Tuint16_t(505), Tuint16_t(505),
	Tuint16_t(505), Tuint16_t(505), Tuint16_t(506), Tuint16_t(506), Tuint16_t(507), Tuint16_t(508), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(505),
	Tuint16_t(509), Tuint16_t(509), Tuint16_t(509), Tuint16_t(509), Tuint16_t(509), Tuint16_t(509), Tuint16_t(509), Tuint16_t(509), Tuint16_t(509), Tuint16_t(509), Tuint16_t(509), Tuint16_t(509), Tuint16_t(509), Tuint16_t(509), Tuint16_t(509), Tuint16_t(509),
	Tuint16_t(509), Tuint16_t(509), Tuint16_t(510), Tuint16_t(510), Tuint16_t(511), Tuint16_t(512), Tuint16_t(512), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(513), Tuint16_t(513), Tuint16_t(513), Tuint16_t(513), Tuint16_t(513), Tuint16_t(513), Tuint16_t(513), Tuint16_t(513), Tuint16_t(513), Tuint16_t(513), Tuint16_t(513), Tuint16_t(513), Tuint16_t(513), Tuint16_t(513), Tuint16_t(513), Tuint16_t(513),
	Tuint16_t(513), Tuint16_t(513), Tuint16_t(514), Tuint16_t(514), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(515), Tuint16_t(515), Tuint16_t(515), Tuint16_t(515), Tuint16_t(515), Tuint16_t(515), Tuint16_t(515), Tuint16_t(515), Tuint16_t(515), Tuint16_t(515), Tuint16_t(515), Tuint16_t(515), Tuint16_t(515), Tuint16_t(163), Tuint16_t(515), Tuint16_t(515),
	Tuint16_t(515), Tuint16_t(163), Tuint16_t(516), Tuint16_t(516), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 45
	Tuint16_t(517), Tuint16_t(517), Tuint16_t(517), Tuint16_t(517), Tuint16_t(517), Tuint16_t(517), Tuint16_t(517), Tuint16_t(517), Tuint16_t(517), Tuint16_t(517), Tuint16_t(517), Tuint16_t(517), Tuint16_t(517), Tuint16_t(517), Tuint16_t(517), Tuint16_t(517),
	Tuint16_t(517), Tuint16_t(517), Tuint16_t(517), Tuint16_t(517), Tuint16_t(517), Tuint16_t(517), Tuint16_t(517), Tuint16_t(517), Tuint16_t(517), Tuint16_t(517), Tuint16_t(517), Tuint16_t(517), Tuint16_t(517), Tuint16_t(517), Tuint16_t(517), Tuint16_t(517),
	Tuint16_t(517), Tuint16_t(517), Tuint16_t(517), Tuint16_t(518), Tuint16_t(518), Tuint16_t(517), Tuint16_t(517), Tuint16_t(517), Tuint16_t(517), Tuint16_t(517), Tuint16_t(517), Tuint16_t(517), Tuint16_t(517), Tuint16_t(517), Tuint16_t(517), Tuint16_t(517),
	Tuint16_t(517), Tuint16_t(517), Tuint16_t(517), Tuint16_t(517), Tuint16_t(519), Tuint16_t(519), Tuint16_t(520), Tuint16_t(521), Tuint16_t(521), Tuint16_t(521), Tuint16_t(521), Tuint16_t(521), Tuint16_t(521), Tuint16_t(521), Tuint16_t(520), Tuint16_t(520),
	Tuint16_t(520), Tuint16_t(520), Tuint16_t(520), Tuint16_t(520), Tuint16_t(520), Tuint16_t(520), Tuint16_t(521), Tuint16_t(520), Tuint16_t(520), Tuint16_t(522), Tuint16_t(522), Tuint16_t(522), Tuint16_t(522), Tuint16_t(522), Tuint16_t(522), Tuint16_t(522),
	Tuint16_t(522), Tuint16_t(522), Tuint16_t(523), Tuint16_t(522), Tuint16_t(524), Tuint16_t(524), Tuint16_t(524), Tuint16_t(525), Tuint16_t(526), Tuint16_t(526), Tuint16_t(524), Tuint16_t(527), Tuint16_t(517), Tuint16_t(522), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(528), Tuint16_t(528), Tuint16_t(528), Tuint16_t(528), Tuint16_t(528), Tuint16_t(528), Tuint16_t(528), Tuint16_t(528), Tuint16_t(528), Tuint16_t(528), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(529), Tuint16_t(529), Tuint16_t(529), Tuint16_t(529), Tuint16_t(529), Tuint16_t(529), Tuint16_t(529), Tuint16_t(529), Tuint16_t(529), Tuint16_t(529), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 46
	Tuint16_t(530), Tuint16_t(530), Tuint16_t(531), Tuint16_t(532), Tuint16_t(533), Tuint16_t(531), Tuint16_t(534), Tuint16_t(530), Tuint16_t(533), Tuint16_t(535), Tuint16_t(536), Tuint16_t(537), Tuint16_t(537), Tuint16_t(537), Tuint16_t(538), Tuint16_t(537),
	Tuint16_t(539), Tuint16_t(539), Tuint16_t(539), Tuint16_t(539), Tuint16_t(539), Tuint16_t(539), Tuint16_t(539), Tuint16_t(539), Tuint16_t(539), Tuint16_t(539), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540),
	Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540),
	Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(541), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540),
	Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540),
	Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540),
	Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 47
	Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(542), Tuint16_t(542), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540),
	Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540),
	Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(540), Tuint16_t(543), Tuint16_t(540), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495),
	Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495),
	Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495),
	Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495),
	Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 48
	Tuint16_t(544), Tuint16_t(544), Tuint16_t(544), Tuint16_t(544), Tuint16_t(544), Tuint16_t(544), Tuint16_t(544), Tuint16_t(544), Tuint16_t(544), Tuint16_t(544), Tuint16_t(544), Tuint16_t(544), Tuint16_t(544), Tuint16_t(544), Tuint16_t(544), Tuint16_t(544),
	Tuint16_t(544), Tuint16_t(544), Tuint16_t(544), Tuint16_t(544), Tuint16_t(544), Tuint16_t(544), Tuint16_t(544), Tuint16_t(544), Tuint16_t(544), Tuint16_t(544), Tuint16_t(544), Tuint16_t(544), Tuint16_t(544), Tuint16_t(544), Tuint16_t(544), Tuint16_t(163),
	Tuint16_t(545), Tuint16_t(545), Tuint16_t(545), Tuint16_t(546), Tuint16_t(546), Tuint16_t(546), Tuint16_t(546), Tuint16_t(545), Tuint16_t(545), Tuint16_t(546), Tuint16_t(546), Tuint16_t(546), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(546), Tuint16_t(546), Tuint16_t(545), Tuint16_t(546), Tuint16_t(546), Tuint16_t(546), Tuint16_t(546), Tuint16_t(546), Tuint16_t(546), Tuint16_t(547), Tuint16_t(547), Tuint16_t(547), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(548), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(549), Tuint16_t(549), Tuint16_t(550), Tuint16_t(550), Tuint16_t(550), Tuint16_t(550), Tuint16_t(550), Tuint16_t(550), Tuint16_t(550), Tuint16_t(550), Tuint16_t(550), Tuint16_t(550),
	Tuint16_t(551), Tuint16_t(551), Tuint16_t(551), Tuint16_t(551), Tuint16_t(551), Tuint16_t(551), Tuint16_t(551), Tuint16_t(551), Tuint16_t(551), Tuint16_t(551), Tuint16_t(551), Tuint16_t(551), Tuint16_t(551), Tuint16_t(551), Tuint16_t(551), Tuint16_t(551),
	Tuint16_t(551), Tuint16_t(551), Tuint16_t(551), Tuint16_t(551), Tuint16_t(551), Tuint16_t(551), Tuint16_t(551), Tuint16_t(551), Tuint16_t(551), Tuint16_t(551), Tuint16_t(551), Tuint16_t(551), Tuint16_t(551), Tuint16_t(551), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(551), Tuint16_t(551), Tuint16_t(551), Tuint16_t(551), Tuint16_t(551), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 49
	Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552),
	Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552),
	Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(553), Tuint16_t(553), Tuint16_t(553), Tuint16_t(552), Tuint16_t(552), Tuint16_t(553), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552),
	Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(552), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(554), Tuint16_t(554), Tuint16_t(554), Tuint16_t(554), Tuint16_t(554), Tuint16_t(554), Tuint16_t(554), Tuint16_t(554), Tuint16_t(554), Tuint16_t(554), Tuint16_t(555), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(556), Tuint16_t(556),
	Tuint16_t(557), Tuint16_t(557), Tuint16_t(557), Tuint16_t(557), Tuint16_t(557), Tuint16_t(557), Tuint16_t(557), Tuint16_t(557), Tuint16_t(557), Tuint16_t(557), Tuint16_t(557), Tuint16_t(557), Tuint16_t(557), Tuint16_t(557), Tuint16_t(557), Tuint16_t(557),
	Tuint16_t(557), Tuint16_t(557), Tuint16_t(557), Tuint16_t(557), Tuint16_t(557), Tuint16_t(557), Tuint16_t(557), Tuint16_t(557), Tuint16_t(557), Tuint16_t(557), Tuint16_t(557), Tuint16_t(557), Tuint16_t(557), Tuint16_t(557), Tuint16_t(557), Tuint16_t(557),

	// block 50
	Tuint16_t(558), Tuint16_t(558), Tuint16_t(558), Tuint16_t(558), Tuint16_t(558), Tuint16_t(558), Tuint16_t(558), Tuint16_t(558), Tuint16_t(558), Tuint16_t(558), Tuint16_t(558), Tuint16_t(558), Tuint16_t(558), Tuint16_t(558), Tuint16_t(558), Tuint16_t(558),
	Tuint16_t(558), Tuint16_t(558), Tuint16_t(558), Tuint16_t(558), Tuint16_t(558), Tuint16_t(558), Tuint16_t(558), Tuint16_t(559), Tuint16_t(559), Tuint16_t(560), Tuint16_t(560), Tuint16_t(559), Tuint16_t(163), Tuint16_t(163), Tuint16_t(561), Tuint16_t(561),
	Tuint16_t(562), Tuint16_t(562), Tuint16_t(562), Tuint16_t(562), Tuint16_t(562), Tuint16_t(562), Tuint16_t(562), Tuint16_t(562), Tuint16_t(562), Tuint16_t(562), Tuint16_t(562), Tuint16_t(562), Tuint16_t(562), Tuint16_t(562), Tuint16_t(562), Tuint16_t(562),
	Tuint16_t(562), Tuint16_t(562), Tuint16_t(562), Tuint16_t(562), Tuint16_t(562), Tuint16_t(562), Tuint16_t(562), Tuint16_t(562), Tuint16_t(562), Tuint16_t(562), Tuint16_t(562), Tuint16_t(562), Tuint16_t(562), Tuint16_t(562), Tuint16_t(562), Tuint16_t(562),
	Tuint16_t(562), Tuint16_t(562), Tuint16_t(562), Tuint16_t(562), Tuint16_t(562), Tuint16_t(562), Tuint16_t(562), Tuint16_t(562), Tuint16_t(562), Tuint16_t(562), Tuint16_t(562), Tuint16_t(562), Tuint16_t(562), Tuint16_t(562), Tuint16_t(562), Tuint16_t(562),
	Tuint16_t(562), Tuint16_t(562), Tuint16_t(562), Tuint16_t(562), Tuint16_t(562), Tuint16_t(563), Tuint16_t(564), Tuint16_t(563), Tuint16_t(564), Tuint16_t(564), Tuint16_t(564), Tuint16_t(564), Tuint16_t(564), Tuint16_t(564), Tuint16_t(564), Tuint16_t(163),
	Tuint16_t(565), Tuint16_t(566), Tuint16_t(564), Tuint16_t(566), Tuint16_t(566), Tuint16_t(564), Tuint16_t(564), Tuint16_t(564), Tuint16_t(564), Tuint16_t(564), Tuint16_t(564), Tuint16_t(564), Tuint16_t(564), Tuint16_t(563), Tuint16_t(563), Tuint16_t(563),
	Tuint16_t(563), Tuint16_t(563), Tuint16_t(563), Tuint16_t(564), Tuint16_t(564), Tuint16_t(567), Tuint16_t(567), Tuint16_t(567), Tuint16_t(567), Tuint16_t(567), Tuint16_t(567), Tuint16_t(567), Tuint16_t(567), Tuint16_t(163), Tuint16_t(163), Tuint16_t(567),

	// block 51
	Tuint16_t(568), Tuint16_t(568), Tuint16_t(568), Tuint16_t(568), Tuint16_t(568), Tuint16_t(568), Tuint16_t(568), Tuint16_t(568), Tuint16_t(568), Tuint16_t(568), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(568), Tuint16_t(568), Tuint16_t(568), Tuint16_t(568), Tuint16_t(568), Tuint16_t(568), Tuint16_t(568), Tuint16_t(568), Tuint16_t(568), Tuint16_t(568), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(569), Tuint16_t(569), Tuint16_t(569), Tuint16_t(569), Tuint16_t(569), Tuint16_t(569), Tuint16_t(569), Tuint16_t(570), Tuint16_t(571), Tuint16_t(571), Tuint16_t(571), Tuint16_t(571), Tuint16_t(569), Tuint16_t(569), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(572), Tuint16_t(573),
	Tuint16_t(573), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(573), Tuint16_t(573), Tuint16_t(573), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 52
	Tuint16_t(574), Tuint16_t(574), Tuint16_t(574), Tuint16_t(574), Tuint16_t(575), Tuint16_t(576), Tuint16_t(576), Tuint16_t(576), Tuint16_t(576), Tuint16_t(576), Tuint16_t(576), Tuint16_t(576), Tuint16_t(576), Tuint16_t(576), Tuint16_t(576), Tuint16_t(576),
	Tuint16_t(576), Tuint16_t(576), Tuint16_t(576), Tuint16_t(576), Tuint16_t(576), Tuint16_t(576), Tuint16_t(576), Tuint16_t(576), Tuint16_t(576), Tuint16_t(576), Tuint16_t(576), Tuint16_t(576), Tuint16_t(576), Tuint16_t(576), Tuint16_t(576), Tuint16_t(576),
	Tuint16_t(576), Tuint16_t(576), Tuint16_t(576), Tuint16_t(576), Tuint16_t(576), Tuint16_t(576), Tuint16_t(576), Tuint16_t(576), Tuint16_t(576), Tuint16_t(576), Tuint16_t(576), Tuint16_t(576), Tuint16_t(576), Tuint16_t(576), Tuint16_t(576), Tuint16_t(576),
	Tuint16_t(576), Tuint16_t(576), Tuint16_t(576), Tuint16_t(576), Tuint16_t(577), Tuint16_t(578), Tuint16_t(574), Tuint16_t(574), Tuint16_t(574), Tuint16_t(574), Tuint16_t(574), Tuint16_t(575), Tuint16_t(574), Tuint16_t(575), Tuint16_t(575), Tuint16_t(575),
	Tuint16_t(575), Tuint16_t(575), Tuint16_t(574), Tuint16_t(575), Tuint16_t(579), Tuint16_t(576), Tuint16_t(576), Tuint16_t(576), Tuint16_t(576), Tuint16_t(576), Tuint16_t(576), Tuint16_t(576), Tuint16_t(576), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(580), Tuint16_t(580), Tuint16_t(580), Tuint16_t(580), Tuint16_t(580), Tuint16_t(580), Tuint16_t(580), Tuint16_t(580), Tuint16_t(580), Tuint16_t(580), Tuint16_t(581), Tuint16_t(581), Tuint16_t(582), Tuint16_t(583), Tuint16_t(581), Tuint16_t(581),
	Tuint16_t(582), Tuint16_t(584), Tuint16_t(584), Tuint16_t(584), Tuint16_t(584), Tuint16_t(584), Tuint16_t(584), Tuint16_t(584), Tuint16_t(584), Tuint16_t(584), Tuint16_t(584), Tuint16_t(577), Tuint16_t(577), Tuint16_t(577), Tuint16_t(577), Tuint16_t(577),
	Tuint16_t(577), Tuint16_t(577), Tuint16_t(577), Tuint16_t(577), Tuint16_t(584), Tuint16_t(584), Tuint16_t(584), Tuint16_t(584), Tuint16_t(584), Tuint16_t(584), Tuint16_t(584), Tuint16_t(584), Tuint16_t(584), Tuint16_t(581), Tuint16_t(581), Tuint16_t(163),

	// block 53
	Tuint16_t(585), Tuint16_t(585), Tuint16_t(586), Tuint16_t(587), Tuint16_t(587), Tuint16_t(587), Tuint16_t(587), Tuint16_t(587), Tuint16_t(587), Tuint16_t(587), Tuint16_t(587), Tuint16_t(587), Tuint16_t(587), Tuint16_t(587), Tuint16_t(587), Tuint16_t(587),
	Tuint16_t(587), Tuint16_t(587), Tuint16_t(587), Tuint16_t(587), Tuint16_t(587), Tuint16_t(587), Tuint16_t(587), Tuint16_t(587), Tuint16_t(587), Tuint16_t(587), Tuint16_t(587), Tuint16_t(587), Tuint16_t(587), Tuint16_t(587), Tuint16_t(587), Tuint16_t(587),
	Tuint16_t(587), Tuint16_t(586), Tuint16_t(585), Tuint16_t(585), Tuint16_t(585), Tuint16_t(585), Tuint16_t(586), Tuint16_t(586), Tuint16_t(585), Tuint16_t(585), Tuint16_t(588), Tuint16_t(589), Tuint16_t(585), Tuint16_t(585), Tuint16_t(587), Tuint16_t(587),
	Tuint16_t(590), Tuint16_t(590), Tuint16_t(590), Tuint16_t(590), Tuint16_t(590), Tuint16_t(590), Tuint16_t(590), Tuint16_t(590), Tuint16_t(590), Tuint16_t(590), Tuint16_t(587), Tuint16_t(587), Tuint16_t(587), Tuint16_t(587), Tuint16_t(587), Tuint16_t(587),
	Tuint16_t(591), Tuint16_t(591), Tuint16_t(591), Tuint16_t(591), Tuint16_t(591), Tuint16_t(591), Tuint16_t(591), Tuint16_t(591), Tuint16_t(591), Tuint16_t(591), Tuint16_t(591), Tuint16_t(591), Tuint16_t(591), Tuint16_t(591), Tuint16_t(591), Tuint16_t(591),
	Tuint16_t(591), Tuint16_t(591), Tuint16_t(591), Tuint16_t(591), Tuint16_t(591), Tuint16_t(591), Tuint16_t(591), Tuint16_t(591), Tuint16_t(591), Tuint16_t(591), Tuint16_t(591), Tuint16_t(591), Tuint16_t(591), Tuint16_t(591), Tuint16_t(591), Tuint16_t(591),
	Tuint16_t(591), Tuint16_t(591), Tuint16_t(591), Tuint16_t(591), Tuint16_t(591), Tuint16_t(591), Tuint16_t(592), Tuint16_t(593), Tuint16_t(594), Tuint16_t(594), Tuint16_t(593), Tuint16_t(593), Tuint16_t(593), Tuint16_t(594), Tuint16_t(593), Tuint16_t(594),
	Tuint16_t(594), Tuint16_t(594), Tuint16_t(595), Tuint16_t(595), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(596), Tuint16_t(596), Tuint16_t(596), Tuint16_t(596),

	// block 54
	Tuint16_t(597), Tuint16_t(597), Tuint16_t(597), Tuint16_t(597), Tuint16_t(597), Tuint16_t(597), Tuint16_t(597), Tuint16_t(597), Tuint16_t(597), Tuint16_t(597), Tuint16_t(597), Tuint16_t(597), Tuint16_t(597), Tuint16_t(597), Tuint16_t(597), Tuint16_t(597),
	Tuint16_t(597), Tuint16_t(597), Tuint16_t(597), Tuint16_t(597), Tuint16_t(597), Tuint16_t(597), Tuint16_t(597), Tuint16_t(597), Tuint16_t(597), Tuint16_t(597), Tuint16_t(597), Tuint16_t(597), Tuint16_t(597), Tuint16_t(597), Tuint16_t(597), Tuint16_t(597),
	Tuint16_t(597), Tuint16_t(597), Tuint16_t(597), Tuint16_t(597), Tuint16_t(598), Tuint16_t(598), Tuint16_t(598), Tuint16_t(598), Tuint16_t(598), Tuint16_t(598), Tuint16_t(598), Tuint16_t(598), Tuint16_t(599), Tuint16_t(599), Tuint16_t(599), Tuint16_t(599),
	Tuint16_t(599), Tuint16_t(599), Tuint16_t(599), Tuint16_t(599), Tuint16_t(598), Tuint16_t(598), Tuint16_t(600), Tuint16_t(601), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(602), Tuint16_t(602), Tuint16_t(603), Tuint16_t(603), Tuint16_t(603),
	Tuint16_t(604), Tuint16_t(604), Tuint16_t(604), Tuint16_t(604), Tuint16_t(604), Tuint16_t(604), Tuint16_t(604), Tuint16_t(604), Tuint16_t(604), Tuint16_t(604), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(597), Tuint16_t(597), Tuint16_t(597),
	Tuint16_t(605), Tuint16_t(605), Tuint16_t(605), Tuint16_t(605), Tuint16_t(605), Tuint16_t(605), Tuint16_t(605), Tuint16_t(605), Tuint16_t(605), Tuint16_t(605), Tuint16_t(606), Tuint16_t(606), Tuint16_t(606), Tuint16_t(606), Tuint16_t(606), Tuint16_t(606),
	Tuint16_t(606), Tuint16_t(606), Tuint16_t(606), Tuint16_t(606), Tuint16_t(606), Tuint16_t(606), Tuint16_t(606), Tuint16_t(606), Tuint16_t(606), Tuint16_t(606), Tuint16_t(606), Tuint16_t(606), Tuint16_t(606), Tuint16_t(606), Tuint16_t(606), Tuint16_t(606),
	Tuint16_t(606), Tuint16_t(606), Tuint16_t(606), Tuint16_t(606), Tuint16_t(606), Tuint16_t(606), Tuint16_t(606), Tuint16_t(606), Tuint16_t(607), Tuint16_t(607), Tuint16_t(607), Tuint16_t(608), Tuint16_t(607), Tuint16_t(607), Tuint16_t(609), Tuint16_t(609),

	// block 55
	Tuint16_t(610), Tuint16_t(611), Tuint16_t(612), Tuint16_t(613), Tuint16_t(614), Tuint16_t(615), Tuint16_t(616), Tuint16_t(617), Tuint16_t(618), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(619), Tuint16_t(619), Tuint16_t(619), Tuint16_t(619), Tuint16_t(619), Tuint16_t(619), Tuint16_t(619), Tuint16_t(619), Tuint16_t(619), Tuint16_t(619), Tuint16_t(619), Tuint16_t(619), Tuint16_t(619), Tuint16_t(619), Tuint16_t(619), Tuint16_t(619),
	Tuint16_t(619), Tuint16_t(619), Tuint16_t(619), Tuint16_t(619), Tuint16_t(619), Tuint16_t(619), Tuint16_t(619), Tuint16_t(619), Tuint16_t(619), Tuint16_t(619), Tuint16_t(619), Tuint16_t(619), Tuint16_t(619), Tuint16_t(619), Tuint16_t(619), Tuint16_t(619),
	Tuint16_t(619), Tuint16_t(619), Tuint16_t(619), Tuint16_t(619), Tuint16_t(619), Tuint16_t(619), Tuint16_t(619), Tuint16_t(619), Tuint16_t(619), Tuint16_t(619), Tuint16_t(619), Tuint16_t(163), Tuint16_t(163), Tuint16_t(619), Tuint16_t(619), Tuint16_t(619),
	Tuint16_t(620), Tuint16_t(620), Tuint16_t(620), Tuint16_t(620), Tuint16_t(620), Tuint16_t(620), Tuint16_t(620), Tuint16_t(620), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(621), Tuint16_t(622), Tuint16_t(621), Tuint16_t(623), Tuint16_t(622), Tuint16_t(624), Tuint16_t(624), Tuint16_t(625), Tuint16_t(624), Tuint16_t(625), Tuint16_t(626), Tuint16_t(622), Tuint16_t(625), Tuint16_t(625), Tuint16_t(622), Tuint16_t(622),
	Tuint16_t(625), Tuint16_t(627), Tuint16_t(622), Tuint16_t(622), Tuint16_t(622), Tuint16_t(622), Tuint16_t(622), Tuint16_t(622), Tuint16_t(622), Tuint16_t(628), Tuint16_t(629), Tuint16_t(630), Tuint16_t(630), Tuint16_t(624), Tuint16_t(630), Tuint16_t(630),
	Tuint16_t(630), Tuint16_t(630), Tuint16_t(631), Tuint16_t(632), Tuint16_t(633), Tuint16_t(629), Tuint16_t(629), Tuint16_t(634), Tuint16_t(635), Tuint16_t(635), Tuint16_t(636), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 56
	Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70),
	Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70),
	Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(221), Tuint16_t(221), Tuint16_t(221), Tuint16_t(221), Tuint16_t(221), Tuint16_t(637), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147),
	Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147),
	Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147),
	Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(638), Tuint16_t(638), Tuint16_t(638),
	Tuint16_t(638), Tuint16_t(638), Tuint16_t(148), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(638), Tuint16_t(638), Tuint16_t(638), Tuint16_t(638), Tuint16_t(638), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70),
	Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(639), Tuint16_t(640), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(641), Tuint16_t(70), Tuint16_t(70),

	// block 57
	Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(642), Tuint16_t(70),
	Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(643), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(644), Tuint16_t(644), Tuint16_t(644), Tuint16_t(644), Tuint16_t(644),
	Tuint16_t(644), Tuint16_t(644), Tuint16_t(644), Tuint16_t(644), Tuint16_t(645), Tuint16_t(644), Tuint16_t(644), Tuint16_t(644), Tuint16_t(645), Tuint16_t(644), Tuint16_t(644), Tuint16_t(644), Tuint16_t(644), Tuint16_t(644), Tuint16_t(644), Tuint16_t(644),
	Tuint16_t(644), Tuint16_t(644), Tuint16_t(644), Tuint16_t(644), Tuint16_t(644), Tuint16_t(644), Tuint16_t(644), Tuint16_t(644), Tuint16_t(644), Tuint16_t(644), Tuint16_t(644), Tuint16_t(644), Tuint16_t(644), Tuint16_t(644), Tuint16_t(644), Tuint16_t(646),
	Tuint16_t(647), Tuint16_t(647), Tuint16_t(158), Tuint16_t(158), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154),
	Tuint16_t(158), Tuint16_t(158), Tuint16_t(158), Tuint16_t(158), Tuint16_t(158), Tuint16_t(158), Tuint16_t(158), Tuint16_t(158), Tuint16_t(158), Tuint16_t(158), Tuint16_t(158), Tuint16_t(158), Tuint16_t(158), Tuint16_t(158), Tuint16_t(158), Tuint16_t(158),
	Tuint16_t(158), Tuint16_t(158), Tuint16_t(158), Tuint16_t(158), Tuint16_t(158), Tuint16_t(158), Tuint16_t(158), Tuint16_t(573), Tuint16_t(573), Tuint16_t(573), Tuint16_t(573), Tuint16_t(573), Tuint16_t(573), Tuint16_t(573), Tuint16_t(573), Tuint16_t(573),
	Tuint16_t(573), Tuint16_t(573), Tuint16_t(573), Tuint16_t(573), Tuint16_t(573), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(648), Tuint16_t(154), Tuint16_t(649), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154),

	// block 58
	Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66),
	Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66),
	Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(67), Tuint16_t(65), Tuint16_t(66),
	Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66),
	Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66),
	Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66),
	Tuint16_t(650), Tuint16_t(651), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66),
	Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66),

	// block 59
	Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66),
	Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(69), Tuint16_t(69), Tuint16_t(69), Tuint16_t(69), Tuint16_t(652), Tuint16_t(653), Tuint16_t(70), Tuint16_t(70), Tuint16_t(654), Tuint16_t(70),
	Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66),
	Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66),
	Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(67), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66),
	Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66),
	Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66),
	Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66),

	// block 60
	Tuint16_t(655), Tuint16_t(655), Tuint16_t(655), Tuint16_t(655), Tuint16_t(655), Tuint16_t(655), Tuint16_t(655), Tuint16_t(655), Tuint16_t(656), Tuint16_t(656), Tuint16_t(656), Tuint16_t(656), Tuint16_t(656), Tuint16_t(656), Tuint16_t(656), Tuint16_t(656),
	Tuint16_t(655), Tuint16_t(655), Tuint16_t(655), Tuint16_t(655), Tuint16_t(655), Tuint16_t(655), Tuint16_t(163), Tuint16_t(163), Tuint16_t(656), Tuint16_t(656), Tuint16_t(656), Tuint16_t(656), Tuint16_t(656), Tuint16_t(656), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(655), Tuint16_t(655), Tuint16_t(655), Tuint16_t(655), Tuint16_t(655), Tuint16_t(655), Tuint16_t(655), Tuint16_t(655), Tuint16_t(656), Tuint16_t(656), Tuint16_t(656), Tuint16_t(656), Tuint16_t(656), Tuint16_t(656), Tuint16_t(656), Tuint16_t(656),
	Tuint16_t(655), Tuint16_t(655), Tuint16_t(655), Tuint16_t(655), Tuint16_t(655), Tuint16_t(655), Tuint16_t(655), Tuint16_t(655), Tuint16_t(656), Tuint16_t(656), Tuint16_t(656), Tuint16_t(656), Tuint16_t(656), Tuint16_t(656), Tuint16_t(656), Tuint16_t(656),
	Tuint16_t(655), Tuint16_t(655), Tuint16_t(655), Tuint16_t(655), Tuint16_t(655), Tuint16_t(655), Tuint16_t(163), Tuint16_t(163), Tuint16_t(656), Tuint16_t(656), Tuint16_t(656), Tuint16_t(656), Tuint16_t(656), Tuint16_t(656), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(173), Tuint16_t(655), Tuint16_t(173), Tuint16_t(655), Tuint16_t(173), Tuint16_t(655), Tuint16_t(173), Tuint16_t(655), Tuint16_t(163), Tuint16_t(656), Tuint16_t(163), Tuint16_t(656), Tuint16_t(163), Tuint16_t(656), Tuint16_t(163), Tuint16_t(656),
	Tuint16_t(655), Tuint16_t(655), Tuint16_t(655), Tuint16_t(655), Tuint16_t(655), Tuint16_t(655), Tuint16_t(655), Tuint16_t(655), Tuint16_t(656), Tuint16_t(656), Tuint16_t(656), Tuint16_t(656), Tuint16_t(656), Tuint16_t(656), Tuint16_t(656), Tuint16_t(656),
	Tuint16_t(657), Tuint16_t(657), Tuint16_t(658), Tuint16_t(658), Tuint16_t(658), Tuint16_t(658), Tuint16_t(659), Tuint16_t(659), Tuint16_t(660), Tuint16_t(660), Tuint16_t(661), Tuint16_t(661), Tuint16_t(662), Tuint16_t(662), Tuint16_t(163), Tuint16_t(163),

	// block 61
	Tuint16_t(663), Tuint16_t(663), Tuint16_t(663), Tuint16_t(663), Tuint16_t(663), Tuint16_t(663), Tuint16_t(663), Tuint16_t(663), Tuint16_t(664), Tuint16_t(664), Tuint16_t(664), Tuint16_t(664), Tuint16_t(664), Tuint16_t(664), Tuint16_t(664), Tuint16_t(664),
	Tuint16_t(663), Tuint16_t(663), Tuint16_t(663), Tuint16_t(663), Tuint16_t(663), Tuint16_t(663), Tuint16_t(663), Tuint16_t(663), Tuint16_t(664), Tuint16_t(664), Tuint16_t(664), Tuint16_t(664), Tuint16_t(664), Tuint16_t(664), Tuint16_t(664), Tuint16_t(664),
	Tuint16_t(663), Tuint16_t(663), Tuint16_t(663), Tuint16_t(663), Tuint16_t(663), Tuint16_t(663), Tuint16_t(663), Tuint16_t(663), Tuint16_t(664), Tuint16_t(664), Tuint16_t(664), Tuint16_t(664), Tuint16_t(664), Tuint16_t(664), Tuint16_t(664), Tuint16_t(664),
	Tuint16_t(655), Tuint16_t(655), Tuint16_t(665), Tuint16_t(666), Tuint16_t(665), Tuint16_t(163), Tuint16_t(173), Tuint16_t(665), Tuint16_t(656), Tuint16_t(656), Tuint16_t(667), Tuint16_t(667), Tuint16_t(668), Tuint16_t(162), Tuint16_t(669), Tuint16_t(162),
	Tuint16_t(162), Tuint16_t(162), Tuint16_t(665), Tuint16_t(666), Tuint16_t(665), Tuint16_t(163), Tuint16_t(173), Tuint16_t(665), Tuint16_t(670), Tuint16_t(670), Tuint16_t(670), Tuint16_t(670), Tuint16_t(668), Tuint16_t(162), Tuint16_t(162), Tuint16_t(162),
	Tuint16_t(655), Tuint16_t(655), Tuint16_t(173), Tuint16_t(173), Tuint16_t(163), Tuint16_t(163), Tuint16_t(173), Tuint16_t(173), Tuint16_t(656), Tuint16_t(656), Tuint16_t(671), Tuint16_t(671), Tuint16_t(163), Tuint16_t(162), Tuint16_t(162), Tuint16_t(162),
	Tuint16_t(655), Tuint16_t(655), Tuint16_t(173), Tuint16_t(173), Tuint16_t(173), Tuint16_t(215), Tuint16_t(173), Tuint16_t(173), Tuint16_t(656), Tuint16_t(656), Tuint16_t(672), Tuint16_t(672), Tuint16_t(220), Tuint16_t(162), Tuint16_t(162), Tuint16_t(162),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(665), Tuint16_t(666), Tuint16_t(665), Tuint16_t(163), Tuint16_t(173), Tuint16_t(665), Tuint16_t(673), Tuint16_t(673), Tuint16_t(674), Tuint16_t(674), Tuint16_t(668), Tuint16_t(162), Tuint16_t(162), Tuint16_t(163),

	// block 62
	Tuint16_t(675), Tuint16_t(675), Tuint16_t(675), Tuint16_t(675), Tuint16_t(675), Tuint16_t(675), Tuint16_t(675), Tuint16_t(675), Tuint16_t(675), Tuint16_t(675), Tuint16_t(675), Tuint16_t(51), Tuint16_t(676), Tuint16_t(677), Tuint16_t(678), Tuint16_t(679),
	Tuint16_t(680), Tuint16_t(680), Tuint16_t(680), Tuint16_t(680), Tuint16_t(680), Tuint16_t(680), Tuint16_t(681), Tuint16_t(43), Tuint16_t(682), Tuint16_t(683), Tuint16_t(684), Tuint16_t(685), Tuint16_t(685), Tuint16_t(686), Tuint16_t(684), Tuint16_t(685),
	Tuint16_t(43), Tuint16_t(43), Tuint16_t(43), Tuint16_t(43), Tuint16_t(687), Tuint16_t(43), Tuint16_t(43), Tuint16_t(687), Tuint16_t(688), Tuint16_t(689), Tuint16_t(690), Tuint16_t(691), Tuint16_t(692), Tuint16_t(693), Tuint16_t(694), Tuint16_t(695),
	Tuint16_t(696), Tuint16_t(696), Tuint16_t(697), Tuint16_t(697), Tuint16_t(697), Tuint16_t(43), Tuint16_t(43), Tuint16_t(43), Tuint16_t(43), Tuint16_t(49), Tuint16_t(57), Tuint16_t(43), Tuint16_t(698), Tuint16_t(699), Tuint16_t(43), Tuint16_t(700),
	Tuint16_t(701), Tuint16_t(43), Tuint16_t(43), Tuint16_t(43), Tuint16_t(702), Tuint16_t(703), Tuint16_t(704), Tuint16_t(699), Tuint16_t(699), Tuint16_t(698), Tuint16_t(43), Tuint16_t(43), Tuint16_t(43), Tuint16_t(43), Tuint16_t(43), Tuint16_t(43),
	Tuint16_t(43), Tuint16_t(43), Tuint16_t(50), Tuint16_t(705), Tuint16_t(700), Tuint16_t(43), Tuint16_t(43), Tuint16_t(43), Tuint16_t(43), Tuint16_t(43), Tuint16_t(43), Tuint16_t(43), Tuint16_t(43), Tuint16_t(43), Tuint16_t(43), Tuint16_t(675),
	Tuint16_t(51), Tuint16_t(706), Tuint16_t(706), Tuint16_t(706), Tuint16_t(706), Tuint16_t(707), Tuint16_t(708), Tuint16_t(709), Tuint16_t(710), Tuint16_t(711), Tuint16_t(712), Tuint16_t(712), Tuint16_t(712), Tuint16_t(712), Tuint16_t(712), Tuint16_t(712),
	Tuint16_t(54), Tuint16_t(645), Tuint16_t(163), Tuint16_t(163), Tuint16_t(54), Tuint16_t(54), Tuint16_t(54), Tuint16_t(54), Tuint16_t(54), Tuint16_t(54), Tuint16_t(713), Tuint16_t(714), Tuint16_t(715), Tuint16_t(716), Tuint16_t(717), Tuint16_t(644),

	// block 63
	Tuint16_t(54), Tuint16_t(54), Tuint16_t(54), Tuint16_t(54), Tuint16_t(54), Tuint16_t(54), Tuint16_t(54), Tuint16_t(54), Tuint16_t(54), Tuint16_t(54), Tuint16_t(713), Tuint16_t(714), Tuint16_t(715), Tuint16_t(716), Tuint16_t(717), Tuint16_t(163),
	Tuint16_t(644), Tuint16_t(644), Tuint16_t(644), Tuint16_t(644), Tuint16_t(644), Tuint16_t(644), Tuint16_t(644), Tuint16_t(644), Tuint16_t(644), Tuint16_t(644), Tuint16_t(644), Tuint16_t(644), Tuint16_t(644), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(431), Tuint16_t(431), Tuint16_t(431), Tuint16_t(431), Tuint16_t(431), Tuint16_t(431), Tuint16_t(431), Tuint16_t(431), Tuint16_t(431), Tuint16_t(431), Tuint16_t(431), Tuint16_t(431), Tuint16_t(431), Tuint16_t(431), Tuint16_t(431), Tuint16_t(431),
	Tuint16_t(431), Tuint16_t(431), Tuint16_t(431), Tuint16_t(431), Tuint16_t(431), Tuint16_t(431), Tuint16_t(431), Tuint16_t(431), Tuint16_t(431), Tuint16_t(431), Tuint16_t(431), Tuint16_t(431), Tuint16_t(431), Tuint16_t(431), Tuint16_t(431), Tuint16_t(431),
	Tuint16_t(431), Tuint16_t(718), Tuint16_t(718), Tuint16_t(718), Tuint16_t(718), Tuint16_t(718), Tuint16_t(718), Tuint16_t(718), Tuint16_t(718), Tuint16_t(718), Tuint16_t(718), Tuint16_t(718), Tuint16_t(718), Tuint16_t(718), Tuint16_t(718), Tuint16_t(718),
	Tuint16_t(719), Tuint16_t(719), Tuint16_t(719), Tuint16_t(719), Tuint16_t(719), Tuint16_t(719), Tuint16_t(719), Tuint16_t(719), Tuint16_t(719), Tuint16_t(719), Tuint16_t(719), Tuint16_t(719), Tuint16_t(719), Tuint16_t(720), Tuint16_t(720), Tuint16_t(720),
	Tuint16_t(720), Tuint16_t(719), Tuint16_t(720), Tuint16_t(721), Tuint16_t(720), Tuint16_t(719), Tuint16_t(719), Tuint16_t(158), Tuint16_t(158), Tuint16_t(158), Tuint16_t(158), Tuint16_t(719), Tuint16_t(719), Tuint16_t(719), Tuint16_t(719), Tuint16_t(719),
	Tuint16_t(722), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 64
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(724), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(724), Tuint16_t(723), Tuint16_t(723), Tuint16_t(725), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(725), Tuint16_t(725),
	Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(725), Tuint16_t(723), Tuint16_t(724), Tuint16_t(723), Tuint16_t(723), Tuint16_t(726), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(723), Tuint16_t(723),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(727), Tuint16_t(723), Tuint16_t(724), Tuint16_t(723), Tuint16_t(728), Tuint16_t(723), Tuint16_t(724), Tuint16_t(729), Tuint16_t(730), Tuint16_t(731), Tuint16_t(724), Tuint16_t(724), Tuint16_t(732), Tuint16_t(725),
	Tuint16_t(724), Tuint16_t(724), Tuint16_t(733), Tuint16_t(724), Tuint16_t(725), Tuint16_t(734), Tuint16_t(734), Tuint16_t(734), Tuint16_t(734), Tuint16_t(735), Tuint16_t(723), Tuint16_t(723), Tuint16_t(725), Tuint16_t(725), Tuint16_t(724), Tuint16_t(724),
	Tuint16_t(715), Tuint16_t(715), Tuint16_t(715), Tuint16_t(715), Tuint16_t(715), Tuint16_t(724), Tuint16_t(725), Tuint16_t(725), Tuint16_t(736), Tuint16_t(736), Tuint16_t(723), Tuint16_t(715), Tuint16_t(723), Tuint16_t(723), Tuint16_t(737), Tuint16_t(460),
	Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58),
	Tuint16_t(738), Tuint16_t(738), Tuint16_t(738), Tuint16_t(738), Tuint16_t(738), Tuint16_t(738), Tuint16_t(738), Tuint16_t(738), Tuint16_t(738), Tuint16_t(738), Tuint16_t(738), Tuint16_t(738), Tuint16_t(738), Tuint16_t(738), Tuint16_t(738), Tuint16_t(738),
	Tuint16_t(739), Tuint16_t(739), Tuint16_t(739), Tuint16_t(739), Tuint16_t(739), Tuint16_t(739), Tuint16_t(739), Tuint16_t(739), Tuint16_t(739), Tuint16_t(739), Tuint16_t(739), Tuint16_t(739), Tuint16_t(739), Tuint16_t(739), Tuint16_t(739), Tuint16_t(739),

	// block 65
	Tuint16_t(740), Tuint16_t(740), Tuint16_t(740), Tuint16_t(65), Tuint16_t(66), Tuint16_t(740), Tuint16_t(740), Tuint16_t(740), Tuint16_t(740), Tuint16_t(58), Tuint16_t(723), Tuint16_t(723), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(741), Tuint16_t(742), Tuint16_t(742), Tuint16_t(742), Tuint16_t(742), Tuint16_t(742), Tuint16_t(50), Tuint16_t(50), Tuint16_t(743), Tuint16_t(743), Tuint16_t(743), Tuint16_t(743),
	Tuint16_t(50), Tuint16_t(743), Tuint16_t(743), Tuint16_t(50), Tuint16_t(743), Tuint16_t(743), Tuint16_t(50), Tuint16_t(743), Tuint16_t(45), Tuint16_t(742), Tuint16_t(742), Tuint16_t(743), Tuint16_t(743), Tuint16_t(743), Tuint16_t(50), Tuint16_t(45),
	Tuint16_t(743), Tuint16_t(743), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(743), Tuint16_t(743), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(743), Tuint16_t(743), Tuint16_t(743), Tuint16_t(743),
	Tuint16_t(743), Tuint16_t(743), Tuint16_t(743), Tuint16_t(743), Tuint16_t(743), Tuint16_t(743), Tuint16_t(743), Tuint16_t(743), Tuint16_t(743), Tuint16_t(743), Tuint16_t(743), Tuint16_t(743), Tuint16_t(743), Tuint16_t(743), Tuint16_t(50), Tuint16_t(50),
	Tuint16_t(743), Tuint16_t(743), Tuint16_t(50), Tuint16_t(743), Tuint16_t(50), Tuint16_t(743), Tuint16_t(743), Tuint16_t(743), Tuint16_t(743), Tuint16_t(743), Tuint16_t(743), Tuint16_t(743), Tuint16_t(45), Tuint16_t(743), Tuint16_t(45), Tuint16_t(45),
	Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(743), Tuint16_t(743), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45),
	Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50),

	// block 66
	Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(50), Tuint16_t(50),
	Tuint16_t(50), Tuint16_t(50), Tuint16_t(745), Tuint16_t(53), Tuint16_t(50), Tuint16_t(744), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(744),
	Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(50), Tuint16_t(744), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50),
	Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(744), Tuint16_t(744), Tuint16_t(50), Tuint16_t(50),
	Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(744), Tuint16_t(50), Tuint16_t(744), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(744), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50),
	Tuint16_t(50), Tuint16_t(50), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50),
	Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(50), Tuint16_t(50), Tuint16_t(744), Tuint16_t(744),
	Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744),

	// block 67
	Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(744),
	Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(744), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50),
	Tuint16_t(50), Tuint16_t(50), Tuint16_t(744), Tuint16_t(744), Tuint16_t(50), Tuint16_t(50), Tuint16_t(744), Tuint16_t(50), Tuint16_t(744), Tuint16_t(744), Tuint16_t(50), Tuint16_t(744), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50),
	Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50),
	Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(50), Tuint16_t(50),
	Tuint16_t(744), Tuint16_t(744), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744),
	Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(50), Tuint16_t(50),
	Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(50), Tuint16_t(744), Tuint16_t(744), Tuint16_t(50), Tuint16_t(50), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(50),

	// block 68
	Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(746), Tuint16_t(747), Tuint16_t(746), Tuint16_t(747), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45),
	Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(748), Tuint16_t(748), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45),
	Tuint16_t(50), Tuint16_t(50), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(47), Tuint16_t(749), Tuint16_t(750), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45),
	Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751),
	Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751),
	Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751),
	Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751),
	Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(751), Tuint16_t(45), Tuint16_t(50), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45),

	// block 69
	Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(752), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45),
	Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(751), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50),
	Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50),
	Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(743), Tuint16_t(743), Tuint16_t(45), Tuint16_t(743), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45),
	Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(47),
	Tuint16_t(743), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50),
	Tuint16_t(50), Tuint16_t(50), Tuint16_t(743), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(748), Tuint16_t(748), Tuint16_t(748), Tuint16_t(748), Tuint16_t(47), Tuint16_t(47), Tuint16_t(47),
	Tuint16_t(748), Tuint16_t(47), Tuint16_t(47), Tuint16_t(748), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(47), Tuint16_t(47), Tuint16_t(47), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45),

	// block 70
	Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45),
	Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45),
	Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753),
	Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753),
	Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753),
	Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753),
	Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58),
	Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58),

	// block 71
	Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(54), Tuint16_t(54), Tuint16_t(54), Tuint16_t(54), Tuint16_t(54), Tuint16_t(54), Tuint16_t(54), Tuint16_t(54),
	Tuint16_t(54), Tuint16_t(54), Tuint16_t(54), Tuint16_t(54), Tuint16_t(54), Tuint16_t(54), Tuint16_t(54), Tuint16_t(54), Tuint16_t(54), Tuint16_t(54), Tuint16_t(54), Tuint16_t(54), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(754), Tuint16_t(754), Tuint16_t(754), Tuint16_t(754), Tuint16_t(754), Tuint16_t(754), Tuint16_t(754), Tuint16_t(754), Tuint16_t(754), Tuint16_t(754),
	Tuint16_t(754), Tuint16_t(754), Tuint16_t(755), Tuint16_t(754), Tuint16_t(754), Tuint16_t(754), Tuint16_t(754), Tuint16_t(754), Tuint16_t(754), Tuint16_t(754), Tuint16_t(754), Tuint16_t(754), Tuint16_t(754), Tuint16_t(754), Tuint16_t(754), Tuint16_t(754),
	Tuint16_t(756), Tuint16_t(756), Tuint16_t(756), Tuint16_t(756), Tuint16_t(756), Tuint16_t(756), Tuint16_t(756), Tuint16_t(756), Tuint16_t(756), Tuint16_t(756), Tuint16_t(756), Tuint16_t(756), Tuint16_t(756), Tuint16_t(756), Tuint16_t(756), Tuint16_t(756),
	Tuint16_t(756), Tuint16_t(756), Tuint16_t(756), Tuint16_t(756), Tuint16_t(756), Tuint16_t(756), Tuint16_t(756), Tuint16_t(756), Tuint16_t(756), Tuint16_t(756), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58),
	Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58),

	// block 72
	Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45),
	Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45),
	Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45),
	Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45),
	Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45),
	Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45),
	Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45),
	Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45),

	// block 73
	Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45),
	Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45),
	Tuint16_t(743), Tuint16_t(743), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(47), Tuint16_t(47), Tuint16_t(45), Tuint16_t(45), Tuint16_t(743), Tuint16_t(743),
	Tuint16_t(743), Tuint16_t(743), Tuint16_t(743), Tuint16_t(743), Tuint16_t(743), Tuint16_t(743), Tuint16_t(742), Tuint16_t(50), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(743), Tuint16_t(743), Tuint16_t(743), Tuint16_t(743),
	Tuint16_t(742), Tuint16_t(50), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(743), Tuint16_t(743), Tuint16_t(45), Tuint16_t(45), Tuint16_t(743), Tuint16_t(743), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(743),
	Tuint16_t(743), Tuint16_t(743), Tuint16_t(743), Tuint16_t(743), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45),
	Tuint16_t(45), Tuint16_t(45), Tuint16_t(743), Tuint16_t(45), Tuint16_t(743), Tuint16_t(45), Tuint16_t(45), Tuint16_t(743), Tuint16_t(743), Tuint16_t(743), Tuint16_t(743), Tuint16_t(743), Tuint16_t(743), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45),
	Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(741), Tuint16_t(741), Tuint16_t(757), Tuint16_t(757), Tuint16_t(50),

	// block 74
	Tuint16_t(47), Tuint16_t(47), Tuint16_t(47), Tuint16_t(47), Tuint16_t(47), Tuint16_t(758), Tuint16_t(743), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(47), Tuint16_t(752),
	Tuint16_t(752), Tuint16_t(47), Tuint16_t(752), Tuint16_t(45), Tuint16_t(748), Tuint16_t(748), Tuint16_t(752), Tuint16_t(752), Tuint16_t(47), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(759), Tuint16_t(752), Tuint16_t(752),
	Tuint16_t(47), Tuint16_t(752), Tuint16_t(47), Tuint16_t(47), Tuint16_t(752), Tuint16_t(752), Tuint16_t(47), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(47), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(47), Tuint16_t(47),
	Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(47), Tuint16_t(47), Tuint16_t(47), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752),
	Tuint16_t(742), Tuint16_t(752), Tuint16_t(742), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(748), Tuint16_t(748), Tuint16_t(748), Tuint16_t(748), Tuint16_t(748), Tuint16_t(748), Tuint16_t(748), Tuint16_t(748),
	Tuint16_t(748), Tuint16_t(748), Tuint16_t(748), Tuint16_t(748), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(47),
	Tuint16_t(742), Tuint16_t(758), Tuint16_t(758), Tuint16_t(742), Tuint16_t(752), Tuint16_t(47), Tuint16_t(47), Tuint16_t(752), Tuint16_t(47), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(758), Tuint16_t(758), Tuint16_t(760),
	Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(47), Tuint16_t(752), Tuint16_t(752), Tuint16_t(47), Tuint16_t(748),

	// block 75
	Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45),
	Tuint16_t(752), Tuint16_t(752), Tuint16_t(47), Tuint16_t(748), Tuint16_t(47), Tuint16_t(47), Tuint16_t(47), Tuint16_t(47), Tuint16_t(752), Tuint16_t(47), Tuint16_t(752), Tuint16_t(47), Tuint16_t(47), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752),
	Tuint16_t(47), Tuint16_t(748), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(47), Tuint16_t(752), Tuint16_t(752), Tuint16_t(748), Tuint16_t(748), Tuint16_t(761), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752),
	Tuint16_t(47), Tuint16_t(47), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(748), Tuint16_t(748), Tuint16_t(752),
	Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(748), Tuint16_t(748), Tuint16_t(752), Tuint16_t(752), Tuint16_t(47), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(748), Tuint16_t(47),
	Tuint16_t(752), Tuint16_t(47), Tuint16_t(752), Tuint16_t(47), Tuint16_t(748), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752),
	Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(47), Tuint16_t(748), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752),
	Tuint16_t(47), Tuint16_t(47), Tuint16_t(748), Tuint16_t(748), Tuint16_t(47), Tuint16_t(748), Tuint16_t(752), Tuint16_t(47), Tuint16_t(47), Tuint16_t(759), Tuint16_t(748), Tuint16_t(752), Tuint16_t(752), Tuint16_t(748), Tuint16_t(752), Tuint16_t(752),

	// block 76
	Tuint16_t(752), Tuint16_t(752), Tuint16_t(47), Tuint16_t(752), Tuint16_t(752), Tuint16_t(748), Tuint16_t(45), Tuint16_t(45), Tuint16_t(47), Tuint16_t(47), Tuint16_t(762), Tuint16_t(762), Tuint16_t(759), Tuint16_t(759), Tuint16_t(752), Tuint16_t(47),
	Tuint16_t(752), Tuint16_t(752), Tuint16_t(47), Tuint16_t(45), Tuint16_t(47), Tuint16_t(45), Tuint16_t(47), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(47), Tuint16_t(45), Tuint16_t(45),
	Tuint16_t(45), Tuint16_t(47), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(748), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45),
	Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(47), Tuint16_t(47), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45),
	Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(47), Tuint16_t(45), Tuint16_t(45), Tuint16_t(47), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(748), Tuint16_t(45), Tuint16_t(748), Tuint16_t(45),
	Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(748), Tuint16_t(748), Tuint16_t(748), Tuint16_t(45), Tuint16_t(748), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45),
	Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(47), Tuint16_t(47), Tuint16_t(752), Tuint16_t(752), Tuint16_t(752), Tuint16_t(703), Tuint16_t(704), Tuint16_t(703), Tuint16_t(704), Tuint16_t(703), Tuint16_t(704), Tuint16_t(703), Tuint16_t(704),
	Tuint16_t(703), Tuint16_t(704), Tuint16_t(703), Tuint16_t(704), Tuint16_t(703), Tuint16_t(704), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58),

	// block 77
	Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58),
	Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(45), Tuint16_t(748), Tuint16_t(748), Tuint16_t(748), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45),
	Tuint16_t(45), Tuint16_t(47), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45),
	Tuint16_t(748), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(748),
	Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(744), Tuint16_t(744), Tuint16_t(746), Tuint16_t(747), Tuint16_t(50), Tuint16_t(744), Tuint16_t(744), Tuint16_t(50), Tuint16_t(744), Tuint16_t(50), Tuint16_t(744), Tuint16_t(50), Tuint16_t(50),
	Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(744), Tuint16_t(744), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(50),
	Tuint16_t(50), Tuint16_t(50), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(746), Tuint16_t(747), Tuint16_t(746), Tuint16_t(747), Tuint16_t(746), Tuint16_t(747), Tuint16_t(746), Tuint16_t(747), Tuint16_t(746), Tuint16_t(747),
	Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50),

	// block 78
	Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763),
	Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763),
	Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763),
	Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763),
	Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763),
	Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763),
	Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763),
	Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763), Tuint16_t(763),

	// block 79
	Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50),
	Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50),
	Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50),
	Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(741), Tuint16_t(741), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50),
	Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50),
	Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50),
	Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50),
	Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50),

	// block 80
	Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(746), Tuint16_t(747), Tuint16_t(746), Tuint16_t(747), Tuint16_t(746), Tuint16_t(747), Tuint16_t(746), Tuint16_t(747), Tuint16_t(746), Tuint16_t(747), Tuint16_t(746), Tuint16_t(747), Tuint16_t(746),
	Tuint16_t(747), Tuint16_t(746), Tuint16_t(747), Tuint16_t(746), Tuint16_t(747), Tuint16_t(746), Tuint16_t(747), Tuint16_t(746), Tuint16_t(747), Tuint16_t(50), Tuint16_t(50), Tuint16_t(744), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50),
	Tuint16_t(744), Tuint16_t(50), Tuint16_t(50), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(50), Tuint16_t(50), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744),
	Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(744), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50),
	Tuint16_t(744), Tuint16_t(744), Tuint16_t(50), Tuint16_t(50), Tuint16_t(744), Tuint16_t(744), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(744),
	Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(50), Tuint16_t(744), Tuint16_t(744), Tuint16_t(50), Tuint16_t(50), Tuint16_t(746), Tuint16_t(747), Tuint16_t(746), Tuint16_t(747), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50),
	Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(744), Tuint16_t(744), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50),
	Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(744), Tuint16_t(50), Tuint16_t(50), Tuint16_t(744), Tuint16_t(744), Tuint16_t(50), Tuint16_t(50), Tuint16_t(746), Tuint16_t(747), Tuint16_t(50), Tuint16_t(50),

	// block 81
	Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50),
	Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50),
	Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(50),
	Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(744), Tuint16_t(744), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(744), Tuint16_t(744), Tuint16_t(50), Tuint16_t(50),
	Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50),
	Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50),
	Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(744), Tuint16_t(744), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50),
	Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744),

	// block 82
	Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744),
	Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744),
	Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(50), Tuint16_t(744),
	Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744),
	Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744),
	Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(744), Tuint16_t(50),
	Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(50),
	Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(744), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50),

	// block 83
	Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(47), Tuint16_t(47), Tuint16_t(47), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45),
	Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(748), Tuint16_t(748), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45),
	Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45),
	Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50),
	Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(45), Tuint16_t(45), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(50), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45),
	Tuint16_t(748), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(748), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45),
	Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45),
	Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(753), Tuint16_t(753), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45),

	// block 84
	Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45),
	Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(753), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45),
	Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45),
	Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45),
	Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45),
	Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45),
	Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45),
	Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(45), Tuint16_t(764), Tuint16_t(45),

	// block 85
	Tuint16_t(765), Tuint16_t(765), Tuint16_t(765), Tuint16_t(765), Tuint16_t(765), Tuint16_t(765), Tuint16_t(765), Tuint16_t(765), Tuint16_t(765), Tuint16_t(765), Tuint16_t(765), Tuint16_t(765), Tuint16_t(765), Tuint16_t(765), Tuint16_t(765), Tuint16_t(765),
	Tuint16_t(765), Tuint16_t(765), Tuint16_t(765), Tuint16_t(765), Tuint16_t(765), Tuint16_t(765), Tuint16_t(765), Tuint16_t(765), Tuint16_t(765), Tuint16_t(765), Tuint16_t(765), Tuint16_t(765), Tuint16_t(765), Tuint16_t(765), Tuint16_t(765), Tuint16_t(765),
	Tuint16_t(765), Tuint16_t(765), Tuint16_t(765), Tuint16_t(765), Tuint16_t(765), Tuint16_t(765), Tuint16_t(765), Tuint16_t(765), Tuint16_t(765), Tuint16_t(765), Tuint16_t(765), Tuint16_t(765), Tuint16_t(765), Tuint16_t(765), Tuint16_t(765), Tuint16_t(765),
	Tuint16_t(766), Tuint16_t(766), Tuint16_t(766), Tuint16_t(766), Tuint16_t(766), Tuint16_t(766), Tuint16_t(766), Tuint16_t(766), Tuint16_t(766), Tuint16_t(766), Tuint16_t(766), Tuint16_t(766), Tuint16_t(766), Tuint16_t(766), Tuint16_t(766), Tuint16_t(766),
	Tuint16_t(766), Tuint16_t(766), Tuint16_t(766), Tuint16_t(766), Tuint16_t(766), Tuint16_t(766), Tuint16_t(766), Tuint16_t(766), Tuint16_t(766), Tuint16_t(766), Tuint16_t(766), Tuint16_t(766), Tuint16_t(766), Tuint16_t(766), Tuint16_t(766), Tuint16_t(766),
	Tuint16_t(766), Tuint16_t(766), Tuint16_t(766), Tuint16_t(766), Tuint16_t(766), Tuint16_t(766), Tuint16_t(766), Tuint16_t(766), Tuint16_t(766), Tuint16_t(766), Tuint16_t(766), Tuint16_t(766), Tuint16_t(766), Tuint16_t(766), Tuint16_t(766), Tuint16_t(766),
	Tuint16_t(65), Tuint16_t(66), Tuint16_t(767), Tuint16_t(768), Tuint16_t(769), Tuint16_t(770), Tuint16_t(771), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(772), Tuint16_t(773), Tuint16_t(774),
	Tuint16_t(775), Tuint16_t(70), Tuint16_t(65), Tuint16_t(66), Tuint16_t(70), Tuint16_t(65), Tuint16_t(66), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(645), Tuint16_t(644), Tuint16_t(776), Tuint16_t(776),

	// block 86
	Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212),
	Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212),
	Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212),
	Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212),
	Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212),
	Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212),
	Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(777), Tuint16_t(778), Tuint16_t(778), Tuint16_t(778), Tuint16_t(778), Tuint16_t(778), Tuint16_t(778), Tuint16_t(211), Tuint16_t(212), Tuint16_t(211), Tuint16_t(212), Tuint16_t(779),
	Tuint16_t(779), Tuint16_t(779), Tuint16_t(211), Tuint16_t(212), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(780), Tuint16_t(780), Tuint16_t(780), Tuint16_t(780), Tuint16_t(781), Tuint16_t(780), Tuint16_t(780),

	// block 87
	Tuint16_t(782), Tuint16_t(782), Tuint16_t(782), Tuint16_t(782), Tuint16_t(782), Tuint16_t(782), Tuint16_t(782), Tuint16_t(782), Tuint16_t(782), Tuint16_t(782), Tuint16_t(782), Tuint16_t(782), Tuint16_t(782), Tuint16_t(782), Tuint16_t(782), Tuint16_t(782),
	Tuint16_t(782), Tuint16_t(782), Tuint16_t(782), Tuint16_t(782), Tuint16_t(782), Tuint16_t(782), Tuint16_t(782), Tuint16_t(782), Tuint16_t(782), Tuint16_t(782), Tuint16_t(782), Tuint16_t(782), Tuint16_t(782), Tuint16_t(782), Tuint16_t(782), Tuint16_t(782),
	Tuint16_t(782), Tuint16_t(782), Tuint16_t(782), Tuint16_t(782), Tuint16_t(782), Tuint16_t(782), Tuint16_t(163), Tuint16_t(782), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(782), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783),
	Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783),
	Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783),
	Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(783), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(784),
	Tuint16_t(785), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(786),

	// block 88
	Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483),
	Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(163), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(163),
	Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(163), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(163),
	Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(163), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(163),
	Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(163), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(163),
	Tuint16_t(787), Tuint16_t(787), Tuint16_t(787), Tuint16_t(787), Tuint16_t(787), Tuint16_t(787), Tuint16_t(787), Tuint16_t(787), Tuint16_t(787), Tuint16_t(787), Tuint16_t(787), Tuint16_t(787), Tuint16_t(787), Tuint16_t(787), Tuint16_t(787), Tuint16_t(787),
	Tuint16_t(787), Tuint16_t(787), Tuint16_t(787), Tuint16_t(787), Tuint16_t(787), Tuint16_t(787), Tuint16_t(787), Tuint16_t(787), Tuint16_t(787), Tuint16_t(787), Tuint16_t(787), Tuint16_t(787), Tuint16_t(787), Tuint16_t(787), Tuint16_t(787), Tuint16_t(787),

	// block 89
	Tuint16_t(43), Tuint16_t(43), Tuint16_t(788), Tuint16_t(789), Tuint16_t(788), Tuint16_t(789), Tuint16_t(43), Tuint16_t(43), Tuint16_t(43), Tuint16_t(788), Tuint16_t(789), Tuint16_t(43), Tuint16_t(788), Tuint16_t(789), Tuint16_t(43), Tuint16_t(43),
	Tuint16_t(43), Tuint16_t(43), Tuint16_t(43), Tuint16_t(43), Tuint16_t(43), Tuint16_t(43), Tuint16_t(43), Tuint16_t(680), Tuint16_t(43), Tuint16_t(43), Tuint16_t(680), Tuint16_t(43), Tuint16_t(788), Tuint16_t(789), Tuint16_t(43), Tuint16_t(43),
	Tuint16_t(788), Tuint16_t(789), Tuint16_t(703), Tuint16_t(704), Tuint16_t(703), Tuint16_t(704), Tuint16_t(703), Tuint16_t(704), Tuint16_t(703), Tuint16_t(704), Tuint16_t(43), Tuint16_t(43), Tuint16_t(43), Tuint16_t(43), Tuint16_t(699), Tuint16_t(790),
	Tuint16_t(43), Tuint16_t(43), Tuint16_t(43), Tuint16_t(43), Tuint16_t(43), Tuint16_t(43), Tuint16_t(43), Tuint16_t(43), Tuint16_t(43), Tuint16_t(43), Tuint16_t(680), Tuint16_t(680), Tuint16_t(699), Tuint16_t(43), Tuint16_t(43), Tuint16_t(43),
	Tuint16_t(680), Tuint16_t(791), Tuint16_t(684), Tuint16_t(792), Tuint16_t(43), Tuint16_t(43), Tuint16_t(43), Tuint16_t(43), Tuint16_t(43), Tuint16_t(43), Tuint16_t(43), Tuint16_t(43), Tuint16_t(791), Tuint16_t(43), Tuint16_t(791), Tuint16_t(791),
	Tuint16_t(45), Tuint16_t(45), Tuint16_t(43), Tuint16_t(699), Tuint16_t(699), Tuint16_t(703), Tuint16_t(704), Tuint16_t(703), Tuint16_t(704), Tuint16_t(703), Tuint16_t(704), Tuint16_t(703), Tuint16_t(704), Tuint16_t(680), Tuint16_t(753), Tuint16_t(753),
	Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753),
	Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753), Tuint16_t(753),

	// block 90
	Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793),
	Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(163), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793),
	Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793),
	Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793),
	Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793),
	Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793),
	Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793),
	Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 91
	Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793),
	Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793),
	Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793),
	Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793),
	Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793),
	Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793),
	Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793),
	Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793),

	// block 92
	Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793),
	Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793),
	Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793),
	Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793),
	Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793),
	Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(793), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(794), Tuint16_t(794), Tuint16_t(795), Tuint16_t(795), Tuint16_t(794), Tuint16_t(794), Tuint16_t(794), Tuint16_t(794), Tuint16_t(794), Tuint16_t(794), Tuint16_t(794), Tuint16_t(794), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 93
	Tuint16_t(675), Tuint16_t(796), Tuint16_t(797), Tuint16_t(798), Tuint16_t(723), Tuint16_t(799), Tuint16_t(800), Tuint16_t(801), Tuint16_t(802), Tuint16_t(803), Tuint16_t(802), Tuint16_t(803), Tuint16_t(804), Tuint16_t(805), Tuint16_t(804), Tuint16_t(805),
	Tuint16_t(802), Tuint16_t(803), Tuint16_t(45), Tuint16_t(806), Tuint16_t(802), Tuint16_t(803), Tuint16_t(802), Tuint16_t(803), Tuint16_t(802), Tuint16_t(803), Tuint16_t(802), Tuint16_t(803), Tuint16_t(807), Tuint16_t(808), Tuint16_t(809), Tuint16_t(809),
	Tuint16_t(45), Tuint16_t(801), Tuint16_t(801), Tuint16_t(801), Tuint16_t(801), Tuint16_t(801), Tuint16_t(801), Tuint16_t(801), Tuint16_t(801), Tuint16_t(801), Tuint16_t(810), Tuint16_t(810), Tuint16_t(810), Tuint16_t(810), Tuint16_t(811), Tuint16_t(811),
	Tuint16_t(812), Tuint16_t(813), Tuint16_t(813), Tuint16_t(813), Tuint16_t(813), Tuint16_t(813), Tuint16_t(723), Tuint16_t(814), Tuint16_t(801), Tuint16_t(801), Tuint16_t(801), Tuint16_t(815), Tuint16_t(816), Tuint16_t(817), Tuint16_t(818), Tuint16_t(818),
	Tuint16_t(163), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819),
	Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819),
	Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819),
	Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819),

	// block 94
	Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819),
	Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(163), Tuint16_t(163), Tuint16_t(820), Tuint16_t(820), Tuint16_t(821), Tuint16_t(821), Tuint16_t(822), Tuint16_t(822), Tuint16_t(819),
	Tuint16_t(823), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824),
	Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824),
	Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824),
	Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824),
	Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824),
	Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(825), Tuint16_t(826), Tuint16_t(827), Tuint16_t(827), Tuint16_t(824),

	// block 95
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828),
	Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828),
	Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828),
	Tuint16_t(163), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829),
	Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829),
	Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829),
	Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(830), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829),
	Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829),

	// block 96
	Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(163),
	Tuint16_t(831), Tuint16_t(831), Tuint16_t(832), Tuint16_t(832), Tuint16_t(832), Tuint16_t(832), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831),
	Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828),
	Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828), Tuint16_t(828),
	Tuint16_t(818), Tuint16_t(818), Tuint16_t(818), Tuint16_t(818), Tuint16_t(818), Tuint16_t(818), Tuint16_t(818), Tuint16_t(818), Tuint16_t(818), Tuint16_t(818), Tuint16_t(818), Tuint16_t(818), Tuint16_t(818), Tuint16_t(818), Tuint16_t(818), Tuint16_t(818),
	Tuint16_t(818), Tuint16_t(818), Tuint16_t(818), Tuint16_t(818), Tuint16_t(818), Tuint16_t(818), Tuint16_t(818), Tuint16_t(818), Tuint16_t(818), Tuint16_t(818), Tuint16_t(818), Tuint16_t(818), Tuint16_t(818), Tuint16_t(818), Tuint16_t(818), Tuint16_t(818),
	Tuint16_t(818), Tuint16_t(818), Tuint16_t(818), Tuint16_t(818), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824),

	// block 97
	Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833),
	Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(834), Tuint16_t(834), Tuint16_t(163),
	Tuint16_t(832), Tuint16_t(832), Tuint16_t(832), Tuint16_t(832), Tuint16_t(832), Tuint16_t(832), Tuint16_t(832), Tuint16_t(832), Tuint16_t(832), Tuint16_t(832), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831),
	Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831),
	Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(835), Tuint16_t(835), Tuint16_t(835), Tuint16_t(835), Tuint16_t(835), Tuint16_t(835), Tuint16_t(835), Tuint16_t(835),
	Tuint16_t(723), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58),
	Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833),
	Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(833), Tuint16_t(834), Tuint16_t(834), Tuint16_t(834), Tuint16_t(460),

	// block 98
	Tuint16_t(832), Tuint16_t(832), Tuint16_t(832), Tuint16_t(832), Tuint16_t(832), Tuint16_t(832), Tuint16_t(832), Tuint16_t(832), Tuint16_t(832), Tuint16_t(832), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831),
	Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(836), Tuint16_t(831), Tuint16_t(836), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831),
	Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831),
	Tuint16_t(831), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58), Tuint16_t(58),
	Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),
	Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837),
	Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837),
	Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(831),

	// block 99
	Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837),
	Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837),
	Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837),
	Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837),
	Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837),
	Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(837), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831),
	Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831),
	Tuint16_t(831), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831),

	// block 100
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(723), Tuint16_t(723),
	Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831),
	Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(831), Tuint16_t(723),

	// block 101
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),

	// block 102
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),

	// block 103
	Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839),
	Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(840), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839),
	Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839),
	Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839),
	Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839),
	Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839),
	Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839),
	Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839),

	// block 104
	Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839),
	Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839),
	Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839),
	Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839),
	Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839),
	Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839),
	Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839),
	Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839),

	// block 105
	Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(839), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841),
	Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841),
	Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841),
	Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(841), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(842), Tuint16_t(842), Tuint16_t(842), Tuint16_t(842), Tuint16_t(842), Tuint16_t(842), Tuint16_t(842), Tuint16_t(842), Tuint16_t(842), Tuint16_t(842), Tuint16_t(842), Tuint16_t(842), Tuint16_t(842), Tuint16_t(842), Tuint16_t(842), Tuint16_t(842),
	Tuint16_t(842), Tuint16_t(842), Tuint16_t(842), Tuint16_t(842), Tuint16_t(842), Tuint16_t(842), Tuint16_t(842), Tuint16_t(842), Tuint16_t(842), Tuint16_t(842), Tuint16_t(842), Tuint16_t(842), Tuint16_t(842), Tuint16_t(842), Tuint16_t(842), Tuint16_t(842),
	Tuint16_t(842), Tuint16_t(842), Tuint16_t(842), Tuint16_t(842), Tuint16_t(842), Tuint16_t(842), Tuint16_t(842), Tuint16_t(842), Tuint16_t(843), Tuint16_t(843), Tuint16_t(843), Tuint16_t(843), Tuint16_t(843), Tuint16_t(843), Tuint16_t(844), Tuint16_t(845),

	// block 106
	Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846),
	Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846),
	Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846),
	Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846),
	Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846),
	Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846),
	Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846),
	Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846),

	// block 107
	Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(847), Tuint16_t(848), Tuint16_t(849), Tuint16_t(849),
	Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846), Tuint16_t(846),
	Tuint16_t(850), Tuint16_t(850), Tuint16_t(850), Tuint16_t(850), Tuint16_t(850), Tuint16_t(850), Tuint16_t(850), Tuint16_t(850), Tuint16_t(850), Tuint16_t(850), Tuint16_t(846), Tuint16_t(846), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(851), Tuint16_t(852), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241),
	Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241),
	Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(853), Tuint16_t(246),
	Tuint16_t(248), Tuint16_t(248), Tuint16_t(248), Tuint16_t(854), Tuint16_t(787), Tuint16_t(787), Tuint16_t(787), Tuint16_t(787), Tuint16_t(787), Tuint16_t(787), Tuint16_t(787), Tuint16_t(787), Tuint16_t(855), Tuint16_t(855), Tuint16_t(854), Tuint16_t(856),

	// block 108
	Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241),
	Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(240), Tuint16_t(241), Tuint16_t(857), Tuint16_t(857), Tuint16_t(787), Tuint16_t(787),
	Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858),
	Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858),
	Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858),
	Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858),
	Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(859), Tuint16_t(859), Tuint16_t(859), Tuint16_t(859), Tuint16_t(859), Tuint16_t(859), Tuint16_t(859), Tuint16_t(859), Tuint16_t(859), Tuint16_t(859),
	Tuint16_t(860), Tuint16_t(860), Tuint16_t(861), Tuint16_t(862), Tuint16_t(863), Tuint16_t(863), Tuint16_t(863), Tuint16_t(862), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 109
	Tuint16_t(864), Tuint16_t(864), Tuint16_t(864), Tuint16_t(864), Tuint16_t(864), Tuint16_t(864), Tuint16_t(864), Tuint16_t(864), Tuint16_t(46), Tuint16_t(46), Tuint16_t(46), Tuint16_t(46), Tuint16_t(46), Tuint16_t(46), Tuint16_t(46), Tuint16_t(46),
	Tuint16_t(46), Tuint16_t(46), Tuint16_t(46), Tuint16_t(46), Tuint16_t(46), Tuint16_t(46), Tuint16_t(46), Tuint16_t(149), Tuint16_t(149), Tuint16_t(149), Tuint16_t(149), Tuint16_t(149), Tuint16_t(149), Tuint16_t(149), Tuint16_t(149), Tuint16_t(149),
	Tuint16_t(46), Tuint16_t(46), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66),
	Tuint16_t(70), Tuint16_t(70), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66),
	Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66),
	Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66),
	Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66),
	Tuint16_t(644), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(865), Tuint16_t(65), Tuint16_t(66),

	// block 110
	Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(149), Tuint16_t(866), Tuint16_t(866), Tuint16_t(65), Tuint16_t(66), Tuint16_t(867), Tuint16_t(70), Tuint16_t(92),
	Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(868), Tuint16_t(70), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66),
	Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(869), Tuint16_t(870), Tuint16_t(871), Tuint16_t(872), Tuint16_t(869), Tuint16_t(70),
	Tuint16_t(873), Tuint16_t(874), Tuint16_t(875), Tuint16_t(876), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66),
	Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(877), Tuint16_t(878), Tuint16_t(879), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(65), Tuint16_t(66), Tuint16_t(163), Tuint16_t(70), Tuint16_t(163), Tuint16_t(70), Tuint16_t(65), Tuint16_t(66), Tuint16_t(65), Tuint16_t(66), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(880), Tuint16_t(880), Tuint16_t(880), Tuint16_t(65), Tuint16_t(66), Tuint16_t(92), Tuint16_t(147), Tuint16_t(147), Tuint16_t(70), Tuint16_t(92), Tuint16_t(92), Tuint16_t(92), Tuint16_t(92), Tuint16_t(92),

	// block 111
	Tuint16_t(881), Tuint16_t(881), Tuint16_t(882), Tuint16_t(881), Tuint16_t(881), Tuint16_t(881), Tuint16_t(883), Tuint16_t(881), Tuint16_t(881), Tuint16_t(881), Tuint16_t(881), Tuint16_t(882), Tuint16_t(881), Tuint16_t(881), Tuint16_t(881), Tuint16_t(881),
	Tuint16_t(881), Tuint16_t(881), Tuint16_t(881), Tuint16_t(881), Tuint16_t(881), Tuint16_t(881), Tuint16_t(881), Tuint16_t(881), Tuint16_t(881), Tuint16_t(881), Tuint16_t(881), Tuint16_t(881), Tuint16_t(881), Tuint16_t(881), Tuint16_t(881), Tuint16_t(881),
	Tuint16_t(881), Tuint16_t(881), Tuint16_t(881), Tuint16_t(884), Tuint16_t(884), Tuint16_t(882), Tuint16_t(882), Tuint16_t(884), Tuint16_t(885), Tuint16_t(885), Tuint16_t(885), Tuint16_t(885), Tuint16_t(883), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(886), Tuint16_t(886), Tuint16_t(886), Tuint16_t(887), Tuint16_t(887), Tuint16_t(887), Tuint16_t(888), Tuint16_t(888), Tuint16_t(889), Tuint16_t(890), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(891), Tuint16_t(891), Tuint16_t(891), Tuint16_t(891), Tuint16_t(891), Tuint16_t(891), Tuint16_t(891), Tuint16_t(891), Tuint16_t(891), Tuint16_t(891), Tuint16_t(891), Tuint16_t(891), Tuint16_t(891), Tuint16_t(891), Tuint16_t(891), Tuint16_t(891),
	Tuint16_t(891), Tuint16_t(891), Tuint16_t(891), Tuint16_t(891), Tuint16_t(891), Tuint16_t(891), Tuint16_t(891), Tuint16_t(891), Tuint16_t(891), Tuint16_t(891), Tuint16_t(891), Tuint16_t(891), Tuint16_t(891), Tuint16_t(891), Tuint16_t(891), Tuint16_t(891),
	Tuint16_t(891), Tuint16_t(891), Tuint16_t(891), Tuint16_t(891), Tuint16_t(891), Tuint16_t(891), Tuint16_t(891), Tuint16_t(891), Tuint16_t(891), Tuint16_t(891), Tuint16_t(891), Tuint16_t(891), Tuint16_t(891), Tuint16_t(891), Tuint16_t(891), Tuint16_t(891),
	Tuint16_t(891), Tuint16_t(891), Tuint16_t(891), Tuint16_t(891), Tuint16_t(892), Tuint16_t(892), Tuint16_t(893), Tuint16_t(893), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 112
	Tuint16_t(894), Tuint16_t(894), Tuint16_t(895), Tuint16_t(895), Tuint16_t(895), Tuint16_t(895), Tuint16_t(895), Tuint16_t(895), Tuint16_t(895), Tuint16_t(895), Tuint16_t(895), Tuint16_t(895), Tuint16_t(895), Tuint16_t(895), Tuint16_t(895), Tuint16_t(895),
	Tuint16_t(895), Tuint16_t(895), Tuint16_t(895), Tuint16_t(895), Tuint16_t(895), Tuint16_t(895), Tuint16_t(895), Tuint16_t(895), Tuint16_t(895), Tuint16_t(895), Tuint16_t(895), Tuint16_t(895), Tuint16_t(895), Tuint16_t(895), Tuint16_t(895), Tuint16_t(895),
	Tuint16_t(895), Tuint16_t(895), Tuint16_t(895), Tuint16_t(895), Tuint16_t(895), Tuint16_t(895), Tuint16_t(895), Tuint16_t(895), Tuint16_t(895), Tuint16_t(895), Tuint16_t(895), Tuint16_t(895), Tuint16_t(895), Tuint16_t(895), Tuint16_t(895), Tuint16_t(895),
	Tuint16_t(895), Tuint16_t(895), Tuint16_t(895), Tuint16_t(895), Tuint16_t(894), Tuint16_t(894), Tuint16_t(894), Tuint16_t(894), Tuint16_t(894), Tuint16_t(894), Tuint16_t(894), Tuint16_t(894), Tuint16_t(894), Tuint16_t(894), Tuint16_t(894), Tuint16_t(894),
	Tuint16_t(894), Tuint16_t(894), Tuint16_t(894), Tuint16_t(894), Tuint16_t(896), Tuint16_t(897), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(898), Tuint16_t(898),
	Tuint16_t(899), Tuint16_t(899), Tuint16_t(899), Tuint16_t(899), Tuint16_t(899), Tuint16_t(899), Tuint16_t(899), Tuint16_t(899), Tuint16_t(899), Tuint16_t(899), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(336), Tuint16_t(336), Tuint16_t(336), Tuint16_t(336), Tuint16_t(336), Tuint16_t(336), Tuint16_t(336), Tuint16_t(336), Tuint16_t(336), Tuint16_t(336), Tuint16_t(336), Tuint16_t(336), Tuint16_t(336), Tuint16_t(336), Tuint16_t(336), Tuint16_t(336),
	Tuint16_t(336), Tuint16_t(900), Tuint16_t(335), Tuint16_t(901), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(335), Tuint16_t(343), Tuint16_t(343), Tuint16_t(343), Tuint16_t(335), Tuint16_t(343), Tuint16_t(335), Tuint16_t(335), Tuint16_t(333),

	// block 113
	Tuint16_t(902), Tuint16_t(902), Tuint16_t(902), Tuint16_t(902), Tuint16_t(902), Tuint16_t(902), Tuint16_t(902), Tuint16_t(902), Tuint16_t(902), Tuint16_t(902), Tuint16_t(903), Tuint16_t(903), Tuint16_t(903), Tuint16_t(903), Tuint16_t(903), Tuint16_t(903),
	Tuint16_t(903), Tuint16_t(903), Tuint16_t(903), Tuint16_t(903), Tuint16_t(903), Tuint16_t(903), Tuint16_t(903), Tuint16_t(903), Tuint16_t(903), Tuint16_t(903), Tuint16_t(903), Tuint16_t(903), Tuint16_t(903), Tuint16_t(903), Tuint16_t(903), Tuint16_t(903),
	Tuint16_t(903), Tuint16_t(903), Tuint16_t(903), Tuint16_t(903), Tuint16_t(903), Tuint16_t(903), Tuint16_t(904), Tuint16_t(904), Tuint16_t(904), Tuint16_t(904), Tuint16_t(904), Tuint16_t(905), Tuint16_t(905), Tuint16_t(905), Tuint16_t(906), Tuint16_t(907),
	Tuint16_t(908), Tuint16_t(908), Tuint16_t(908), Tuint16_t(908), Tuint16_t(908), Tuint16_t(908), Tuint16_t(908), Tuint16_t(908), Tuint16_t(908), Tuint16_t(908), Tuint16_t(908), Tuint16_t(908), Tuint16_t(908), Tuint16_t(908), Tuint16_t(908), Tuint16_t(908),
	Tuint16_t(908), Tuint16_t(908), Tuint16_t(908), Tuint16_t(908), Tuint16_t(908), Tuint16_t(908), Tuint16_t(908), Tuint16_t(909), Tuint16_t(909), Tuint16_t(909), Tuint16_t(909), Tuint16_t(909), Tuint16_t(909), Tuint16_t(909), Tuint16_t(909), Tuint16_t(909),
	Tuint16_t(909), Tuint16_t(909), Tuint16_t(910), Tuint16_t(911), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(912),
	Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478),
	Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(478), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 114
	Tuint16_t(913), Tuint16_t(913), Tuint16_t(913), Tuint16_t(914), Tuint16_t(915), Tuint16_t(915), Tuint16_t(915), Tuint16_t(915), Tuint16_t(915), Tuint16_t(915), Tuint16_t(915), Tuint16_t(915), Tuint16_t(915), Tuint16_t(915), Tuint16_t(915), Tuint16_t(915),
	Tuint16_t(915), Tuint16_t(915), Tuint16_t(915), Tuint16_t(915), Tuint16_t(915), Tuint16_t(915), Tuint16_t(915), Tuint16_t(915), Tuint16_t(915), Tuint16_t(915), Tuint16_t(915), Tuint16_t(915), Tuint16_t(915), Tuint16_t(915), Tuint16_t(915), Tuint16_t(915),
	Tuint16_t(915), Tuint16_t(915), Tuint16_t(915), Tuint16_t(915), Tuint16_t(915), Tuint16_t(915), Tuint16_t(915), Tuint16_t(915), Tuint16_t(915), Tuint16_t(915), Tuint16_t(915), Tuint16_t(915), Tuint16_t(915), Tuint16_t(915), Tuint16_t(915), Tuint16_t(915),
	Tuint16_t(915), Tuint16_t(915), Tuint16_t(915), Tuint16_t(916), Tuint16_t(914), Tuint16_t(914), Tuint16_t(913), Tuint16_t(913), Tuint16_t(913), Tuint16_t(913), Tuint16_t(914), Tuint16_t(914), Tuint16_t(913), Tuint16_t(913), Tuint16_t(914), Tuint16_t(914),
	Tuint16_t(917), Tuint16_t(918), Tuint16_t(918), Tuint16_t(918), Tuint16_t(918), Tuint16_t(918), Tuint16_t(918), Tuint16_t(919), Tuint16_t(920), Tuint16_t(920), Tuint16_t(918), Tuint16_t(918), Tuint16_t(918), Tuint16_t(918), Tuint16_t(163), Tuint16_t(921),
	Tuint16_t(922), Tuint16_t(922), Tuint16_t(922), Tuint16_t(922), Tuint16_t(922), Tuint16_t(922), Tuint16_t(922), Tuint16_t(922), Tuint16_t(922), Tuint16_t(922), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(918), Tuint16_t(918),
	Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(471), Tuint16_t(923), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461),
	Tuint16_t(472), Tuint16_t(472), Tuint16_t(472), Tuint16_t(472), Tuint16_t(472), Tuint16_t(472), Tuint16_t(472), Tuint16_t(472), Tuint16_t(472), Tuint16_t(472), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(163),

	// block 115
	Tuint16_t(924), Tuint16_t(924), Tuint16_t(924), Tuint16_t(924), Tuint16_t(924), Tuint16_t(924), Tuint16_t(924), Tuint16_t(924), Tuint16_t(924), Tuint16_t(924), Tuint16_t(924), Tuint16_t(924), Tuint16_t(924), Tuint16_t(924), Tuint16_t(924), Tuint16_t(924),
	Tuint16_t(924), Tuint16_t(924), Tuint16_t(924), Tuint16_t(924), Tuint16_t(924), Tuint16_t(924), Tuint16_t(924), Tuint16_t(924), Tuint16_t(924), Tuint16_t(924), Tuint16_t(924), Tuint16_t(924), Tuint16_t(924), Tuint16_t(924), Tuint16_t(924), Tuint16_t(924),
	Tuint16_t(924), Tuint16_t(924), Tuint16_t(924), Tuint16_t(924), Tuint16_t(924), Tuint16_t(924), Tuint16_t(924), Tuint16_t(924), Tuint16_t(924), Tuint16_t(925), Tuint16_t(925), Tuint16_t(925), Tuint16_t(925), Tuint16_t(925), Tuint16_t(925), Tuint16_t(926),
	Tuint16_t(926), Tuint16_t(925), Tuint16_t(925), Tuint16_t(926), Tuint16_t(926), Tuint16_t(925), Tuint16_t(925), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(924), Tuint16_t(924), Tuint16_t(924), Tuint16_t(925), Tuint16_t(924), Tuint16_t(924), Tuint16_t(924), Tuint16_t(924), Tuint16_t(924), Tuint16_t(924), Tuint16_t(924), Tuint16_t(924), Tuint16_t(925), Tuint16_t(926), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(927), Tuint16_t(927), Tuint16_t(927), Tuint16_t(927), Tuint16_t(927), Tuint16_t(927), Tuint16_t(927), Tuint16_t(927), Tuint16_t(927), Tuint16_t(927), Tuint16_t(163), Tuint16_t(163), Tuint16_t(928), Tuint16_t(929), Tuint16_t(929), Tuint16_t(929),
	Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461),
	Tuint16_t(923), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(461), Tuint16_t(473), Tuint16_t(473), Tuint16_t(473), Tuint16_t(461), Tuint16_t(470), Tuint16_t(471), Tuint16_t(470), Tuint16_t(461), Tuint16_t(461),

	// block 116
	Tuint16_t(930), Tuint16_t(930), Tuint16_t(930), Tuint16_t(930), Tuint16_t(930), Tuint16_t(930), Tuint16_t(930), Tuint16_t(930), Tuint16_t(930), Tuint16_t(930), Tuint16_t(930), Tuint16_t(930), Tuint16_t(930), Tuint16_t(930), Tuint16_t(930), Tuint16_t(930),
	Tuint16_t(930), Tuint16_t(930), Tuint16_t(930), Tuint16_t(930), Tuint16_t(930), Tuint16_t(930), Tuint16_t(930), Tuint16_t(930), Tuint16_t(930), Tuint16_t(930), Tuint16_t(930), Tuint16_t(930), Tuint16_t(930), Tuint16_t(930), Tuint16_t(930), Tuint16_t(930),
	Tuint16_t(930), Tuint16_t(930), Tuint16_t(930), Tuint16_t(930), Tuint16_t(930), Tuint16_t(930), Tuint16_t(930), Tuint16_t(930), Tuint16_t(930), Tuint16_t(930), Tuint16_t(930), Tuint16_t(930), Tuint16_t(930), Tuint16_t(930), Tuint16_t(930), Tuint16_t(930),
	Tuint16_t(931), Tuint16_t(930), Tuint16_t(931), Tuint16_t(931), Tuint16_t(931), Tuint16_t(932), Tuint16_t(932), Tuint16_t(931), Tuint16_t(931), Tuint16_t(932), Tuint16_t(930), Tuint16_t(932), Tuint16_t(932), Tuint16_t(930), Tuint16_t(931), Tuint16_t(933),
	Tuint16_t(934), Tuint16_t(933), Tuint16_t(934), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(930), Tuint16_t(930), Tuint16_t(935), Tuint16_t(936), Tuint16_t(937),
	Tuint16_t(938), Tuint16_t(938), Tuint16_t(938), Tuint16_t(938), Tuint16_t(938), Tuint16_t(938), Tuint16_t(938), Tuint16_t(938), Tuint16_t(938), Tuint16_t(938), Tuint16_t(938), Tuint16_t(939), Tuint16_t(940), Tuint16_t(940), Tuint16_t(939), Tuint16_t(939),
	Tuint16_t(941), Tuint16_t(941), Tuint16_t(938), Tuint16_t(942), Tuint16_t(942), Tuint16_t(939), Tuint16_t(943), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 117
	Tuint16_t(163), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(163), Tuint16_t(163), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(163), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(163),
	Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70),
	Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70),
	Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(944), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(866), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147),
	Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(221), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(945), Tuint16_t(46), Tuint16_t(46), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946),

	// block 118
	Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946),
	Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946),
	Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946),
	Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946), Tuint16_t(946),
	Tuint16_t(938), Tuint16_t(938), Tuint16_t(938), Tuint16_t(938), Tuint16_t(938), Tuint16_t(938), Tuint16_t(938), Tuint16_t(938), Tuint16_t(938), Tuint16_t(938), Tuint16_t(938), Tuint16_t(938), Tuint16_t(938), Tuint16_t(938), Tuint16_t(938), Tuint16_t(938),
	Tuint16_t(938), Tuint16_t(938), Tuint16_t(938), Tuint16_t(938), Tuint16_t(938), Tuint16_t(938), Tuint16_t(938), Tuint16_t(938), Tuint16_t(938), Tuint16_t(938), Tuint16_t(938), Tuint16_t(938), Tuint16_t(938), Tuint16_t(938), Tuint16_t(938), Tuint16_t(938),
	Tuint16_t(938), Tuint16_t(938), Tuint16_t(938), Tuint16_t(939), Tuint16_t(939), Tuint16_t(940), Tuint16_t(939), Tuint16_t(939), Tuint16_t(940), Tuint16_t(939), Tuint16_t(939), Tuint16_t(941), Tuint16_t(947), Tuint16_t(943), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(948), Tuint16_t(948), Tuint16_t(948), Tuint16_t(948), Tuint16_t(948), Tuint16_t(948), Tuint16_t(948), Tuint16_t(948), Tuint16_t(948), Tuint16_t(948), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 119
	Tuint16_t(949), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(949), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(949), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(949), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(949), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),

	// block 120
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(949), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(949), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(949), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(949), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(949), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),

	// block 121
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(949), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(949), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(949), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(949), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),

	// block 122
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(949), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(949), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(949), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(949), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(949), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),

	// block 123
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(949), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(949), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(949), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(949), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),

	// block 124
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(949), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(949), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(949), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(949), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(949), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),

	// block 125
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(949), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(949), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(949), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(949), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),

	// block 126
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(949), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950),
	Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(950), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481),
	Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(481), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482),
	Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482),
	Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482),
	Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(482), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 127
	Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951),
	Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951),
	Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951),
	Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951),
	Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951),
	Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951),
	Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951),
	Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951), Tuint16_t(951),

	// block 128
	Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952),
	Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952),
	Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952),
	Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952),
	Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952),
	Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952),
	Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952),
	Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952),

	// block 129
	Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953),
	Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953),
	Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953),
	Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953),
	Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953),
	Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953),
	Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953),
	Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953),

	// block 130
	Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(953), Tuint16_t(838), Tuint16_t(953), Tuint16_t(838), Tuint16_t(838), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(838),
	Tuint16_t(953), Tuint16_t(838), Tuint16_t(953), Tuint16_t(838), Tuint16_t(838), Tuint16_t(953), Tuint16_t(953), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953),
	Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953),
	Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953),
	Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953),
	Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953),

	// block 131
	Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953),
	Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953),
	Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953),
	Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953),
	Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953),
	Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 132
	Tuint16_t(652), Tuint16_t(652), Tuint16_t(652), Tuint16_t(652), Tuint16_t(652), Tuint16_t(652), Tuint16_t(652), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(257), Tuint16_t(257), Tuint16_t(257), Tuint16_t(257), Tuint16_t(257), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(270), Tuint16_t(265), Tuint16_t(270),
	Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(954), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270),
	Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(262), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(262), Tuint16_t(270), Tuint16_t(262),
	Tuint16_t(270), Tuint16_t(270), Tuint16_t(262), Tuint16_t(270), Tuint16_t(270), Tuint16_t(262), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270), Tuint16_t(270),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),

	// block 133
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(331), Tuint16_t(331), Tuint16_t(331), Tuint16_t(331), Tuint16_t(331), Tuint16_t(331), Tuint16_t(331), Tuint16_t(331), Tuint16_t(331), Tuint16_t(331), Tuint16_t(331), Tuint16_t(331), Tuint16_t(331), Tuint16_t(331),
	Tuint16_t(331), Tuint16_t(331), Tuint16_t(331), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302),
	Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),

	// block 134
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(955), Tuint16_t(955),
	Tuint16_t(955), Tuint16_t(955), Tuint16_t(955), Tuint16_t(955), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),

	// block 135
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),

	// block 136
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(956), Tuint16_t(957),
	Tuint16_t(280), Tuint16_t(280), Tuint16_t(280), Tuint16_t(280), Tuint16_t(280), Tuint16_t(280), Tuint16_t(280), Tuint16_t(280), Tuint16_t(280), Tuint16_t(280), Tuint16_t(280), Tuint16_t(280), Tuint16_t(280), Tuint16_t(280), Tuint16_t(280), Tuint16_t(280),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),

	// block 137
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(302), Tuint16_t(302), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(280),
	Tuint16_t(958), Tuint16_t(958), Tuint16_t(958), Tuint16_t(958), Tuint16_t(958), Tuint16_t(958), Tuint16_t(958), Tuint16_t(958), Tuint16_t(958), Tuint16_t(958), Tuint16_t(958), Tuint16_t(958), Tuint16_t(958), Tuint16_t(958), Tuint16_t(958), Tuint16_t(958),
	Tuint16_t(958), Tuint16_t(958), Tuint16_t(958), Tuint16_t(958), Tuint16_t(958), Tuint16_t(958), Tuint16_t(958), Tuint16_t(958), Tuint16_t(958), Tuint16_t(958), Tuint16_t(958), Tuint16_t(958), Tuint16_t(958), Tuint16_t(958), Tuint16_t(958), Tuint16_t(958),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(959), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(955), Tuint16_t(955), Tuint16_t(277), Tuint16_t(960), Tuint16_t(280), Tuint16_t(280),

	// block 138
	Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(962),
	Tuint16_t(963), Tuint16_t(963), Tuint16_t(963), Tuint16_t(964), Tuint16_t(963), Tuint16_t(963), Tuint16_t(963), Tuint16_t(965), Tuint16_t(966), Tuint16_t(963), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(855), Tuint16_t(855),
	Tuint16_t(963), Tuint16_t(967), Tuint16_t(967), Tuint16_t(700), Tuint16_t(700), Tuint16_t(965), Tuint16_t(966), Tuint16_t(965), Tuint16_t(966), Tuint16_t(965), Tuint16_t(966), Tuint16_t(965), Tuint16_t(966), Tuint16_t(965), Tuint16_t(966), Tuint16_t(965),
	Tuint16_t(966), Tuint16_t(968), Tuint16_t(969), Tuint16_t(968), Tuint16_t(969), Tuint16_t(798), Tuint16_t(798), Tuint16_t(965), Tuint16_t(966), Tuint16_t(963), Tuint16_t(963), Tuint16_t(963), Tuint16_t(963), Tuint16_t(700), Tuint16_t(700), Tuint16_t(700),
	Tuint16_t(970), Tuint16_t(166), Tuint16_t(971), Tuint16_t(163), Tuint16_t(166), Tuint16_t(972), Tuint16_t(973), Tuint16_t(973), Tuint16_t(967), Tuint16_t(974), Tuint16_t(975), Tuint16_t(974), Tuint16_t(975), Tuint16_t(974), Tuint16_t(975), Tuint16_t(976),
	Tuint16_t(963), Tuint16_t(977), Tuint16_t(713), Tuint16_t(978), Tuint16_t(979), Tuint16_t(979), Tuint16_t(715), Tuint16_t(163), Tuint16_t(977), Tuint16_t(431), Tuint16_t(976), Tuint16_t(963), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(955), Tuint16_t(286), Tuint16_t(955), Tuint16_t(286), Tuint16_t(955), Tuint16_t(302), Tuint16_t(955), Tuint16_t(286), Tuint16_t(955), Tuint16_t(286), Tuint16_t(955), Tuint16_t(286), Tuint16_t(955), Tuint16_t(286), Tuint16_t(955), Tuint16_t(286),

	// block 139
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286),
	Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(286), Tuint16_t(302), Tuint16_t(302), Tuint16_t(51),

	// block 140
	Tuint16_t(163), Tuint16_t(973), Tuint16_t(980), Tuint16_t(976), Tuint16_t(431), Tuint16_t(976), Tuint16_t(963), Tuint16_t(981), Tuint16_t(974), Tuint16_t(975), Tuint16_t(963), Tuint16_t(713), Tuint16_t(970), Tuint16_t(982), Tuint16_t(971), Tuint16_t(983),
	Tuint16_t(984), Tuint16_t(984), Tuint16_t(984), Tuint16_t(984), Tuint16_t(984), Tuint16_t(984), Tuint16_t(984), Tuint16_t(984), Tuint16_t(984), Tuint16_t(984), Tuint16_t(972), Tuint16_t(166), Tuint16_t(979), Tuint16_t(715), Tuint16_t(979), Tuint16_t(973),
	Tuint16_t(963), Tuint16_t(985), Tuint16_t(985), Tuint16_t(985), Tuint16_t(985), Tuint16_t(985), Tuint16_t(985), Tuint16_t(59), Tuint16_t(59), Tuint16_t(59), Tuint16_t(59), Tuint16_t(59), Tuint16_t(59), Tuint16_t(59), Tuint16_t(59), Tuint16_t(59),
	Tuint16_t(59), Tuint16_t(59), Tuint16_t(59), Tuint16_t(59), Tuint16_t(59), Tuint16_t(59), Tuint16_t(59), Tuint16_t(59), Tuint16_t(59), Tuint16_t(59), Tuint16_t(59), Tuint16_t(974), Tuint16_t(977), Tuint16_t(975), Tuint16_t(986), Tuint16_t(700),
	Tuint16_t(46), Tuint16_t(987), Tuint16_t(987), Tuint16_t(987), Tuint16_t(987), Tuint16_t(987), Tuint16_t(987), Tuint16_t(62), Tuint16_t(62), Tuint16_t(62), Tuint16_t(62), Tuint16_t(62), Tuint16_t(62), Tuint16_t(62), Tuint16_t(62), Tuint16_t(62),
	Tuint16_t(62), Tuint16_t(62), Tuint16_t(62), Tuint16_t(62), Tuint16_t(62), Tuint16_t(62), Tuint16_t(62), Tuint16_t(62), Tuint16_t(62), Tuint16_t(62), Tuint16_t(62), Tuint16_t(974), Tuint16_t(715), Tuint16_t(975), Tuint16_t(715), Tuint16_t(974),
	Tuint16_t(975), Tuint16_t(988), Tuint16_t(989), Tuint16_t(990), Tuint16_t(991), Tuint16_t(825), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824),
	Tuint16_t(826), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824),

	// block 141
	Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824),
	Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(992), Tuint16_t(992),
	Tuint16_t(830), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829),
	Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(163), Tuint16_t(163), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(163), Tuint16_t(163), Tuint16_t(829), Tuint16_t(829), Tuint16_t(829), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(431), Tuint16_t(431), Tuint16_t(715), Tuint16_t(46), Tuint16_t(723), Tuint16_t(431), Tuint16_t(431), Tuint16_t(163), Tuint16_t(723), Tuint16_t(715), Tuint16_t(715), Tuint16_t(715), Tuint16_t(715), Tuint16_t(723), Tuint16_t(723), Tuint16_t(163),
	Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(993), Tuint16_t(993), Tuint16_t(993), Tuint16_t(723), Tuint16_t(723), Tuint16_t(958), Tuint16_t(958),

	// block 142
	Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(163), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994),
	Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994),
	Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(163), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994),
	Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(163), Tuint16_t(994), Tuint16_t(994), Tuint16_t(163), Tuint16_t(994),
	Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 143
	Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994),
	Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994),
	Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994),
	Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994),
	Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994),
	Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994),
	Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994),
	Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(994), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 144
	Tuint16_t(995), Tuint16_t(996), Tuint16_t(997), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(998), Tuint16_t(998), Tuint16_t(998), Tuint16_t(998), Tuint16_t(998), Tuint16_t(998), Tuint16_t(998), Tuint16_t(998), Tuint16_t(998),
	Tuint16_t(998), Tuint16_t(998), Tuint16_t(998), Tuint16_t(998), Tuint16_t(998), Tuint16_t(998), Tuint16_t(998), Tuint16_t(998), Tuint16_t(998), Tuint16_t(998), Tuint16_t(998), Tuint16_t(998), Tuint16_t(998), Tuint16_t(998), Tuint16_t(998), Tuint16_t(998),
	Tuint16_t(998), Tuint16_t(998), Tuint16_t(998), Tuint16_t(998), Tuint16_t(998), Tuint16_t(998), Tuint16_t(998), Tuint16_t(998), Tuint16_t(998), Tuint16_t(998), Tuint16_t(998), Tuint16_t(998), Tuint16_t(998), Tuint16_t(998), Tuint16_t(998), Tuint16_t(998),
	Tuint16_t(998), Tuint16_t(998), Tuint16_t(998), Tuint16_t(998), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(999), Tuint16_t(999), Tuint16_t(999), Tuint16_t(999), Tuint16_t(999), Tuint16_t(999), Tuint16_t(999), Tuint16_t(999), Tuint16_t(999),
	Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000),
	Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000),
	Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000),
	Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1000), Tuint16_t(1001), Tuint16_t(1001), Tuint16_t(1001), Tuint16_t(1001), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002),

	// block 145
	Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1001), Tuint16_t(1001), Tuint16_t(1002), Tuint16_t(1003), Tuint16_t(1003), Tuint16_t(163),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1002), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(158), Tuint16_t(163), Tuint16_t(163),

	// block 146
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 147
	Tuint16_t(1004), Tuint16_t(1004), Tuint16_t(1004), Tuint16_t(1004), Tuint16_t(1004), Tuint16_t(1004), Tuint16_t(1004), Tuint16_t(1004), Tuint16_t(1004), Tuint16_t(1004), Tuint16_t(1004), Tuint16_t(1004), Tuint16_t(1004), Tuint16_t(1004), Tuint16_t(1004), Tuint16_t(1004),
	Tuint16_t(1004), Tuint16_t(1004), Tuint16_t(1004), Tuint16_t(1004), Tuint16_t(1004), Tuint16_t(1004), Tuint16_t(1004), Tuint16_t(1004), Tuint16_t(1004), Tuint16_t(1004), Tuint16_t(1004), Tuint16_t(1004), Tuint16_t(1004), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1005), Tuint16_t(1005), Tuint16_t(1005), Tuint16_t(1005), Tuint16_t(1005), Tuint16_t(1005), Tuint16_t(1005), Tuint16_t(1005), Tuint16_t(1005), Tuint16_t(1005), Tuint16_t(1005), Tuint16_t(1005), Tuint16_t(1005), Tuint16_t(1005), Tuint16_t(1005), Tuint16_t(1005),
	Tuint16_t(1005), Tuint16_t(1005), Tuint16_t(1005), Tuint16_t(1005), Tuint16_t(1005), Tuint16_t(1005), Tuint16_t(1005), Tuint16_t(1005), Tuint16_t(1005), Tuint16_t(1005), Tuint16_t(1005), Tuint16_t(1005), Tuint16_t(1005), Tuint16_t(1005), Tuint16_t(1005), Tuint16_t(1005),
	Tuint16_t(1005), Tuint16_t(1005), Tuint16_t(1005), Tuint16_t(1005), Tuint16_t(1005), Tuint16_t(1005), Tuint16_t(1005), Tuint16_t(1005), Tuint16_t(1005), Tuint16_t(1005), Tuint16_t(1005), Tuint16_t(1005), Tuint16_t(1005), Tuint16_t(1005), Tuint16_t(1005), Tuint16_t(1005),
	Tuint16_t(1005), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1006), Tuint16_t(1007), Tuint16_t(1007), Tuint16_t(1007), Tuint16_t(1007), Tuint16_t(1007), Tuint16_t(1007), Tuint16_t(1007), Tuint16_t(1007), Tuint16_t(1007), Tuint16_t(1007), Tuint16_t(1007), Tuint16_t(1007), Tuint16_t(1007), Tuint16_t(1007), Tuint16_t(1007),
	Tuint16_t(1007), Tuint16_t(1007), Tuint16_t(1007), Tuint16_t(1007), Tuint16_t(1007), Tuint16_t(1007), Tuint16_t(1007), Tuint16_t(1007), Tuint16_t(1007), Tuint16_t(1007), Tuint16_t(1007), Tuint16_t(1007), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 148
	Tuint16_t(1008), Tuint16_t(1008), Tuint16_t(1008), Tuint16_t(1008), Tuint16_t(1008), Tuint16_t(1008), Tuint16_t(1008), Tuint16_t(1008), Tuint16_t(1008), Tuint16_t(1008), Tuint16_t(1008), Tuint16_t(1008), Tuint16_t(1008), Tuint16_t(1008), Tuint16_t(1008), Tuint16_t(1008),
	Tuint16_t(1008), Tuint16_t(1008), Tuint16_t(1008), Tuint16_t(1008), Tuint16_t(1008), Tuint16_t(1008), Tuint16_t(1008), Tuint16_t(1008), Tuint16_t(1008), Tuint16_t(1008), Tuint16_t(1008), Tuint16_t(1008), Tuint16_t(1008), Tuint16_t(1008), Tuint16_t(1008), Tuint16_t(1008),
	Tuint16_t(1009), Tuint16_t(1009), Tuint16_t(1009), Tuint16_t(1009), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(1008), Tuint16_t(1008), Tuint16_t(1008),
	Tuint16_t(1010), Tuint16_t(1010), Tuint16_t(1010), Tuint16_t(1010), Tuint16_t(1010), Tuint16_t(1010), Tuint16_t(1010), Tuint16_t(1010), Tuint16_t(1010), Tuint16_t(1010), Tuint16_t(1010), Tuint16_t(1010), Tuint16_t(1010), Tuint16_t(1010), Tuint16_t(1010), Tuint16_t(1010),
	Tuint16_t(1010), Tuint16_t(1011), Tuint16_t(1010), Tuint16_t(1010), Tuint16_t(1010), Tuint16_t(1010), Tuint16_t(1010), Tuint16_t(1010), Tuint16_t(1010), Tuint16_t(1010), Tuint16_t(1011), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1012), Tuint16_t(1012), Tuint16_t(1012), Tuint16_t(1012), Tuint16_t(1012), Tuint16_t(1012), Tuint16_t(1012), Tuint16_t(1012), Tuint16_t(1012), Tuint16_t(1012), Tuint16_t(1012), Tuint16_t(1012), Tuint16_t(1012), Tuint16_t(1012), Tuint16_t(1012), Tuint16_t(1012),
	Tuint16_t(1012), Tuint16_t(1012), Tuint16_t(1012), Tuint16_t(1012), Tuint16_t(1012), Tuint16_t(1012), Tuint16_t(1012), Tuint16_t(1012), Tuint16_t(1012), Tuint16_t(1012), Tuint16_t(1012), Tuint16_t(1012), Tuint16_t(1012), Tuint16_t(1012), Tuint16_t(1012), Tuint16_t(1012),
	Tuint16_t(1012), Tuint16_t(1012), Tuint16_t(1012), Tuint16_t(1012), Tuint16_t(1012), Tuint16_t(1012), Tuint16_t(1013), Tuint16_t(1013), Tuint16_t(1013), Tuint16_t(1013), Tuint16_t(1013), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 149
	Tuint16_t(1014), Tuint16_t(1014), Tuint16_t(1014), Tuint16_t(1014), Tuint16_t(1014), Tuint16_t(1014), Tuint16_t(1014), Tuint16_t(1014), Tuint16_t(1014), Tuint16_t(1014), Tuint16_t(1014), Tuint16_t(1014), Tuint16_t(1014), Tuint16_t(1014), Tuint16_t(1014), Tuint16_t(1014),
	Tuint16_t(1014), Tuint16_t(1014), Tuint16_t(1014), Tuint16_t(1014), Tuint16_t(1014), Tuint16_t(1014), Tuint16_t(1014), Tuint16_t(1014), Tuint16_t(1014), Tuint16_t(1014), Tuint16_t(1014), Tuint16_t(1014), Tuint16_t(1014), Tuint16_t(1014), Tuint16_t(163), Tuint16_t(1015),
	Tuint16_t(1016), Tuint16_t(1016), Tuint16_t(1016), Tuint16_t(1016), Tuint16_t(1016), Tuint16_t(1016), Tuint16_t(1016), Tuint16_t(1016), Tuint16_t(1016), Tuint16_t(1016), Tuint16_t(1016), Tuint16_t(1016), Tuint16_t(1016), Tuint16_t(1016), Tuint16_t(1016), Tuint16_t(1016),
	Tuint16_t(1016), Tuint16_t(1016), Tuint16_t(1016), Tuint16_t(1016), Tuint16_t(1016), Tuint16_t(1016), Tuint16_t(1016), Tuint16_t(1016), Tuint16_t(1016), Tuint16_t(1016), Tuint16_t(1016), Tuint16_t(1016), Tuint16_t(1016), Tuint16_t(1016), Tuint16_t(1016), Tuint16_t(1016),
	Tuint16_t(1016), Tuint16_t(1016), Tuint16_t(1016), Tuint16_t(1016), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(1016), Tuint16_t(1016), Tuint16_t(1016), Tuint16_t(1016), Tuint16_t(1016), Tuint16_t(1016), Tuint16_t(1016), Tuint16_t(1016),
	Tuint16_t(1017), Tuint16_t(1018), Tuint16_t(1018), Tuint16_t(1018), Tuint16_t(1018), Tuint16_t(1018), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 150
	Tuint16_t(1019), Tuint16_t(1019), Tuint16_t(1019), Tuint16_t(1019), Tuint16_t(1019), Tuint16_t(1019), Tuint16_t(1019), Tuint16_t(1019), Tuint16_t(1019), Tuint16_t(1019), Tuint16_t(1019), Tuint16_t(1019), Tuint16_t(1019), Tuint16_t(1019), Tuint16_t(1019), Tuint16_t(1019),
	Tuint16_t(1019), Tuint16_t(1019), Tuint16_t(1019), Tuint16_t(1019), Tuint16_t(1019), Tuint16_t(1019), Tuint16_t(1019), Tuint16_t(1019), Tuint16_t(1019), Tuint16_t(1019), Tuint16_t(1019), Tuint16_t(1019), Tuint16_t(1019), Tuint16_t(1019), Tuint16_t(1019), Tuint16_t(1019),
	Tuint16_t(1019), Tuint16_t(1019), Tuint16_t(1019), Tuint16_t(1019), Tuint16_t(1019), Tuint16_t(1019), Tuint16_t(1019), Tuint16_t(1019), Tuint16_t(1020), Tuint16_t(1020), Tuint16_t(1020), Tuint16_t(1020), Tuint16_t(1020), Tuint16_t(1020), Tuint16_t(1020), Tuint16_t(1020),
	Tuint16_t(1020), Tuint16_t(1020), Tuint16_t(1020), Tuint16_t(1020), Tuint16_t(1020), Tuint16_t(1020), Tuint16_t(1020), Tuint16_t(1020), Tuint16_t(1020), Tuint16_t(1020), Tuint16_t(1020), Tuint16_t(1020), Tuint16_t(1020), Tuint16_t(1020), Tuint16_t(1020), Tuint16_t(1020),
	Tuint16_t(1020), Tuint16_t(1020), Tuint16_t(1020), Tuint16_t(1020), Tuint16_t(1020), Tuint16_t(1020), Tuint16_t(1020), Tuint16_t(1020), Tuint16_t(1020), Tuint16_t(1020), Tuint16_t(1020), Tuint16_t(1020), Tuint16_t(1020), Tuint16_t(1020), Tuint16_t(1020), Tuint16_t(1020),
	Tuint16_t(1021), Tuint16_t(1021), Tuint16_t(1021), Tuint16_t(1021), Tuint16_t(1021), Tuint16_t(1021), Tuint16_t(1021), Tuint16_t(1021), Tuint16_t(1021), Tuint16_t(1021), Tuint16_t(1021), Tuint16_t(1021), Tuint16_t(1021), Tuint16_t(1021), Tuint16_t(1021), Tuint16_t(1021),
	Tuint16_t(1021), Tuint16_t(1021), Tuint16_t(1021), Tuint16_t(1021), Tuint16_t(1021), Tuint16_t(1021), Tuint16_t(1021), Tuint16_t(1021), Tuint16_t(1021), Tuint16_t(1021), Tuint16_t(1021), Tuint16_t(1021), Tuint16_t(1021), Tuint16_t(1021), Tuint16_t(1021), Tuint16_t(1021),
	Tuint16_t(1021), Tuint16_t(1021), Tuint16_t(1021), Tuint16_t(1021), Tuint16_t(1021), Tuint16_t(1021), Tuint16_t(1021), Tuint16_t(1021), Tuint16_t(1021), Tuint16_t(1021), Tuint16_t(1021), Tuint16_t(1021), Tuint16_t(1021), Tuint16_t(1021), Tuint16_t(1021), Tuint16_t(1021),

	// block 151
	Tuint16_t(1022), Tuint16_t(1022), Tuint16_t(1022), Tuint16_t(1022), Tuint16_t(1022), Tuint16_t(1022), Tuint16_t(1022), Tuint16_t(1022), Tuint16_t(1022), Tuint16_t(1022), Tuint16_t(1022), Tuint16_t(1022), Tuint16_t(1022), Tuint16_t(1022), Tuint16_t(1022), Tuint16_t(1022),
	Tuint16_t(1022), Tuint16_t(1022), Tuint16_t(1022), Tuint16_t(1022), Tuint16_t(1022), Tuint16_t(1022), Tuint16_t(1022), Tuint16_t(1022), Tuint16_t(1022), Tuint16_t(1022), Tuint16_t(1022), Tuint16_t(1022), Tuint16_t(1022), Tuint16_t(1022), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1023), Tuint16_t(1023), Tuint16_t(1023), Tuint16_t(1023), Tuint16_t(1023), Tuint16_t(1023), Tuint16_t(1023), Tuint16_t(1023), Tuint16_t(1023), Tuint16_t(1023), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1024), Tuint16_t(1024), Tuint16_t(1024), Tuint16_t(1024), Tuint16_t(1024), Tuint16_t(1024), Tuint16_t(1024), Tuint16_t(1024), Tuint16_t(1024), Tuint16_t(1024), Tuint16_t(1024), Tuint16_t(1024), Tuint16_t(1024), Tuint16_t(1024), Tuint16_t(1024), Tuint16_t(1024),
	Tuint16_t(1024), Tuint16_t(1024), Tuint16_t(1024), Tuint16_t(1024), Tuint16_t(1024), Tuint16_t(1024), Tuint16_t(1024), Tuint16_t(1024), Tuint16_t(1024), Tuint16_t(1024), Tuint16_t(1024), Tuint16_t(1024), Tuint16_t(1024), Tuint16_t(1024), Tuint16_t(1024), Tuint16_t(1024),
	Tuint16_t(1024), Tuint16_t(1024), Tuint16_t(1024), Tuint16_t(1024), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(1025), Tuint16_t(1025), Tuint16_t(1025), Tuint16_t(1025), Tuint16_t(1025), Tuint16_t(1025), Tuint16_t(1025), Tuint16_t(1025),
	Tuint16_t(1025), Tuint16_t(1025), Tuint16_t(1025), Tuint16_t(1025), Tuint16_t(1025), Tuint16_t(1025), Tuint16_t(1025), Tuint16_t(1025), Tuint16_t(1025), Tuint16_t(1025), Tuint16_t(1025), Tuint16_t(1025), Tuint16_t(1025), Tuint16_t(1025), Tuint16_t(1025), Tuint16_t(1025),
	Tuint16_t(1025), Tuint16_t(1025), Tuint16_t(1025), Tuint16_t(1025), Tuint16_t(1025), Tuint16_t(1025), Tuint16_t(1025), Tuint16_t(1025), Tuint16_t(1025), Tuint16_t(1025), Tuint16_t(1025), Tuint16_t(1025), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 152
	Tuint16_t(1026), Tuint16_t(1026), Tuint16_t(1026), Tuint16_t(1026), Tuint16_t(1026), Tuint16_t(1026), Tuint16_t(1026), Tuint16_t(1026), Tuint16_t(1026), Tuint16_t(1026), Tuint16_t(1026), Tuint16_t(1026), Tuint16_t(1026), Tuint16_t(1026), Tuint16_t(1026), Tuint16_t(1026),
	Tuint16_t(1026), Tuint16_t(1026), Tuint16_t(1026), Tuint16_t(1026), Tuint16_t(1026), Tuint16_t(1026), Tuint16_t(1026), Tuint16_t(1026), Tuint16_t(1026), Tuint16_t(1026), Tuint16_t(1026), Tuint16_t(1026), Tuint16_t(1026), Tuint16_t(1026), Tuint16_t(1026), Tuint16_t(1026),
	Tuint16_t(1026), Tuint16_t(1026), Tuint16_t(1026), Tuint16_t(1026), Tuint16_t(1026), Tuint16_t(1026), Tuint16_t(1026), Tuint16_t(1026), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027),
	Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027),
	Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027),
	Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(1027), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(1028),
	Tuint16_t(1029), Tuint16_t(1029), Tuint16_t(1029), Tuint16_t(1029), Tuint16_t(1029), Tuint16_t(1029), Tuint16_t(1029), Tuint16_t(1029), Tuint16_t(1029), Tuint16_t(1029), Tuint16_t(1029), Tuint16_t(163), Tuint16_t(1029), Tuint16_t(1029), Tuint16_t(1029), Tuint16_t(1029),

	// block 153
	Tuint16_t(1029), Tuint16_t(1029), Tuint16_t(1029), Tuint16_t(1029), Tuint16_t(1029), Tuint16_t(1029), Tuint16_t(1029), Tuint16_t(1029), Tuint16_t(1029), Tuint16_t(1029), Tuint16_t(1029), Tuint16_t(163), Tuint16_t(1029), Tuint16_t(1029), Tuint16_t(1029), Tuint16_t(1029),
	Tuint16_t(1029), Tuint16_t(1029), Tuint16_t(1029), Tuint16_t(163), Tuint16_t(1029), Tuint16_t(1029), Tuint16_t(163), Tuint16_t(1030), Tuint16_t(1030), Tuint16_t(1030), Tuint16_t(1030), Tuint16_t(1030), Tuint16_t(1030), Tuint16_t(1030), Tuint16_t(1030), Tuint16_t(1030),
	Tuint16_t(1030), Tuint16_t(1030), Tuint16_t(163), Tuint16_t(1030), Tuint16_t(1030), Tuint16_t(1030), Tuint16_t(1030), Tuint16_t(1030), Tuint16_t(1030), Tuint16_t(1030), Tuint16_t(1030), Tuint16_t(1030), Tuint16_t(1030), Tuint16_t(1030), Tuint16_t(1030), Tuint16_t(1030),
	Tuint16_t(1030), Tuint16_t(1030), Tuint16_t(163), Tuint16_t(1030), Tuint16_t(1030), Tuint16_t(1030), Tuint16_t(1030), Tuint16_t(1030), Tuint16_t(1030), Tuint16_t(1030), Tuint16_t(163), Tuint16_t(1030), Tuint16_t(1030), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 154
	Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031),
	Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031),
	Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031),
	Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031),
	Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031),
	Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031),
	Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031),
	Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031),

	// block 155
	Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031),
	Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031),
	Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031),
	Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031),
	Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(1031), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 156
	Tuint16_t(147), Tuint16_t(1032), Tuint16_t(1032), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(163), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147),
	Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147),
	Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147),
	Tuint16_t(147), Tuint16_t(163), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(147), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 157
	Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(262), Tuint16_t(262), Tuint16_t(1033), Tuint16_t(262), Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(1033),
	Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(1033),
	Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(1033),
	Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(262), Tuint16_t(1033), Tuint16_t(1033), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(1033), Tuint16_t(262), Tuint16_t(262), Tuint16_t(1033),
	Tuint16_t(1034), Tuint16_t(1034), Tuint16_t(1034), Tuint16_t(1034), Tuint16_t(1034), Tuint16_t(1034), Tuint16_t(1034), Tuint16_t(1034), Tuint16_t(1034), Tuint16_t(1034), Tuint16_t(1034), Tuint16_t(1034), Tuint16_t(1034), Tuint16_t(1034), Tuint16_t(1034), Tuint16_t(1034),
	Tuint16_t(1034), Tuint16_t(1034), Tuint16_t(1034), Tuint16_t(1034), Tuint16_t(1034), Tuint16_t(1034), Tuint16_t(262), Tuint16_t(1035), Tuint16_t(1036), Tuint16_t(1036), Tuint16_t(1036), Tuint16_t(1036), Tuint16_t(1036), Tuint16_t(1036), Tuint16_t(1036), Tuint16_t(1036),
	Tuint16_t(1037), Tuint16_t(1037), Tuint16_t(1037), Tuint16_t(1037), Tuint16_t(1037), Tuint16_t(1037), Tuint16_t(1037), Tuint16_t(1037), Tuint16_t(1037), Tuint16_t(1037), Tuint16_t(1037), Tuint16_t(1037), Tuint16_t(1037), Tuint16_t(1037), Tuint16_t(1037), Tuint16_t(1037),
	Tuint16_t(1037), Tuint16_t(1037), Tuint16_t(1037), Tuint16_t(1037), Tuint16_t(1037), Tuint16_t(1037), Tuint16_t(1037), Tuint16_t(1038), Tuint16_t(1038), Tuint16_t(1039), Tuint16_t(1039), Tuint16_t(1039), Tuint16_t(1039), Tuint16_t(1039), Tuint16_t(1039), Tuint16_t(1039),

	// block 158
	Tuint16_t(1040), Tuint16_t(1040), Tuint16_t(1040), Tuint16_t(1040), Tuint16_t(1040), Tuint16_t(1040), Tuint16_t(1040), Tuint16_t(1040), Tuint16_t(1040), Tuint16_t(1040), Tuint16_t(1040), Tuint16_t(1040), Tuint16_t(1040), Tuint16_t(1040), Tuint16_t(1040), Tuint16_t(1040),
	Tuint16_t(1040), Tuint16_t(1040), Tuint16_t(1040), Tuint16_t(1040), Tuint16_t(1040), Tuint16_t(1040), Tuint16_t(1040), Tuint16_t(1040), Tuint16_t(1040), Tuint16_t(1040), Tuint16_t(1040), Tuint16_t(1040), Tuint16_t(1040), Tuint16_t(1040), Tuint16_t(1040), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(1041), Tuint16_t(1041), Tuint16_t(1041), Tuint16_t(1041), Tuint16_t(1041), Tuint16_t(1041), Tuint16_t(1041), Tuint16_t(1041), Tuint16_t(1041),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(1042), Tuint16_t(1042), Tuint16_t(1042), Tuint16_t(1042), Tuint16_t(1042), Tuint16_t(1042), Tuint16_t(1042), Tuint16_t(1042), Tuint16_t(1042), Tuint16_t(1042), Tuint16_t(1042), Tuint16_t(1042), Tuint16_t(1042), Tuint16_t(1042), Tuint16_t(1042), Tuint16_t(1042),
	Tuint16_t(1042), Tuint16_t(1042), Tuint16_t(1042), Tuint16_t(262), Tuint16_t(1042), Tuint16_t(1042), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(1043), Tuint16_t(1043), Tuint16_t(1043), Tuint16_t(1043), Tuint16_t(1043),

	// block 159
	Tuint16_t(1044), Tuint16_t(1044), Tuint16_t(1044), Tuint16_t(1044), Tuint16_t(1044), Tuint16_t(1044), Tuint16_t(1044), Tuint16_t(1044), Tuint16_t(1044), Tuint16_t(1044), Tuint16_t(1044), Tuint16_t(1044), Tuint16_t(1044), Tuint16_t(1044), Tuint16_t(1044), Tuint16_t(1044),
	Tuint16_t(1044), Tuint16_t(1044), Tuint16_t(1044), Tuint16_t(1044), Tuint16_t(1044), Tuint16_t(1044), Tuint16_t(1045), Tuint16_t(1045), Tuint16_t(1045), Tuint16_t(1045), Tuint16_t(1045), Tuint16_t(1045), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(1046),
	Tuint16_t(1047), Tuint16_t(1047), Tuint16_t(1047), Tuint16_t(1047), Tuint16_t(1047), Tuint16_t(1047), Tuint16_t(1047), Tuint16_t(1047), Tuint16_t(1047), Tuint16_t(1047), Tuint16_t(1047), Tuint16_t(1047), Tuint16_t(1047), Tuint16_t(1047), Tuint16_t(1047), Tuint16_t(1047),
	Tuint16_t(1047), Tuint16_t(1047), Tuint16_t(1047), Tuint16_t(1047), Tuint16_t(1047), Tuint16_t(1047), Tuint16_t(1047), Tuint16_t(1047), Tuint16_t(1047), Tuint16_t(1047), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(1048),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),

	// block 160
	Tuint16_t(1049), Tuint16_t(1049), Tuint16_t(1049), Tuint16_t(1049), Tuint16_t(1049), Tuint16_t(1049), Tuint16_t(1049), Tuint16_t(1049), Tuint16_t(1049), Tuint16_t(1049), Tuint16_t(1049), Tuint16_t(1049), Tuint16_t(1049), Tuint16_t(1049), Tuint16_t(1049), Tuint16_t(1049),
	Tuint16_t(1049), Tuint16_t(1049), Tuint16_t(1049), Tuint16_t(1049), Tuint16_t(1049), Tuint16_t(1049), Tuint16_t(1049), Tuint16_t(1049), Tuint16_t(1049), Tuint16_t(1049), Tuint16_t(1049), Tuint16_t(1049), Tuint16_t(1049), Tuint16_t(1049), Tuint16_t(1049), Tuint16_t(1049),
	Tuint16_t(1050), Tuint16_t(1050), Tuint16_t(1050), Tuint16_t(1050), Tuint16_t(1050), Tuint16_t(1050), Tuint16_t(1050), Tuint16_t(1050), Tuint16_t(1050), Tuint16_t(1050), Tuint16_t(1050), Tuint16_t(1050), Tuint16_t(1050), Tuint16_t(1050), Tuint16_t(1050), Tuint16_t(1050),
	Tuint16_t(1050), Tuint16_t(1050), Tuint16_t(1050), Tuint16_t(1050), Tuint16_t(1050), Tuint16_t(1050), Tuint16_t(1050), Tuint16_t(1050), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1050), Tuint16_t(1050),
	Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051),
	Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051),
	Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051), Tuint16_t(1051),

	// block 161
	Tuint16_t(1052), Tuint16_t(1053), Tuint16_t(1053), Tuint16_t(1053), Tuint16_t(262), Tuint16_t(1053), Tuint16_t(1053), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(1053), Tuint16_t(1053), Tuint16_t(1053), Tuint16_t(1053),
	Tuint16_t(1052), Tuint16_t(1052), Tuint16_t(1052), Tuint16_t(1052), Tuint16_t(262), Tuint16_t(1052), Tuint16_t(1052), Tuint16_t(1052), Tuint16_t(262), Tuint16_t(1052), Tuint16_t(1052), Tuint16_t(1052), Tuint16_t(1052), Tuint16_t(1052), Tuint16_t(1052), Tuint16_t(1052),
	Tuint16_t(1052), Tuint16_t(1052), Tuint16_t(1052), Tuint16_t(1052), Tuint16_t(1052), Tuint16_t(1052), Tuint16_t(1052), Tuint16_t(1052), Tuint16_t(1052), Tuint16_t(1052), Tuint16_t(1052), Tuint16_t(1052), Tuint16_t(1052), Tuint16_t(1052), Tuint16_t(1052), Tuint16_t(1052),
	Tuint16_t(1052), Tuint16_t(1052), Tuint16_t(1052), Tuint16_t(1052), Tuint16_t(1052), Tuint16_t(1052), Tuint16_t(262), Tuint16_t(262), Tuint16_t(1054), Tuint16_t(1054), Tuint16_t(1054), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(1055),
	Tuint16_t(1056), Tuint16_t(1056), Tuint16_t(1056), Tuint16_t(1056), Tuint16_t(1056), Tuint16_t(1056), Tuint16_t(1056), Tuint16_t(1056), Tuint16_t(1056), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(1057), Tuint16_t(1057), Tuint16_t(1057), Tuint16_t(1057), Tuint16_t(1057), Tuint16_t(1057), Tuint16_t(1058), Tuint16_t(1058), Tuint16_t(1057), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(1059), Tuint16_t(1059), Tuint16_t(1059), Tuint16_t(1059), Tuint16_t(1059), Tuint16_t(1059), Tuint16_t(1059), Tuint16_t(1059), Tuint16_t(1059), Tuint16_t(1059), Tuint16_t(1059), Tuint16_t(1059), Tuint16_t(1059), Tuint16_t(1059), Tuint16_t(1059), Tuint16_t(1059),
	Tuint16_t(1059), Tuint16_t(1059), Tuint16_t(1059), Tuint16_t(1059), Tuint16_t(1059), Tuint16_t(1059), Tuint16_t(1059), Tuint16_t(1059), Tuint16_t(1059), Tuint16_t(1059), Tuint16_t(1059), Tuint16_t(1059), Tuint16_t(1059), Tuint16_t(1060), Tuint16_t(1060), Tuint16_t(1061),

	// block 162
	Tuint16_t(1062), Tuint16_t(1062), Tuint16_t(1062), Tuint16_t(1062), Tuint16_t(1062), Tuint16_t(1062), Tuint16_t(1062), Tuint16_t(1062), Tuint16_t(1062), Tuint16_t(1062), Tuint16_t(1062), Tuint16_t(1062), Tuint16_t(1062), Tuint16_t(1062), Tuint16_t(1062), Tuint16_t(1062),
	Tuint16_t(1062), Tuint16_t(1062), Tuint16_t(1062), Tuint16_t(1062), Tuint16_t(1062), Tuint16_t(1062), Tuint16_t(1062), Tuint16_t(1062), Tuint16_t(1062), Tuint16_t(1062), Tuint16_t(1062), Tuint16_t(1062), Tuint16_t(1062), Tuint16_t(1063), Tuint16_t(1063), Tuint16_t(1063),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(1064), Tuint16_t(1064), Tuint16_t(1064), Tuint16_t(1064), Tuint16_t(1064), Tuint16_t(1064), Tuint16_t(1064), Tuint16_t(1064), Tuint16_t(1065), Tuint16_t(1064), Tuint16_t(1064), Tuint16_t(1064), Tuint16_t(1064), Tuint16_t(1064), Tuint16_t(1064), Tuint16_t(1064),
	Tuint16_t(1064), Tuint16_t(1064), Tuint16_t(1064), Tuint16_t(1064), Tuint16_t(1064), Tuint16_t(1064), Tuint16_t(1064), Tuint16_t(1064), Tuint16_t(1064), Tuint16_t(1064), Tuint16_t(1064), Tuint16_t(1064), Tuint16_t(1064), Tuint16_t(1064), Tuint16_t(1064), Tuint16_t(1064),
	Tuint16_t(1064), Tuint16_t(1064), Tuint16_t(1064), Tuint16_t(1064), Tuint16_t(1064), Tuint16_t(1066), Tuint16_t(1066), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(1067), Tuint16_t(1067), Tuint16_t(1067), Tuint16_t(1067), Tuint16_t(1067),
	Tuint16_t(1068), Tuint16_t(1068), Tuint16_t(1069), Tuint16_t(1068), Tuint16_t(1068), Tuint16_t(1068), Tuint16_t(1070), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),

	// block 163
	Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071),
	Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071),
	Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071),
	Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(1071), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(1072), Tuint16_t(1073), Tuint16_t(1073), Tuint16_t(1073), Tuint16_t(1073), Tuint16_t(1073), Tuint16_t(1073),
	Tuint16_t(1074), Tuint16_t(1074), Tuint16_t(1074), Tuint16_t(1074), Tuint16_t(1074), Tuint16_t(1074), Tuint16_t(1074), Tuint16_t(1074), Tuint16_t(1074), Tuint16_t(1074), Tuint16_t(1074), Tuint16_t(1074), Tuint16_t(1074), Tuint16_t(1074), Tuint16_t(1074), Tuint16_t(1074),
	Tuint16_t(1074), Tuint16_t(1074), Tuint16_t(1074), Tuint16_t(1074), Tuint16_t(1074), Tuint16_t(1074), Tuint16_t(262), Tuint16_t(262), Tuint16_t(1075), Tuint16_t(1075), Tuint16_t(1075), Tuint16_t(1075), Tuint16_t(1075), Tuint16_t(1075), Tuint16_t(1075), Tuint16_t(1075),
	Tuint16_t(1076), Tuint16_t(1076), Tuint16_t(1076), Tuint16_t(1076), Tuint16_t(1076), Tuint16_t(1076), Tuint16_t(1076), Tuint16_t(1076), Tuint16_t(1076), Tuint16_t(1076), Tuint16_t(1076), Tuint16_t(1076), Tuint16_t(1076), Tuint16_t(1076), Tuint16_t(1076), Tuint16_t(1076),
	Tuint16_t(1076), Tuint16_t(1076), Tuint16_t(1076), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(1077), Tuint16_t(1077), Tuint16_t(1077), Tuint16_t(1077), Tuint16_t(1077), Tuint16_t(1077), Tuint16_t(1077), Tuint16_t(1077),

	// block 164
	Tuint16_t(1078), Tuint16_t(1078), Tuint16_t(1078), Tuint16_t(1078), Tuint16_t(1078), Tuint16_t(1078), Tuint16_t(1078), Tuint16_t(1078), Tuint16_t(1078), Tuint16_t(1078), Tuint16_t(1078), Tuint16_t(1078), Tuint16_t(1078), Tuint16_t(1078), Tuint16_t(1078), Tuint16_t(1078),
	Tuint16_t(1078), Tuint16_t(1078), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(1079), Tuint16_t(1079), Tuint16_t(1079), Tuint16_t(1079), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(1080), Tuint16_t(1080), Tuint16_t(1080), Tuint16_t(1080), Tuint16_t(1080), Tuint16_t(1080), Tuint16_t(1080),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),

	// block 165
	Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081),
	Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081),
	Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081),
	Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081),
	Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(1081), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),

	// block 166
	Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082),
	Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082),
	Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082),
	Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(1082), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083),
	Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083),
	Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083),
	Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(1083), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(1084), Tuint16_t(1084), Tuint16_t(1084), Tuint16_t(1084), Tuint16_t(1084), Tuint16_t(1084),

	// block 167
	Tuint16_t(1085), Tuint16_t(1085), Tuint16_t(1085), Tuint16_t(1085), Tuint16_t(1085), Tuint16_t(1085), Tuint16_t(1085), Tuint16_t(1085), Tuint16_t(1085), Tuint16_t(1085), Tuint16_t(1085), Tuint16_t(1085), Tuint16_t(1085), Tuint16_t(1085), Tuint16_t(1085), Tuint16_t(1085),
	Tuint16_t(1085), Tuint16_t(1085), Tuint16_t(1085), Tuint16_t(1085), Tuint16_t(1085), Tuint16_t(1085), Tuint16_t(1085), Tuint16_t(1085), Tuint16_t(1085), Tuint16_t(1085), Tuint16_t(1085), Tuint16_t(1085), Tuint16_t(1085), Tuint16_t(1085), Tuint16_t(1085), Tuint16_t(1085),
	Tuint16_t(1085), Tuint16_t(1085), Tuint16_t(1086), Tuint16_t(1086), Tuint16_t(1087), Tuint16_t(1087), Tuint16_t(1087), Tuint16_t(1087), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302),
	Tuint16_t(1088), Tuint16_t(1088), Tuint16_t(1088), Tuint16_t(1088), Tuint16_t(1088), Tuint16_t(1088), Tuint16_t(1088), Tuint16_t(1088), Tuint16_t(1088), Tuint16_t(1088), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),

	// block 168
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),

	// block 169
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(1089), Tuint16_t(1089), Tuint16_t(1089), Tuint16_t(1089), Tuint16_t(1089), Tuint16_t(1089), Tuint16_t(1089), Tuint16_t(1089), Tuint16_t(1089), Tuint16_t(1089), Tuint16_t(1089), Tuint16_t(1089), Tuint16_t(1089), Tuint16_t(1089), Tuint16_t(1089), Tuint16_t(1089),
	Tuint16_t(1089), Tuint16_t(1089), Tuint16_t(1089), Tuint16_t(1089), Tuint16_t(1089), Tuint16_t(1089), Tuint16_t(1089), Tuint16_t(1089), Tuint16_t(1089), Tuint16_t(1089), Tuint16_t(1089), Tuint16_t(1089), Tuint16_t(1089), Tuint16_t(1089), Tuint16_t(1089), Tuint16_t(262),

	// block 170
	Tuint16_t(1090), Tuint16_t(1090), Tuint16_t(1090), Tuint16_t(1090), Tuint16_t(1090), Tuint16_t(1090), Tuint16_t(1090), Tuint16_t(1090), Tuint16_t(1090), Tuint16_t(1090), Tuint16_t(1090), Tuint16_t(1090), Tuint16_t(1090), Tuint16_t(1090), Tuint16_t(1090), Tuint16_t(1090),
	Tuint16_t(1090), Tuint16_t(1090), Tuint16_t(1090), Tuint16_t(1090), Tuint16_t(1090), Tuint16_t(1090), Tuint16_t(1090), Tuint16_t(1090), Tuint16_t(1090), Tuint16_t(1090), Tuint16_t(1090), Tuint16_t(1090), Tuint16_t(1090), Tuint16_t(1090), Tuint16_t(1090), Tuint16_t(1090),
	Tuint16_t(1090), Tuint16_t(1090), Tuint16_t(1090), Tuint16_t(1090), Tuint16_t(1090), Tuint16_t(1090), Tuint16_t(1090), Tuint16_t(1090), Tuint16_t(1090), Tuint16_t(1090), Tuint16_t(262), Tuint16_t(1091), Tuint16_t(1091), Tuint16_t(1092), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(1090), Tuint16_t(1090), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),

	// block 171
	Tuint16_t(1093), Tuint16_t(1093), Tuint16_t(1093), Tuint16_t(1093), Tuint16_t(1093), Tuint16_t(1093), Tuint16_t(1093), Tuint16_t(1093), Tuint16_t(1093), Tuint16_t(1093), Tuint16_t(1093), Tuint16_t(1093), Tuint16_t(1093), Tuint16_t(1093), Tuint16_t(1093), Tuint16_t(1093),
	Tuint16_t(1093), Tuint16_t(1093), Tuint16_t(1093), Tuint16_t(1093), Tuint16_t(1093), Tuint16_t(1093), Tuint16_t(1093), Tuint16_t(1093), Tuint16_t(1093), Tuint16_t(1093), Tuint16_t(1093), Tuint16_t(1093), Tuint16_t(1093), Tuint16_t(1094), Tuint16_t(1094), Tuint16_t(1094),
	Tuint16_t(1094), Tuint16_t(1094), Tuint16_t(1094), Tuint16_t(1094), Tuint16_t(1094), Tuint16_t(1094), Tuint16_t(1094), Tuint16_t(1093), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(1095), Tuint16_t(1095), Tuint16_t(1095), Tuint16_t(1095), Tuint16_t(1095), Tuint16_t(1095), Tuint16_t(1095), Tuint16_t(1095), Tuint16_t(1095), Tuint16_t(1095), Tuint16_t(1095), Tuint16_t(1095), Tuint16_t(1095), Tuint16_t(1095), Tuint16_t(1095), Tuint16_t(1095),
	Tuint16_t(1095), Tuint16_t(1095), Tuint16_t(1095), Tuint16_t(1095), Tuint16_t(1095), Tuint16_t(1095), Tuint16_t(1096), Tuint16_t(1096), Tuint16_t(1096), Tuint16_t(1096), Tuint16_t(1096), Tuint16_t(1096), Tuint16_t(1096), Tuint16_t(1096), Tuint16_t(1096), Tuint16_t(1096),
	Tuint16_t(1096), Tuint16_t(1097), Tuint16_t(1097), Tuint16_t(1097), Tuint16_t(1097), Tuint16_t(1098), Tuint16_t(1098), Tuint16_t(1098), Tuint16_t(1098), Tuint16_t(1098), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302),
	Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302),
	Tuint16_t(1099), Tuint16_t(1099), Tuint16_t(1099), Tuint16_t(1099), Tuint16_t(1099), Tuint16_t(1099), Tuint16_t(1099), Tuint16_t(1099), Tuint16_t(1099), Tuint16_t(1099), Tuint16_t(1099), Tuint16_t(1099), Tuint16_t(1099), Tuint16_t(1099), Tuint16_t(1099), Tuint16_t(1099),

	// block 172
	Tuint16_t(1099), Tuint16_t(1099), Tuint16_t(1100), Tuint16_t(1100), Tuint16_t(1100), Tuint16_t(1100), Tuint16_t(1101), Tuint16_t(1101), Tuint16_t(1101), Tuint16_t(1101), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(1102), Tuint16_t(1102), Tuint16_t(1102), Tuint16_t(1102), Tuint16_t(1102), Tuint16_t(1102), Tuint16_t(1102), Tuint16_t(1102), Tuint16_t(1102), Tuint16_t(1102), Tuint16_t(1102), Tuint16_t(1102), Tuint16_t(1102), Tuint16_t(1102), Tuint16_t(1102), Tuint16_t(1102),
	Tuint16_t(1102), Tuint16_t(1102), Tuint16_t(1102), Tuint16_t(1102), Tuint16_t(1102), Tuint16_t(1103), Tuint16_t(1103), Tuint16_t(1103), Tuint16_t(1103), Tuint16_t(1103), Tuint16_t(1103), Tuint16_t(1103), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(1104), Tuint16_t(1104), Tuint16_t(1104), Tuint16_t(1104), Tuint16_t(1104), Tuint16_t(1104), Tuint16_t(1104), Tuint16_t(1104), Tuint16_t(1104), Tuint16_t(1104), Tuint16_t(1104), Tuint16_t(1104), Tuint16_t(1104), Tuint16_t(1104), Tuint16_t(1104), Tuint16_t(1104),
	Tuint16_t(1104), Tuint16_t(1104), Tuint16_t(1104), Tuint16_t(1104), Tuint16_t(1104), Tuint16_t(1104), Tuint16_t(1104), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),

	// block 173
	Tuint16_t(1105), Tuint16_t(1106), Tuint16_t(1105), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107),
	Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107),
	Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107),
	Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1106), Tuint16_t(1106), Tuint16_t(1106), Tuint16_t(1106), Tuint16_t(1106), Tuint16_t(1106), Tuint16_t(1106), Tuint16_t(1106),
	Tuint16_t(1106), Tuint16_t(1106), Tuint16_t(1106), Tuint16_t(1106), Tuint16_t(1106), Tuint16_t(1106), Tuint16_t(1108), Tuint16_t(1109), Tuint16_t(1109), Tuint16_t(1110), Tuint16_t(1110), Tuint16_t(1110), Tuint16_t(1110), Tuint16_t(1110), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(1111), Tuint16_t(1111), Tuint16_t(1111), Tuint16_t(1111), Tuint16_t(1111), Tuint16_t(1111), Tuint16_t(1111), Tuint16_t(1111), Tuint16_t(1111), Tuint16_t(1111), Tuint16_t(1111), Tuint16_t(1111), Tuint16_t(1111), Tuint16_t(1111),
	Tuint16_t(1111), Tuint16_t(1111), Tuint16_t(1111), Tuint16_t(1111), Tuint16_t(1111), Tuint16_t(1111), Tuint16_t(1112), Tuint16_t(1112), Tuint16_t(1112), Tuint16_t(1112), Tuint16_t(1112), Tuint16_t(1112), Tuint16_t(1112), Tuint16_t(1112), Tuint16_t(1112), Tuint16_t(1112),
	Tuint16_t(1108), Tuint16_t(1107), Tuint16_t(1107), Tuint16_t(1106), Tuint16_t(1106), Tuint16_t(1107), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(1113),

	// block 174
	Tuint16_t(1114), Tuint16_t(1114), Tuint16_t(1115), Tuint16_t(1116), Tuint16_t(1116), Tuint16_t(1116), Tuint16_t(1116), Tuint16_t(1116), Tuint16_t(1116), Tuint16_t(1116), Tuint16_t(1116), Tuint16_t(1116), Tuint16_t(1116), Tuint16_t(1116), Tuint16_t(1116), Tuint16_t(1116),
	Tuint16_t(1116), Tuint16_t(1116), Tuint16_t(1116), Tuint16_t(1116), Tuint16_t(1116), Tuint16_t(1116), Tuint16_t(1116), Tuint16_t(1116), Tuint16_t(1116), Tuint16_t(1116), Tuint16_t(1116), Tuint16_t(1116), Tuint16_t(1116), Tuint16_t(1116), Tuint16_t(1116), Tuint16_t(1116),
	Tuint16_t(1116), Tuint16_t(1116), Tuint16_t(1116), Tuint16_t(1116), Tuint16_t(1116), Tuint16_t(1116), Tuint16_t(1116), Tuint16_t(1116), Tuint16_t(1116), Tuint16_t(1116), Tuint16_t(1116), Tuint16_t(1116), Tuint16_t(1116), Tuint16_t(1116), Tuint16_t(1116), Tuint16_t(1116),
	Tuint16_t(1115), Tuint16_t(1115), Tuint16_t(1115), Tuint16_t(1117), Tuint16_t(1117), Tuint16_t(1117), Tuint16_t(1117), Tuint16_t(1115), Tuint16_t(1115), Tuint16_t(1118), Tuint16_t(1119), Tuint16_t(1120), Tuint16_t(1120), Tuint16_t(1121), Tuint16_t(1122), Tuint16_t(1122),
	Tuint16_t(1122), Tuint16_t(1122), Tuint16_t(1117), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(1121), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1123), Tuint16_t(1123), Tuint16_t(1123), Tuint16_t(1123), Tuint16_t(1123), Tuint16_t(1123), Tuint16_t(1123), Tuint16_t(1123), Tuint16_t(1123), Tuint16_t(1123), Tuint16_t(1123), Tuint16_t(1123), Tuint16_t(1123), Tuint16_t(1123), Tuint16_t(1123), Tuint16_t(1123),
	Tuint16_t(1123), Tuint16_t(1123), Tuint16_t(1123), Tuint16_t(1123), Tuint16_t(1123), Tuint16_t(1123), Tuint16_t(1123), Tuint16_t(1123), Tuint16_t(1123), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1124), Tuint16_t(1124), Tuint16_t(1124), Tuint16_t(1124), Tuint16_t(1124), Tuint16_t(1124), Tuint16_t(1124), Tuint16_t(1124), Tuint16_t(1124), Tuint16_t(1124), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 175
	Tuint16_t(1125), Tuint16_t(1125), Tuint16_t(1125), Tuint16_t(1126), Tuint16_t(1126), Tuint16_t(1126), Tuint16_t(1126), Tuint16_t(1126), Tuint16_t(1126), Tuint16_t(1126), Tuint16_t(1126), Tuint16_t(1126), Tuint16_t(1126), Tuint16_t(1126), Tuint16_t(1126), Tuint16_t(1126),
	Tuint16_t(1126), Tuint16_t(1126), Tuint16_t(1126), Tuint16_t(1126), Tuint16_t(1126), Tuint16_t(1126), Tuint16_t(1126), Tuint16_t(1126), Tuint16_t(1126), Tuint16_t(1126), Tuint16_t(1126), Tuint16_t(1126), Tuint16_t(1126), Tuint16_t(1126), Tuint16_t(1126), Tuint16_t(1126),
	Tuint16_t(1126), Tuint16_t(1126), Tuint16_t(1126), Tuint16_t(1126), Tuint16_t(1126), Tuint16_t(1126), Tuint16_t(1126), Tuint16_t(1125), Tuint16_t(1125), Tuint16_t(1125), Tuint16_t(1125), Tuint16_t(1125), Tuint16_t(1127), Tuint16_t(1125), Tuint16_t(1125), Tuint16_t(1125),
	Tuint16_t(1125), Tuint16_t(1125), Tuint16_t(1125), Tuint16_t(1128), Tuint16_t(1128), Tuint16_t(163), Tuint16_t(1129), Tuint16_t(1129), Tuint16_t(1129), Tuint16_t(1129), Tuint16_t(1129), Tuint16_t(1129), Tuint16_t(1129), Tuint16_t(1129), Tuint16_t(1129), Tuint16_t(1129),
	Tuint16_t(1130), Tuint16_t(1131), Tuint16_t(1131), Tuint16_t(1131), Tuint16_t(1126), Tuint16_t(1127), Tuint16_t(1127), Tuint16_t(1126), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1132), Tuint16_t(1132), Tuint16_t(1132), Tuint16_t(1132), Tuint16_t(1132), Tuint16_t(1132), Tuint16_t(1132), Tuint16_t(1132), Tuint16_t(1132), Tuint16_t(1132), Tuint16_t(1132), Tuint16_t(1132), Tuint16_t(1132), Tuint16_t(1132), Tuint16_t(1132), Tuint16_t(1132),
	Tuint16_t(1132), Tuint16_t(1132), Tuint16_t(1132), Tuint16_t(1132), Tuint16_t(1132), Tuint16_t(1132), Tuint16_t(1132), Tuint16_t(1132), Tuint16_t(1132), Tuint16_t(1132), Tuint16_t(1132), Tuint16_t(1132), Tuint16_t(1132), Tuint16_t(1132), Tuint16_t(1132), Tuint16_t(1132),
	Tuint16_t(1132), Tuint16_t(1132), Tuint16_t(1132), Tuint16_t(1133), Tuint16_t(1134), Tuint16_t(1134), Tuint16_t(1132), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 176
	Tuint16_t(1135), Tuint16_t(1135), Tuint16_t(1136), Tuint16_t(1137), Tuint16_t(1137), Tuint16_t(1137), Tuint16_t(1137), Tuint16_t(1137), Tuint16_t(1137), Tuint16_t(1137), Tuint16_t(1137), Tuint16_t(1137), Tuint16_t(1137), Tuint16_t(1137), Tuint16_t(1137), Tuint16_t(1137),
	Tuint16_t(1137), Tuint16_t(1137), Tuint16_t(1137), Tuint16_t(1137), Tuint16_t(1137), Tuint16_t(1137), Tuint16_t(1137), Tuint16_t(1137), Tuint16_t(1137), Tuint16_t(1137), Tuint16_t(1137), Tuint16_t(1137), Tuint16_t(1137), Tuint16_t(1137), Tuint16_t(1137), Tuint16_t(1137),
	Tuint16_t(1137), Tuint16_t(1137), Tuint16_t(1137), Tuint16_t(1137), Tuint16_t(1137), Tuint16_t(1137), Tuint16_t(1137), Tuint16_t(1137), Tuint16_t(1137), Tuint16_t(1137), Tuint16_t(1137), Tuint16_t(1137), Tuint16_t(1137), Tuint16_t(1137), Tuint16_t(1137), Tuint16_t(1137),
	Tuint16_t(1137), Tuint16_t(1137), Tuint16_t(1137), Tuint16_t(1136), Tuint16_t(1136), Tuint16_t(1136), Tuint16_t(1135), Tuint16_t(1135), Tuint16_t(1135), Tuint16_t(1135), Tuint16_t(1135), Tuint16_t(1135), Tuint16_t(1135), Tuint16_t(1135), Tuint16_t(1135), Tuint16_t(1136),
	Tuint16_t(1138), Tuint16_t(1137), Tuint16_t(1139), Tuint16_t(1139), Tuint16_t(1137), Tuint16_t(1140), Tuint16_t(1140), Tuint16_t(1141), Tuint16_t(1141), Tuint16_t(1142), Tuint16_t(1143), Tuint16_t(1143), Tuint16_t(1143), Tuint16_t(1140), Tuint16_t(1136), Tuint16_t(1135),
	Tuint16_t(1144), Tuint16_t(1144), Tuint16_t(1144), Tuint16_t(1144), Tuint16_t(1144), Tuint16_t(1144), Tuint16_t(1144), Tuint16_t(1144), Tuint16_t(1144), Tuint16_t(1144), Tuint16_t(1137), Tuint16_t(1141), Tuint16_t(1137), Tuint16_t(1141), Tuint16_t(1140), Tuint16_t(1140),
	Tuint16_t(163), Tuint16_t(1145), Tuint16_t(1145), Tuint16_t(1145), Tuint16_t(1145), Tuint16_t(1145), Tuint16_t(1145), Tuint16_t(1145), Tuint16_t(1145), Tuint16_t(1145), Tuint16_t(1145), Tuint16_t(1145), Tuint16_t(1145), Tuint16_t(1145), Tuint16_t(1145), Tuint16_t(1145),
	Tuint16_t(1145), Tuint16_t(1145), Tuint16_t(1145), Tuint16_t(1145), Tuint16_t(1145), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 177
	Tuint16_t(1146), Tuint16_t(1146), Tuint16_t(1146), Tuint16_t(1146), Tuint16_t(1146), Tuint16_t(1146), Tuint16_t(1146), Tuint16_t(1146), Tuint16_t(1146), Tuint16_t(1146), Tuint16_t(1146), Tuint16_t(1146), Tuint16_t(1146), Tuint16_t(1146), Tuint16_t(1146), Tuint16_t(1146),
	Tuint16_t(1146), Tuint16_t(1146), Tuint16_t(163), Tuint16_t(1146), Tuint16_t(1146), Tuint16_t(1146), Tuint16_t(1146), Tuint16_t(1146), Tuint16_t(1146), Tuint16_t(1146), Tuint16_t(1146), Tuint16_t(1146), Tuint16_t(1146), Tuint16_t(1146), Tuint16_t(1146), Tuint16_t(1146),
	Tuint16_t(1146), Tuint16_t(1146), Tuint16_t(1146), Tuint16_t(1146), Tuint16_t(1146), Tuint16_t(1146), Tuint16_t(1146), Tuint16_t(1146), Tuint16_t(1146), Tuint16_t(1146), Tuint16_t(1146), Tuint16_t(1146), Tuint16_t(1147), Tuint16_t(1147), Tuint16_t(1147), Tuint16_t(1148),
	Tuint16_t(1148), Tuint16_t(1148), Tuint16_t(1147), Tuint16_t(1147), Tuint16_t(1148), Tuint16_t(1149), Tuint16_t(1150), Tuint16_t(1148), Tuint16_t(1151), Tuint16_t(1151), Tuint16_t(1152), Tuint16_t(1151), Tuint16_t(1151), Tuint16_t(1153), Tuint16_t(1148), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 178
	Tuint16_t(1154), Tuint16_t(1154), Tuint16_t(1154), Tuint16_t(1154), Tuint16_t(1154), Tuint16_t(1154), Tuint16_t(1154), Tuint16_t(163), Tuint16_t(1154), Tuint16_t(163), Tuint16_t(1154), Tuint16_t(1154), Tuint16_t(1154), Tuint16_t(1154), Tuint16_t(163), Tuint16_t(1154),
	Tuint16_t(1154), Tuint16_t(1154), Tuint16_t(1154), Tuint16_t(1154), Tuint16_t(1154), Tuint16_t(1154), Tuint16_t(1154), Tuint16_t(1154), Tuint16_t(1154), Tuint16_t(1154), Tuint16_t(1154), Tuint16_t(1154), Tuint16_t(1154), Tuint16_t(1154), Tuint16_t(163), Tuint16_t(1154),
	Tuint16_t(1154), Tuint16_t(1154), Tuint16_t(1154), Tuint16_t(1154), Tuint16_t(1154), Tuint16_t(1154), Tuint16_t(1154), Tuint16_t(1154), Tuint16_t(1154), Tuint16_t(1155), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1156), Tuint16_t(1156), Tuint16_t(1156), Tuint16_t(1156), Tuint16_t(1156), Tuint16_t(1156), Tuint16_t(1156), Tuint16_t(1156), Tuint16_t(1156), Tuint16_t(1156), Tuint16_t(1156), Tuint16_t(1156), Tuint16_t(1156), Tuint16_t(1156), Tuint16_t(1156), Tuint16_t(1156),
	Tuint16_t(1156), Tuint16_t(1156), Tuint16_t(1156), Tuint16_t(1156), Tuint16_t(1156), Tuint16_t(1156), Tuint16_t(1156), Tuint16_t(1156), Tuint16_t(1156), Tuint16_t(1156), Tuint16_t(1156), Tuint16_t(1156), Tuint16_t(1156), Tuint16_t(1156), Tuint16_t(1156), Tuint16_t(1156),
	Tuint16_t(1156), Tuint16_t(1156), Tuint16_t(1156), Tuint16_t(1156), Tuint16_t(1156), Tuint16_t(1156), Tuint16_t(1156), Tuint16_t(1156), Tuint16_t(1156), Tuint16_t(1156), Tuint16_t(1156), Tuint16_t(1156), Tuint16_t(1156), Tuint16_t(1156), Tuint16_t(1156), Tuint16_t(1157),
	Tuint16_t(1158), Tuint16_t(1158), Tuint16_t(1158), Tuint16_t(1157), Tuint16_t(1157), Tuint16_t(1157), Tuint16_t(1157), Tuint16_t(1157), Tuint16_t(1157), Tuint16_t(1159), Tuint16_t(1160), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1161), Tuint16_t(1161), Tuint16_t(1161), Tuint16_t(1161), Tuint16_t(1161), Tuint16_t(1161), Tuint16_t(1161), Tuint16_t(1161), Tuint16_t(1161), Tuint16_t(1161), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 179
	Tuint16_t(1162), Tuint16_t(1163), Tuint16_t(1164), Tuint16_t(1165), Tuint16_t(163), Tuint16_t(1166), Tuint16_t(1166), Tuint16_t(1166), Tuint16_t(1166), Tuint16_t(1166), Tuint16_t(1166), Tuint16_t(1166), Tuint16_t(1166), Tuint16_t(163), Tuint16_t(163), Tuint16_t(1166),
	Tuint16_t(1166), Tuint16_t(163), Tuint16_t(163), Tuint16_t(1166), Tuint16_t(1166), Tuint16_t(1166), Tuint16_t(1166), Tuint16_t(1166), Tuint16_t(1166), Tuint16_t(1166), Tuint16_t(1166), Tuint16_t(1166), Tuint16_t(1166), Tuint16_t(1166), Tuint16_t(1166), Tuint16_t(1166),
	Tuint16_t(1166), Tuint16_t(1166), Tuint16_t(1166), Tuint16_t(1166), Tuint16_t(1166), Tuint16_t(1166), Tuint16_t(1166), Tuint16_t(1166), Tuint16_t(1166), Tuint16_t(163), Tuint16_t(1166), Tuint16_t(1166), Tuint16_t(1166), Tuint16_t(1166), Tuint16_t(1166), Tuint16_t(1166),
	Tuint16_t(1166), Tuint16_t(163), Tuint16_t(1166), Tuint16_t(1166), Tuint16_t(163), Tuint16_t(1166), Tuint16_t(1166), Tuint16_t(1166), Tuint16_t(1166), Tuint16_t(1166), Tuint16_t(163), Tuint16_t(1167), Tuint16_t(1168), Tuint16_t(1166), Tuint16_t(1169), Tuint16_t(1164),
	Tuint16_t(1162), Tuint16_t(1164), Tuint16_t(1164), Tuint16_t(1164), Tuint16_t(1164), Tuint16_t(163), Tuint16_t(163), Tuint16_t(1164), Tuint16_t(1164), Tuint16_t(163), Tuint16_t(163), Tuint16_t(1164), Tuint16_t(1164), Tuint16_t(1170), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1166), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(1169), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(1171), Tuint16_t(1166), Tuint16_t(1166),
	Tuint16_t(1166), Tuint16_t(1166), Tuint16_t(1164), Tuint16_t(1164), Tuint16_t(163), Tuint16_t(163), Tuint16_t(1172), Tuint16_t(1172), Tuint16_t(1172), Tuint16_t(1172), Tuint16_t(1172), Tuint16_t(1172), Tuint16_t(1172), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1172), Tuint16_t(1172), Tuint16_t(1172), Tuint16_t(1172), Tuint16_t(1172), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 180
	Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173),
	Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173),
	Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173),
	Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1174), Tuint16_t(1174), Tuint16_t(1174), Tuint16_t(1175), Tuint16_t(1175), Tuint16_t(1175), Tuint16_t(1175), Tuint16_t(1175), Tuint16_t(1175), Tuint16_t(1175), Tuint16_t(1175),
	Tuint16_t(1174), Tuint16_t(1174), Tuint16_t(1176), Tuint16_t(1175), Tuint16_t(1175), Tuint16_t(1174), Tuint16_t(1177), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(1178), Tuint16_t(1178), Tuint16_t(1179), Tuint16_t(1180), Tuint16_t(1180),
	Tuint16_t(1181), Tuint16_t(1181), Tuint16_t(1181), Tuint16_t(1181), Tuint16_t(1181), Tuint16_t(1181), Tuint16_t(1181), Tuint16_t(1181), Tuint16_t(1181), Tuint16_t(1181), Tuint16_t(1179), Tuint16_t(1179), Tuint16_t(163), Tuint16_t(1180), Tuint16_t(1182), Tuint16_t(1173),
	Tuint16_t(1173), Tuint16_t(1173), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 181
	Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1183),
	Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1183),
	Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1183),
	Tuint16_t(1184), Tuint16_t(1185), Tuint16_t(1185), Tuint16_t(1186), Tuint16_t(1186), Tuint16_t(1186), Tuint16_t(1186), Tuint16_t(1186), Tuint16_t(1186), Tuint16_t(1185), Tuint16_t(1186), Tuint16_t(1185), Tuint16_t(1185), Tuint16_t(1184), Tuint16_t(1185), Tuint16_t(1186),
	Tuint16_t(1186), Tuint16_t(1185), Tuint16_t(1187), Tuint16_t(1188), Tuint16_t(1183), Tuint16_t(1183), Tuint16_t(1189), Tuint16_t(1183), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1190), Tuint16_t(1190), Tuint16_t(1190), Tuint16_t(1190), Tuint16_t(1190), Tuint16_t(1190), Tuint16_t(1190), Tuint16_t(1190), Tuint16_t(1190), Tuint16_t(1190), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 182
	Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191),
	Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191),
	Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1192),
	Tuint16_t(1193), Tuint16_t(1193), Tuint16_t(1194), Tuint16_t(1194), Tuint16_t(1194), Tuint16_t(1194), Tuint16_t(163), Tuint16_t(163), Tuint16_t(1193), Tuint16_t(1193), Tuint16_t(1193), Tuint16_t(1193), Tuint16_t(1194), Tuint16_t(1194), Tuint16_t(1193), Tuint16_t(1195),
	Tuint16_t(1196), Tuint16_t(1197), Tuint16_t(1198), Tuint16_t(1198), Tuint16_t(1199), Tuint16_t(1199), Tuint16_t(1200), Tuint16_t(1200), Tuint16_t(1200), Tuint16_t(1198), Tuint16_t(1198), Tuint16_t(1198), Tuint16_t(1198), Tuint16_t(1198), Tuint16_t(1198), Tuint16_t(1198),
	Tuint16_t(1198), Tuint16_t(1198), Tuint16_t(1198), Tuint16_t(1198), Tuint16_t(1198), Tuint16_t(1198), Tuint16_t(1198), Tuint16_t(1198), Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1191), Tuint16_t(1194), Tuint16_t(1194), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 183
	Tuint16_t(1201), Tuint16_t(1201), Tuint16_t(1201), Tuint16_t(1201), Tuint16_t(1201), Tuint16_t(1201), Tuint16_t(1201), Tuint16_t(1201), Tuint16_t(1201), Tuint16_t(1201), Tuint16_t(1201), Tuint16_t(1201), Tuint16_t(1201), Tuint16_t(1201), Tuint16_t(1201), Tuint16_t(1201),
	Tuint16_t(1201), Tuint16_t(1201), Tuint16_t(1201), Tuint16_t(1201), Tuint16_t(1201), Tuint16_t(1201), Tuint16_t(1201), Tuint16_t(1201), Tuint16_t(1201), Tuint16_t(1201), Tuint16_t(1201), Tuint16_t(1201), Tuint16_t(1201), Tuint16_t(1201), Tuint16_t(1201), Tuint16_t(1201),
	Tuint16_t(1201), Tuint16_t(1201), Tuint16_t(1201), Tuint16_t(1201), Tuint16_t(1201), Tuint16_t(1201), Tuint16_t(1201), Tuint16_t(1201), Tuint16_t(1201), Tuint16_t(1201), Tuint16_t(1201), Tuint16_t(1201), Tuint16_t(1201), Tuint16_t(1201), Tuint16_t(1201), Tuint16_t(1201),
	Tuint16_t(1202), Tuint16_t(1202), Tuint16_t(1202), Tuint16_t(1203), Tuint16_t(1203), Tuint16_t(1203), Tuint16_t(1203), Tuint16_t(1203), Tuint16_t(1203), Tuint16_t(1203), Tuint16_t(1203), Tuint16_t(1202), Tuint16_t(1202), Tuint16_t(1203), Tuint16_t(1202), Tuint16_t(1204),
	Tuint16_t(1203), Tuint16_t(1205), Tuint16_t(1205), Tuint16_t(1206), Tuint16_t(1201), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1207), Tuint16_t(1207), Tuint16_t(1207), Tuint16_t(1207), Tuint16_t(1207), Tuint16_t(1207), Tuint16_t(1207), Tuint16_t(1207), Tuint16_t(1207), Tuint16_t(1207), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(530), Tuint16_t(530), Tuint16_t(530), Tuint16_t(530), Tuint16_t(530), Tuint16_t(530), Tuint16_t(530), Tuint16_t(530), Tuint16_t(530), Tuint16_t(530), Tuint16_t(530), Tuint16_t(530), Tuint16_t(530), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 184
	Tuint16_t(1208), Tuint16_t(1208), Tuint16_t(1208), Tuint16_t(1208), Tuint16_t(1208), Tuint16_t(1208), Tuint16_t(1208), Tuint16_t(1208), Tuint16_t(1208), Tuint16_t(1208), Tuint16_t(1208), Tuint16_t(1208), Tuint16_t(1208), Tuint16_t(1208), Tuint16_t(1208), Tuint16_t(1208),
	Tuint16_t(1208), Tuint16_t(1208), Tuint16_t(1208), Tuint16_t(1208), Tuint16_t(1208), Tuint16_t(1208), Tuint16_t(1208), Tuint16_t(1208), Tuint16_t(1208), Tuint16_t(1208), Tuint16_t(1208), Tuint16_t(1208), Tuint16_t(1208), Tuint16_t(1208), Tuint16_t(1208), Tuint16_t(1208),
	Tuint16_t(1208), Tuint16_t(1208), Tuint16_t(1208), Tuint16_t(1208), Tuint16_t(1208), Tuint16_t(1208), Tuint16_t(1208), Tuint16_t(1208), Tuint16_t(1208), Tuint16_t(1208), Tuint16_t(1208), Tuint16_t(1209), Tuint16_t(1210), Tuint16_t(1209), Tuint16_t(1210), Tuint16_t(1210),
	Tuint16_t(1209), Tuint16_t(1209), Tuint16_t(1209), Tuint16_t(1209), Tuint16_t(1209), Tuint16_t(1209), Tuint16_t(1211), Tuint16_t(1212), Tuint16_t(1208), Tuint16_t(1213), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1214), Tuint16_t(1214), Tuint16_t(1214), Tuint16_t(1214), Tuint16_t(1214), Tuint16_t(1214), Tuint16_t(1214), Tuint16_t(1214), Tuint16_t(1214), Tuint16_t(1214), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 185
	Tuint16_t(1215), Tuint16_t(1215), Tuint16_t(1215), Tuint16_t(1215), Tuint16_t(1215), Tuint16_t(1215), Tuint16_t(1215), Tuint16_t(1215), Tuint16_t(1215), Tuint16_t(1215), Tuint16_t(1215), Tuint16_t(1215), Tuint16_t(1215), Tuint16_t(1215), Tuint16_t(1215), Tuint16_t(1215),
	Tuint16_t(1215), Tuint16_t(1215), Tuint16_t(1215), Tuint16_t(1215), Tuint16_t(1215), Tuint16_t(1215), Tuint16_t(1215), Tuint16_t(1215), Tuint16_t(1215), Tuint16_t(1215), Tuint16_t(1215), Tuint16_t(163), Tuint16_t(163), Tuint16_t(1216), Tuint16_t(1216), Tuint16_t(1216),
	Tuint16_t(1217), Tuint16_t(1217), Tuint16_t(1216), Tuint16_t(1216), Tuint16_t(1216), Tuint16_t(1216), Tuint16_t(1218), Tuint16_t(1216), Tuint16_t(1216), Tuint16_t(1216), Tuint16_t(1216), Tuint16_t(1219), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1220), Tuint16_t(1220), Tuint16_t(1220), Tuint16_t(1220), Tuint16_t(1220), Tuint16_t(1220), Tuint16_t(1220), Tuint16_t(1220), Tuint16_t(1220), Tuint16_t(1220), Tuint16_t(1221), Tuint16_t(1221), Tuint16_t(1222), Tuint16_t(1222), Tuint16_t(1222), Tuint16_t(1223),
	Tuint16_t(1215), Tuint16_t(1215), Tuint16_t(1215), Tuint16_t(1215), Tuint16_t(1215), Tuint16_t(1215), Tuint16_t(1215), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 186
	Tuint16_t(1224), Tuint16_t(1224), Tuint16_t(1224), Tuint16_t(1224), Tuint16_t(1224), Tuint16_t(1224), Tuint16_t(1224), Tuint16_t(1224), Tuint16_t(1224), Tuint16_t(1224), Tuint16_t(1224), Tuint16_t(1224), Tuint16_t(1224), Tuint16_t(1224), Tuint16_t(1224), Tuint16_t(1224),
	Tuint16_t(1224), Tuint16_t(1224), Tuint16_t(1224), Tuint16_t(1224), Tuint16_t(1224), Tuint16_t(1224), Tuint16_t(1224), Tuint16_t(1224), Tuint16_t(1224), Tuint16_t(1224), Tuint16_t(1224), Tuint16_t(1224), Tuint16_t(1224), Tuint16_t(1224), Tuint16_t(1224), Tuint16_t(1224),
	Tuint16_t(1224), Tuint16_t(1224), Tuint16_t(1224), Tuint16_t(1224), Tuint16_t(1224), Tuint16_t(1224), Tuint16_t(1224), Tuint16_t(1224), Tuint16_t(1224), Tuint16_t(1224), Tuint16_t(1224), Tuint16_t(1224), Tuint16_t(1225), Tuint16_t(1225), Tuint16_t(1225), Tuint16_t(1226),
	Tuint16_t(1226), Tuint16_t(1226), Tuint16_t(1226), Tuint16_t(1226), Tuint16_t(1226), Tuint16_t(1226), Tuint16_t(1226), Tuint16_t(1226), Tuint16_t(1225), Tuint16_t(1227), Tuint16_t(1228), Tuint16_t(1229), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 187
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1230), Tuint16_t(1230), Tuint16_t(1230), Tuint16_t(1230), Tuint16_t(1230), Tuint16_t(1230), Tuint16_t(1230), Tuint16_t(1230), Tuint16_t(1230), Tuint16_t(1230), Tuint16_t(1230), Tuint16_t(1230), Tuint16_t(1230), Tuint16_t(1230), Tuint16_t(1230), Tuint16_t(1230),
	Tuint16_t(1230), Tuint16_t(1230), Tuint16_t(1230), Tuint16_t(1230), Tuint16_t(1230), Tuint16_t(1230), Tuint16_t(1230), Tuint16_t(1230), Tuint16_t(1230), Tuint16_t(1230), Tuint16_t(1230), Tuint16_t(1230), Tuint16_t(1230), Tuint16_t(1230), Tuint16_t(1230), Tuint16_t(1230),
	Tuint16_t(1231), Tuint16_t(1231), Tuint16_t(1231), Tuint16_t(1231), Tuint16_t(1231), Tuint16_t(1231), Tuint16_t(1231), Tuint16_t(1231), Tuint16_t(1231), Tuint16_t(1231), Tuint16_t(1231), Tuint16_t(1231), Tuint16_t(1231), Tuint16_t(1231), Tuint16_t(1231), Tuint16_t(1231),
	Tuint16_t(1231), Tuint16_t(1231), Tuint16_t(1231), Tuint16_t(1231), Tuint16_t(1231), Tuint16_t(1231), Tuint16_t(1231), Tuint16_t(1231), Tuint16_t(1231), Tuint16_t(1231), Tuint16_t(1231), Tuint16_t(1231), Tuint16_t(1231), Tuint16_t(1231), Tuint16_t(1231), Tuint16_t(1231),
	Tuint16_t(1232), Tuint16_t(1232), Tuint16_t(1232), Tuint16_t(1232), Tuint16_t(1232), Tuint16_t(1232), Tuint16_t(1232), Tuint16_t(1232), Tuint16_t(1232), Tuint16_t(1232), Tuint16_t(1233), Tuint16_t(1233), Tuint16_t(1233), Tuint16_t(1233), Tuint16_t(1233), Tuint16_t(1233),
	Tuint16_t(1233), Tuint16_t(1233), Tuint16_t(1233), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(1234),

	// block 188
	Tuint16_t(1235), Tuint16_t(1235), Tuint16_t(1235), Tuint16_t(1235), Tuint16_t(1235), Tuint16_t(1235), Tuint16_t(1235), Tuint16_t(163), Tuint16_t(163), Tuint16_t(1235), Tuint16_t(163), Tuint16_t(163), Tuint16_t(1235), Tuint16_t(1235), Tuint16_t(1235), Tuint16_t(1235),
	Tuint16_t(1235), Tuint16_t(1235), Tuint16_t(1235), Tuint16_t(1235), Tuint16_t(163), Tuint16_t(1235), Tuint16_t(1235), Tuint16_t(163), Tuint16_t(1235), Tuint16_t(1235), Tuint16_t(1235), Tuint16_t(1235), Tuint16_t(1235), Tuint16_t(1235), Tuint16_t(1235), Tuint16_t(1235),
	Tuint16_t(1235), Tuint16_t(1235), Tuint16_t(1235), Tuint16_t(1235), Tuint16_t(1235), Tuint16_t(1235), Tuint16_t(1235), Tuint16_t(1235), Tuint16_t(1235), Tuint16_t(1235), Tuint16_t(1235), Tuint16_t(1235), Tuint16_t(1235), Tuint16_t(1235), Tuint16_t(1235), Tuint16_t(1235),
	Tuint16_t(1236), Tuint16_t(1237), Tuint16_t(1237), Tuint16_t(1237), Tuint16_t(1237), Tuint16_t(1237), Tuint16_t(163), Tuint16_t(1237), Tuint16_t(1237), Tuint16_t(163), Tuint16_t(163), Tuint16_t(1238), Tuint16_t(1238), Tuint16_t(1239), Tuint16_t(1240), Tuint16_t(1241),
	Tuint16_t(1237), Tuint16_t(1241), Tuint16_t(1237), Tuint16_t(1242), Tuint16_t(1243), Tuint16_t(1244), Tuint16_t(1243), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1245), Tuint16_t(1245), Tuint16_t(1245), Tuint16_t(1245), Tuint16_t(1245), Tuint16_t(1245), Tuint16_t(1245), Tuint16_t(1245), Tuint16_t(1245), Tuint16_t(1245), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 189
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1246), Tuint16_t(1246), Tuint16_t(1246), Tuint16_t(1246), Tuint16_t(1246), Tuint16_t(1246), Tuint16_t(1246), Tuint16_t(1246), Tuint16_t(163), Tuint16_t(163), Tuint16_t(1246), Tuint16_t(1246), Tuint16_t(1246), Tuint16_t(1246), Tuint16_t(1246), Tuint16_t(1246),
	Tuint16_t(1246), Tuint16_t(1246), Tuint16_t(1246), Tuint16_t(1246), Tuint16_t(1246), Tuint16_t(1246), Tuint16_t(1246), Tuint16_t(1246), Tuint16_t(1246), Tuint16_t(1246), Tuint16_t(1246), Tuint16_t(1246), Tuint16_t(1246), Tuint16_t(1246), Tuint16_t(1246), Tuint16_t(1246),
	Tuint16_t(1246), Tuint16_t(1246), Tuint16_t(1246), Tuint16_t(1246), Tuint16_t(1246), Tuint16_t(1246), Tuint16_t(1246), Tuint16_t(1246), Tuint16_t(1246), Tuint16_t(1246), Tuint16_t(1246), Tuint16_t(1246), Tuint16_t(1246), Tuint16_t(1246), Tuint16_t(1246), Tuint16_t(1246),
	Tuint16_t(1246), Tuint16_t(1247), Tuint16_t(1247), Tuint16_t(1247), Tuint16_t(1248), Tuint16_t(1248), Tuint16_t(1248), Tuint16_t(1248), Tuint16_t(163), Tuint16_t(163), Tuint16_t(1248), Tuint16_t(1248), Tuint16_t(1247), Tuint16_t(1247), Tuint16_t(1247), Tuint16_t(1247),
	Tuint16_t(1249), Tuint16_t(1246), Tuint16_t(1250), Tuint16_t(1246), Tuint16_t(1247), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 190
	Tuint16_t(1251), Tuint16_t(1252), Tuint16_t(1252), Tuint16_t(1252), Tuint16_t(1252), Tuint16_t(1252), Tuint16_t(1252), Tuint16_t(1253), Tuint16_t(1253), Tuint16_t(1252), Tuint16_t(1252), Tuint16_t(1251), Tuint16_t(1251), Tuint16_t(1251), Tuint16_t(1251), Tuint16_t(1251),
	Tuint16_t(1251), Tuint16_t(1251), Tuint16_t(1251), Tuint16_t(1251), Tuint16_t(1251), Tuint16_t(1251), Tuint16_t(1251), Tuint16_t(1251), Tuint16_t(1251), Tuint16_t(1251), Tuint16_t(1251), Tuint16_t(1251), Tuint16_t(1251), Tuint16_t(1251), Tuint16_t(1251), Tuint16_t(1251),
	Tuint16_t(1251), Tuint16_t(1251), Tuint16_t(1251), Tuint16_t(1251), Tuint16_t(1251), Tuint16_t(1251), Tuint16_t(1251), Tuint16_t(1251), Tuint16_t(1251), Tuint16_t(1251), Tuint16_t(1251), Tuint16_t(1251), Tuint16_t(1251), Tuint16_t(1251), Tuint16_t(1251), Tuint16_t(1251),
	Tuint16_t(1251), Tuint16_t(1251), Tuint16_t(1251), Tuint16_t(1254), Tuint16_t(1255), Tuint16_t(1252), Tuint16_t(1252), Tuint16_t(1252), Tuint16_t(1252), Tuint16_t(1256), Tuint16_t(1257), Tuint16_t(1252), Tuint16_t(1252), Tuint16_t(1252), Tuint16_t(1252), Tuint16_t(1258),
	Tuint16_t(1258), Tuint16_t(1258), Tuint16_t(1259), Tuint16_t(1259), Tuint16_t(1258), Tuint16_t(1258), Tuint16_t(1258), Tuint16_t(1255), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1260), Tuint16_t(1261), Tuint16_t(1261), Tuint16_t(1261), Tuint16_t(1261), Tuint16_t(1261), Tuint16_t(1261), Tuint16_t(1262), Tuint16_t(1262), Tuint16_t(1261), Tuint16_t(1261), Tuint16_t(1261), Tuint16_t(1260), Tuint16_t(1260), Tuint16_t(1260), Tuint16_t(1260),
	Tuint16_t(1260), Tuint16_t(1260), Tuint16_t(1260), Tuint16_t(1260), Tuint16_t(1260), Tuint16_t(1260), Tuint16_t(1260), Tuint16_t(1260), Tuint16_t(1260), Tuint16_t(1260), Tuint16_t(1260), Tuint16_t(1260), Tuint16_t(1260), Tuint16_t(1260), Tuint16_t(1260), Tuint16_t(1260),
	Tuint16_t(1260), Tuint16_t(1260), Tuint16_t(1260), Tuint16_t(1260), Tuint16_t(1260), Tuint16_t(1260), Tuint16_t(1260), Tuint16_t(1260), Tuint16_t(1260), Tuint16_t(1260), Tuint16_t(1260), Tuint16_t(1260), Tuint16_t(1260), Tuint16_t(1260), Tuint16_t(1260), Tuint16_t(1260),

	// block 191
	Tuint16_t(1260), Tuint16_t(1260), Tuint16_t(1260), Tuint16_t(1260), Tuint16_t(1263), Tuint16_t(1263), Tuint16_t(1263), Tuint16_t(1263), Tuint16_t(1263), Tuint16_t(1263), Tuint16_t(1261), Tuint16_t(1261), Tuint16_t(1261), Tuint16_t(1261), Tuint16_t(1261), Tuint16_t(1261),
	Tuint16_t(1261), Tuint16_t(1261), Tuint16_t(1261), Tuint16_t(1261), Tuint16_t(1261), Tuint16_t(1261), Tuint16_t(1261), Tuint16_t(1262), Tuint16_t(1264), Tuint16_t(1265), Tuint16_t(1266), Tuint16_t(1267), Tuint16_t(1267), Tuint16_t(1260), Tuint16_t(1266), Tuint16_t(1266),
	Tuint16_t(1266), Tuint16_t(1268), Tuint16_t(1268), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495), Tuint16_t(495),
	Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269),
	Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269),
	Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269),
	Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(1269), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 192
	Tuint16_t(1270), Tuint16_t(1270), Tuint16_t(1270), Tuint16_t(1270), Tuint16_t(1270), Tuint16_t(1270), Tuint16_t(1270), Tuint16_t(1270), Tuint16_t(1270), Tuint16_t(163), Tuint16_t(1270), Tuint16_t(1270), Tuint16_t(1270), Tuint16_t(1270), Tuint16_t(1270), Tuint16_t(1270),
	Tuint16_t(1270), Tuint16_t(1270), Tuint16_t(1270), Tuint16_t(1270), Tuint16_t(1270), Tuint16_t(1270), Tuint16_t(1270), Tuint16_t(1270), Tuint16_t(1270), Tuint16_t(1270), Tuint16_t(1270), Tuint16_t(1270), Tuint16_t(1270), Tuint16_t(1270), Tuint16_t(1270), Tuint16_t(1270),
	Tuint16_t(1270), Tuint16_t(1270), Tuint16_t(1270), Tuint16_t(1270), Tuint16_t(1270), Tuint16_t(1270), Tuint16_t(1270), Tuint16_t(1270), Tuint16_t(1270), Tuint16_t(1270), Tuint16_t(1270), Tuint16_t(1270), Tuint16_t(1270), Tuint16_t(1270), Tuint16_t(1270), Tuint16_t(1271),
	Tuint16_t(1272), Tuint16_t(1272), Tuint16_t(1272), Tuint16_t(1272), Tuint16_t(1272), Tuint16_t(1272), Tuint16_t(1272), Tuint16_t(163), Tuint16_t(1272), Tuint16_t(1272), Tuint16_t(1272), Tuint16_t(1272), Tuint16_t(1272), Tuint16_t(1272), Tuint16_t(1271), Tuint16_t(1273),
	Tuint16_t(1270), Tuint16_t(1274), Tuint16_t(1274), Tuint16_t(1275), Tuint16_t(1276), Tuint16_t(1276), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1277), Tuint16_t(1277), Tuint16_t(1277), Tuint16_t(1277), Tuint16_t(1277), Tuint16_t(1277), Tuint16_t(1277), Tuint16_t(1277), Tuint16_t(1277), Tuint16_t(1277), Tuint16_t(1278), Tuint16_t(1278), Tuint16_t(1278), Tuint16_t(1278), Tuint16_t(1278), Tuint16_t(1278),
	Tuint16_t(1278), Tuint16_t(1278), Tuint16_t(1278), Tuint16_t(1278), Tuint16_t(1278), Tuint16_t(1278), Tuint16_t(1278), Tuint16_t(1278), Tuint16_t(1278), Tuint16_t(1278), Tuint16_t(1278), Tuint16_t(1278), Tuint16_t(1278), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1279), Tuint16_t(1280), Tuint16_t(1281), Tuint16_t(1281), Tuint16_t(1281), Tuint16_t(1281), Tuint16_t(1281), Tuint16_t(1281), Tuint16_t(1281), Tuint16_t(1281), Tuint16_t(1281), Tuint16_t(1281), Tuint16_t(1281), Tuint16_t(1281), Tuint16_t(1281), Tuint16_t(1281),

	// block 193
	Tuint16_t(1281), Tuint16_t(1281), Tuint16_t(1281), Tuint16_t(1281), Tuint16_t(1281), Tuint16_t(1281), Tuint16_t(1281), Tuint16_t(1281), Tuint16_t(1281), Tuint16_t(1281), Tuint16_t(1281), Tuint16_t(1281), Tuint16_t(1281), Tuint16_t(1281), Tuint16_t(1281), Tuint16_t(1281),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(1282), Tuint16_t(1282), Tuint16_t(1282), Tuint16_t(1282), Tuint16_t(1282), Tuint16_t(1282), Tuint16_t(1282), Tuint16_t(1282), Tuint16_t(1282), Tuint16_t(1282), Tuint16_t(1282), Tuint16_t(1282), Tuint16_t(1282), Tuint16_t(1282),
	Tuint16_t(1282), Tuint16_t(1282), Tuint16_t(1282), Tuint16_t(1282), Tuint16_t(1282), Tuint16_t(1282), Tuint16_t(1282), Tuint16_t(1282), Tuint16_t(163), Tuint16_t(1283), Tuint16_t(1282), Tuint16_t(1282), Tuint16_t(1282), Tuint16_t(1282), Tuint16_t(1282), Tuint16_t(1282),
	Tuint16_t(1282), Tuint16_t(1283), Tuint16_t(1282), Tuint16_t(1282), Tuint16_t(1283), Tuint16_t(1282), Tuint16_t(1282), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 194
	Tuint16_t(1284), Tuint16_t(1284), Tuint16_t(1284), Tuint16_t(1284), Tuint16_t(1284), Tuint16_t(1284), Tuint16_t(1284), Tuint16_t(163), Tuint16_t(1284), Tuint16_t(1284), Tuint16_t(163), Tuint16_t(1284), Tuint16_t(1284), Tuint16_t(1284), Tuint16_t(1284), Tuint16_t(1284),
	Tuint16_t(1284), Tuint16_t(1284), Tuint16_t(1284), Tuint16_t(1284), Tuint16_t(1284), Tuint16_t(1284), Tuint16_t(1284), Tuint16_t(1284), Tuint16_t(1284), Tuint16_t(1284), Tuint16_t(1284), Tuint16_t(1284), Tuint16_t(1284), Tuint16_t(1284), Tuint16_t(1284), Tuint16_t(1284),
	Tuint16_t(1284), Tuint16_t(1284), Tuint16_t(1284), Tuint16_t(1284), Tuint16_t(1284), Tuint16_t(1284), Tuint16_t(1284), Tuint16_t(1284), Tuint16_t(1284), Tuint16_t(1284), Tuint16_t(1284), Tuint16_t(1284), Tuint16_t(1284), Tuint16_t(1284), Tuint16_t(1284), Tuint16_t(1284),
	Tuint16_t(1284), Tuint16_t(1285), Tuint16_t(1285), Tuint16_t(1285), Tuint16_t(1285), Tuint16_t(1285), Tuint16_t(1285), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(1285), Tuint16_t(163), Tuint16_t(1285), Tuint16_t(1285), Tuint16_t(163), Tuint16_t(1285),
	Tuint16_t(1285), Tuint16_t(1285), Tuint16_t(1286), Tuint16_t(1285), Tuint16_t(1287), Tuint16_t(1287), Tuint16_t(1288), Tuint16_t(1285), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1289), Tuint16_t(1289), Tuint16_t(1289), Tuint16_t(1289), Tuint16_t(1289), Tuint16_t(1289), Tuint16_t(1289), Tuint16_t(1289), Tuint16_t(1289), Tuint16_t(1289), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1290), Tuint16_t(1290), Tuint16_t(1290), Tuint16_t(1290), Tuint16_t(1290), Tuint16_t(1290), Tuint16_t(163), Tuint16_t(1290), Tuint16_t(1290), Tuint16_t(163), Tuint16_t(1290), Tuint16_t(1290), Tuint16_t(1290), Tuint16_t(1290), Tuint16_t(1290), Tuint16_t(1290),
	Tuint16_t(1290), Tuint16_t(1290), Tuint16_t(1290), Tuint16_t(1290), Tuint16_t(1290), Tuint16_t(1290), Tuint16_t(1290), Tuint16_t(1290), Tuint16_t(1290), Tuint16_t(1290), Tuint16_t(1290), Tuint16_t(1290), Tuint16_t(1290), Tuint16_t(1290), Tuint16_t(1290), Tuint16_t(1290),

	// block 195
	Tuint16_t(1290), Tuint16_t(1290), Tuint16_t(1290), Tuint16_t(1290), Tuint16_t(1290), Tuint16_t(1290), Tuint16_t(1290), Tuint16_t(1290), Tuint16_t(1290), Tuint16_t(1290), Tuint16_t(1291), Tuint16_t(1291), Tuint16_t(1291), Tuint16_t(1291), Tuint16_t(1291), Tuint16_t(163),
	Tuint16_t(1292), Tuint16_t(1292), Tuint16_t(163), Tuint16_t(1291), Tuint16_t(1291), Tuint16_t(1292), Tuint16_t(1291), Tuint16_t(1293), Tuint16_t(1290), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1294), Tuint16_t(1294), Tuint16_t(1294), Tuint16_t(1294), Tuint16_t(1294), Tuint16_t(1294), Tuint16_t(1294), Tuint16_t(1294), Tuint16_t(1294), Tuint16_t(1294), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 196
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1295), Tuint16_t(1295), Tuint16_t(1295), Tuint16_t(1295), Tuint16_t(1295), Tuint16_t(1295), Tuint16_t(1295), Tuint16_t(1295), Tuint16_t(1295), Tuint16_t(1295), Tuint16_t(1295), Tuint16_t(1295), Tuint16_t(1295), Tuint16_t(1295), Tuint16_t(1295), Tuint16_t(1295),
	Tuint16_t(1295), Tuint16_t(1295), Tuint16_t(1295), Tuint16_t(1296), Tuint16_t(1296), Tuint16_t(1297), Tuint16_t(1297), Tuint16_t(1298), Tuint16_t(1298), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 197
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(842), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1299), Tuint16_t(1299), Tuint16_t(1299), Tuint16_t(1299), Tuint16_t(1299), Tuint16_t(1299), Tuint16_t(1299), Tuint16_t(1299), Tuint16_t(1299), Tuint16_t(1299), Tuint16_t(1299), Tuint16_t(1299), Tuint16_t(1299), Tuint16_t(1299), Tuint16_t(1299), Tuint16_t(1299),
	Tuint16_t(388), Tuint16_t(388), Tuint16_t(1299), Tuint16_t(388), Tuint16_t(1299), Tuint16_t(390), Tuint16_t(390), Tuint16_t(390), Tuint16_t(390), Tuint16_t(390), Tuint16_t(390), Tuint16_t(390), Tuint16_t(390), Tuint16_t(391), Tuint16_t(391), Tuint16_t(391),
	Tuint16_t(391), Tuint16_t(390), Tuint16_t(390), Tuint16_t(390), Tuint16_t(390), Tuint16_t(390), Tuint16_t(390), Tuint16_t(390), Tuint16_t(390), Tuint16_t(390), Tuint16_t(390), Tuint16_t(390), Tuint16_t(390), Tuint16_t(390), Tuint16_t(390), Tuint16_t(390),
	Tuint16_t(390), Tuint16_t(390), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(1300),

	// block 198
	Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301),
	Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301),
	Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301),
	Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301),
	Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301),
	Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301),
	Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301),
	Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301),

	// block 199
	Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301),
	Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 200
	Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302),
	Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302),
	Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302),
	Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302),
	Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302),
	Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302),
	Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(1302), Tuint16_t(163),
	Tuint16_t(1303), Tuint16_t(1303), Tuint16_t(1303), Tuint16_t(1303), Tuint16_t(1303), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 201
	Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301),
	Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301),
	Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301),
	Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301),
	Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(1301), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 202
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304),
	Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304),
	Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304),
	Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304),
	Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304),
	Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304), Tuint16_t(1304),
	Tuint16_t(1304), Tuint16_t(1305), Tuint16_t(1305), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 203
	Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306),
	Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306),
	Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306),
	Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306),
	Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306),
	Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306),
	Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306),
	Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306),

	// block 204
	Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306),
	Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306),
	Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(1306), Tuint16_t(163),
	Tuint16_t(1307), Tuint16_t(1307), Tuint16_t(1307), Tuint16_t(1307), Tuint16_t(1307), Tuint16_t(1307), Tuint16_t(1307), Tuint16_t(1307), Tuint16_t(1307), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 205
	Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308),
	Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308),
	Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308),
	Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308),
	Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308),
	Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308),
	Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308),
	Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308),

	// block 206
	Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308),
	Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308),
	Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308),
	Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308),
	Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(1308), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 207
	Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858),
	Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858),
	Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858),
	Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858),
	Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858),
	Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858),
	Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858),
	Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858),

	// block 208
	Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858),
	Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858),
	Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858),
	Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(858), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1309), Tuint16_t(1309), Tuint16_t(1309), Tuint16_t(1309), Tuint16_t(1309), Tuint16_t(1309), Tuint16_t(1309), Tuint16_t(1309), Tuint16_t(1309), Tuint16_t(1309), Tuint16_t(1309), Tuint16_t(1309), Tuint16_t(1309), Tuint16_t(1309), Tuint16_t(1309), Tuint16_t(1309),
	Tuint16_t(1309), Tuint16_t(1309), Tuint16_t(1309), Tuint16_t(1309), Tuint16_t(1309), Tuint16_t(1309), Tuint16_t(1309), Tuint16_t(1309), Tuint16_t(1309), Tuint16_t(1309), Tuint16_t(1309), Tuint16_t(1309), Tuint16_t(1309), Tuint16_t(1309), Tuint16_t(1309), Tuint16_t(163),
	Tuint16_t(1310), Tuint16_t(1310), Tuint16_t(1310), Tuint16_t(1310), Tuint16_t(1310), Tuint16_t(1310), Tuint16_t(1310), Tuint16_t(1310), Tuint16_t(1310), Tuint16_t(1310), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(1311), Tuint16_t(1311),
	Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312),

	// block 209
	Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312),
	Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312),
	Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312),
	Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(1312), Tuint16_t(163),
	Tuint16_t(1313), Tuint16_t(1313), Tuint16_t(1313), Tuint16_t(1313), Tuint16_t(1313), Tuint16_t(1313), Tuint16_t(1313), Tuint16_t(1313), Tuint16_t(1313), Tuint16_t(1313), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1314), Tuint16_t(1314), Tuint16_t(1314), Tuint16_t(1314), Tuint16_t(1314), Tuint16_t(1314), Tuint16_t(1314), Tuint16_t(1314), Tuint16_t(1314), Tuint16_t(1314), Tuint16_t(1314), Tuint16_t(1314), Tuint16_t(1314), Tuint16_t(1314), Tuint16_t(1314), Tuint16_t(1314),
	Tuint16_t(1314), Tuint16_t(1314), Tuint16_t(1314), Tuint16_t(1314), Tuint16_t(1314), Tuint16_t(1314), Tuint16_t(1314), Tuint16_t(1314), Tuint16_t(1314), Tuint16_t(1314), Tuint16_t(1314), Tuint16_t(1314), Tuint16_t(1314), Tuint16_t(1314), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1315), Tuint16_t(1315), Tuint16_t(1315), Tuint16_t(1315), Tuint16_t(1315), Tuint16_t(1316), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 210
	Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317),
	Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317),
	Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317),
	Tuint16_t(1318), Tuint16_t(1318), Tuint16_t(1318), Tuint16_t(1318), Tuint16_t(1318), Tuint16_t(1318), Tuint16_t(1318), Tuint16_t(1319), Tuint16_t(1319), Tuint16_t(1320), Tuint16_t(1321), Tuint16_t(1321), Tuint16_t(1322), Tuint16_t(1322), Tuint16_t(1322), Tuint16_t(1322),
	Tuint16_t(1323), Tuint16_t(1323), Tuint16_t(1324), Tuint16_t(1324), Tuint16_t(1319), Tuint16_t(1322), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1325), Tuint16_t(1325), Tuint16_t(1325), Tuint16_t(1325), Tuint16_t(1325), Tuint16_t(1325), Tuint16_t(1325), Tuint16_t(1325), Tuint16_t(1325), Tuint16_t(1325), Tuint16_t(163), Tuint16_t(1326), Tuint16_t(1326), Tuint16_t(1326), Tuint16_t(1326), Tuint16_t(1326),
	Tuint16_t(1326), Tuint16_t(1326), Tuint16_t(163), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317),
	Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317),

	// block 211
	Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317), Tuint16_t(1317),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 212
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1327), Tuint16_t(1327), Tuint16_t(1327), Tuint16_t(1327), Tuint16_t(1327), Tuint16_t(1327), Tuint16_t(1327), Tuint16_t(1327), Tuint16_t(1327), Tuint16_t(1327), Tuint16_t(1327), Tuint16_t(1327), Tuint16_t(1327), Tuint16_t(1327), Tuint16_t(1327), Tuint16_t(1327),
	Tuint16_t(1327), Tuint16_t(1327), Tuint16_t(1327), Tuint16_t(1327), Tuint16_t(1327), Tuint16_t(1327), Tuint16_t(1327), Tuint16_t(1327), Tuint16_t(1327), Tuint16_t(1327), Tuint16_t(1327), Tuint16_t(1327), Tuint16_t(1327), Tuint16_t(1327), Tuint16_t(1327), Tuint16_t(1327),
	Tuint16_t(1328), Tuint16_t(1328), Tuint16_t(1328), Tuint16_t(1328), Tuint16_t(1328), Tuint16_t(1328), Tuint16_t(1328), Tuint16_t(1328), Tuint16_t(1328), Tuint16_t(1328), Tuint16_t(1328), Tuint16_t(1328), Tuint16_t(1328), Tuint16_t(1328), Tuint16_t(1328), Tuint16_t(1328),
	Tuint16_t(1328), Tuint16_t(1328), Tuint16_t(1328), Tuint16_t(1328), Tuint16_t(1328), Tuint16_t(1328), Tuint16_t(1328), Tuint16_t(1328), Tuint16_t(1328), Tuint16_t(1328), Tuint16_t(1328), Tuint16_t(1328), Tuint16_t(1328), Tuint16_t(1328), Tuint16_t(1328), Tuint16_t(1328),

	// block 213
	Tuint16_t(1329), Tuint16_t(1329), Tuint16_t(1329), Tuint16_t(1329), Tuint16_t(1329), Tuint16_t(1329), Tuint16_t(1329), Tuint16_t(1329), Tuint16_t(1329), Tuint16_t(1329), Tuint16_t(1329), Tuint16_t(1329), Tuint16_t(1329), Tuint16_t(1329), Tuint16_t(1329), Tuint16_t(1329),
	Tuint16_t(1329), Tuint16_t(1329), Tuint16_t(1329), Tuint16_t(1329), Tuint16_t(1329), Tuint16_t(1329), Tuint16_t(1329), Tuint16_t(1330), Tuint16_t(1331), Tuint16_t(1332), Tuint16_t(1332), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 214
	Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333),
	Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333),
	Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333),
	Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333),
	Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(1333), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(1334),
	Tuint16_t(1333), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335),
	Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335),
	Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335),

	// block 215
	Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(1335), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(1336),
	Tuint16_t(1336), Tuint16_t(1336), Tuint16_t(1336), Tuint16_t(1337), Tuint16_t(1337), Tuint16_t(1337), Tuint16_t(1337), Tuint16_t(1337), Tuint16_t(1337), Tuint16_t(1337), Tuint16_t(1337), Tuint16_t(1337), Tuint16_t(1337), Tuint16_t(1337), Tuint16_t(1337), Tuint16_t(1337),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1338), Tuint16_t(1339), Tuint16_t(1340), Tuint16_t(799), Tuint16_t(1341), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1342), Tuint16_t(1342), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 216
	Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343),
	Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343),
	Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343),
	Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343),
	Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343),
	Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343),
	Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343),
	Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343),

	// block 217
	Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343),
	Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343),
	Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343),
	Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343),
	Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343),
	Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343),
	Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343),
	Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 218
	Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344),
	Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344),
	Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344),
	Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344),
	Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344),
	Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344),
	Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344),
	Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344),

	// block 219
	Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344),
	Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344),
	Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344),
	Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344),
	Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344),
	Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(1344), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 220
	Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(1343), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 221
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1345), Tuint16_t(1345), Tuint16_t(1345), Tuint16_t(1345), Tuint16_t(163), Tuint16_t(1345), Tuint16_t(1345), Tuint16_t(1345), Tuint16_t(1345), Tuint16_t(1345), Tuint16_t(1345), Tuint16_t(1345), Tuint16_t(163), Tuint16_t(1345), Tuint16_t(1345), Tuint16_t(163),

	// block 222
	Tuint16_t(824), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819),
	Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819),
	Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819),
	Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819),
	Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819),
	Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819),
	Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819),
	Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819),

	// block 223
	Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819),
	Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819),
	Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819),
	Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819),
	Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819),
	Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819),
	Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819),
	Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819),

	// block 224
	Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819),
	Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(819),
	Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(819), Tuint16_t(819), Tuint16_t(819), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(824), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346),

	// block 225
	Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346),
	Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346),
	Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346),
	Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346),
	Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346),
	Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346),
	Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346),
	Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346),

	// block 226
	Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346),
	Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346),
	Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346),
	Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346),
	Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346),
	Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346),
	Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346),
	Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(1346), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 227
	Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347),
	Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347),
	Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347),
	Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347),
	Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347),
	Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347),
	Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 228
	Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(1347), Tuint16_t(163), Tuint16_t(163), Tuint16_t(1348), Tuint16_t(1349), Tuint16_t(1350), Tuint16_t(1351),
	Tuint16_t(1352), Tuint16_t(1352), Tuint16_t(1352), Tuint16_t(1352), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 229
	Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154),
	Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154),
	Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154),
	Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),

	// block 230
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 231
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),

	// block 232
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 233
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(163), Tuint16_t(163), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(1353), Tuint16_t(1354), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(1355), Tuint16_t(1356), Tuint16_t(1356),
	Tuint16_t(1356), Tuint16_t(1356), Tuint16_t(1356), Tuint16_t(51), Tuint16_t(51), Tuint16_t(51), Tuint16_t(51), Tuint16_t(51), Tuint16_t(51), Tuint16_t(51), Tuint16_t(51), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154),

	// block 234
	Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(460), Tuint16_t(460), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(154), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(723), Tuint16_t(723), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 235
	Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002),
	Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002),
	Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002),
	Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1002),
	Tuint16_t(1002), Tuint16_t(1002), Tuint16_t(1357), Tuint16_t(1357), Tuint16_t(1357), Tuint16_t(1002), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 236
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(835), Tuint16_t(835), Tuint16_t(835), Tuint16_t(835), Tuint16_t(835), Tuint16_t(835), Tuint16_t(835), Tuint16_t(835), Tuint16_t(835), Tuint16_t(835), Tuint16_t(835), Tuint16_t(835), Tuint16_t(835), Tuint16_t(835), Tuint16_t(835), Tuint16_t(835),
	Tuint16_t(835), Tuint16_t(835), Tuint16_t(835), Tuint16_t(835), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 237
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(832), Tuint16_t(832), Tuint16_t(832), Tuint16_t(832), Tuint16_t(832), Tuint16_t(832), Tuint16_t(832), Tuint16_t(832), Tuint16_t(832), Tuint16_t(832), Tuint16_t(832), Tuint16_t(832), Tuint16_t(832), Tuint16_t(832), Tuint16_t(832), Tuint16_t(832),
	Tuint16_t(832), Tuint16_t(832), Tuint16_t(835), Tuint16_t(835), Tuint16_t(835), Tuint16_t(835), Tuint16_t(835), Tuint16_t(835), Tuint16_t(835), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 238
	Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724),
	Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725),
	Tuint16_t(725), Tuint16_t(725), Tuint16_t(736), Tuint16_t(736), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725),
	Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724),
	Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(725), Tuint16_t(725),
	Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(163), Tuint16_t(736), Tuint16_t(736), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725),
	Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724),
	Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724),

	// block 239
	Tuint16_t(724), Tuint16_t(724), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(736), Tuint16_t(736), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725),
	Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(724), Tuint16_t(163), Tuint16_t(724), Tuint16_t(724),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(724), Tuint16_t(163), Tuint16_t(163), Tuint16_t(724), Tuint16_t(724), Tuint16_t(163), Tuint16_t(163), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(163), Tuint16_t(724), Tuint16_t(724),
	Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(163), Tuint16_t(725), Tuint16_t(163), Tuint16_t(725), Tuint16_t(736), Tuint16_t(736),
	Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(163), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725),
	Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724),
	Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725),
	Tuint16_t(725), Tuint16_t(725), Tuint16_t(736), Tuint16_t(736), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725),

	// block 240
	Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(724), Tuint16_t(724), Tuint16_t(163), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(163), Tuint16_t(163), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724),
	Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(163), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(163), Tuint16_t(725), Tuint16_t(725),
	Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(736), Tuint16_t(736), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725),
	Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(724), Tuint16_t(724), Tuint16_t(163), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(163),
	Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(163), Tuint16_t(724), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724),
	Tuint16_t(724), Tuint16_t(163), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(736), Tuint16_t(736), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725),
	Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724),
	Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724),

	// block 241
	Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(736), Tuint16_t(736),
	Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725),
	Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724),
	Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725),
	Tuint16_t(725), Tuint16_t(725), Tuint16_t(736), Tuint16_t(736), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725),
	Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724),
	Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(725), Tuint16_t(725),
	Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(736), Tuint16_t(736), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725),

	// block 242
	Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724),
	Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724),
	Tuint16_t(724), Tuint16_t(724), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(736), Tuint16_t(736), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725),
	Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724),
	Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724),
	Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(736), Tuint16_t(736),
	Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725),
	Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724),

	// block 243
	Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725),
	Tuint16_t(725), Tuint16_t(725), Tuint16_t(736), Tuint16_t(736), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725),
	Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(163), Tuint16_t(163), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724),
	Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724),
	Tuint16_t(724), Tuint16_t(1358), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725),
	Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(715), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725),
	Tuint16_t(725), Tuint16_t(725), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724),
	Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(1358), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725),

	// block 244
	Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725),
	Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(715), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724),
	Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724),
	Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(1358), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725),
	Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(715),
	Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724),
	Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(1358),
	Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725),

	// block 245
	Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(715), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725),
	Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724),
	Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(724), Tuint16_t(1358), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725),
	Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725),
	Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(715), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(725), Tuint16_t(724), Tuint16_t(725), Tuint16_t(163), Tuint16_t(163), Tuint16_t(1359), Tuint16_t(1359),
	Tuint16_t(1359), Tuint16_t(1359), Tuint16_t(1359), Tuint16_t(1359), Tuint16_t(1359), Tuint16_t(1359), Tuint16_t(1359), Tuint16_t(1359), Tuint16_t(1359), Tuint16_t(1359), Tuint16_t(1359), Tuint16_t(1359), Tuint16_t(1359), Tuint16_t(1359), Tuint16_t(1359), Tuint16_t(1359),
	Tuint16_t(1359), Tuint16_t(1359), Tuint16_t(1359), Tuint16_t(1359), Tuint16_t(1359), Tuint16_t(1359), Tuint16_t(1359), Tuint16_t(1359), Tuint16_t(1359), Tuint16_t(1359), Tuint16_t(1359), Tuint16_t(1359), Tuint16_t(1359), Tuint16_t(1359), Tuint16_t(1359), Tuint16_t(1359),
	Tuint16_t(1359), Tuint16_t(1359), Tuint16_t(1359), Tuint16_t(1359), Tuint16_t(1359), Tuint16_t(1359), Tuint16_t(1359), Tuint16_t(1359), Tuint16_t(1359), Tuint16_t(1359), Tuint16_t(1359), Tuint16_t(1359), Tuint16_t(1359), Tuint16_t(1359), Tuint16_t(1359), Tuint16_t(1359),

	// block 246
	Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360),
	Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360),
	Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360),
	Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360),
	Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360),
	Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360),
	Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360),
	Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360),

	// block 247
	Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361),
	Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361),
	Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361),
	Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361),
	Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361),
	Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361),
	Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360),
	Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1361), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360),

	// block 248
	Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1361), Tuint16_t(1360), Tuint16_t(1360), Tuint16_t(1362), Tuint16_t(1363), Tuint16_t(1362), Tuint16_t(1362), Tuint16_t(1364), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361),
	Tuint16_t(163), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361), Tuint16_t(1361),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 249
	Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(92), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70),
	Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(643), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(70), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 250
	Tuint16_t(1365), Tuint16_t(1365), Tuint16_t(1365), Tuint16_t(1365), Tuint16_t(1365), Tuint16_t(1365), Tuint16_t(1365), Tuint16_t(163), Tuint16_t(1365), Tuint16_t(1365), Tuint16_t(1365), Tuint16_t(1365), Tuint16_t(1365), Tuint16_t(1365), Tuint16_t(1365), Tuint16_t(1365),
	Tuint16_t(1365), Tuint16_t(1365), Tuint16_t(1365), Tuint16_t(1365), Tuint16_t(1365), Tuint16_t(1365), Tuint16_t(1365), Tuint16_t(1365), Tuint16_t(1365), Tuint16_t(163), Tuint16_t(163), Tuint16_t(1365), Tuint16_t(1365), Tuint16_t(1365), Tuint16_t(1365), Tuint16_t(1365),
	Tuint16_t(1365), Tuint16_t(1365), Tuint16_t(163), Tuint16_t(1365), Tuint16_t(1365), Tuint16_t(163), Tuint16_t(1365), Tuint16_t(1365), Tuint16_t(1365), Tuint16_t(1365), Tuint16_t(1365), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 251
	Tuint16_t(1366), Tuint16_t(1366), Tuint16_t(1366), Tuint16_t(1366), Tuint16_t(1366), Tuint16_t(1366), Tuint16_t(1366), Tuint16_t(1366), Tuint16_t(1366), Tuint16_t(1366), Tuint16_t(1366), Tuint16_t(1366), Tuint16_t(1366), Tuint16_t(1366), Tuint16_t(1366), Tuint16_t(1366),
	Tuint16_t(1366), Tuint16_t(1366), Tuint16_t(1366), Tuint16_t(1366), Tuint16_t(1366), Tuint16_t(1366), Tuint16_t(1366), Tuint16_t(1366), Tuint16_t(1366), Tuint16_t(1366), Tuint16_t(1366), Tuint16_t(1366), Tuint16_t(1366), Tuint16_t(1366), Tuint16_t(1366), Tuint16_t(1366),
	Tuint16_t(1366), Tuint16_t(1366), Tuint16_t(1366), Tuint16_t(1366), Tuint16_t(1366), Tuint16_t(1366), Tuint16_t(1366), Tuint16_t(1366), Tuint16_t(1366), Tuint16_t(1366), Tuint16_t(1366), Tuint16_t(1366), Tuint16_t(1366), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1367), Tuint16_t(1367), Tuint16_t(1367), Tuint16_t(1367), Tuint16_t(1367), Tuint16_t(1367), Tuint16_t(1367), Tuint16_t(1368), Tuint16_t(1368), Tuint16_t(1368), Tuint16_t(1368), Tuint16_t(1368), Tuint16_t(1369), Tuint16_t(1369), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1370), Tuint16_t(1370), Tuint16_t(1370), Tuint16_t(1370), Tuint16_t(1370), Tuint16_t(1370), Tuint16_t(1370), Tuint16_t(1370), Tuint16_t(1370), Tuint16_t(1370), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(1366), Tuint16_t(1371),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 252
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1372), Tuint16_t(1372), Tuint16_t(1372), Tuint16_t(1372), Tuint16_t(1372), Tuint16_t(1372), Tuint16_t(1372), Tuint16_t(1372), Tuint16_t(1372), Tuint16_t(1372), Tuint16_t(1372), Tuint16_t(1372), Tuint16_t(1372), Tuint16_t(1372), Tuint16_t(1372), Tuint16_t(1372),
	Tuint16_t(1372), Tuint16_t(1372), Tuint16_t(1372), Tuint16_t(1372), Tuint16_t(1372), Tuint16_t(1372), Tuint16_t(1372), Tuint16_t(1372), Tuint16_t(1372), Tuint16_t(1372), Tuint16_t(1372), Tuint16_t(1372), Tuint16_t(1372), Tuint16_t(1372), Tuint16_t(1373), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1374), Tuint16_t(1374), Tuint16_t(1374), Tuint16_t(1374), Tuint16_t(1374), Tuint16_t(1374), Tuint16_t(1374), Tuint16_t(1374), Tuint16_t(1374), Tuint16_t(1374), Tuint16_t(1374), Tuint16_t(1374), Tuint16_t(1374), Tuint16_t(1374), Tuint16_t(1374), Tuint16_t(1374),
	Tuint16_t(1374), Tuint16_t(1374), Tuint16_t(1374), Tuint16_t(1374), Tuint16_t(1374), Tuint16_t(1374), Tuint16_t(1374), Tuint16_t(1374), Tuint16_t(1374), Tuint16_t(1374), Tuint16_t(1374), Tuint16_t(1374), Tuint16_t(1374), Tuint16_t(1374), Tuint16_t(1374), Tuint16_t(1374),
	Tuint16_t(1374), Tuint16_t(1374), Tuint16_t(1374), Tuint16_t(1374), Tuint16_t(1374), Tuint16_t(1374), Tuint16_t(1374), Tuint16_t(1374), Tuint16_t(1374), Tuint16_t(1374), Tuint16_t(1374), Tuint16_t(1374), Tuint16_t(1375), Tuint16_t(1375), Tuint16_t(1375), Tuint16_t(1375),
	Tuint16_t(1376), Tuint16_t(1376), Tuint16_t(1376), Tuint16_t(1376), Tuint16_t(1376), Tuint16_t(1376), Tuint16_t(1376), Tuint16_t(1376), Tuint16_t(1376), Tuint16_t(1376), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(1377),

	// block 253
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(163), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(163), Tuint16_t(483), Tuint16_t(483), Tuint16_t(163),
	Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(483), Tuint16_t(163),

	// block 254
	Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378),
	Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378),
	Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378),
	Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378),
	Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378),
	Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378),
	Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378),
	Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378),

	// block 255
	Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378),
	Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378),
	Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378),
	Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378),
	Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(1378), Tuint16_t(262), Tuint16_t(262), Tuint16_t(1379), Tuint16_t(1379), Tuint16_t(1379), Tuint16_t(1379), Tuint16_t(1379), Tuint16_t(1379), Tuint16_t(1379), Tuint16_t(1379), Tuint16_t(1379),
	Tuint16_t(1380), Tuint16_t(1380), Tuint16_t(1380), Tuint16_t(1380), Tuint16_t(1380), Tuint16_t(1380), Tuint16_t(1380), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),

	// block 256
	Tuint16_t(1381), Tuint16_t(1381), Tuint16_t(1381), Tuint16_t(1381), Tuint16_t(1381), Tuint16_t(1381), Tuint16_t(1381), Tuint16_t(1381), Tuint16_t(1381), Tuint16_t(1381), Tuint16_t(1381), Tuint16_t(1381), Tuint16_t(1381), Tuint16_t(1381), Tuint16_t(1381), Tuint16_t(1381),
	Tuint16_t(1381), Tuint16_t(1381), Tuint16_t(1381), Tuint16_t(1381), Tuint16_t(1381), Tuint16_t(1381), Tuint16_t(1381), Tuint16_t(1381), Tuint16_t(1381), Tuint16_t(1381), Tuint16_t(1381), Tuint16_t(1381), Tuint16_t(1381), Tuint16_t(1381), Tuint16_t(1381), Tuint16_t(1381),
	Tuint16_t(1381), Tuint16_t(1381), Tuint16_t(1382), Tuint16_t(1382), Tuint16_t(1382), Tuint16_t(1382), Tuint16_t(1382), Tuint16_t(1382), Tuint16_t(1382), Tuint16_t(1382), Tuint16_t(1382), Tuint16_t(1382), Tuint16_t(1382), Tuint16_t(1382), Tuint16_t(1382), Tuint16_t(1382),
	Tuint16_t(1382), Tuint16_t(1382), Tuint16_t(1382), Tuint16_t(1382), Tuint16_t(1382), Tuint16_t(1382), Tuint16_t(1382), Tuint16_t(1382), Tuint16_t(1382), Tuint16_t(1382), Tuint16_t(1382), Tuint16_t(1382), Tuint16_t(1382), Tuint16_t(1382), Tuint16_t(1382), Tuint16_t(1382),
	Tuint16_t(1382), Tuint16_t(1382), Tuint16_t(1382), Tuint16_t(1382), Tuint16_t(1383), Tuint16_t(1383), Tuint16_t(1383), Tuint16_t(1384), Tuint16_t(1385), Tuint16_t(1385), Tuint16_t(1385), Tuint16_t(1386), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(1387), Tuint16_t(1387), Tuint16_t(1387), Tuint16_t(1387), Tuint16_t(1387), Tuint16_t(1387), Tuint16_t(1387), Tuint16_t(1387), Tuint16_t(1387), Tuint16_t(1387), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(1388), Tuint16_t(1388),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),

	// block 257
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(302), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389),

	// block 258
	Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389),
	Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389),
	Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1390), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389),
	Tuint16_t(1391), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),

	// block 259
	Tuint16_t(302), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389),
	Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389),
	Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1390), Tuint16_t(1389),
	Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(1389), Tuint16_t(302), Tuint16_t(302),
	Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),
	Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262), Tuint16_t(262),

	// block 260
	Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(302), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392),
	Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392),
	Tuint16_t(302), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(302), Tuint16_t(1392), Tuint16_t(302), Tuint16_t(302), Tuint16_t(1392), Tuint16_t(302), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392),
	Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(302), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(302), Tuint16_t(1392), Tuint16_t(302), Tuint16_t(1392), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302),
	Tuint16_t(302), Tuint16_t(302), Tuint16_t(1392), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(1392), Tuint16_t(302), Tuint16_t(1392), Tuint16_t(302), Tuint16_t(1392), Tuint16_t(302), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392),
	Tuint16_t(302), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(302), Tuint16_t(1392), Tuint16_t(302), Tuint16_t(302), Tuint16_t(1392), Tuint16_t(302), Tuint16_t(1392), Tuint16_t(302), Tuint16_t(1392), Tuint16_t(302), Tuint16_t(1392), Tuint16_t(302), Tuint16_t(1392),
	Tuint16_t(302), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(302), Tuint16_t(1392), Tuint16_t(302), Tuint16_t(302), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(302), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392),
	Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(302), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(302), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(302), Tuint16_t(1392), Tuint16_t(302),

	// block 261
	Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(302), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392),
	Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302),
	Tuint16_t(302), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(302), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(302), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392),
	Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(1392), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302),
	Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302),
	Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302),
	Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302),
	Tuint16_t(274), Tuint16_t(274), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302), Tuint16_t(302),

	// block 262
	Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1394), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393),
	Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393),
	Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393),
	Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393),
	Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393),
	Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393),
	Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393),

	// block 263
	Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393),
	Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1395),
	Tuint16_t(1395), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393),
	Tuint16_t(1395), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1394),
	Tuint16_t(1395), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393),
	Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393),
	Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),

	// block 264
	Tuint16_t(54), Tuint16_t(54), Tuint16_t(54), Tuint16_t(54), Tuint16_t(54), Tuint16_t(54), Tuint16_t(54), Tuint16_t(54), Tuint16_t(54), Tuint16_t(54), Tuint16_t(54), Tuint16_t(58), Tuint16_t(58), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(1393),
	Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396),
	Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396),
	Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(723), Tuint16_t(723), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393),
	Tuint16_t(1397), Tuint16_t(1397), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1397), Tuint16_t(1397),

	// block 265
	Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(1396), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(1398), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(1398), Tuint16_t(1398), Tuint16_t(1398), Tuint16_t(1398), Tuint16_t(1398), Tuint16_t(1398), Tuint16_t(1398), Tuint16_t(1398), Tuint16_t(1398), Tuint16_t(1398), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(1393), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1399), Tuint16_t(1399), Tuint16_t(1399), Tuint16_t(1399), Tuint16_t(1399), Tuint16_t(1399), Tuint16_t(1399), Tuint16_t(1399), Tuint16_t(1399), Tuint16_t(1399),
	Tuint16_t(1399), Tuint16_t(1399), Tuint16_t(1399), Tuint16_t(1399), Tuint16_t(1399), Tuint16_t(1399), Tuint16_t(1399), Tuint16_t(1399), Tuint16_t(1399), Tuint16_t(1399), Tuint16_t(1399), Tuint16_t(1399), Tuint16_t(1399), Tuint16_t(1399), Tuint16_t(1399), Tuint16_t(1399),

	// block 266
	Tuint16_t(1400), Tuint16_t(1398), Tuint16_t(1401), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(1398), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(1398),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(1398), Tuint16_t(1398), Tuint16_t(1398), Tuint16_t(1398), Tuint16_t(1398), Tuint16_t(1401), Tuint16_t(1398), Tuint16_t(1398), Tuint16_t(1398), Tuint16_t(460), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(460), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(1402), Tuint16_t(1402), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),

	// block 267
	Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),

	// block 268
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(727), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(727), Tuint16_t(727), Tuint16_t(727), Tuint16_t(727), Tuint16_t(727), Tuint16_t(727), Tuint16_t(727), Tuint16_t(727), Tuint16_t(727), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(727), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(727), Tuint16_t(1394), Tuint16_t(1394),

	// block 269
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1403), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(727), Tuint16_t(727), Tuint16_t(1393), Tuint16_t(727), Tuint16_t(727), Tuint16_t(727), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(727), Tuint16_t(727),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1403), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1403), Tuint16_t(1404), Tuint16_t(1404), Tuint16_t(727), Tuint16_t(727), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(727), Tuint16_t(727), Tuint16_t(727), Tuint16_t(727), Tuint16_t(727), Tuint16_t(727), Tuint16_t(727), Tuint16_t(727), Tuint16_t(727), Tuint16_t(727), Tuint16_t(727), Tuint16_t(727),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(727), Tuint16_t(1394), Tuint16_t(727), Tuint16_t(1393), Tuint16_t(727), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1405), Tuint16_t(1405), Tuint16_t(1405), Tuint16_t(1405), Tuint16_t(1405),

	// block 270
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(727),
	Tuint16_t(1394), Tuint16_t(727), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403),
	Tuint16_t(1403), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403),
	Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1403), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),

	// block 271
	Tuint16_t(1394), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1394), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1403),
	Tuint16_t(1394), Tuint16_t(1403), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1403), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(727), Tuint16_t(1393), Tuint16_t(1394),

	// block 272
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(723), Tuint16_t(723),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(727), Tuint16_t(727), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1393),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(727),
	Tuint16_t(727), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(727), Tuint16_t(1404), Tuint16_t(1404), Tuint16_t(727), Tuint16_t(727), Tuint16_t(727), Tuint16_t(727), Tuint16_t(1403), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393),

	// block 273
	Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(727), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(727), Tuint16_t(727), Tuint16_t(727), Tuint16_t(727), Tuint16_t(1393), Tuint16_t(1393),
	Tuint16_t(1404), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393),
	Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1394), Tuint16_t(727), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(727), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393),
	Tuint16_t(1393), Tuint16_t(727), Tuint16_t(727), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(727), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393),
	Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(727), Tuint16_t(727), Tuint16_t(727), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393),
	Tuint16_t(1393), Tuint16_t(727), Tuint16_t(727), Tuint16_t(727), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(727), Tuint16_t(727), Tuint16_t(727), Tuint16_t(1393),
	Tuint16_t(1393), Tuint16_t(727), Tuint16_t(1393), Tuint16_t(727), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(727), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(727),
	Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(727), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(727), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),

	// block 274
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),

	// block 275
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1403), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1403), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(727), Tuint16_t(1403), Tuint16_t(727), Tuint16_t(727), Tuint16_t(727),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(727), Tuint16_t(727), Tuint16_t(727), Tuint16_t(727), Tuint16_t(727), Tuint16_t(727), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(727), Tuint16_t(1393), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(727), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(727), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),

	// block 276
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),

	// block 277
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(1394), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),

	// block 278
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),

	// block 279
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),

	// block 280
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(1403), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1403),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1403), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1394), Tuint16_t(723), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(723), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1403), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),

	// block 281
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1406), Tuint16_t(1406), Tuint16_t(1406), Tuint16_t(1406), Tuint16_t(1394), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1394), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1394), Tuint16_t(1403), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403),
	Tuint16_t(1394), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),

	// block 282
	Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393),
	Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393),
	Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393),
	Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393),
	Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393),
	Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1393), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),

	// block 283
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1394), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1403), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),

	// block 284
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),

	// block 285
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(163), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723),
	Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(723), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(1407), Tuint16_t(1407), Tuint16_t(1407), Tuint16_t(1407), Tuint16_t(1407), Tuint16_t(1407), Tuint16_t(1407), Tuint16_t(1407), Tuint16_t(1407), Tuint16_t(1407), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 286
	Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395),
	Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(1395), Tuint16_t(958), Tuint16_t(958),

	// block 287
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 288
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),

	// block 289
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),

	// block 290
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),

	// block 291
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 292
	Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953),
	Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(953), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 293
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(958), Tuint16_t(958),

	// block 294
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838),
	Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(838), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),
	Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163), Tuint16_t(163),

	// block 295
	Tuint16_t(707), Tuint16_t(712), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707),
	Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707),
	Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408),
	Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408),
	Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408),
	Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408),
	Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408),
	Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408), Tuint16_t(1408),

	// block 296
	Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707),
	Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707),
	Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707),
	Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707),
	Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707),
	Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707),
	Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707),
	Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707),

	// block 297
	Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961),
	Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961),
	Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961),
	Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961),
	Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961),
	Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961),
	Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961),
	Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961),

	// block 298
	Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961),
	Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961),
	Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961),
	Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961),
	Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961),
	Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961),
	Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961), Tuint16_t(961),
	Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707), Tuint16_t(707),

	// block 299
	Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952),
	Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952),
	Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952),
	Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952),
	Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952),
	Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952),
	Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952),
	Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(952), Tuint16_t(958), Tuint16_t(958),
} /* pcre2_ucd.c:2386:16 */

// End of pcre2_ucd.c

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// ************************************************
//
//           Validate a UTF string                *
//

// This function is called (optionally) at the start of compile or match, to
// check that a supposed UTF string is actually valid. The early check means
// that subsequent code can assume it is dealing with a valid string. The check
// can be turned off for maximum performance, but the consequences of supplying an
// invalid string are then undefined.
//
// Arguments:
//   string       points to the string
//   length       length of string
//   errp         pointer to an error position offset variable
//
// Returns:       == 0    if the string is a valid UTF string
//                != 0    otherwise, setting the offset of the bad character

func X_pcre2_valid_utf_8(tls *libc.TLS, string TPCRE2_SPTR8, length Tsize_t, erroroffset uintptr) int32 { /* pcre2_valid_utf.c:94:1: */
	var p TPCRE2_SPTR8
	var c Tuint32_t

	// ----------------- Check a UTF-8 string -----------------

	// Originally, this function checked according to RFC 2279, allowing for values
	// in the range 0 to 0x7fffffff, up to 6 bytes long, but ensuring that they were
	// in the canonical format. Once somebody had pointed out RFC 3629 to me (it
	// obsoletes 2279), additional restrictions were applied. The values are now
	// limited to be between 0 and 0x0010ffff, no more than 4 bytes long, and the
	// subrange 0xd000 to 0xdfff is excluded. However, the format of 5-byte and 6-byte
	// characters is still checked. Error returns are as follows:
	//
	// PCRE2_ERROR_UTF8_ERR1   Missing 1 byte at the end of the string
	// PCRE2_ERROR_UTF8_ERR2   Missing 2 bytes at the end of the string
	// PCRE2_ERROR_UTF8_ERR3   Missing 3 bytes at the end of the string
	// PCRE2_ERROR_UTF8_ERR4   Missing 4 bytes at the end of the string
	// PCRE2_ERROR_UTF8_ERR5   Missing 5 bytes at the end of the string
	// PCRE2_ERROR_UTF8_ERR6   2nd-byte's two top bits are not 0x80
	// PCRE2_ERROR_UTF8_ERR7   3rd-byte's two top bits are not 0x80
	// PCRE2_ERROR_UTF8_ERR8   4th-byte's two top bits are not 0x80
	// PCRE2_ERROR_UTF8_ERR9   5th-byte's two top bits are not 0x80
	// PCRE2_ERROR_UTF8_ERR10  6th-byte's two top bits are not 0x80
	// PCRE2_ERROR_UTF8_ERR11  5-byte character is not permitted by RFC 3629
	// PCRE2_ERROR_UTF8_ERR12  6-byte character is not permitted by RFC 3629
	// PCRE2_ERROR_UTF8_ERR13  4-byte character with value > 0x10ffff is not permitted
	// PCRE2_ERROR_UTF8_ERR14  3-byte character with value 0xd800-0xdfff is not permitted
	// PCRE2_ERROR_UTF8_ERR15  Overlong 2-byte sequence
	// PCRE2_ERROR_UTF8_ERR16  Overlong 3-byte sequence
	// PCRE2_ERROR_UTF8_ERR17  Overlong 4-byte sequence
	// PCRE2_ERROR_UTF8_ERR18  Overlong 5-byte sequence (won't ever occur)
	// PCRE2_ERROR_UTF8_ERR19  Overlong 6-byte sequence (won't ever occur)
	// PCRE2_ERROR_UTF8_ERR20  Isolated 0x80 byte (not within UTF-8 character)
	// PCRE2_ERROR_UTF8_ERR21  Byte with the illegal value 0xfe or 0xff

	for p = string; length > uint64(0); p++ {
		var ab Tuint32_t
		var d Tuint32_t

		c = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(p)))
		length--

		if c < Tuint32_t(128) {
			continue
		} // ASCII character

		if c < Tuint32_t(0xc0) {
			*(*Tsize_t)(unsafe.Pointer(erroroffset)) = Tsize_t((int64(p) - int64(string)) / 1)
			return -22
		}

		if c >= Tuint32_t(0xfe) {
			*(*Tsize_t)(unsafe.Pointer(erroroffset)) = Tsize_t((int64(p) - int64(string)) / 1)
			return -23
		}

		ab = Tuint32_t(X_pcre2_utf8_table4[c&Tuint32_t(0x3f)]) // Number of additional bytes (1-5)
		if length < Tsize_t(ab) {
			*(*Tsize_t)(unsafe.Pointer(erroroffset)) = Tsize_t((int64(p) - int64(string)) / 1)
			switch Tsize_t(ab) - length {
			case uint64(1):
				return -3
				fallthrough
			case uint64(2):
				return -4
				fallthrough
			case uint64(3):
				return -5
				fallthrough
			case uint64(4):
				return -6
				fallthrough
			case uint64(5):
				return -7
			}
		}
		length = length - Tsize_t(ab) // Length remaining

		// Check top bits in the second byte

		if libc.AssignUint32(&d, Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PreIncUintptr(&p, 1)))))&Tuint32_t(0xc0) != Tuint32_t(0x80) {
			*(*Tsize_t)(unsafe.Pointer(erroroffset)) = Tsize_t(int32((int64(p)-int64(string))/1) - 1)
			return -8
		}

		// For each length, check that the remaining bytes start with the 0x80 bit
		//   set and not the 0x40 bit. Then check for an overlong sequence, and for the
		//   excluded range 0xd800 to 0xdfff.

		switch ab {
		// 2-byte character. No further bytes to check for 0x80. Check first byte
		//     for for xx00 000x (overlong sequence).

		case Tuint32_t(1):
			if c&Tuint32_t(0x3e) == Tuint32_t(0) {
				*(*Tsize_t)(unsafe.Pointer(erroroffset)) = Tsize_t(int32((int64(p)-int64(string))/1) - 1)
				return -17
			}
			break

		// 3-byte character. Check third byte for 0x80. Then check first 2 bytes
		//       for 1110 0000, xx0x xxxx (overlong sequence) or
		//           1110 1101, 1010 xxxx (0xd800 - 0xdfff)

		case Tuint32_t(2):
			if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PreIncUintptr(&p, 1))))&0xc0 != 0x80 {
				*(*Tsize_t)(unsafe.Pointer(erroroffset)) = Tsize_t(int32((int64(p)-int64(string))/1) - 2)
				return -9
			}
			if c == Tuint32_t(0xe0) && d&Tuint32_t(0x20) == Tuint32_t(0) {
				*(*Tsize_t)(unsafe.Pointer(erroroffset)) = Tsize_t(int32((int64(p)-int64(string))/1) - 2)
				return -18
			}
			if c == Tuint32_t(0xed) && d >= Tuint32_t(0xa0) {
				*(*Tsize_t)(unsafe.Pointer(erroroffset)) = Tsize_t(int32((int64(p)-int64(string))/1) - 2)
				return -16
			}
			break

		// 4-byte character. Check 3rd and 4th bytes for 0x80. Then check first 2
		//        bytes for for 1111 0000, xx00 xxxx (overlong sequence), then check for a
		//        character greater than 0x0010ffff (f4 8f bf bf)

		case Tuint32_t(3):
			if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PreIncUintptr(&p, 1))))&0xc0 != 0x80 {
				*(*Tsize_t)(unsafe.Pointer(erroroffset)) = Tsize_t(int32((int64(p)-int64(string))/1) - 2)
				return -9
			}
			if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PreIncUintptr(&p, 1))))&0xc0 != 0x80 {
				*(*Tsize_t)(unsafe.Pointer(erroroffset)) = Tsize_t(int32((int64(p)-int64(string))/1) - 3)
				return -10
			}
			if c == Tuint32_t(0xf0) && d&Tuint32_t(0x30) == Tuint32_t(0) {
				*(*Tsize_t)(unsafe.Pointer(erroroffset)) = Tsize_t(int32((int64(p)-int64(string))/1) - 3)
				return -19
			}
			if c > Tuint32_t(0xf4) || c == Tuint32_t(0xf4) && d > Tuint32_t(0x8f) {
				*(*Tsize_t)(unsafe.Pointer(erroroffset)) = Tsize_t(int32((int64(p)-int64(string))/1) - 3)
				return -15
			}
			break

		// 5-byte and 6-byte characters are not allowed by RFC 3629, and will be
		//     rejected by the length test below. However, we do the appropriate tests
		//     here so that overlong sequences get diagnosed, and also in case there is
		//     ever an option for handling these larger code points.

		// 5-byte character. Check 3rd, 4th, and 5th bytes for 0x80. Then check for
		//     1111 1000, xx00 0xxx

		case Tuint32_t(4):
			if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PreIncUintptr(&p, 1))))&0xc0 != 0x80 {
				*(*Tsize_t)(unsafe.Pointer(erroroffset)) = Tsize_t(int32((int64(p)-int64(string))/1) - 2)
				return -9
			}
			if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PreIncUintptr(&p, 1))))&0xc0 != 0x80 {
				*(*Tsize_t)(unsafe.Pointer(erroroffset)) = Tsize_t(int32((int64(p)-int64(string))/1) - 3)
				return -10
			}
			if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PreIncUintptr(&p, 1))))&0xc0 != 0x80 {
				*(*Tsize_t)(unsafe.Pointer(erroroffset)) = Tsize_t(int32((int64(p)-int64(string))/1) - 4)
				return -11
			}
			if c == Tuint32_t(0xf8) && d&Tuint32_t(0x38) == Tuint32_t(0) {
				*(*Tsize_t)(unsafe.Pointer(erroroffset)) = Tsize_t(int32((int64(p)-int64(string))/1) - 4)
				return -20
			}
			break

		// 6-byte character. Check 3rd-6th bytes for 0x80. Then check for
		//     1111 1100, xx00 00xx.

		case Tuint32_t(5):
			if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PreIncUintptr(&p, 1))))&0xc0 != 0x80 {
				*(*Tsize_t)(unsafe.Pointer(erroroffset)) = Tsize_t(int32((int64(p)-int64(string))/1) - 2)
				return -9
			}
			if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PreIncUintptr(&p, 1))))&0xc0 != 0x80 {
				*(*Tsize_t)(unsafe.Pointer(erroroffset)) = Tsize_t(int32((int64(p)-int64(string))/1) - 3)
				return -10
			}
			if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PreIncUintptr(&p, 1))))&0xc0 != 0x80 {
				*(*Tsize_t)(unsafe.Pointer(erroroffset)) = Tsize_t(int32((int64(p)-int64(string))/1) - 4)
				return -11
			}
			if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PreIncUintptr(&p, 1))))&0xc0 != 0x80 {
				*(*Tsize_t)(unsafe.Pointer(erroroffset)) = Tsize_t(int32((int64(p)-int64(string))/1) - 5)
				return -12
			}
			if c == Tuint32_t(0xfc) && d&Tuint32_t(0x3c) == Tuint32_t(0) {
				*(*Tsize_t)(unsafe.Pointer(erroroffset)) = Tsize_t(int32((int64(p)-int64(string))/1) - 5)
				return -21
			}
			break
		}

		// Character is valid under RFC 2279, but 4-byte and 5-byte characters are
		//   excluded by RFC 3629. The pointer p is currently at the last byte of the
		//   character.

		if ab > Tuint32_t(3) {
			*(*Tsize_t)(unsafe.Pointer(erroroffset)) = Tsize_t(Tuint32_t(int32((int64(p)-int64(string))/1)) - ab)
			if ab == Tuint32_t(4) {
				return -13
			}
			return -14
		}
	}
	return 0

	// ----------------- Check a UTF-16 string -----------------

}

// End of pcre2_valid_utf.c

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// ************************************************
//
//       Match character against an XCLASS        *
//

// This function is called to match a character against an extended class that
// might contain codepoints above 255 and/or Unicode properties.
//
// Arguments:
//   c           the character
//   data        points to the flag code unit of the XCLASS data
//   utf         TRUE if in UTF mode
//
// Returns:      TRUE if character matches, else FALSE

func X_pcre2_xclass_8(tls *libc.TLS, c Tuint32_t, data TPCRE2_SPTR8, utf TBOOL) TBOOL { /* pcre2_xclass.c:69:1: */
	var t TPCRE2_UCHAR8
	var negated TBOOL = libc.Bool32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data)))&DXCL_NOT != 0)

	// In 8 bit mode, this must always be TRUE. Help the compiler to know that.
	utf = DTRUE

	// Code points < 256 are matched against a bitmap, if one is present. If not,
	// we still carry on, because there may be ranges that start below 256 in the
	// additional data.

	if c < Tuint32_t(256) {
		if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data)))&DXCL_HASPROP == 0 {
			if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data)))&DXCL_MAP == 0 {
				return negated
			}
			return libc.Bool32(uint32(*(*Tuint8_t)(unsafe.Pointer(data + uintptr(1) + uintptr(c/Tuint32_t(8)))))&(uint32(1)<<(c&Tuint32_t(7))) != uint32(0))
		}
		if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data)))&DXCL_MAP != 0 && uint32(*(*Tuint8_t)(unsafe.Pointer(data + uintptr(1) + uintptr(c/Tuint32_t(8)))))&(uint32(1)<<(c&Tuint32_t(7))) != uint32(0) {
			return libc.BoolInt32(!(negated != 0))
		} // char found
	}

	// First skip the bit map if present. Then match against the list of Unicode
	// properties or large chars or ranges that end with a large char. We won't ever
	// encounter XCL_PROP or XCL_NOTPROP when UTF support is not compiled.

	if int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&data, 1))))&DXCL_MAP != 0 {
		data += TPCRE2_SPTR8(uint64(32) / uint64(unsafe.Sizeof(TPCRE2_UCHAR8(0))))
	}

	for int32(libc.AssignUint8(&t, *(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&data, 1))))) != DXCL_END {
		var x Tuint32_t
		var y Tuint32_t
		if int32(t) == DXCL_SINGLE {
			if utf != 0 {
				x = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&data, 1))))
				if x >= 0xc0 {
					if x&0x20 == Tuint32_t(0) {
						x = x&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&data, 1))))&0x3f
					} else if x&0x10 == Tuint32_t(0) {
						x = x&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data + 1)))&0x3f
						data += uintptr(2)
					} else if x&0x08 == Tuint32_t(0) {
						x = x&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data + 2)))&0x3f
						data += uintptr(3)
					} else if x&0x04 == Tuint32_t(0) {
						x = x&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data + 3)))&0x3f
						data += uintptr(4)
					} else {
						x = x&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data + 4)))&0x3f
						data += uintptr(5)
					}
				}

				// macro generates multiple statements
			} else {
				x = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&data, 1))))
			}
			if c == x {
				return libc.BoolInt32(!(negated != 0))
			}
		} else if int32(t) == DXCL_RANGE {
			if utf != 0 {
				x = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&data, 1))))
				if x >= 0xc0 {
					if x&0x20 == Tuint32_t(0) {
						x = x&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&data, 1))))&0x3f
					} else if x&0x10 == Tuint32_t(0) {
						x = x&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data + 1)))&0x3f
						data += uintptr(2)
					} else if x&0x08 == Tuint32_t(0) {
						x = x&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data + 2)))&0x3f
						data += uintptr(3)
					} else if x&0x04 == Tuint32_t(0) {
						x = x&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data + 3)))&0x3f
						data += uintptr(4)
					} else {
						x = x&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data + 4)))&0x3f
						data += uintptr(5)
					}
				}

				// macro generates multiple statements
				y = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&data, 1))))
				if y >= 0xc0 {
					if y&0x20 == Tuint32_t(0) {
						y = y&0x1f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&data, 1))))&0x3f
					} else if y&0x10 == Tuint32_t(0) {
						y = y&0x0f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data + 1)))&0x3f
						data += uintptr(2)
					} else if y&0x08 == Tuint32_t(0) {
						y = y&0x07<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data + 1)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data + 2)))&0x3f
						data += uintptr(3)
					} else if y&0x04 == Tuint32_t(0) {
						y = y&0x03<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data + 1)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data + 2)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data + 3)))&0x3f
						data += uintptr(4)
					} else {
						y = y&0x01<<30 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data)))&0x3f<<24 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data + 1)))&0x3f<<18 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data + 2)))&0x3f<<12 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data + 3)))&0x3f<<6 | uint32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data + 4)))&0x3f
						data += uintptr(5)
					}
				}

				// macro generates multiple statements
			} else {
				x = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&data, 1))))
				y = Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(libc.PostIncUintptr(&data, 1))))
			}
			if c >= x && c <= y {
				return libc.BoolInt32(!(negated != 0))
			}
		} else {
			var prop uintptr = uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12
			var isprop TBOOL = libc.Bool32(int32(t) == DXCL_PROP)
			var ok TBOOL

			switch int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data))) {
			case DPT_ANY:
				if isprop != 0 {
					return libc.BoolInt32(!(negated != 0))
				}
				break
				fallthrough

			case DPT_LAMP:
				if libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop)).Fchartype) == ucp_Lu || int32((*Tucd_record)(unsafe.Pointer(prop)).Fchartype) == ucp_Ll || int32((*Tucd_record)(unsafe.Pointer(prop)).Fchartype) == ucp_Lt) == isprop {
					return libc.BoolInt32(!(negated != 0))
				}
				break
				fallthrough

			case DPT_GC:
				if libc.Bool32(Tuint32_t(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data + 1))) == X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype]) == isprop {
					return libc.BoolInt32(!(negated != 0))
				}
				break
				fallthrough

			case DPT_PC:
				if libc.Bool32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data + 1))) == int32((*Tucd_record)(unsafe.Pointer(prop)).Fchartype)) == isprop {
					return libc.BoolInt32(!(negated != 0))
				}
				break
				fallthrough

			case DPT_SC:
				if libc.Bool32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data + 1))) == int32((*Tucd_record)(unsafe.Pointer(prop)).Fscript)) == isprop {
					return libc.BoolInt32(!(negated != 0))
				}
				break
				fallthrough

			case DPT_SCX:
				ok = libc.Bool32(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data + 1))) == int32((*Tucd_record)(unsafe.Pointer(prop)).Fscript) || *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_script_sets_8)) + uintptr(int32((*Tucd_record)(unsafe.Pointer(prop)).Fscriptx_bidiclass)&DUCD_SCRIPTX_MASK)*4 + uintptr(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data + 1)))/32)*4))&(uint32(1)<<(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data + 1)))%32)) != Tuint32_t(0))
				if ok == isprop {
					return libc.BoolInt32(!(negated != 0))
				}
				break
				fallthrough

			case DPT_ALNUM:
				if libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_L || X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_N) == isprop {
					return libc.BoolInt32(!(negated != 0))
				}
				break
				fallthrough

			// Perl space used to exclude VT, but from Perl 5.18 it is included,
			//       which means that Perl space and POSIX space are now identical. PCRE
			//       was changed at release 8.34.

			case DPT_SPACE:
				fallthrough // Perl space
			case DPT_PXSPACE: // POSIX space
				switch c {
				case Tuint32_t('\011'):
					fallthrough
				case Tuint32_t('\040'):
					fallthrough
				case Tuint32_t(uint8('\xa0')):
					fallthrough
				case Tuint32_t(0x1680):
					fallthrough /* OGHAM SPACE MARK */
				case Tuint32_t(0x180e):
					fallthrough /* MONGOLIAN VOWEL SEPARATOR */
				case Tuint32_t(0x2000):
					fallthrough /* EN QUAD */
				case Tuint32_t(0x2001):
					fallthrough /* EM QUAD */
				case Tuint32_t(0x2002):
					fallthrough /* EN SPACE */
				case Tuint32_t(0x2003):
					fallthrough /* EM SPACE */
				case Tuint32_t(0x2004):
					fallthrough /* THREE-PER-EM SPACE */
				case Tuint32_t(0x2005):
					fallthrough /* FOUR-PER-EM SPACE */
				case Tuint32_t(0x2006):
					fallthrough /* SIX-PER-EM SPACE */
				case Tuint32_t(0x2007):
					fallthrough /* FIGURE SPACE */
				case Tuint32_t(0x2008):
					fallthrough /* PUNCTUATION SPACE */
				case Tuint32_t(0x2009):
					fallthrough /* THIN SPACE */
				case Tuint32_t(0x200A):
					fallthrough /* HAIR SPACE */
				case Tuint32_t(0x202f):
					fallthrough /* NARROW NO-BREAK SPACE */
				case Tuint32_t(0x205f):
					fallthrough /* MEDIUM MATHEMATICAL SPACE */
				case Tuint32_t(0x3000):
					fallthrough
				case Tuint32_t('\012'):
					fallthrough
				case Tuint32_t('\013'):
					fallthrough
				case Tuint32_t('\014'):
					fallthrough
				case Tuint32_t('\015'):
					fallthrough
				case Tuint32_t(uint8('\x85')):
					fallthrough
				case Tuint32_t(0x2028):
					fallthrough /* LINE SEPARATOR */
				case Tuint32_t(0x2029):
					if isprop != 0 {
						return libc.BoolInt32(!(negated != 0))
					}
					break
					fallthrough

				default:
					if libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_Z) == isprop {
						return libc.BoolInt32(!(negated != 0))
					}
					break
				}
				break
				fallthrough

			case DPT_WORD:
				if libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_L || X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_N || c == Tuint32_t('\137')) ==
					isprop {
					return libc.BoolInt32(!(negated != 0))
				}
				break
				fallthrough

			case DPT_UCNC:
				if c < Tuint32_t(0xa0) {
					if libc.Bool32(c == Tuint32_t('\044') || c == Tuint32_t('\100') || c == Tuint32_t('\140')) == isprop {
						return libc.BoolInt32(!(negated != 0))
					}
				} else {
					if libc.Bool32(c < Tuint32_t(0xd800) || c > Tuint32_t(0xdfff)) == isprop {
						return libc.BoolInt32(!(negated != 0))
					}
				}
				break
				fallthrough

			case DPT_BIDICL:
				if libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop)).Fscriptx_bidiclass)>>DUCD_BIDICLASS_SHIFT == int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data + 1)))) == isprop {
					return libc.BoolInt32(!(negated != 0))
				}
				break
				fallthrough

			case DPT_BOOL:
				ok = libc.Bool32(*(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_boolprop_sets_8)) + uintptr(int32((*Tucd_record)(unsafe.Pointer(prop)).Fbprops)&DUCD_BPROPS_MASK)*4 + uintptr(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data + 1)))/32)*4))&(uint32(1)<<(int32(*(*TPCRE2_UCHAR8)(unsafe.Pointer(data + 1)))%32)) != Tuint32_t(0))
				if ok == isprop {
					return libc.BoolInt32(!(negated != 0))
				}
				break
				fallthrough

			// The following three properties can occur only in an XCLASS, as there
			//       is no \p or \P coding for them.

			// Graphic character. Implement this as not Z (space or separator) and
			//       not C (other), except for Cf (format) with a few exceptions. This seems
			//       to be what Perl does. The exceptional characters are:
			//
			//       U+061C           Arabic Letter Mark
			//       U+180E           Mongolian Vowel Separator
			//       U+2066 - U+2069  Various "isolate"s
			//

			case DPT_PXGRAPH:
				if libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] != ucp_Z && (X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] != ucp_C || int32((*Tucd_record)(unsafe.Pointer(prop)).Fchartype) == ucp_Cf && c != Tuint32_t(0x061c) && c != Tuint32_t(0x180e) && (c < Tuint32_t(0x2066) || c > Tuint32_t(0x2069)))) == isprop {
					return libc.BoolInt32(!(negated != 0))
				}
				break
				fallthrough

			// Printable character: same as graphic, with the addition of Zs, i.e.
			//       not Zl and not Zp, and U+180E.

			case DPT_PXPRINT:
				if libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop)).Fchartype) != ucp_Zl && int32((*Tucd_record)(unsafe.Pointer(prop)).Fchartype) != ucp_Zp && (X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] != ucp_C || int32((*Tucd_record)(unsafe.Pointer(prop)).Fchartype) == ucp_Cf && c != Tuint32_t(0x061c) && (c < Tuint32_t(0x2066) || c > Tuint32_t(0x2069)))) == isprop {
					return libc.BoolInt32(!(negated != 0))
				}
				break
				fallthrough

			// Punctuation: all Unicode punctuation, plus ASCII characters that
			//       Unicode treats as symbols rather than punctuation, for Perl
			//       compatibility (these are $+<=>^`|~).

			case DPT_PXPUNCT:
				if libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_P || c < Tuint32_t(128) && X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_S) == isprop {
					return libc.BoolInt32(!(negated != 0))
				}
				break
				fallthrough

			// This should never occur, but compilers may mutter if there is no
			//       default.

			default:
				return DFALSE
			}

			data += uintptr(2)
		}
	}

	return negated // char did not match
}

// End of pcre2_xclass.c

func init() {
	*(*func(*libc.TLS, Tsize_t, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_default_compile_context_8)) + 0)) = default_malloc                  // pcre2_context.c:134:5:
	*(*func(*libc.TLS, uintptr, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_default_compile_context_8)) + 8)) = default_free                            // pcre2_context.c:134:21:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_default_compile_context_8)) + 40 /* .tables */)) = uintptr(unsafe.Pointer(&X_pcre2_default_tables_8)) // pcre2_context.c:137:3:
	*(*func(*libc.TLS, Tsize_t, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_default_compile_context_8)) + 0)) = default_malloc                  // pcre2_context.c:134:5:
	*(*func(*libc.TLS, uintptr, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_default_compile_context_8)) + 8)) = default_free                            // pcre2_context.c:134:21:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_default_compile_context_8)) + 40 /* .tables */)) = uintptr(unsafe.Pointer(&X_pcre2_default_tables_8)) // pcre2_context.c:137:3:
	*(*func(*libc.TLS, Tsize_t, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_default_convert_context_8)) + 0)) = default_malloc                  // pcre2_context.c:198:5:
	*(*func(*libc.TLS, uintptr, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_default_convert_context_8)) + 8)) = default_free                            // pcre2_context.c:198:21:
	*(*func(*libc.TLS, Tsize_t, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_default_convert_context_8)) + 0)) = default_malloc                  // pcre2_context.c:198:5:
	*(*func(*libc.TLS, uintptr, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_default_convert_context_8)) + 8)) = default_free                            // pcre2_context.c:198:21:
	*(*func(*libc.TLS, Tsize_t, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_default_match_context_8)) + 0)) = default_malloc                    // pcre2_context.c:164:5:
	*(*func(*libc.TLS, uintptr, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_default_match_context_8)) + 8)) = default_free                              // pcre2_context.c:164:21:
	*(*func(*libc.TLS, Tsize_t, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_default_match_context_8)) + 0)) = default_malloc                    // pcre2_context.c:164:5:
	*(*func(*libc.TLS, uintptr, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_default_match_context_8)) + 8)) = default_free                              // pcre2_context.c:164:21:
}

var ts1 = "\x00MARK\x00ACCEPT\x00F\x00FAIL\x00COMMIT\x00PRUNE\x00SKIP\x00THEN\x00pla\x00plb\x00napla\x00naplb\x00nla\x00nlb\x00positive_lookahead\x00positive_lookbehind\x00non_atomic_positive_lookahead\x00non_atomic_positive_lookbehind\x00negative_lookahead\x00negative_lookbehind\x00atomic\x00sr\x00asr\x00script_run\x00atomic_script_run\x00alpha\x00lower\x00upper\x00alnum\x00ascii\x00blank\x00cntrl\x00digit\x00graph\x00print\x00punct\x00space\x00word\x00xdigit\x00UTF8)\x00UTF)\x00UCP)\x00NOTEMPTY)\x00NOTEMPTY_ATSTART)\x00NO_AUTO_POSSESS)\x00NO_DOTSTAR_ANCHOR)\x00NO_JIT)\x00NO_START_OPT)\x00LIMIT_HEAP=\x00LIMIT_MATCH=\x00LIMIT_DEPTH=\x00LIMIT_RECURSION=\x00CR)\x00LF)\x00CRLF)\x00ANY)\x00NUL)\x00ANYCRLF)\x00BSR_ANYCRLF)\x00BSR_UNICODE)\x00bidiclass\x00bc\x00script\x00sc\x00scriptextensions\x00scx\x00[:<:]]\x00[:>:]]\x00Q\\E\x00VERSION\x00DEFINE\x00Z\x0010.40 2022-04-14\x0010.402022-04-14\x00\\?*+|.^${}[]()\x00(){}123456789\x00(*NUL)\x00]\x00:]\x00\\\x00[\x00^\x00alnum:alpha:ascii:blank:cntrl:digit:graph:lower:print:punct:space:upper:word:xdigit:\x00\x00no error\x00\\ at end of pattern\x00\\c at end of pattern\x00unrecognized character follows \\\x00numbers out of order in {} quantifier\x00number too big in {} quantifier\x00missing terminating ] for character class\x00escape sequence is invalid in character class\x00range out of order in character class\x00quantifier does not follow a repeatable item\x00internal error: unexpected repeat\x00unrecognized character after (? or (?-\x00POSIX named classes are supported only within a class\x00POSIX collating elements are not supported\x00missing closing parenthesis\x00reference to non-existent subpattern\x00pattern passed as NULL\x00unrecognised compile-time option bit(s)\x00missing ) after (?# comment\x00parentheses are too deeply nested\x00regular expression is too large\x00failed to allocate heap memory\x00unmatched closing parenthesis\x00internal error: code overflow\x00missing closing parenthesis for condition\x00lookbehind assertion is not fixed length\x00a relative value of zero is not allowed\x00conditional subpattern contains more than two branches\x00assertion expected after (?( or (?(?C)\x00digit expected after (?+ or (?-\x00unknown POSIX class name\x00internal error in pcre2_study(): should not occur\x00this version of PCRE2 does not have Unicode support\x00parentheses are too deeply nested (stack check)\x00character code point value in \\x{} or \\o{} is too large\x00lookbehind is too complicated\x00\\C is not allowed in a lookbehind assertion in UTF-8 mode\x00PCRE2 does not support \\F, \\L, \\l, \\N{name}, \\U, or \\u\x00number after (?C is greater than 255\x00closing parenthesis for (?C expected\x00invalid escape sequence in (*VERB) name\x00unrecognized character after (?P\x00syntax error in subpattern name (missing terminator?)\x00two named subpatterns have the same name (PCRE2_DUPNAMES not set)\x00subpattern name must start with a non-digit\x00this version of PCRE2 does not have support for \\P, \\p, or \\X\x00malformed \\P or \\p sequence\x00unknown property after \\P or \\p\x00subpattern name is too long (maximum 32 code units)\x00too many named subpatterns (maximum 10000)\x00invalid range in character class\x00octal value is greater than \\377 in 8-bit non-UTF-8 mode\x00internal error: overran compiling workspace\x00internal error: previously-checked referenced subpattern not found\x00DEFINE subpattern contains more than one branch\x00missing opening brace after \\o\x00internal error: unknown newline setting\x00\\g is not followed by a braced, angle-bracketed, or quoted name/number or by a plain number\x00(?R (recursive pattern call) must be followed by a closing parenthesis\x00obsolete error (should not occur)\x00(*VERB) not recognized or malformed\x00subpattern number is too big\x00subpattern name expected\x00internal error: parsed pattern overflow\x00non-octal character in \\o{} (closing brace missing?)\x00different names for subpatterns of the same number are not allowed\x00(*MARK) must have an argument\x00non-hex character in \\x{} (closing brace missing?)\x00\\c must be followed by a printable ASCII character\x00\\k is not followed by a braced, angle-bracketed, or quoted name\x00internal error: unknown meta code in check_lookbehinds()\x00\\N is not supported in a class\x00callout string is too long\x00disallowed Unicode code point (>= 0xd800 && <= 0xdfff)\x00using UTF is disabled by the application\x00using UCP is disabled by the application\x00name is too long in (*MARK), (*PRUNE), (*SKIP), or (*THEN)\x00character code point value in \\u.... sequence is too large\x00digits missing in \\x{} or \\o{} or \\N{U+}\x00syntax error or number too big in (?(VERSION condition\x00internal error: unknown opcode in auto_possessify()\x00missing terminating delimiter for callout with string argument\x00unrecognized string delimiter follows (?C\x00using \\C is disabled by the application\x00(?| and/or (?J: or (?x: parentheses are too deeply nested\x00using \\C is disabled in this PCRE2 library\x00regular expression is too complicated\x00lookbehind assertion is too long\x00pattern string is longer than the limit set by the application\x00internal error: unknown code in parsed pattern\x00internal error: bad code value in parsed_skip()\x00PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES is not allowed in UTF-16 mode\x00invalid option bits with PCRE2_LITERAL\x00\\N{U+dddd} is supported only in Unicode (UTF) mode\x00invalid hyphen in option setting\x00(*alpha_assertion) not recognized\x00script runs require Unicode support, which this version of PCRE2 does not have\x00too many capturing groups (maximum 65535)\x00atomic assertion expected after (?( or (?(?C)\x00\\K is not allowed in lookarounds (but see PCRE2_EXTRA_ALLOW_LOOKAROUND_BSK)\x00\x00no error\x00no match\x00partial match\x00UTF-8 error: 1 byte missing at end\x00UTF-8 error: 2 bytes missing at end\x00UTF-8 error: 3 bytes missing at end\x00UTF-8 error: 4 bytes missing at end\x00UTF-8 error: 5 bytes missing at end\x00UTF-8 error: byte 2 top bits not 0x80\x00UTF-8 error: byte 3 top bits not 0x80\x00UTF-8 error: byte 4 top bits not 0x80\x00UTF-8 error: byte 5 top bits not 0x80\x00UTF-8 error: byte 6 top bits not 0x80\x00UTF-8 error: 5-byte character is not allowed (RFC 3629)\x00UTF-8 error: 6-byte character is not allowed (RFC 3629)\x00UTF-8 error: code points greater than 0x10ffff are not defined\x00UTF-8 error: code points 0xd800-0xdfff are not defined\x00UTF-8 error: overlong 2-byte sequence\x00UTF-8 error: overlong 3-byte sequence\x00UTF-8 error: overlong 4-byte sequence\x00UTF-8 error: overlong 5-byte sequence\x00UTF-8 error: overlong 6-byte sequence\x00UTF-8 error: isolated byte with 0x80 bit set\x00UTF-8 error: illegal byte (0xfe or 0xff)\x00UTF-16 error: missing low surrogate at end\x00UTF-16 error: invalid low surrogate\x00UTF-16 error: isolated low surrogate\x00UTF-32 error: code points 0xd800-0xdfff are not defined\x00UTF-32 error: code points greater than 0x10ffff are not defined\x00bad data value\x00patterns do not all use the same character tables\x00magic number missing\x00pattern compiled in wrong mode: 8/16/32-bit error\x00bad offset value\x00bad option value\x00invalid replacement string\x00bad offset into UTF string\x00callout error code\x00invalid data in workspace for DFA restart\x00too much recursion for DFA matching\x00backreference condition or recursion test is not supported for DFA matching\x00function is not supported for DFA matching\x00pattern contains an item that is not supported for DFA matching\x00workspace size exceeded in DFA matching\x00internal error - pattern overwritten?\x00bad JIT option\x00JIT stack limit reached\x00match limit exceeded\x00no more memory\x00unknown substring\x00non-unique substring name\x00NULL argument passed with non-zero length\x00nested recursion at the same subject position\x00matching depth limit exceeded\x00requested value is not available\x00requested value is not set\x00offset limit set without PCRE2_USE_OFFSET_LIMIT\x00bad escape sequence in replacement string\x00expected closing curly bracket in replacement string\x00bad substitution in replacement string\x00match with end before start or start moved backwards is not supported\x00too many replacements (more than INT_MAX)\x00bad serialized data\x00heap limit exceeded\x00invalid syntax\x00internal error - duplicate substitution match\x00PCRE2_MATCH_INVALID_UTF is not supported for DFA matching\x00\x00\x00\x00JIT is not supported\x00MARK\x00adlam\x00adlm\x00aghb\x00ahex\x00ahom\x00alpha\x00alphabetic\x00anatolianhieroglyphs\x00any\x00arab\x00arabic\x00armenian\x00armi\x00armn\x00ascii\x00asciihexdigit\x00avestan\x00avst\x00bali\x00balinese\x00bamu\x00bamum\x00bass\x00bassavah\x00batak\x00batk\x00beng\x00bengali\x00bhaiksuki\x00bhks\x00bidial\x00bidian\x00bidib\x00bidibn\x00bidic\x00bidicontrol\x00bidics\x00bidien\x00bidies\x00bidiet\x00bidifsi\x00bidil\x00bidilre\x00bidilri\x00bidilro\x00bidim\x00bidimirrored\x00bidinsm\x00bidion\x00bidipdf\x00bidipdi\x00bidir\x00bidirle\x00bidirli\x00bidirlo\x00bidis\x00bidiws\x00bopo\x00bopomofo\x00brah\x00brahmi\x00brai\x00braille\x00bugi\x00buginese\x00buhd\x00buhid\x00c\x00cakm\x00canadianaboriginal\x00cans\x00cari\x00carian\x00cased\x00caseignorable\x00caucasianalbanian\x00cc\x00cf\x00chakma\x00cham\x00changeswhencasefolded\x00changeswhencasemapped\x00changeswhenlowercased\x00changeswhentitlecased\x00changeswhenuppercased\x00cher\x00cherokee\x00chorasmian\x00chrs\x00ci\x00cn\x00co\x00common\x00copt\x00coptic\x00cpmn\x00cprt\x00cs\x00cuneiform\x00cwcf\x00cwcm\x00cwl\x00cwt\x00cwu\x00cypriot\x00cyprominoan\x00cyrillic\x00cyrl\x00dash\x00defaultignorablecodepoint\x00dep\x00deprecated\x00deseret\x00deva\x00devanagari\x00di\x00dia\x00diacritic\x00diak\x00divesakuru\x00dogr\x00dogra\x00dsrt\x00dupl\x00duployan\x00ebase\x00ecomp\x00egyp\x00egyptianhieroglyphs\x00elba\x00elbasan\x00elym\x00elymaic\x00emod\x00emoji\x00emojicomponent\x00emojimodifier\x00emojimodifierbase\x00emojipresentation\x00epres\x00ethi\x00ethiopic\x00ext\x00extendedpictographic\x00extender\x00extpict\x00geor\x00georgian\x00glag\x00glagolitic\x00gong\x00gonm\x00goth\x00gothic\x00gran\x00grantha\x00graphemebase\x00graphemeextend\x00graphemelink\x00grbase\x00greek\x00grek\x00grext\x00grlink\x00gujarati\x00gujr\x00gunjalagondi\x00gurmukhi\x00guru\x00han\x00hang\x00hangul\x00hani\x00hanifirohingya\x00hano\x00hanunoo\x00hatr\x00hatran\x00hebr\x00hebrew\x00hex\x00hexdigit\x00hira\x00hiragana\x00hluw\x00hmng\x00hmnp\x00hung\x00idc\x00idcontinue\x00ideo\x00ideographic\x00ids\x00idsb\x00idsbinaryoperator\x00idst\x00idstart\x00idstrinaryoperator\x00imperialaramaic\x00inherited\x00inscriptionalpahlavi\x00inscriptionalparthian\x00ital\x00java\x00javanese\x00joinc\x00joincontrol\x00kaithi\x00kali\x00kana\x00kannada\x00katakana\x00kayahli\x00khar\x00kharoshthi\x00khitansmallscript\x00khmer\x00khmr\x00khoj\x00khojki\x00khudawadi\x00kits\x00knda\x00kthi\x00l\x00l&\x00lana\x00lao\x00laoo\x00latin\x00latn\x00lc\x00lepc\x00lepcha\x00limb\x00limbu\x00lina\x00linb\x00lineara\x00linearb\x00lisu\x00ll\x00lm\x00lo\x00loe\x00logicalorderexception\x00lower\x00lowercase\x00lt\x00lu\x00lyci\x00lycian\x00lydi\x00lydian\x00m\x00mahajani\x00mahj\x00maka\x00makasar\x00malayalam\x00mand\x00mandaic\x00mani\x00manichaean\x00marc\x00marchen\x00masaramgondi\x00math\x00mc\x00me\x00medefaidrin\x00medf\x00meeteimayek\x00mend\x00mendekikakui\x00merc\x00mero\x00meroiticcursive\x00meroitichieroglyphs\x00miao\x00mlym\x00mn\x00modi\x00mong\x00mongolian\x00mro\x00mroo\x00mtei\x00mult\x00multani\x00myanmar\x00mymr\x00n\x00nabataean\x00nand\x00nandinagari\x00narb\x00nbat\x00nchar\x00nd\x00newa\x00newtailue\x00nko\x00nkoo\x00nl\x00no\x00noncharactercodepoint\x00nshu\x00nushu\x00nyiakengpuachuehmong\x00ogam\x00ogham\x00olchiki\x00olck\x00oldhungarian\x00olditalic\x00oldnortharabian\x00oldpermic\x00oldpersian\x00oldsogdian\x00oldsoutharabian\x00oldturkic\x00olduyghur\x00oriya\x00orkh\x00orya\x00osage\x00osge\x00osma\x00osmanya\x00ougr\x00p\x00pahawhhmong\x00palm\x00palmyrene\x00patsyn\x00patternsyntax\x00patternwhitespace\x00patws\x00pauc\x00paucinhau\x00pc\x00pcm\x00pd\x00pe\x00perm\x00pf\x00phag\x00phagspa\x00phli\x00phlp\x00phnx\x00phoenician\x00pi\x00plrd\x00po\x00prependedconcatenationmark\x00prti\x00ps\x00psalterpahlavi\x00qaac\x00qaai\x00qmark\x00quotationmark\x00radical\x00regionalindicator\x00rejang\x00ri\x00rjng\x00rohg\x00runic\x00runr\x00s\x00samaritan\x00samr\x00sarb\x00saur\x00saurashtra\x00sc\x00sd\x00sentenceterminal\x00sgnw\x00sharada\x00shavian\x00shaw\x00shrd\x00sidd\x00siddham\x00signwriting\x00sind\x00sinh\x00sinhala\x00sk\x00sm\x00so\x00softdotted\x00sogd\x00sogdian\x00sogo\x00sora\x00sorasompeng\x00soyo\x00soyombo\x00space\x00sterm\x00sund\x00sundanese\x00sylo\x00sylotinagri\x00syrc\x00syriac\x00tagalog\x00tagb\x00tagbanwa\x00taile\x00taitham\x00taiviet\x00takr\x00takri\x00tale\x00talu\x00tamil\x00taml\x00tang\x00tangsa\x00tangut\x00tavt\x00telu\x00telugu\x00term\x00terminalpunctuation\x00tfng\x00tglg\x00thaa\x00thaana\x00thai\x00tibetan\x00tibt\x00tifinagh\x00tirh\x00tirhuta\x00tnsa\x00toto\x00ugar\x00ugaritic\x00uideo\x00unifiedideograph\x00unknown\x00upper\x00uppercase\x00vai\x00vaii\x00variationselector\x00vith\x00vithkuqi\x00vs\x00wancho\x00wara\x00warangciti\x00wcho\x00whitespace\x00wspace\x00xan\x00xidc\x00xidcontinue\x00xids\x00xidstart\x00xpeo\x00xps\x00xsp\x00xsux\x00xuc\x00xwd\x00yezi\x00yezidi\x00yi\x00yiii\x00z\x00zanabazarsquare\x00zanb\x00zinh\x00zl\x00zp\x00zs\x00zyyy\x00zzzz\x00\x0014.0.0\x00"
var ts = (*reflect.StringHeader)(unsafe.Pointer(&ts1)).Data
